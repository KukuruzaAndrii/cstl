/* *****************************************************************************
Copyright: Boaz Segev, 2019-2022
License: ISC / MIT (choose your license)

Feel free to copy, use and enjoy according to the license provided.
********************************************************************************

********************************************************************************


            THE fio-stl.h FILE IS AUTO-GENERATED, DO NOT EDIT


***************************************************************************** */

/** ****************************************************************************
# facil.io's C STL - Simple (type) Template Library

This file contains macros that create generic / common core types, such as:

* Linked Lists - defined by `FIO_LIST_NAME`

* Dynamic Arrays - defined by `FIO_ARRAY_NAME`

* Hash Maps / Sets - defined by `FIO_MAP_NAME`

* Binary Safe Dynamic Strings - defined by `FIO_STR_NAME` or `FIO_STR_SMALL`

* Reference counting / Type wrapper - defined by `FIO_REF_NAME` (adds atomic)

* Pointer Tagging for Types - defined by `FIO_PTR_TAG(p)`/`FIO_PTR_UNTAG(p)`

* Soft / Dynamic Types (FIOBJ) - defined by `FIO_FIOBJ`


This file also contains common helper macros / primitives, such as:

* Macro Stringifier - `FIO_MACRO2STR(macro)`

* Version Macros - i.e., `FIO_VERSION_MAJOR` / `FIO_VERSION_STRING`

* Pointer Math - i.e., `FIO_PTR_MATH_ADD` / `FIO_PTR_FROM_FIELD`

* Memory Allocation Macros - i.e., `FIO_MEM_REALLOC`

* Security Related macros - i.e., `FIO_MEM_STACK_WIPE`

* String Information Helper Type - `fio_str_info_s` / `FIO_STR_INFO_IS_EQ`

* Naming Macros - i.e., `FIO_NAME` / `FIO_NAME2` / `FIO_NAME_BL`

* OS portable Threads - defined by `FIO_THREADS`

* OS portable file helpers - defined by `FIO_FILES`

* Sleep / Thread Scheduling Macros - i.e., `FIO_THREAD_RESCHEDULE`

* Logging and Assertion (no heap allocation) - defined by `FIO_LOG`

* Atomic add/subtract/replace - defined by `FIO_ATOMIC`

* Bit-Byte Operations - defined by `FIO_BITWISE` and `FIO_BITMAP` (adds atomic)

* Data Hashing (using Risky Hash) - defined by `FIO_RAND`

* Psedo Random Generation - defined by `FIO_RAND`

* String / Number conversion - defined by `FIO_ATOL`

* Time Helpers - defined by `FIO_TIME`

* Task / Timer Queues (Event Loop Engine) - defined by `FIO_QUEUE`

* Command Line Interface helpers - defined by `FIO_CLI`

* Socket Helpers - defined by `FIO_SOCK`

* Polling Helpers - defined by `FIO_POLL`

* Data Stream Containers - defined by `FIO_STREAM`

* Signal (pass-through) Monitors - defined by `FIO_SIGNAL`

* Custom Memory Pool / Allocation - defined by `FIO_MEMORY_NAME` / `FIO_MALLOC`,
  if `FIO_MALLOC` is used, it updates `FIO_MEM_REALLOC` etc'

* Custom JSON Parser - defined by `FIO_JSON`

However, this file does very little unless specifically requested.

To make sure this file defines a specific macro or type, it's macro should be
set.

In addition, if the `FIO_TEST_CSTL` macro is defined, the self-testing function
`fio_test_dynamic_types()` will be defined. the `fio_test_dynamic_types`
function will test the functionality of this file and, as consequence, will
define all available macros.

**Notes**:

- To make this file usable for kernel authoring, the `include` statements should
be reviewed.

- To make these functions safe for kernel authoring, the `FIO_MEM_REALLOC` and
`FIO_MEM_FREE` macros should be (re)-defined.

  These macros default to using the `realloc` and `free` functions calls. If
  `FIO_MALLOC` was defined, these macros will default to the custom memory
  allocator.

- To make the custom memory allocator safe for kernel authoring, the
  `FIO_MEM_PAGE_ALLOC`, `FIO_MEM_PAGE_REALLOC` and `FIO_MEM_PAGE_FREE` macros
  should be redefined. These macros default to using `mmap` and `munmap` (on
  linux, also `mremap`).

- The functions defined using this file default to `static` or `static
  inline`.

  To create an externally visible API, define the `FIO_EXTERN`. Define the
  `FIO_EXTERN_COMPLETE` macro to include the API's implementation as well.

- To implement a library style version guard, define the `FIO_VERSION_GUARD`
macro in a single translation unit (.c file) **before** including this STL
library for the first time.

***************************************************************************** */
#ifndef H___FIO_CSTL_COMBINED___H
#define H___FIO_CSTL_COMBINED___H
#endif /* H___FIO_CSTL_COMBINED___H */
#ifndef FIO_INCLUDE_FILE
#define FIO_INCLUDE_FILE "fio-stl.h"
#endif
/* *****************************************************************************
C++ extern start
***************************************************************************** */
/* support C++ */
#ifdef __cplusplus
extern "C" {
/* C++ keyword was deprecated */
#ifndef register
#define register
#endif
/* C keyword - unavailable in C++ */
#ifndef restrict
#define restrict
#endif
#endif

/* *****************************************************************************




                            Constants (included once)


Note:
The common header is messy and has a lot of building blocks that are used
throughout the other modules.
***************************************************************************** */
#ifndef H___FIO_CSTL_INCLUDE_ONCE___H
#define H___FIO_CSTL_INCLUDE_ONCE___H

/* *****************************************************************************
Compiler detection, GCC / CLang features and OS dependent included files
***************************************************************************** */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#if !defined(__GNUC__) && !defined(__clang__) && !defined(GNUC_BYPASS)
#ifndef __attribute__
#define __attribute__(...)
#endif
#ifndef __has_include
#define __has_include(...) 0
#endif
#ifndef __has_builtin
#define __has_builtin(...) 0
#endif
#define GNUC_BYPASS 1
#elif !defined(__clang__) && !defined(__has_builtin)
/* E.g: GCC < 6.0 doesn't support __has_builtin */
#define __has_builtin(...) 0
#define GNUC_BYPASS        1
#endif

#ifndef __has_include
#define __has_include(...) 0
#define GNUC_BYPASS 1
#endif

#if defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5))
/* GCC < 4.5 doesn't support deprecation reason string */
#define DEPRECATED(reason) __attribute__((deprecated))
#else
#define DEPRECATED(reason) __attribute__((deprecated(reason)))
#endif

#if defined(__GNUC__) || defined(__clang__)
#define FIO_ALIGN(bytes) __attribute__((aligned(bytes)))
#elif defined(__INTEL_COMPILER) || defined(_MSC_VER)
#define FIO_ALIGN(bytes)
// #define FIO_ALIGN(bytes) __declspec(align(bytes))
#else
#define FIO_ALIGN(bytes)
#endif

#if _MSC_VER
#define inline __inline
#define __thread __declspec(thread)
#elif !defined(__clang__) && !defined(__GNUC__)
#define __thread _Thread_local
#endif

#if defined(__clang__) || defined(__GNUC__)
/** Clobber CPU registers and prevent compiler reordering optimizations. */
#define FIO_COMPILER_GUARD __asm__ volatile("" ::: "memory")
#elif defined(_MSC_VER)
#include <intrin.h>
/** Clobber CPU registers and prevent compiler reordering optimizations. */
#define FIO_COMPILER_GUARD _ReadWriteBarrier()
#pragma message("Warning: Windows deprecated it's low-level C memory barrier.")
#else
#warning Unknown OS / compiler, some macros are poorly defined and errors might occur.
#define FIO_COMPILER_GUARD asm volatile("" ::: "memory")
#endif

#if defined(__unix__) || defined(__linux__) || defined(__APPLE__)
#define FIO_HAVE_UNIX_TOOLS 1
#define FIO_OS_POSIX        1
#define FIO___PRINTF_STYLE  printf
#elif defined(_WIN32) || defined(_WIN64) || defined(WIN32) ||                  \
    defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)
#define FIO_OS_WIN     1
#define POSIX_C_SOURCE 200809L
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS 1
#endif

#if defined(__MINGW32__)
/* Mingw supports */
#define FIO_HAVE_UNIX_TOOLS    2
#define __USE_MINGW_ANSI_STDIO 1
#define FIO___PRINTF_STYLE     __MINGW_PRINTF_FORMAT
#elif defined(__CYGWIN__)
/* TODO: cygwin support */
#define FIO_HAVE_UNIX_TOOLS    3
#define __USE_MINGW_ANSI_STDIO 1
#define FIO___PRINTF_STYLE     __MINGW_PRINTF_FORMAT
#else
#define FIO_HAVE_UNIX_TOOLS 0
typedef SSIZE_T ssize_t;
#endif /* __CYGWIN__ __MINGW32__ */
#else
#define FIO_HAVE_UNIX_TOOLS 0
#warning Unknown OS / compiler, some macros are poorly defined and errors might occur.
#endif

#include <ctype.h>
#include <errno.h>
#include <signal.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <time.h>

#ifndef CLOCK_REALTIME
#define CLOCK_REALTIME 0
#endif
#ifndef CLOCK_MONOTONIC
#define CLOCK_MONOTONIC 0
#endif

#if FIO_HAVE_UNIX_TOOLS
#include <sys/param.h>
#include <unistd.h>
#endif

/* *****************************************************************************
Aligned Memory Access Selectors
***************************************************************************** */

#ifndef FIO_UNALIGNED_ACCESS
/** Allows facil.io to attempt unaligned memory access on *some* CPU systems. */
#define FIO_UNALIGNED_ACCESS 1
#endif

#ifndef FIO_UNALIGNED_MEMORY_ACCESS_ENABLED
#if FIO_UNALIGNED_ACCESS &&                                                    \
    (__amd64 || __amd64__ || __x86_64 || __x86_64__ || __i386 ||               \
     __aarch64__ || _M_IX86 || _M_X64 || _M_ARM64 || __ARM_FEATURE_UNALIGNED)
/** True when unaligned memory is allowed. */
#define FIO_UNALIGNED_MEMORY_ACCESS_ENABLED 1
#else
#define FIO_UNALIGNED_MEMORY_ACCESS_ENABLED 0
#endif
#endif /* FIO_UNALIGNED_MEMORY_ACCESS_ENABLED */

/* *****************************************************************************
Function Attributes
***************************************************************************** */

/** Marks a function as `static`, `inline` and possibly unused. */
#define FIO_IFUNC static inline __attribute__((unused))

/** Marks a function as `static` and possibly unused. */
#define FIO_SFUNC static __attribute__((unused))

/** Marks a function as weak */
#define FIO_WEAK __attribute__((weak))

#if _MSC_VER
#pragma section(".CRT$XCU", read)
#undef FIO_CONSTRUCTOR
#undef FIO_DESTRUCTOR
/** Marks a function as a constructor - if supported. */

#if _WIN64 /* MSVC linker uses different name mangling on 32bit systems */
#define FIO___CONSTRUCTOR_INTERNAL(fname)                                      \
  static void fname(void);                                                     \
  __pragma(comment(linker, "/include:" #fname "__")); /* and next.... */       \
  __declspec(allocate(".CRT$XCU")) void (*fname##__)(void) = fname;            \
  static void fname(void)
#else
#define FIO___CONSTRUCTOR_INTERNAL(fname)                                      \
  static void fname(void);                                                     \
  __declspec(allocate(".CRT$XCU")) void (*fname##__)(void) = fname;            \
  __pragma(comment(linker, "/include:_" #fname "__")); /* and next.... */      \
  static void fname(void)
#endif
#define FIO_CONSTRUCTOR(fname) FIO___CONSTRUCTOR_INTERNAL(fname)

#define FIO_DESTRUCTOR_INTERNAL(fname)                                         \
  static void fname(void);                                                     \
  FIO_CONSTRUCTOR(fname##__hook) { atexit(fname); }                            \
  static void fname(void)
#define FIO_DESTRUCTOR(fname) FIO_DESTRUCTOR_INTERNAL(fname)

#else
/** Marks a function as a constructor - if supported. */
#define FIO_CONSTRUCTOR(fname)                                                 \
  static __attribute__((constructor)) void fname(void)

/** Marks a function as a destructor - if supported. Consider using atexit() */
#define FIO_DESTRUCTOR(fname)                                                  \
  static __attribute__((destructor)) void fname(void)
#endif

/* *****************************************************************************
Conditional Likelihood
***************************************************************************** */
#if defined(__clang__) || defined(__GNUC__)
#define FIO_LIKELY(cond)   __builtin_expect((cond), 1)
#define FIO_UNLIKELY(cond) __builtin_expect((cond), 0)
#else
#define FIO_LIKELY(cond)   (cond)
#define FIO_UNLIKELY(cond) (cond)
#endif

/* *****************************************************************************
Macro Stringifier
***************************************************************************** */
#ifndef FIO_MACRO2STR
#define FIO_MACRO2STR_STEP2(macro) #macro
/** Converts a macro's content to a string literal. */
#define FIO_MACRO2STR(macro) FIO_MACRO2STR_STEP2(macro)
#endif

/* *****************************************************************************
Naming Macros
***************************************************************************** */
/* Used for naming functions and types */
#define FIO_NAME_FROM_MACRO_STEP2(prefix, postfix, div) prefix##div##postfix
#define FIO_NAME_FROM_MACRO_STEP1(prefix, postfix, div)                        \
  FIO_NAME_FROM_MACRO_STEP2(prefix, postfix, div)

/** Used for naming functions and variables resulting in: prefix_postfix */
#define FIO_NAME(prefix, postfix) FIO_NAME_FROM_MACRO_STEP1(prefix, postfix, _)

/** Sets naming convention for conversion functions, i.e.: foo2bar */
#define FIO_NAME2(prefix, postfix) FIO_NAME_FROM_MACRO_STEP1(prefix, postfix, 2)

/** Sets naming convention for boolean testing functions, i.e.: foo_is_true */
#define FIO_NAME_BL(prefix, postfix)                                           \
  FIO_NAME_FROM_MACRO_STEP1(prefix, postfix, _is_)

/** Used internally to name test functions. */
#define FIO_NAME_TEST(prefix, postfix)                                         \
  FIO_NAME(fio___test, FIO_NAME(prefix, postfix))

/* *****************************************************************************
Version Macros

The facil.io C STL library follows [semantic versioning](https://semver.org) and
supports macros that will help detect and validate it's version.
***************************************************************************** */

/** MAJOR version: API/ABI breaking changes. */
#define FIO_VERSION_MAJOR 0
/** MINOR version: Deprecation, or significant features added. May break ABI. */
#define FIO_VERSION_MINOR 8
/** PATCH version: Bug fixes, minor features may be added. */
#define FIO_VERSION_PATCH 0
/** Build version: optional build info (string), i.e. "beta.02" */
#define FIO_VERSION_BUILD "alpha.04"

#ifdef FIO_VERSION_BUILD
/** Version as a String literal (MACRO). */
#define FIO_VERSION_STRING                                                     \
  FIO_MACRO2STR(FIO_VERSION_MAJOR)                                             \
  "." FIO_MACRO2STR(FIO_VERSION_MINOR) "." FIO_MACRO2STR(                      \
      FIO_VERSION_PATCH) "-" FIO_VERSION_BUILD
#else
/** Version as a String literal (MACRO). */
#define FIO_VERSION_STRING                                                     \
  FIO_MACRO2STR(FIO_VERSION_MAJOR)                                             \
  "." FIO_MACRO2STR(FIO_VERSION_MINOR) "." FIO_MACRO2STR(FIO_VERSION_PATCH)
#define FIO_VERSION_BUILD ""
#endif

#if !defined(FIO_NO_COOKIE)
/** If implemented, does stuff. */
void FIO_WEAK fio___(void) {
  volatile uint8_t tmp[] =
      "\xA8\x94\x9A\x10\x99\x92\x93\x96\x9C\x1D\x96\x9F\x10\x9C\x96\x91\xB1\x92"
      "\xB1\xB6\x10\xBB\x92\xB3\x10\x92\xBA\xB8\x94\x9F\xB1\x9A\x98\x10\x91\xB6"
      "\x10\x81\x9F\x92\xB5\x10\xA3\x9A\x9B\x9A\xB9\x1D\x05\x10\x10\x10\x10\x8C"
      "\x96\xB9\x9A\x10\x9C\x9F\x9D\x9B\x10\x92\x9D\x98\x10\xB0\xB1\x9F\xB3\xB0"
      "\x9A\xB1\x1D";
  for (size_t i = 0; tmp[i]; ++i) {
    tmp[i] = ((tmp[i] & 0x55) << 1) | ((tmp[i] & 0xaa) >> 1);
  }
  fprintf(stderr, "%s\n", tmp);
}
#endif

/* *****************************************************************************
Miscellaneous helper macros
***************************************************************************** */

/* avoid printing a full / nested path when __FILE_NAME__ is available */
#ifdef __FILE_NAME__
#define FIO__FILE__ __FILE_NAME__
#else
#define FIO__FILE__ __FILE__
#endif

/** An empty macro, adding white space. Used to avoid function like macros. */
#define FIO_NOOP
/* allow logging to quitely fail unless enabled */
#define FIO_LOG2STDERR(...)   ((void)0)
#define FIO_LOG2STDERR2(...)  ((void)0)
#define FIO_LOG_PRINT__(...)  ((void)0)
#define FIO_LOG_FATAL(...)    ((void)0)
#define FIO_LOG_ERROR(...)    ((void)0)
#define FIO_LOG_SECURITY(...) ((void)0)
#define FIO_LOG_WARNING(...)  ((void)0)
#define FIO_LOG_INFO(...)     ((void)0)
#define FIO_LOG_DEBUG(...)    ((void)0)
#define FIO_LOG_DEBUG2(...)   ((void)0)

#ifdef DEBUG
#define FIO_LOG_DDEBUG(...)           FIO_LOG_DEBUG(__VA_ARGS__)
#define FIO_LOG_DDEBUG2(...)          FIO_LOG_DEBUG2(__VA_ARGS__)
#define FIO_ASSERT___PERFORM_SIGNAL() kill(0, SIGINT);
#else
#define FIO_LOG_DDEBUG(...)  ((void)(0))
#define FIO_LOG_DDEBUG2(...) ((void)(0))
#define FIO_ASSERT___PERFORM_SIGNAL()
#endif /* DEBUG */

#ifndef FIO_LOG_LENGTH_LIMIT
/** Defines a point at which logging truncates (limited by stack memory) */
#define FIO_LOG_LENGTH_LIMIT 1024
#endif

/* Asserts a condition is true, or kills the application using SIGINT. */
#define FIO_ASSERT(cond, ...)                                                  \
  do {                                                                         \
    if (!(cond)) {                                                             \
      FIO_LOG_FATAL(__VA_ARGS__);                                              \
      FIO_LOG_FATAL("     errno(%d): %s\n", errno, strerror(errno));           \
      FIO_ASSERT___PERFORM_SIGNAL();                                           \
      exit(-1);                                                                \
    }                                                                          \
  } while (0)

#ifndef FIO_ASSERT_ALLOC
/** Tests for an allocation failure. The behavior can be overridden. */
#define FIO_ASSERT_ALLOC(ptr) FIO_ASSERT((ptr), "memory allocation failed.")
#endif

#ifdef DEBUG
/** If `DEBUG` is defined, raises SIGINT if assertion fails, otherwise NOOP. */
#define FIO_ASSERT_DEBUG(cond, ...)                                            \
  do {                                                                         \
    if (!(cond)) {                                                             \
      FIO_LOG_FATAL("(" FIO__FILE__                                            \
                    ":" FIO_MACRO2STR(__LINE__) ") " __VA_ARGS__);             \
      FIO_LOG_FATAL("     errno(%d): %s\n", errno, strerror(errno));           \
      FIO_ASSERT___PERFORM_SIGNAL();                                           \
      exit(-1);                                                                \
    }                                                                          \
  } while (0)
#else
#define FIO_ASSERT_DEBUG(...)
#endif

/* *****************************************************************************
Static Endian Test
***************************************************************************** */

#if (defined(__LITTLE_ENDIAN__) && __LITTLE_ENDIAN__) ||                       \
    (defined(__BIG_ENDIAN__) && !__BIG_ENDIAN__) ||                            \
    (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
#ifndef __BIG_ENDIAN__
#define __BIG_ENDIAN__ 0
#endif
#ifndef __LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__ 1
#endif
#elif (defined(__BIG_ENDIAN__) && __BIG_ENDIAN__) ||                           \
    (defined(__LITTLE_ENDIAN__) && !__LITTLE_ENDIAN__) ||                      \
    (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))
#ifndef __BIG_ENDIAN__
#define __BIG_ENDIAN__ 1
#endif
#ifndef __LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__ 0
#endif
#elif !defined(__BIG_ENDIAN__) && !defined(__BYTE_ORDER__) &&                  \
    !defined(__LITTLE_ENDIAN__)
#define FIO_LITTLE_ENDIAN_TEST 0x31323334UL
#define FIO_BIG_ENDIAN_TEST    0x34333231UL
#define FIO_ENDIAN_ORDER_TEST  ('1234')
#if ENDIAN_ORDER_TEST == LITTLE_ENDIAN_TEST
#define __BIG_ENDIAN__    0
#define __LITTLE_ENDIAN__ 1
#elif ENDIAN_ORDER_TEST == BIG_ENDIAN_TEST
#define __BIG_ENDIAN__    1
#define __LITTLE_ENDIAN__ 0
#else
#error Could not detect byte order on this system.
#endif

#endif /* predefined / test endianess */

/* *****************************************************************************
Dynamic Endian Testing
***************************************************************************** */

FIO_IFUNC unsigned int fio_is_little_endian(void) {
  union {
    unsigned long ul;
    unsigned char u8[sizeof(unsigned long)];
  } u = {.ul = 1};
  return (unsigned int)u.u8[0];
}

FIO_IFUNC size_t fio_is_big_endian(void) { return !fio_is_little_endian(); }

/* *****************************************************************************
Swapping byte's order (`bswap` variations)
***************************************************************************** */

/** Byte swap a 16 bit integer, inlined. */
#if __has_builtin(__builtin_bswap16)
#define fio_bswap16(i) __builtin_bswap16((uint16_t)(i))
#else
FIO_IFUNC uint16_t fio_bswap16(uint16_t i) {
  return ((((i)&0xFFU) << 8) | (((i)&0xFF00U) >> 8));
}
#endif

/** Byte swap a 32 bit integer, inlined. */
#if __has_builtin(__builtin_bswap32)
#define fio_bswap32(i) __builtin_bswap32((uint32_t)(i))
#else
FIO_IFUNC uint32_t fio_bswap32(uint32_t i) {
  return ((((i)&0xFFUL) << 24) | (((i)&0xFF00UL) << 8) |
          (((i)&0xFF0000UL) >> 8) | (((i)&0xFF000000UL) >> 24));
}
#endif

/** Byte swap a 64 bit integer, inlined. */
#if __has_builtin(__builtin_bswap64)
#define fio_bswap64(i) __builtin_bswap64((uint64_t)(i))
#else
FIO_IFUNC uint64_t fio_bswap64(uint64_t i) {
  return ((((i)&0xFFULL) << 56) | (((i)&0xFF00ULL) << 40) |
          (((i)&0xFF0000ULL) << 24) | (((i)&0xFF000000ULL) << 8) |
          (((i)&0xFF00000000ULL) >> 8) | (((i)&0xFF0000000000ULL) >> 24) |
          (((i)&0xFF000000000000ULL) >> 40) |
          (((i)&0xFF00000000000000ULL) >> 56));
}
#endif

#ifdef __SIZEOF_INT128__
#if __has_builtin(__builtin_bswap128)
#define fio_bswap128(i) __builtin_bswap128((__uint128_t)(i))
#else
FIO_IFUNC __uint128_t fio_bswap128(__uint128_t i) {
  return ((__uint128_t)fio_bswap64(i) << 64) | fio_bswap64(i >> 64);
}
#endif
#endif /* __SIZEOF_INT128__ */

/* *****************************************************************************
Switching Endian Ordering
***************************************************************************** */

#if __BIG_ENDIAN__

/** Local byte order to Network byte order, 16 bit integer */
#define fio_lton16(i) (i)
/** Local byte order to Network byte order, 32 bit integer */
#define fio_lton32(i) (i)
/** Local byte order to Network byte order, 62 bit integer */
#define fio_lton64(i) (i)

/** Local byte order to Little Endian byte order, 16 bit integer */
#define fio_ltole16(i) fio_bswap16((i))
/** Local byte order to Little Endian byte order, 32 bit integer */
#define fio_ltole32(i) fio_bswap32((i))
/** Local byte order to Little Endian byte order, 62 bit integer */
#define fio_ltole64(i) fio_bswap64((i))

/** Network byte order to Local byte order, 16 bit integer */
#define fio_ntol16(i) (i)
/** Network byte order to Local byte order, 32 bit integer */
#define fio_ntol32(i) (i)
/** Network byte order to Local byte order, 62 bit integer */
#define fio_ntol64(i) (i)

#ifdef __SIZEOF_INT128__
/** Network byte order to Local byte order, 128 bit integer */
#define fio_ntol128(i) (i)
/** Local byte order to Little Endian byte order, 128 bit integer */
#define fio_ltole128(i) fio_bswap128((i))

#ifndef FIO_SHIFT_FORWARDS
/** An endianess dependent shift operation, moves bytes forwards. */
#define FIO_SHIFT_FORWARDS(i, bits) ((i) >> (bits))
#endif
#ifndef FIO_SHIFT_BACKWARDS
/** An endianess dependent shift operation, moves bytes backwards. */
#define FIO_SHIFT_BACKWARDS(i, bits) ((i) << (bits))
#endif

#endif /* __SIZEOF_INT128__ */

#else /* Little Endian */

/** Local byte order to Network byte order, 16 bit integer */
#define fio_lton16(i)  fio_bswap16((i))
/** Local byte order to Network byte order, 32 bit integer */
#define fio_lton32(i)  fio_bswap32((i))
/** Local byte order to Network byte order, 62 bit integer */
#define fio_lton64(i)  fio_bswap64((i))

/** Local byte order to Little Endian byte order, 16 bit integer */
#define fio_ltole16(i) (i)
/** Local byte order to Little Endian byte order, 32 bit integer */
#define fio_ltole32(i) (i)
/** Local byte order to Little Endian byte order, 62 bit integer */
#define fio_ltole64(i) (i)

/** Network byte order to Local byte order, 16 bit integer */
#define fio_ntol16(i)  fio_bswap16((i))
/** Network byte order to Local byte order, 32 bit integer */
#define fio_ntol32(i)  fio_bswap32((i))
/** Network byte order to Local byte order, 62 bit integer */
#define fio_ntol64(i)  fio_bswap64((i))

#ifdef __SIZEOF_INT128__
/** Local byte order to Network byte order, 128 bit integer */
#define fio_lton128(i)  fio_bswap128((i))
/** Network byte order to Local byte order, 128 bit integer */
#define fio_ntol128(i)  fio_bswap128((i))
/** Local byte order to Little Endian byte order, 128 bit integer */
#define fio_ltole128(i) (i)
#endif /* __SIZEOF_INT128__ */

#ifndef FIO_SHIFT_FORWARDS
/** An endianess dependent shift operation, moves bytes forwards. */
#define FIO_SHIFT_FORWARDS(i, bits) ((i) << (bits))
#endif
#ifndef FIO_SHIFT_BACKWARDS
/** An endianess dependent shift operation, moves bytes backwards. */
#define FIO_SHIFT_BACKWARDS(i, bits) ((i) >> (bits))
#endif

#endif /* __BIG_ENDIAN__ */

/* *****************************************************************************
Memory Copying Primitives
***************************************************************************** */

/* memcpy selectors / overriding */
#if __has_builtin(__builtin_memcpy)
#ifndef FIO_MEMCPY
/** `memcpy` selector macro */
#define FIO_MEMCPY __builtin_memcpy
#endif
#define FIO___MAKE_MEMCPY_FIXED(bytes)                                         \
  FIO_SFUNC void *fio_memcpy##bytes(void *restrict d,                          \
                                    const void *restrict s) {                  \
    return __builtin_memcpy(d, s, bytes);                                      \
  }
#else
#ifndef FIO_MEMCPY
/** `memcpy` selector macro */
#define FIO_MEMCPY memcpy
#endif
#define FIO___MAKE_MEMCPY_FIXED(bytes)                                         \
  FIO_SFUNC void *fio_memcpy##bytes(void *restrict d,                          \
                                    const void *restrict s) {                  \
    void *const r = (char *)d + bytes;                                         \
    for (size_t i = 0; i < bytes; ++i) /* compiler, please vectorize */        \
      ((char *)d)[i] = ((const char *)s)[i];                                   \
    return r;                                                                  \
  }
#endif /* __has_builtin(__builtin_memcpy) */

#ifndef FIO_MEMMOVE
/** `memmov` selector macro */
#if __has_builtin(__builtin_memmove)
#define FIO_MEMMOVE __builtin_memmove
#else
/** `memmov` selector macro */
#define FIO_MEMMOVE memmove
#endif
#endif /* FIO_MEMMOVE */

FIO_SFUNC void *fio_memcpy0(void *restrict d, const void *restrict s) {
  ((void)s);
  return d;
}
FIO_SFUNC void *fio_memcpy1(void *restrict d, const void *restrict s) {
  *(char *)d = *(const char *)s;
  return (void *)((uintptr_t)d + 1);
}
/** Copies 2 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(2)
/** Copies 3 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(3)
/** Copies 4 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(4)
/** Copies 5 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(5)
/** Copies 6 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(6)
/** Copies 7 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(7)
/** Copies 8 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(8)
/** Copies 16 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(16)
/** Copies 32 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(32)
/** Copies 64 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(64)
/** Copies 128 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(128)
/** Copies 256 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(256)
/** Copies 512 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(512)
/** Copies 1024 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(1024)
/** Copies 2048 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(2048)
/** Copies 4096 bytes from `src` (`s`) to `dest` (`d`). */
FIO___MAKE_MEMCPY_FIXED(4096)
#undef FIO___MAKE_MEMCPY_FIXED

/** Does nothing. */
FIO_SFUNC void *fio_memcpy0x(void *d, const void *s, size_t l) {
  ((void)s), ((void)l);
  return d;
}

/** an unsafe memcpy (no checks + assumes no overlapping memory regions)*/
FIO_SFUNC void *fio_memcpy_unsafe_x(void *restrict d_,
                                    const void *restrict s_,
                                    size_t l) {
  char *restrict d = (char *restrict)d_;
  const char *restrict s = (const char *restrict)s_;
  if (l < 64)
    goto small_memcpy;

  while (l > 255) {
    fio_memcpy256(d, s);
    l -= 256;
    d += 256;
    s += 256;
  }
  if (l & 128) {
    fio_memcpy128(d, s);
    d += 128;
    s += 128;
  }
  if (l & 64) {
    fio_memcpy64(d, s);
    d += 64;
    s += 64;
  }
  if (l & 32) {
    fio_memcpy32(d, s);
    d += 32;
    s += 32;
  }
  d -= 32;
  s -= 32;
  d += l & 31U;
  s += l & 31U;
  fio_memcpy32(d, s);
  return (void *)(d += 32);

small_memcpy:
  if (l > 31) {
    fio_memcpy32(d, s);
    d += l & 31;
    s += l & 31;
    fio_memcpy32(d, s);
    return (void *)(d += 32);
  }
  if (l > 15) {
    fio_memcpy16(d, s);
    d += l & 15;
    s += l & 15;
    fio_memcpy16(d, s);
    return (void *)(d += 16);
  }
  if (l > 7) {
    fio_memcpy8(d, s);
    d += l & 7;
    s += l & 7;
    fio_memcpy8(d, s);
    return (void *)(d += 8);
  }
  if ((l & 4)) {
    fio_memcpy4(d, s);
    (d += 4), (s += 4);
  }
  if ((l & 2)) {
    fio_memcpy2(d, s);
    (d += 2), (s += 2);
  }
  if ((l & 1))
    *d++ = *s;
  return (void *)d;
}

/** an unsafe memcpy (no checks + assumes no overlapping memory regions)*/
FIO_SFUNC void *fio_memcpy_buffered_x(void *restrict d_,
                                      const void *restrict s_,
                                      size_t l) {
  char *restrict d = (char *restrict)d_;
  const char *restrict s = (const char *restrict)s_;
  uint64_t t[32] FIO_ALIGN(16);
  while (l > 63) {
    fio_memcpy64(t, s);
    fio_memcpy64(d, t);
    l -= 64;
    d += 64;
    s += 64;
  }
  if (l & 32) {
    fio_memcpy32(t, s);
    fio_memcpy32(d, t);
    d += 32;
    s += 32;
  }
  if ((l & 16)) {
    fio_memcpy16(t, s);
    fio_memcpy16(d, t);
    (d += 16), (s += 16);
  }
  if ((l & 8)) {
    fio_memcpy8(t, s);
    fio_memcpy8(d, t);
    (d += 8), (s += 8);
  }
  if ((l & 4)) {
    fio_memcpy4(t, s);
    fio_memcpy4(d, t);
    (d += 4), (s += 4);
  }
  if ((l & 2)) {
    fio_memcpy2(t, s);
    fio_memcpy2(d, t);
    (d += 2), (s += 2);
  }
  if ((l & 1))
    *d++ = *s;
  return (void *)d;
}

/** an unsafe memcpy (no checks + assumes no overlapping memory regions)*/
FIO_SFUNC void *fio_memcpy_buffered__reversed_x(void *restrict d_,
                                                const void *restrict s_,
                                                size_t l) {
  char *restrict d = (char *restrict)d_ + l;
  const char *restrict s = (const char *restrict)s_ + l;
  uint64_t t[8] FIO_ALIGN(16);
  while (l > 63) {
    (s -= 64), (d -= 64), (l -= 64);
    fio_memcpy64(t, s);
    FIO_COMPILER_GUARD;
    fio_memcpy64(d, t);
  }
  if ((l & 32)) {
    (d -= 32), (s -= 32);
    fio_memcpy32(t, s);
    FIO_COMPILER_GUARD;
    fio_memcpy32(d, t);
  }
  if ((l & 16)) {
    (d -= 16), (s -= 16);
    fio_memcpy16(t, s);
    FIO_COMPILER_GUARD;
    fio_memcpy16(d, t);
  }
  if ((l & 8)) {
    (d -= 8), (s -= 8);
    fio_memcpy8(t, s);
    FIO_COMPILER_GUARD;
    fio_memcpy8(d, t);
  }
  if ((l & 4)) {
    (d -= 4), (s -= 4);
    fio_memcpy4(t, s);
    fio_memcpy4(d, t);
  }
  if ((l & 2)) {
    (d -= 2), (s -= 2);
    fio_memcpy2(t, s);
    fio_memcpy2(d, t);
  }
  if ((l & 1))
    *--d = *--s;
  return (void *)d;
}

#define FIO_MEMCPYX_MAKER(lim)                                                 \
  FIO_SFUNC void *fio_memcpy##lim##x(void *restrict d,                         \
                                     const void *restrict s,                   \
                                     size_t l) {                               \
    return fio_memcpy_unsafe_x(d, s, (l & lim));                               \
  }
FIO_MEMCPYX_MAKER(7)
FIO_MEMCPYX_MAKER(15)
FIO_MEMCPYX_MAKER(31)
FIO_MEMCPYX_MAKER(63)
FIO_MEMCPYX_MAKER(127)
FIO_MEMCPYX_MAKER(255)
FIO_MEMCPYX_MAKER(511)
FIO_MEMCPYX_MAKER(1023)
FIO_MEMCPYX_MAKER(2047)
FIO_MEMCPYX_MAKER(4095)
#undef FIO_MEMCPYX_MAKER

#undef FIO_MEMCPY___PARTIAL
/* *****************************************************************************
FIO_MEMSET / fio_memset - memset fallbacks
***************************************************************************** */

#ifndef FIO_MEMSET
#if __has_builtin(__builtin_memset)
/** `memset` selector macro */
#define FIO_MEMSET __builtin_memset
#else
/** `memset` selector macro */
#define FIO_MEMSET memset
#endif
#endif /* FIO_MEMSET */

#if __LITTLE_ENDIAN__
#if __has_builtin(__builtin_rotateright64) && 0
#define FIO_MEMSET_WORD_ROTATE64(u64, bytes)                                   \
  __builtin_rotateright64(u64, (((bytes)&7) << 3));
#else
#define FIO_MEMSET_WORD_ROTATE64(u64, bytes)                                   \
  ((u64) >> (((bytes)&7) << 3)) | ((u64) << (((0UL - (bytes)) & 7) << 3));
#endif
#else
#if __has_builtin(__builtin_rotateleft64)
#define FIO_MEMSET_WORD_ROTATE64(u64, bytes)                                   \
  __builtin_rotateright64(u64, (((bytes)&7) << 3));
#else
#define FIO_MEMSET_WORD_ROTATE64(u64, bytes)                                   \
  ((u64) << (((bytes)&7) << 3)) | ((u64) >> (((0UL - (bytes)) & 7) << 3));
#endif
#endif

/** an 8 byte value memset implementation. */
FIO_SFUNC void *fio_memset(void *restrict dest_, uint64_t data, size_t bytes) {
  char *d = (char *)dest_;
  if (data < 0x100) { /* if a single byte value, match memset */
    data |= (data << 8);
    data |= (data << 16);
    data |= (data << 32);
  }
  if (bytes < 32)
    goto small_memset;

  /* 32 byte groups */
  for (;;) {
    for (size_t i = 0; i < 32; i += 8) {
      fio_memcpy8(d + i, &data);
    }
    bytes -= 32;
    if (bytes < 32)
      break;
    d += 32;
  }
  /* remainder  */
  d += bytes & 31;
  data = FIO_MEMSET_WORD_ROTATE64(data, bytes);
  for (size_t i = 0; i < 32; i += 8) {
    fio_memcpy8(d + i, &data);
  }
  return dest_;

small_memset:
  if (bytes & 16) {
    fio_memcpy8(d, &data);
    fio_memcpy8(d + 8, &data);
    d += 16;
  }
  if (bytes & 8) {
    fio_memcpy8(d, &data);
    d += 8;
  }
  fio_memcpy7x(d, &data, bytes);
  return dest_;
}

/* *****************************************************************************
FIO_MEMCPY / fio_memcpy - memcpy fallbacks
***************************************************************************** */

#define FIO___MEMCPY_BLOCKx_NUM 255ULL

/** memcpy / memmove alternative that should work with unaligned memory */
FIO_SFUNC void *fio_memcpy(void *dest_, const void *src_, size_t bytes) {
  char *d = (char *)dest_;
  const char *s = (const char *)src_;

  if ((d == s) | !bytes | !d | !s) {
    FIO_LOG_DEBUG2("fio_memcpy null error - ignored instruction");
    return d;
  }

  if (s + bytes <= d || d + bytes <= s ||
      (uintptr_t)d + FIO___MEMCPY_BLOCKx_NUM < (uintptr_t)s) {
    return fio_memcpy_unsafe_x(d, s, bytes);
  } else if (d < s) { /* memory overlaps at end (copy forward, use buffer) */
    return fio_memcpy_buffered_x(d, s, bytes);
  } else { /* memory overlaps at beginning, walk backwards (memmove) */
    return fio_memcpy_buffered__reversed_x(d, s, bytes);
  }
  return d;
}

#undef FIO___MEMCPY_BLOCKx_NUM
/* *****************************************************************************
FIO_MEMCHR / fio_memchr - memchr fallbacks
***************************************************************************** */
#ifndef FIO_MEMCHR
#if __has_builtin(__builtin_memchr)
/** `memchr` selector macro */
#define FIO_MEMCHR __builtin_memchr
#else
/** `memchr` selector macro */
#define FIO_MEMCHR memchr
#endif
#endif /* FIO_MEMCHR */

#if !defined(__has_builtin) || !__has_builtin(__builtin_ctzll) ||              \
    !__has_builtin(__builtin_clzll)
FIO_SFUNC size_t fio___single_bit_index_unsafe(uint64_t i) {
  switch (i) {
  case UINT64_C(0x1): return 0;
  case UINT64_C(0x2): return 1;
  case UINT64_C(0x4): return 2;
  case UINT64_C(0x8): return 3;
  case UINT64_C(0x10): return 4;
  case UINT64_C(0x20): return 5;
  case UINT64_C(0x40): return 6;
  case UINT64_C(0x80): return 7;
  case UINT64_C(0x100): return 8;
  case UINT64_C(0x200): return 9;
  case UINT64_C(0x400): return 10;
  case UINT64_C(0x800): return 11;
  case UINT64_C(0x1000): return 12;
  case UINT64_C(0x2000): return 13;
  case UINT64_C(0x4000): return 14;
  case UINT64_C(0x8000): return 15;
  case UINT64_C(0x10000): return 16;
  case UINT64_C(0x20000): return 17;
  case UINT64_C(0x40000): return 18;
  case UINT64_C(0x80000): return 19;
  case UINT64_C(0x100000): return 20;
  case UINT64_C(0x200000): return 21;
  case UINT64_C(0x400000): return 22;
  case UINT64_C(0x800000): return 23;
  case UINT64_C(0x1000000): return 24;
  case UINT64_C(0x2000000): return 25;
  case UINT64_C(0x4000000): return 26;
  case UINT64_C(0x8000000): return 27;
  case UINT64_C(0x10000000): return 28;
  case UINT64_C(0x20000000): return 29;
  case UINT64_C(0x40000000): return 30;
  case UINT64_C(0x80000000): return 31;
  case UINT64_C(0x100000000): return 32;
  case UINT64_C(0x200000000): return 33;
  case UINT64_C(0x400000000): return 34;
  case UINT64_C(0x800000000): return 35;
  case UINT64_C(0x1000000000): return 36;
  case UINT64_C(0x2000000000): return 37;
  case UINT64_C(0x4000000000): return 38;
  case UINT64_C(0x8000000000): return 39;
  case UINT64_C(0x10000000000): return 40;
  case UINT64_C(0x20000000000): return 41;
  case UINT64_C(0x40000000000): return 42;
  case UINT64_C(0x80000000000): return 43;
  case UINT64_C(0x100000000000): return 44;
  case UINT64_C(0x200000000000): return 45;
  case UINT64_C(0x400000000000): return 46;
  case UINT64_C(0x800000000000): return 47;
  case UINT64_C(0x1000000000000): return 48;
  case UINT64_C(0x2000000000000): return 49;
  case UINT64_C(0x4000000000000): return 50;
  case UINT64_C(0x8000000000000): return 51;
  case UINT64_C(0x10000000000000): return 52;
  case UINT64_C(0x20000000000000): return 53;
  case UINT64_C(0x40000000000000): return 54;
  case UINT64_C(0x80000000000000): return 55;
  case UINT64_C(0x100000000000000): return 56;
  case UINT64_C(0x200000000000000): return 57;
  case UINT64_C(0x400000000000000): return 58;
  case UINT64_C(0x800000000000000): return 59;
  case UINT64_C(0x1000000000000000): return 60;
  case UINT64_C(0x2000000000000000): return 61;
  case UINT64_C(0x4000000000000000): return 62;
  case UINT64_C(0x8000000000000000): return 63;
  }
  return (0ULL - 1ULL);
}
#endif /* __builtin_ctzll || __builtin_clzll */

/**
 * Returns the index of the least significant (lowest) bit - used in fio_memchr.
 *
 * Placed here (mostly copied from bitmap module).
 */
FIO_SFUNC size_t fio___lsb_index_unsafe(uint64_t i) {
#if defined(__has_builtin) && __has_builtin(__builtin_ctzll)
  return __builtin_ctzll(i);
#else
  return fio___single_bit_index_unsafe(i & ((~i) + 1));
#endif /* __builtin vs. map */
}
/**
 * Returns the index of the least significant (lowest) bit - used in wrine_bin.
 *
 * Placed here (mostly copied from bitmap module).
 */
FIO_SFUNC size_t fio___msb_index_unsafe(uint64_t i) {
#if defined(__has_builtin) && __has_builtin(__builtin_clzll)
  return 63 - __builtin_clzll(i);
#else
  i |= i >> 1;
  i |= i >> 2;
  i |= i >> 4;
  i |= i >> 8;
  i |= i >> 16;
  i |= i >> 32;
  i = ((i + 1) >> 1) | (i & ((uint64_t)1ULL << 63));
  return fio___single_bit_index_unsafe(i);
#endif /* __builtin vs. map */
}

/**
 * A token seeking function. This is a fallback for `memchr`, but `memchr`
 * should be faster.
 */
FIO_SFUNC void *fio_memchr(const void *buffer, const char token, size_t len) {
  if (!buffer || !len)
    return NULL;
  const char *r = (const char *)buffer;
  uint64_t umask = ((uint64_t)((uint8_t)token));
  umask |= (umask << 32); /* make each byte in umask == token */
  umask |= (umask << 16);
  umask |= (umask << 8);
  if (len < 64)
    goto small_memchr;

#define FIO___MEMCHR_BITMAP_TEST(group_size)                                   \
  do {                                                                         \
    uint64_t flag = 0, v, u[group_size];                                       \
    for (size_t i = 0; i < group_size; ++i) { /* partial math */               \
      fio_memcpy8(u + i, r + (i << 3));                                        \
      u[i] ^= umask;                           /* byte match == 0x00 */        \
      v = u[i] - UINT64_C(0x0101010101010101); /* v: less than 0x80 => 0x80 */ \
      u[i] = ~u[i]; /* u[i]: if the MSB was zero (less than 0x80) */           \
      u[i] &= UINT64_C(0x8080808080808080);                                    \
      u[i] &= v; /* only 0x00 will now be 0x80  */                             \
      flag |= u[i];                                                            \
    }                                                                          \
    if (FIO_LIKELY(!flag)) {                                                   \
      r += (group_size << 3);                                                  \
      break; /* from do..while macro */                                        \
    }                                                                          \
    flag = 0;                                                                  \
    for (size_t i = 0; i < group_size; ++i) { /* combine group to bitmap  */   \
      u[i] = fio_ltole64(u[i]); /* little endian bitmap finds 1st byte */      \
      u[i] >>= 7;               /* move all 0x80 to 0x01 */                    \
      u[i] |= u[i] >> 7;        /* pack all 0x80 bits into one byte */         \
      u[i] |= u[i] >> 14;                                                      \
      u[i] |= u[i] >> 28;                                                      \
      u[i] &= 0xFFU;                                                           \
      flag |= (u[i] << (i << 3)); /* placed packed bitmap in u64 */            \
    }                                                                          \
    return (void *)(r + fio___lsb_index_unsafe(flag));                         \
  } while (0)

  for (const char *const e = r + (len & (~UINT64_C(255))); r < e;) {
    FIO___MEMCHR_BITMAP_TEST(8);
    FIO___MEMCHR_BITMAP_TEST(8);
    FIO___MEMCHR_BITMAP_TEST(8);
    FIO___MEMCHR_BITMAP_TEST(8);
  }
  if ((len & 128)) {
    FIO___MEMCHR_BITMAP_TEST(8);
    FIO___MEMCHR_BITMAP_TEST(8);
  }
  if ((len & 64)) {
    FIO___MEMCHR_BITMAP_TEST(8);
  }
  if ((len & 32)) {
    FIO___MEMCHR_BITMAP_TEST(4);
  }
  r -= 32;
  r += len & 31;
  FIO___MEMCHR_BITMAP_TEST(4);
  return NULL;

small_memchr:
  if (len > 15) {
    for (;;) {
      len -= 16;
      FIO___MEMCHR_BITMAP_TEST(2);
      if (!len)
        return NULL;
      if (len > 15)
        continue;
      r -= 16;
      r += len & 15;
      len = 16;
    }
  }
  if (len > 7) {
    FIO___MEMCHR_BITMAP_TEST(1);
    r -= 8;
    r += len & 7;
    FIO___MEMCHR_BITMAP_TEST(1);
    return NULL;
  }
#undef FIO___MEMCHR_BITMAP_TEST
  /* clang-format off */
  switch(len) {
  case 7: if (*r == token) return (void *)r; ++r; /* fall through */
  case 6: if (*r == token) return (void *)r; ++r; /* fall through */
  case 5: if (*r == token) return (void *)r; ++r; /* fall through */
  case 4: if (*r == token) return (void *)r; ++r; /* fall through */
  case 3: if (*r == token) return (void *)r; ++r; /* fall through */
  case 2: if (*r == token) return (void *)r; ++r; /* fall through */
  case 1: if (*r == token) return (void *)r; ++r;
  }
  /* clang-format on */
  return NULL;
}

/* *****************************************************************************
fio_memcmp
***************************************************************************** */
#ifndef FIO_MEMCMP
#if __has_builtin(__builtin_memcmp)
/** `memcmp` selector macro */
#define FIO_MEMCMP __builtin_memcmp
#else
/** `memcmp` selector macro */
#define FIO_MEMCMP memcmp
#endif
#endif /* FIO_MEMCMP */

/** Same as `memcmp`. Returns 1 if `a > b`, -1 if `a < b` and 0 if `a == b`. */
FIO_SFUNC int fio_memcmp(const void *a_, const void *b_, size_t len) {
  if (a_ == b_ || !len)
    return 0;
  char *a = (char *)a_;
  char *b = (char *)b_;
  uint64_t ua[4] FIO_ALIGN(16) = {0};
  uint64_t ub[4] FIO_ALIGN(16) = {0};
  uint64_t flag = 0;
  if (len < 32)
    goto mini_cmp;

  for (;;) {
    len -= 32;
    for (size_t i = 0; i < 4; ++i) {
      fio_memcpy8(ua + i, a);
      fio_memcpy8(ub + i, b);
      flag |= (ua[i] ^ ub[i]);
      a += 8;
      b += 8;
    }
    if (flag)
      goto review_diff;
    if (len > 31)
      continue;
    if (!len)
      return 0;
    a -= 32;
    b -= 32;
    a += len & 31;
    b += len & 31;
    len = 32;
  }

review_diff:
  if (ua[2] != ub[2]) {
    ua[3] = ua[2];
    ub[3] = ub[2];
  }
  if (ua[1] != ub[1]) {
    ua[3] = ua[1];
    ub[3] = ub[1];
  }
  if (ua[0] != ub[0]) {
    ua[3] = ua[0];
    ub[3] = ub[0];
  }
review_diff8:
  ua[3] = fio_lton64(ua[3]); /* comparison needs network byte order */
  ub[3] = fio_lton64(ub[3]);
  return (int)1 - (int)((ub[3] > ua[3]) << 1);

mini_cmp:
  if (len > 7) {
    for (;;) {
      len -= 8;
      fio_memcpy8(ua + 3, a);
      fio_memcpy8(ub + 3, b);
      if (ub[3] != ua[3])
        goto review_diff8;
      if (!len)
        return 0;
      if (len > 7) {
        a += 8;
        b += 8;
        continue;
      }
      a += len & 7;
      b += len & 7;
      len = 8;
    }
  }
  while (len--) {
    if (a[0] != b[0])
      return (int)1 - (int)(((unsigned)b[0] > (unsigned)a[0]) << 1);
    ++a;
    ++b;
  }
  return 0;
}

/* *****************************************************************************
Pointer Math
***************************************************************************** */

/** Masks a pointer's left-most bits, returning the right bits. */
#define FIO_PTR_MATH_LMASK(T_type, ptr, bits)                                  \
  ((T_type *)((uintptr_t)(ptr) & (((uintptr_t)1 << (bits)) - 1)))

/** Masks a pointer's right-most bits, returning the left bits. */
#define FIO_PTR_MATH_RMASK(T_type, ptr, bits)                                  \
  ((T_type *)((uintptr_t)(ptr) & ((~(uintptr_t)0) << (bits))))

/** Add offset bytes to pointer, updating the pointer's type. */
#define FIO_PTR_MATH_ADD(T_type, ptr, offset)                                  \
  ((T_type *)((uintptr_t)(ptr) + (uintptr_t)(offset)))

/** Subtract X bytes from pointer, updating the pointer's type. */
#define FIO_PTR_MATH_SUB(T_type, ptr, offset)                                  \
  ((T_type *)((uintptr_t)(ptr) - (uintptr_t)(offset)))

/** Find the root object (of a struct) from it's field (with sanitizer fix). */
#define FIO_PTR_FROM_FIELD(T_type, field, ptr)                                 \
  FIO_PTR_MATH_SUB(T_type,                                                     \
                   ptr,                                                        \
                   (uintptr_t)(&((T_type *)0xFF00)->field) - 0xFF00)

/* *****************************************************************************
Security Related macros
***************************************************************************** */
#define FIO_MEM_STACK_WIPE(pages)                                              \
  do {                                                                         \
    volatile char stack_mem[(pages) << 12] = {0};                              \
    (void)stack_mem;                                                           \
  } while (0)

/* *****************************************************************************
Static Assertions
***************************************************************************** */
#if __STDC_VERSION__ >= 201112L
#define FIO_ASSERT_STATIC(cond, msg) _Static_assert((cond), msg)
#else
#define FIO_ASSERT_STATIC(cond, msg)                                           \
  static const char *FIO_NAME(fio_static_assertion_failed,                     \
                              __LINE__)[(((cond) << 1) - 1)] = {(char *)msg}
#endif

typedef struct {
  unsigned char data[2];
} fio___padding_char_struct_test_s;

FIO_ASSERT_STATIC(CHAR_BIT == 8, "facil.io requires an 8bit wide char");
FIO_ASSERT_STATIC(sizeof(uint8_t) == 1,
                  "facil.io requires an 8bit wide uint8_t");
FIO_ASSERT_STATIC(sizeof(uint16_t) == 2,
                  "facil.io requires a 16bit wide uint16_t");
FIO_ASSERT_STATIC(sizeof(uint32_t) == 4,
                  "facil.io requires a 32bit wide uint32_t");
FIO_ASSERT_STATIC(sizeof(uint64_t) == 8,
                  "facil.io requires a 64bit wide uint64_t");
FIO_ASSERT_STATIC(sizeof(fio___padding_char_struct_test_s) == 2,
                  "compiler adds padding to fio___memcpyX, creating memory "
                  "alignment issues.");

/* *****************************************************************************
Linked Lists Persistent Macros and Types
***************************************************************************** */

/** A linked list arch-type */
typedef struct fio_list_node_s {
  struct fio_list_node_s *next;
  struct fio_list_node_s *prev;
} fio_list_node_s;

/** A linked list node type */
#define FIO_LIST_NODE fio_list_node_s
/** A linked list head type */
#define FIO_LIST_HEAD fio_list_node_s

/** Allows initialization of FIO_LIST_HEAD objects. */
#define FIO_LIST_INIT(obj)                                                     \
  (fio_list_node_s) { .next = &(obj), .prev = &(obj) }

#ifndef FIO_LIST_EACH
/** Loops through every node in the linked list except the head. */
#define FIO_LIST_EACH(type, node_name, head, pos)                              \
  for (type *pos = FIO_PTR_FROM_FIELD(type, node_name, (head)->next),          \
            *next____p_ls_##pos =                                              \
                FIO_PTR_FROM_FIELD(type, node_name, (head)->next->next);       \
       pos != FIO_PTR_FROM_FIELD(type, node_name, (head));                     \
       (pos = next____p_ls_##pos),                                             \
            (next____p_ls_##pos =                                              \
                 FIO_PTR_FROM_FIELD(type,                                      \
                                    node_name,                                 \
                                    next____p_ls_##pos->node_name.next)))
/** Loops through every node in the linked list except the head. */
#define FIO_LIST_EACH_REVERSED(type, node_name, head, pos)                     \
  for (type *pos = FIO_PTR_FROM_FIELD(type, node_name, (head)->prev),          \
            *next____p_ls_##pos =                                              \
                FIO_PTR_FROM_FIELD(type, node_name, (head)->next->prev);       \
       pos != FIO_PTR_FROM_FIELD(type, node_name, (head));                     \
       (pos = next____p_ls_##pos),                                             \
            (next____p_ls_##pos =                                              \
                 FIO_PTR_FROM_FIELD(type,                                      \
                                    node_name,                                 \
                                    next____p_ls_##pos->node_name.prev)))
#endif

/** UNSAFE macro for pushing a node to a list. */
#define FIO_LIST_PUSH(head, n)                                                 \
  do {                                                                         \
    (n)->prev = (head)->prev;                                                  \
    (n)->next = (head);                                                        \
    (head)->prev->next = (n);                                                  \
    (head)->prev = (n);                                                        \
  } while (0)

/** UNSAFE macro for removing a node from a list. */
#define FIO_LIST_REMOVE(n)                                                     \
  do {                                                                         \
    (n)->prev->next = (n)->next;                                               \
    (n)->next->prev = (n)->prev;                                               \
  } while (0)

/** UNSAFE macro for removing a node from a list. Resets node data. */
#define FIO_LIST_REMOVE_RESET(n)                                               \
  do {                                                                         \
    (n)->prev->next = (n)->next;                                               \
    (n)->next->prev = (n)->prev;                                               \
    (n)->next = (n)->prev = (n);                                               \
  } while (0)

/** UNSAFE macro for popping a node to a list. */
#define FIO_LIST_POP(type, node_name, dest_ptr, head)                          \
  do {                                                                         \
    (dest_ptr) = FIO_PTR_FROM_FIELD(type, node_name, ((head)->next));          \
    FIO_LIST_REMOVE(&(dest_ptr)->node_name);                                   \
  } while (0)

/** UNSAFE macro for testing if a list is empty. */
#define FIO_LIST_IS_EMPTY(head)                                                \
  ((!(head)) || ((!(head)->next) | ((head)->next == (head))))

/* *****************************************************************************
Indexed Linked Lists Persistent Macros and Types

Indexed Linked Lists can be used to create a linked list that uses is always
relative to some root pointer (usually the root of an array). This:

1. Allows easy reallocation of the list without requiring pointer updates.

2. Could be used for memory optimization if the array limits are known.

The "head" index is usually validated by reserving the value of `-1` to indicate
an empty list.
***************************************************************************** */
#ifndef FIO_INDEXED_LIST_EACH

/** A 32 bit indexed linked list node type */
typedef struct fio_index32_node_s {
  uint32_t next;
  uint32_t prev;
} fio_index32_node_s;

/** A 16 bit indexed linked list node type */
typedef struct fio_index16_node_s {
  uint16_t next;
  uint16_t prev;
} fio_index16_node_s;

/** An 8 bit indexed linked list node type */
typedef struct fio_index8_node_s {
  uint8_t next;
  uint8_t prev;
} fio_index8_node_s;

/** A 32 bit indexed linked list node type */
#define FIO_INDEXED_LIST32_NODE fio_index32_node_s
#define FIO_INDEXED_LIST32_HEAD uint32_t
/** A 16 bit indexed linked list node type */
#define FIO_INDEXED_LIST16_NODE fio_index16_node_s
#define FIO_INDEXED_LIST16_HEAD uint16_t
/** An 8 bit indexed linked list node type */
#define FIO_INDEXED_LIST8_NODE fio_index8_node_s
#define FIO_INDEXED_LIST8_HEAD uint8_t

/** UNSAFE macro for pushing a node to a list. */
#define FIO_INDEXED_LIST_PUSH(root, node_name, head, i)                        \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[n__].node_name.prev = (root)[(head)].node_name.prev;                \
    (root)[n__].node_name.next = (head);                                       \
    (root)[(root)[(head)].node_name.prev].node_name.next = n__;                \
    (root)[(head)].node_name.prev = n__;                                       \
  } while (0)

/** UNSAFE macro for adding a node to the begging of the list. */
#define FIO_INDEXED_LIST_UNSHIFT(root, node_name, head, i)                     \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[n__].node_name.next = (root)[(head)].node_name.next;                \
    (root)[n__].node_name.prev = (head);                                       \
    (root)[(root)[(head)].node_name.next].node_name.prev = n__;                \
    (root)[(head)].node_name.next = n__;                                       \
    (head) = n__;                                                              \
  } while (0)

/** UNSAFE macro for removing a node from a list. */
#define FIO_INDEXED_LIST_REMOVE(root, node_name, i)                            \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[(root)[n__].node_name.prev].node_name.next =                        \
        (root)[n__].node_name.next;                                            \
    (root)[(root)[n__].node_name.next].node_name.prev =                        \
        (root)[n__].node_name.prev;                                            \
  } while (0)

/** UNSAFE macro for removing a node from a list. Resets node data. */
#define FIO_INDEXED_LIST_REMOVE_RESET(root, node_name, i)                      \
  do {                                                                         \
    register const size_t n__ = (i);                                           \
    (root)[(root)[n__].node_name.prev].node_name.next =                        \
        (root)[n__].node_name.next;                                            \
    (root)[(root)[n__].node_name.next].node_name.prev =                        \
        (root)[n__].node_name.prev;                                            \
    (root)[n__].node_name.next = (root)[n__].node_name.prev = n__;             \
  } while (0)

/** Loops through every index in the indexed list, assuming `head` is valid. */
#define FIO_INDEXED_LIST_EACH(root, node_name, head, pos)                      \
  for (size_t pos = (head), stopper___ils___ = 0; !stopper___ils___;           \
       stopper___ils___ = ((pos = (root)[pos].node_name.next) == (head)))

/** Loops through every index in the indexed list, assuming `head` is valid. */
#define FIO_INDEXED_LIST_EACH_REVERSED(root, node_name, head, pos)             \
  for (size_t pos = ((root)[head].node_name.prev), stopper___ils___ = 0;       \
       !stopper___ils___;                                                      \
       ((stopper___ils___ = (pos == head)),                                    \
        (pos = (root)[pos].node_name.prev)))
#endif

/* *****************************************************************************
String and Buffer Information Containers + Helper Macros
***************************************************************************** */

/** An information type for reporting the string's state. */
typedef struct fio_str_info_s {
  /** The string's length, if any. */
  size_t len;
  /** The string's buffer (pointer to first byte) or NULL on error. */
  char *buf;
  /** The buffer's capacity. Zero (0) indicates the buffer is read-only. */
  size_t capa;
} fio_str_info_s;

/** An information type for reporting/storing buffer data (no `capa`). */
typedef struct fio_buf_info_s {
  /** The buffer's length, if any. */
  size_t len;
  /** The buffer's address (may be NULL if no buffer). */
  char *buf;
} fio_buf_info_s;

/** Compares two `fio_str_info_s` objects for content equality. */
#define FIO_STR_INFO_IS_EQ(s1, s2)                                             \
  ((s1).len == (s2).len && (!(s1).len || (s1).buf == (s2).buf ||               \
                            !FIO_MEMCMP((s1).buf, (s2).buf, (s1).len)))

/** Compares two `fio_buf_info_s` objects for content equality. */
#define FIO_BUF_INFO_IS_EQ(s1, s2) FIO_STR_INFO_IS_EQ((s1), (s2))

/** Converts a C String into a fio_str_info_s. */
#define FIO_STR_INFO1(str)                                                     \
  ((fio_str_info_s){.len = strlen((str)), .buf = (str)})

/** Converts a String with a known length into a fio_str_info_s. */
#define FIO_STR_INFO2(str, length)                                             \
  ((fio_str_info_s){.len = (length), .buf = (str)})

/** Converts a String with a known length and capacity into a fio_str_info_s. */
#define FIO_STR_INFO3(str, length, capacity)                                   \
  ((fio_str_info_s){.len = (length), .buf = (str), .capa = (capacity)})

/** Converts a C String into a fio_buf_info_s. */
#define FIO_BUF_INFO1(str)                                                     \
  ((fio_buf_info_s){.len = strlen((str)), .buf = (str)})

/** Converts a String with a known length into a fio_buf_info_s. */
#define FIO_BUF_INFO2(str, length)                                             \
  ((fio_buf_info_s){.len = (length), .buf = (str)})

/** Converts a fio_buf_info_s into a fio_str_info_s. */
#define FIO_BUF2STR_INFO(buf_info)                                             \
  ((fio_str_info_s){.len = (buf_info).len, .buf = (buf_info).buf})

/** Converts a fio_buf_info_s into a fio_str_info_s. */
#define FIO_STR2BUF_INFO(str_info)                                             \
  ((fio_buf_info_s){.len = (str_info).len, .buf = (str_info).buf})

/* *****************************************************************************
Sleep / Thread Scheduling Macros
*****************************************************************************
*/

#ifndef FIO_THREAD_WAIT
#if FIO_OS_WIN
/**
 * Calls NtDelayExecution with the requested nano-second count.
 */
#define FIO_THREAD_WAIT(nano_sec)                                              \
  do {                                                                         \
    Sleep(((nano_sec) / 1000000) ? ((nano_sec) / 1000000) : 1);                \
  } while (0)
// https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep

#elif FIO_OS_POSIX
/**
 * Calls nanonsleep with the requested nano-second count.
 */
#define FIO_THREAD_WAIT(nano_sec)                                              \
  do {                                                                         \
    const struct timespec tm = {.tv_sec = (time_t)((nano_sec) / 1000000000),   \
                                .tv_nsec = ((long)(nano_sec) % 1000000000)};   \
    nanosleep(&tm, (struct timespec *)NULL);                                   \
  } while (0)

#endif
#endif

#ifndef FIO_THREAD_RESCHEDULE
/**
 * Reschedules the thread by calling nanosleeps for a single nano-second.
 *
 * In practice, the thread will probably sleep for 60ns or more.
 */
#define FIO_THREAD_RESCHEDULE() FIO_THREAD_WAIT(4)
#endif

/* *****************************************************************************


Patch for OSX version < 10.12 from https://stackoverflow.com/a/9781275/4025095

Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if (defined(__MACH__) && !defined(CLOCK_REALTIME))
#warning fio_time functions defined using gettimeofday patch.
#include <sys/time.h>
#define CLOCK_REALTIME 0
#ifndef CLOCK_MONOTONIC
#define CLOCK_MONOTONIC 0
#endif
#define clock_gettime fio_clock_gettime
// clock_gettime is not implemented on older versions of OS X (< 10.12).
// If implemented, CLOCK_MONOTONIC will have already been defined.
FIO_IFUNC int fio_clock_gettime(int clk_id, struct timespec *t) {
  struct timeval now;
  int rv = gettimeofday(&now, NULL);
  if (rv)
    return rv;
  t->tv_sec = now.tv_sec;
  t->tv_nsec = now.tv_usec * 1000;
  return 0;
  (void)clk_id;
}

#endif
/* *****************************************************************************




Patches for Windows




***************************************************************************** */
#if FIO_OS_WIN
#if _MSC_VER
#pragma message("warning: some functionality is enabled by patchwork.")
#else
#warning some functionality is enabled by patchwork.
#endif
#include <fcntl.h>
#include <io.h>
#include <processthreadsapi.h>
#include <sys/types.h>

#include <sys/stat.h>
#include <sysinfoapi.h>
#include <time.h>
#include <winsock2.h> /* struct timeval is here... why? Microsoft. */

/* *****************************************************************************
Windows initialization
***************************************************************************** */

/* Enable console colors */
FIO_CONSTRUCTOR(fio___windows_startup_housekeeping) {
  HANDLE c = GetStdHandle(STD_OUTPUT_HANDLE);
  if (c) {
    DWORD mode = 0;
    if (GetConsoleMode(c, &mode)) {
      mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(c, mode);
    }
  }
  c = GetStdHandle(STD_ERROR_HANDLE);
  if (c) {
    DWORD mode = 0;
    if (GetConsoleMode(c, &mode)) {
      mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(c, mode);
    }
  }
}

/* *****************************************************************************
Inlined patched and MACRO statements
***************************************************************************** */

FIO_IFUNC struct tm *fio___w_gmtime_r(const time_t *timep, struct tm *result) {
  struct tm *t = gmtime(timep);
  if (t && result)
    *result = *t;
  return result;
}

FIO_IFUNC int fio___w_strcasecmp(const char *s1, const char *s2) {
  return _stricmp(s1, s2);
}

FIO_IFUNC int fio___w_write(int fd, const void *b, unsigned int l) {
  return _write(fd, b, l);
}

FIO_IFUNC int fio___w_read(int const fd, void *const b, unsigned const l) {
  return _read(fd, b, l);
}

#if !defined(fstat)
#define fstat _fstat
#endif /* fstat */
#if !defined(stat)
#define stat _stat
#endif /* stat */
#if !defined(unlink)
#define unlink _unlink
#endif /* unlink */

#ifndef O_APPEND
#define O_APPEND      _O_APPEND
#define O_BINARY      _O_BINARY
#define O_CREAT       _O_CREAT
#define O_CREAT       _O_CREAT
#define O_SHORT_LIVED _O_SHORT_LIVED
#define O_CREAT       _O_CREAT
#define O_TEMPORARY   _O_TEMPORARY
#define O_CREAT       _O_CREAT
#define O_EXCL        _O_EXCL
#define O_NOINHERIT   _O_NOINHERIT
#define O_RANDOM      _O_RANDOM
#define O_RDONLY      _O_RDONLY
#define O_RDWR        _O_RDWR
#define O_SEQUENTIAL  _O_SEQUENTIAL
#define O_TEXT        _O_TEXT
#define O_TRUNC       _O_TRUNC
#define O_WRONLY      _O_WRONLY
#define O_U16TEXT     _O_U16TEXT
#define O_U8TEXT      _O_U8TEXT
#define O_WTEXT       _O_WTEXT
#endif /* O_APPEND */

#ifndef S_IWUSR
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IRUSR  _S_IREAD
#define S_IWUSR  _S_IWRITE
#define S_IRWXO  (_S_IREAD | _S_IWRITE)
#define S_IRWXG  (_S_IREAD | _S_IWRITE)
#define S_IRWXU  (_S_IREAD | _S_IWRITE)
#endif /* S_IWUSR */

#ifndef O_TMPFILE
#define O_TMPFILE O_TEMPORARY
#endif

#if defined(CLOCK_REALTIME) && defined(CLOCK_MONOTONIC) &&                     \
    CLOCK_REALTIME == CLOCK_MONOTONIC
#undef CLOCK_MONOTONIC
#undef CLOCK_REALTIME
#endif

#ifndef CLOCK_REALTIME
#ifdef CLOCK_MONOTONIC
#define CLOCK_REALTIME (CLOCK_MONOTONIC + 1)
#else
#define CLOCK_REALTIME 0
#endif
#endif

#ifndef CLOCK_MONOTONIC
#define CLOCK_MONOTONIC 1
#endif

/** patch for clock_gettime */
FIO_SFUNC int fio_clock_gettime(const uint32_t clk_type, struct timespec *tv);
/** patch for pread */
FIO_SFUNC ssize_t fio_pread(int fd, void *buf, size_t count, off_t offset);
/** patch for pwrite */
FIO_SFUNC ssize_t fio_pwrite(int fd,
                             const void *buf,
                             size_t count,
                             off_t offset);
FIO_SFUNC int fio_kill(int pid, int signum);

#define kill       fio_kill
#define pread      fio_pread
#define pwrite     fio_pwrite
#define gmtime_r   fio___w_gmtime_r
#define strcasecmp fio___w_strcasecmp
#define write      fio___w_write
#define read       fio___w_read

#if !FIO_HAVE_UNIX_TOOLS
/* patch clock_gettime */
#define clock_gettime fio_clock_gettime
#define pipe(fds)     _pipe(fds, 65536, _O_BINARY)
#define getpid        GetCurrentProcess
typedef HANDLE pid_t;
#endif

/* *****************************************************************************
Patched functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* based on:
 * https://stackoverflow.com/questions/5404277/porting-clock-gettime-to-windows
 */
/** patch for clock_gettime */
FIO_SFUNC int fio_clock_gettime(const uint32_t clk_type, struct timespec *tv) {
  if (!tv)
    return -1;
  static union {
    uint64_t u;
    LARGE_INTEGER li;
  } freq = {.u = 0};
  static double tick2n = 0;
  union {
    uint64_t u;
    FILETIME ft;
    LARGE_INTEGER li;
  } tu;

  switch (clk_type) {
  case CLOCK_REALTIME:
  realtime_clock:
    GetSystemTimePreciseAsFileTime(&tu.ft);
    tv->tv_sec = tu.u / 10000000;
    tv->tv_nsec = tu.u - (tv->tv_sec * 10000000);
    return 0;

#ifdef CLOCK_PROCESS_CPUTIME_ID
  case CLOCK_PROCESS_CPUTIME_ID:
#endif
#ifdef CLOCK_THREAD_CPUTIME_ID
  case CLOCK_THREAD_CPUTIME_ID:
#endif
  case CLOCK_MONOTONIC:
    if (!QueryPerformanceCounter(&tu.li))
      goto realtime_clock;
    if (!freq.u)
      QueryPerformanceFrequency(&freq.li);
    if (!freq.u) {
      tick2n = 0;
      freq.u = 1;
    } else {
      tick2n = (double)1000000000 / freq.u;
    }
    tv->tv_sec = tu.u / freq.u;
    tv->tv_nsec =
        (uint64_t)(0ULL + ((double)(tu.u - (tv->tv_sec * freq.u)) * tick2n));
    return 0;
  }
  return -1;
}

/** patch for pread */
FIO_SFUNC ssize_t fio_pread(int fd, void *buf, size_t count, off_t offset) {
  /* Credit to Jan Biedermann (GitHub: @janbiedermann) */
  ssize_t bytes_read = 0;
  HANDLE handle = (HANDLE)_get_osfhandle(fd);
  if (handle == INVALID_HANDLE_VALUE)
    goto bad_file;
  OVERLAPPED overlapped = {0};
  if (offset > 0)
    overlapped.Offset = offset;
  if (ReadFile(handle, buf, count, (u_long *)&bytes_read, &overlapped))
    return bytes_read;
  if (GetLastError() == ERROR_HANDLE_EOF)
    return bytes_read;
  errno = EIO;
  return -1;
bad_file:
  errno = EBADF;
  return -1;
}

/** patch for pwrite */
FIO_SFUNC ssize_t fio_pwrite(int fd,
                             const void *buf,
                             size_t count,
                             off_t offset) {
  /* Credit to Jan Biedermann (GitHub: @janbiedermann) */
  ssize_t bytes_written = 0;
  HANDLE handle = (HANDLE)_get_osfhandle(fd);
  if (handle == INVALID_HANDLE_VALUE)
    goto bad_file;
  OVERLAPPED overlapped = {0};
  if (offset > 0)
    overlapped.Offset = offset;
  if (WriteFile(handle, buf, count, (u_long *)&bytes_written, &overlapped))
    return bytes_written;
  errno = EIO;
  return -1;
bad_file:
  errno = EBADF;
  return -1;
}

/** patch for kill */
FIO_SFUNC int fio_kill(int pid, int sig) {
  /* Credit to Jan Biedermann (GitHub: @janbiedermann) */
  HANDLE handle;
  DWORD status;
  if (sig < 0 || sig >= NSIG) {
    errno = EINVAL;
    return -1;
  }
#ifdef SIGCONT
  if (sig == SIGCONT) {
    errno = ENOSYS;
    return -1;
  }
#endif

  if (pid == -1)
    pid = 0;

  if (!pid)
    handle = GetCurrentProcess();
  else
    handle =
        OpenProcess(PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION, FALSE, pid);
  if (!handle)
    goto something_went_wrong;

  switch (sig) {
#ifdef SIGKILL
  case SIGKILL:
#endif
  case SIGTERM:
  case SIGINT: /* terminate */
    if (!TerminateProcess(handle, 1))
      goto something_went_wrong;
    break;
  case 0: /* check status */
    if (!GetExitCodeProcess(handle, &status))
      goto something_went_wrong;
    if (status != STILL_ACTIVE) {
      errno = ESRCH;
      goto cleanup_after_error;
    }
    break;
  default: /* not supported? */ errno = ENOSYS; goto cleanup_after_error;
  }

  if (pid) {
    CloseHandle(handle);
  }
  return 0;

something_went_wrong:

  switch (GetLastError()) {
  case ERROR_INVALID_PARAMETER: errno = ESRCH; break;
  case ERROR_ACCESS_DENIED:
    errno = EPERM;
    if (handle && GetExitCodeProcess(handle, &status) && status != STILL_ACTIVE)
      errno = ESRCH;
    break;
  default: errno = GetLastError();
  }
cleanup_after_error:
  if (handle && pid)
    CloseHandle(handle);
  return -1;
}

#endif /* FIO_EXTERN_COMPLETE */

/* *****************************************************************************



Patches for POSIX



***************************************************************************** */
#elif FIO_OS_POSIX /* POSIX patches */
#endif
/* *****************************************************************************
Done with Patches
***************************************************************************** */

/* *****************************************************************************
End persistent segment (end include-once guard)
***************************************************************************** */
#endif /* H___FIO_CSTL_INCLUDE_ONCE___H */

/* *****************************************************************************




                          Common internal Macros




***************************************************************************** */

/* *****************************************************************************
Memory allocation macros
***************************************************************************** */

#ifndef FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT
/* secure by default */
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT 1
#endif

#if defined(FIO_MEM_REST) || !defined(FIO_MEM_REALLOC) || !defined(FIO_MEM_FREE)

#undef FIO_MEM_REALLOC
#undef FIO_MEM_FREE
#undef FIO_MEM_REALLOC_IS_SAFE
#undef FIO_MEM_REST

/* if a global allocator was previously defined route macros to fio_malloc */
#if defined(H___FIO_MALLOC___H)
/** Reallocates memory, copying (at least) `copy_len` if necessary. */
#define FIO_MEM_REALLOC(ptr, old_size, new_size, copy_len)                     \
  fio_realloc2((ptr), (new_size), (copy_len))
/** Frees allocated memory. */
#define FIO_MEM_FREE(ptr, size) fio_free((ptr))
/** Set to true of internall allocator is used (memory returned set to zero). */
#define FIO_MEM_REALLOC_IS_SAFE 1

#else
/** Reallocates memory, copying (at least) `copy_len` if necessary. */
#define FIO_MEM_REALLOC(ptr, old_size, new_size, copy_len)                     \
  realloc((ptr), (new_size))
/** Frees allocated memory. */
#define FIO_MEM_FREE(ptr, size) free((ptr))
/** Set to true of internall allocator is used (memory returned set to zero). */
#define FIO_MEM_REALLOC_IS_SAFE 0
#endif /* H___FIO_MALLOC___H */

#endif /* defined(FIO_MEM_REALLOC) */

/* *****************************************************************************
Locking selector
***************************************************************************** */

#ifndef FIO_USE_THREAD_MUTEX
#define FIO_USE_THREAD_MUTEX 0
#endif

#ifndef FIO_USE_THREAD_MUTEX_TMP
#define FIO_USE_THREAD_MUTEX_TMP FIO_USE_THREAD_MUTEX
#endif

#if FIO_USE_THREAD_MUTEX_TMP
#define FIO_THREAD
#define FIO___LOCK_NAME          "OS mutex"
#define FIO___LOCK_TYPE          fio_thread_mutex_t
#define FIO___LOCK_INIT          ((FIO___LOCK_TYPE)FIO_THREAD_MUTEX_INIT)
#define FIO___LOCK_DESTROY(lock) fio_thread_mutex_destroy(&(lock))
#define FIO___LOCK_LOCK(lock)                                                  \
  do {                                                                         \
    if (fio_thread_mutex_lock(&(lock)))                                        \
      FIO_LOG_ERROR("Couldn't lock mutex @ %s:%d - error (%d): %s",            \
                    __FILE__,                                                  \
                    __LINE__,                                                  \
                    errno,                                                     \
                    strerror(errno));                                          \
  } while (0)
#define FIO___LOCK_TRYLOCK(lock) fio_thread_mutex_trylock(&(lock))
#define FIO___LOCK_UNLOCK(lock)                                                \
  do {                                                                         \
    if (fio_thread_mutex_unlock(&(lock))) {                                    \
      FIO_LOG_ERROR("Couldn't release mutex @ %s:%d - error (%d): %s",         \
                    __FILE__,                                                  \
                    __LINE__,                                                  \
                    errno,                                                     \
                    strerror(errno));                                          \
    }                                                                          \
  } while (0)

#else
#define FIO___LOCK_NAME          "facil.io spinlocks"
#define FIO___LOCK_TYPE          fio_lock_i
#define FIO___LOCK_INIT          ((FIO___LOCK_TYPE)FIO_LOCK_INIT)
#define FIO___LOCK_DESTROY(lock) ((lock) = FIO___LOCK_INIT)
#define FIO___LOCK_LOCK(lock)    fio_lock(&(lock))
#define FIO___LOCK_TRYLOCK(lock) fio_trylock(&(lock))
#define FIO___LOCK_UNLOCK(lock)  fio_unlock(&(lock))
#endif

/* *****************************************************************************
Special `extern` support for FIO_EVERYTHING - Everything, and the Kitchen Sink
***************************************************************************** */
#if (defined(FIO_EVERYTHING) || defined(FIO_CORE) || defined(FIO_BASIC) ||     \
     defined(FIO_CRYPT) || defined(FIO_SERVER_COMPLETE)) &&                    \
    !defined(FIO_STL_KEEP__)
#if defined(FIO_EXTERN) && ((FIO_EXTERN + 1) < 3)
#undef FIO_EXTERN
#define FIO_EXTERN                     2
#define FIO_EVERYTHING___REMOVE_EXTERN 1
#endif
#if defined(FIO_EXTERN_COMPLETE) && ((FIO_EXTERN_COMPLETE + 1) < 3)
#undef FIO_EXTERN_COMPLETE
#define FIO_EXTERN_COMPLETE                     2
#define FIO_EVERYTHING___REMOVE_EXTERN_COMPLETE 1
#endif
#endif
/* *****************************************************************************
Recursive inclusion management
***************************************************************************** */
#ifndef SFUNC_ /* if we aren't in a recursive #include statement */

#ifdef FIO_EXTERN
#define SFUNC_
#define IFUNC_

#else /* !FIO_EXTERN */
#undef SFUNC
#undef IFUNC
#define SFUNC_ static __attribute__((unused))
#define IFUNC_ static inline __attribute__((unused))
#endif /* FIO_EXTERN */

#undef SFUNC
#undef IFUNC
#define SFUNC SFUNC_
#define IFUNC IFUNC_

#elif !defined(FIO_STL_KEEP__) || (FIO_STL_KEEP__ + 1 != 100)
/* SFUNC_ - internal helper types are always `static` */
#undef SFUNC
#undef IFUNC
#define SFUNC FIO_SFUNC
#define IFUNC FIO_IFUNC
#endif /* SFUNC_ vs FIO_STL_KEEP__*/

/* *****************************************************************************
Pointer Tagging
***************************************************************************** */
#ifndef FIO_PTR_TAG
/**
 * Supports embedded pointer tagging / untagging for the included types.
 *
 * Should resolve to a tagged pointer value. i.e.: ((uintptr_t)(p) | 1)
 */
#define FIO_PTR_TAG(p) (p)
#endif

#ifndef FIO_PTR_UNTAG
/**
 * Supports embedded pointer tagging / untagging for the included types.
 *
 * Should resolve to an untagged pointer value. i.e.: ((uintptr_t)(p) | ~1UL)
 */
#define FIO_PTR_UNTAG(p) (p)
#endif

/**
 * If FIO_PTR_TAG_TYPE is defined, then functions returning a type's pointer
 * will return a pointer of the specified type instead.
 */
#ifndef FIO_PTR_TAG_TYPE
#endif

#ifndef FIO_PTR_TAG_VALIDATE
/**
 * If FIO_PTR_TAG_VALIDATE is defined, tagging will be verified before executing
 * any code.
 *
 * FIO_PTR_TAG_VALIDATE must fail on NULL pointers.
 */
#define FIO_PTR_TAG_VALIDATE(ptr) ((ptr) != NULL)
#endif

#undef FIO_PTR_TAG_VALID_OR_RETURN
#define FIO_PTR_TAG_VALID_OR_RETURN(tagged_ptr, value)                         \
  do {                                                                         \
    if (!(FIO_PTR_TAG_VALIDATE(tagged_ptr))) {                                 \
      FIO_LOG_DEBUG("pointer tag (type) mismatch in function call.");          \
      return (value);                                                          \
    }                                                                          \
  } while (0)
#undef FIO_PTR_TAG_VALID_OR_RETURN_VOID
#define FIO_PTR_TAG_VALID_OR_RETURN_VOID(tagged_ptr)                           \
  do {                                                                         \
    if (!(FIO_PTR_TAG_VALIDATE(tagged_ptr))) {                                 \
      FIO_LOG_DEBUG("pointer tag (type) mismatch in function call.");          \
      return;                                                                  \
    }                                                                          \
  } while (0)
#undef FIO_PTR_TAG_VALID_OR_GOTO
#define FIO_PTR_TAG_VALID_OR_GOTO(tagged_ptr, lable)                           \
  do {                                                                         \
    if (!(FIO_PTR_TAG_VALIDATE(tagged_ptr))) {                                 \
      /* Log error since GOTO indicates cleanup or other side-effects. */      \
      FIO_LOG_ERROR("(" FIO__FILE__ ":" FIO_MACRO2STR(                         \
          __LINE__) ") pointer tag (type) mismatch in function call.");        \
      goto lable;                                                              \
    }                                                                          \
  } while (0)

#define FIO_PTR_TAG_GET_UNTAGGED(untagged_type, tagged_ptr)                    \
  ((untagged_type *)(FIO_PTR_UNTAG(tagged_ptr)))

/* *****************************************************************************



                          Internal Dependencies



***************************************************************************** */
/* Testing Dependencies */
#if defined(FIO_TEST_CSTL) || defined(FIO_LEAK_COUNTER)
#ifndef FIO_TEST_REPEAT
#define FIO_TEST_REPEAT 4096
#endif
#ifndef FIO_LOG
#define FIO_LOG
#endif
#endif

/* Modules that require FIO_SERVER */
#if defined(FIO_PUBSUB)
#ifndef FIO_SERVER
#define FIO_SERVER
#endif
#endif

/* Modules required by FIO_GLOB_MATCH */
#if defined(FIO_PUBSUB)
#ifndef FIO_GLOB_MATCH
#define FIO_GLOB_MATCH
#endif
#ifndef FIO_CHACHA
#define FIO_CHACHA
#endif
#endif

/* Modules that require FIO_POLL */
#if defined(FIO_SERVER)
#ifndef FIO_POLL
#define FIO_POLL
#endif
#endif

/* Modules that require FIO_SIGNAL */
#if defined(FIO_SERVER)
#ifndef FIO_SIGNAL
#define FIO_SIGNAL
#endif
#endif

/* Modules that require FIO_STATE */
#if defined(FIO_MEMORY_NAME) || defined(FIO_MALLOC) ||                         \
    defined(FIOBJ_MALLOC) || defined(FIO_POLL)
#ifndef FIO_STATE
#define FIO_STATE
#endif
#endif

/* Modules that require FIO_STREAM */
#if defined(FIO_SERVER)
#ifndef FIO_STREAM
#define FIO_STREAM
#endif
#endif

/* Modules that require FIO_SOCK */
#if defined(FIO_POLL)
#ifndef FIO_SOCK
#define FIO_SOCK
#endif
#endif

/* Modules that require FIO_QUEUE */
#if defined(FIO_POLL)
#ifndef FIO_QUEUE
#define FIO_QUEUE
#endif
#endif

/* Modules that require FIO_URL */
#if defined(FIO_SOCK)
#ifndef FIO_URL
#define FIO_URL
#endif
#endif

/* Modules that require Threads API */
#if (defined(FIO_QUEUE) && defined(FIO_TEST_CSTL)) ||                          \
    defined(FIO_MEMORY_NAME) || defined(FIO_MALLOC) ||                         \
    defined(FIO_USE_THREAD_MUTEX_TMP)
#ifndef FIO_THREADS
#define FIO_THREADS
#endif
#endif

/* Modules that require the String Core API */
#if defined(FIO_STR_NAME) || defined(FIO_STR_SMALL) ||                         \
    defined(FIO_MAP_KEY_KSTR) || defined(FIO_MAP_KEY_BSTR) ||                  \
    (defined(FIO_MAP_VALUE) && !defined(FIO_MAP_KEY)) ||                       \
    defined(FIO_MAP_VALUE_BSTR) || defined(FIO_SERVER) || defined(FIO_FIOBJ)
#ifndef FIO_STR
#define FIO_STR
#endif
#endif

/* Modules that require File Utils */
#if defined(FIO_STR)
#ifndef FIO_FILES
#define FIO_FILES
#endif
#endif

/* Modules that require randomness */
#if defined(FIO_MEMORY_NAME) || defined(FIO_MALLOC) || defined(FIO_FILES) ||   \
    defined(FIO_STATE) || defined(FIO_STR_NAME) || defined(FIO_STR_SMALL) ||   \
    defined(FIO_CLI) || defined(FIO_MEMORY_NAME) || defined(FIO_MALLOC) ||     \
    defined(FIO_POLL) || defined(FIO_TEST_CSTL)
#ifndef FIO_RAND
#define FIO_RAND
#endif
#endif /* FIO_MALLOC */

/* Modules that require FIO_TIME */
#if defined(FIO_QUEUE) || defined(FIO_RAND)
#ifndef FIO_TIME
#define FIO_TIME
#endif
#endif /* FIO_QUEUE */

/* Modules that require FIO_MATH */
#if defined(FIO_RAND) || defined(FIO_CHACHA) || defined(FIO_TEST_CSTL)
#ifndef FIO_MATH
#define FIO_MATH
#endif
#endif

/* Modules that require FIO_BITMAP */
#if defined(FIO_JSON) || defined(FIO_TEST_CSTL)
#ifndef FIO_BITMAP
#define FIO_BITMAP
#endif
#endif /* FIO_BITMAP */

/* Modules that require FIO_IMAP_CORE */
#if defined(FIO_STATE)
#ifndef FIO_IMAP_CORE
#define FIO_IMAP_CORE
#endif
#endif /* FIO_IMAP_CORE */

/* Modules that require FIO_BITWISE (includes FIO_RAND requirements) */
#if defined(FIO_STR_NAME) || defined(FIO_RAND) || defined(FIO_JSON) ||         \
    defined(FIO_MAP_NAME) || defined(FIO_UMAP_NAME) || defined(FIO_SHA1) ||    \
    defined(FIO_MATH) || defined(FIO_CHACHA) || defined(FIO_HTTP1_PARSER) ||   \
    defined(FIO_SOCK)
#ifndef FIO_BITWISE
#define FIO_BITWISE
#endif
#endif /* FIO_BITWISE */

/* Modules that require FIO_ATOMIC */
#if defined(FIO_BITMAP) || defined(FIO_REF_NAME) || defined(FIO_LOCK2) ||      \
    defined(FIO_STATE) || (defined(FIO_POLL) && !FIO_USE_THREAD_MUTEX_TMP) ||  \
    (defined(FIO_MEMORY_NAME) || defined(FIO_MALLOC)) ||                       \
    (defined(FIO_QUEUE) && !FIO_USE_THREAD_MUTEX_TMP) || defined(FIO_JSON) ||  \
    defined(FIO_SIGNAL) || defined(FIO_BITMAP) || defined(FIO_THREADS) ||      \
    defined(FIO_FIOBJ)
#ifndef FIO_ATOMIC
#define FIO_ATOMIC
#endif
#endif /* FIO_ATOMIC */

/* Modules that require FIO_ATOL */
#if defined(FIO_STR) || defined(FIO_QUEUE) || defined(FIO_TIME) ||             \
    defined(FIO_CLI) || defined(FIO_JSON) || defined(FIO_FILES) ||             \
    defined(FIO_FIOBJ) || defined(FIO_HTTP1_PARSER) || defined(FIO_TEST_CSTL)
#ifndef FIO_ATOL
#define FIO_ATOL
#endif
#endif /* FIO_ATOL */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_LOG        /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                                  Logging





Use:

```c
FIO_LOG2STDERR("message.") // => message.
FIO_LOG_LEVEL = FIO_LOG_LEVEL_WARNING; // set dynamic logging level
FIO_LOG_INFO("message"); // => [no output, exceeds logging level]
int i = 3;
FIO_LOG_WARNING("number invalid: %d", i); // => WARNING: number invalid: 3
```

Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */

/**
 * Enables logging macros that avoid heap memory allocations
 */
#if !defined(H___FIO_LOG___H) && (defined(FIO_LOG) || defined(FIO_LEAK_COUNTER))
#define H___FIO_LOG___H

#if FIO_LOG_LENGTH_LIMIT > 128
#define FIO_LOG____LENGTH_ON_STACK FIO_LOG_LENGTH_LIMIT
#define FIO_LOG____LENGTH_BORDER   (FIO_LOG_LENGTH_LIMIT - 34)
#else
#define FIO_LOG____LENGTH_ON_STACK (FIO_LOG_LENGTH_LIMIT + 34)
#define FIO_LOG____LENGTH_BORDER   FIO_LOG_LENGTH_LIMIT
#endif

#undef FIO_LOG2STDERR

__attribute__((format(FIO___PRINTF_STYLE, 1, 0), weak)) void FIO_LOG2STDERR(
    const char *format,
    ...) {
  va_list argv;
  char tmp___log[FIO_LOG____LENGTH_ON_STACK + 32];
  va_start(argv, format);
  int len___log = vsnprintf(tmp___log, FIO_LOG_LENGTH_LIMIT - 2, format, argv);
  va_end(argv);
  if (len___log > 0) {
    if (len___log >= FIO_LOG_LENGTH_LIMIT - 2) {
      FIO_MEMCPY(tmp___log + FIO_LOG____LENGTH_BORDER,
                 "...\n\t\x1B[2mWARNING:\x1B[0m TRUNCATED!",
                 32);
      len___log = FIO_LOG____LENGTH_BORDER + 32;
    }
    tmp___log[len___log++] = '\n';
    tmp___log[len___log] = '0';
    fwrite(tmp___log, 1, len___log, stderr);
    return;
  }
  fwrite("\x1B[1mERROR:\x1B[0m log output error (can't write).\n",
         1,
         47,
         stderr);
}
#undef FIO_LOG____LENGTH_ON_STACK
#undef FIO_LOG____LENGTH_BORDER

// clang-format off
#undef FIO_LOG2STDERR2
#define FIO_LOG2STDERR2(...) FIO_LOG2STDERR("(" FIO__FILE__ ":" FIO_MACRO2STR(__LINE__) "): " __VA_ARGS__)
// clang-format on

/** Logging level of zero (no logging). */
#define FIO_LOG_LEVEL_NONE 0
/** Log fatal errors. */
#define FIO_LOG_LEVEL_FATAL 1
/** Log errors and fatal errors. */
#define FIO_LOG_LEVEL_ERROR 2
/** Log warnings, errors and fatal errors. */
#define FIO_LOG_LEVEL_WARNING 3
/** Log every message (info, warnings, errors and fatal errors). */
#define FIO_LOG_LEVEL_INFO 4
/** Log everything, including debug messages. */
#define FIO_LOG_LEVEL_DEBUG 5

/** The logging level */
#ifndef FIO_LOG_LEVEL_DEFAULT
#if DEBUG
#define FIO_LOG_LEVEL_DEFAULT FIO_LOG_LEVEL_DEBUG
#else
#define FIO_LOG_LEVEL_DEFAULT FIO_LOG_LEVEL_INFO
#endif
#endif
int __attribute__((weak)) FIO_LOG_LEVEL = FIO_LOG_LEVEL_DEFAULT;

#undef FIO_LOG_PRINT__
#define FIO_LOG_PRINT__(level, ...)                                            \
  do {                                                                         \
    if (level <= FIO_LOG_LEVEL)                                                \
      FIO_LOG2STDERR(__VA_ARGS__);                                             \
  } while (0)

// clang-format off
#undef FIO_LOG_FATAL
#define FIO_LOG_FATAL(...)    FIO_LOG_PRINT__(FIO_LOG_LEVEL_FATAL, "\x1B[1m\x1B[7mFATAL:\x1B[0m    " __VA_ARGS__)
#undef FIO_LOG_ERROR
#define FIO_LOG_ERROR(...)    FIO_LOG_PRINT__(FIO_LOG_LEVEL_ERROR, "\x1B[1mERROR:\x1B[0m    " __VA_ARGS__)
#undef FIO_LOG_SECURITY
#define FIO_LOG_SECURITY(...) FIO_LOG_PRINT__(FIO_LOG_LEVEL_ERROR, "\x1B[1mSECURITY:\x1B[0m " __VA_ARGS__)
#undef FIO_LOG_WARNING
#define FIO_LOG_WARNING(...)  FIO_LOG_PRINT__(FIO_LOG_LEVEL_WARNING, "\x1B[2mWARNING:\x1B[0m  " __VA_ARGS__)
#undef FIO_LOG_INFO
#define FIO_LOG_INFO(...)     FIO_LOG_PRINT__(FIO_LOG_LEVEL_INFO, "INFO:     " __VA_ARGS__)
#undef FIO_LOG_DEBUG
#define FIO_LOG_DEBUG(...)    FIO_LOG_PRINT__(FIO_LOG_LEVEL_DEBUG,"DEBUG:    (" FIO__FILE__ ":" FIO_MACRO2STR(__LINE__) ") " __VA_ARGS__)
#undef FIO_LOG_DEBUG2
#define FIO_LOG_DEBUG2(...)   FIO_LOG_PRINT__(FIO_LOG_LEVEL_DEBUG, "DEBUG:    " __VA_ARGS__)
// clang-format on

#endif /* FIO_LOG */
#undef FIO_LOG
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_LOCK2      /* Development inclusion - ignore line */
#define FIO_ATOMIC     /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                            Atomic Operations



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */

#if defined(FIO_ATOMIC) && !defined(H___FIO_ATOMIC___H)
#define H___FIO_ATOMIC___H 1

/* C11 Atomics are defined? */
#if defined(__ATOMIC_RELAXED)
/** An atomic load operation, returns value in pointer. */
#define fio_atomic_load(dest, p_obj)                                           \
  do {                                                                         \
    dest = __atomic_load_n((p_obj), __ATOMIC_SEQ_CST);                         \
  } while (0)

// clang-format off

/** An atomic compare and exchange operation, returns true if an exchange occured. `p_expected` MAY be overwritten with the existing value (system specific). */
#define fio_atomic_compare_exchange_p(p_obj, p_expected, p_desired) __atomic_compare_exchange((p_obj), (p_expected), (p_desired), 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)
/** An atomic exchange operation, returns previous value */
#define fio_atomic_exchange(p_obj, value) __atomic_exchange_n((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic addition operation, returns previous value */
#define fio_atomic_add(p_obj, value) __atomic_fetch_add((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic subtraction operation, returns previous value */
#define fio_atomic_sub(p_obj, value) __atomic_fetch_sub((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic AND (&) operation, returns previous value */
#define fio_atomic_and(p_obj, value) __atomic_fetch_and((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic XOR (^) operation, returns previous value */
#define fio_atomic_xor(p_obj, value) __atomic_fetch_xor((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic OR (|) operation, returns previous value */
#define fio_atomic_or(p_obj, value) __atomic_fetch_or((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic NOT AND ((~)&) operation, returns previous value */
#define fio_atomic_nand(p_obj, value) __atomic_fetch_nand((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic addition operation, returns new value */
#define fio_atomic_add_fetch(p_obj, value) __atomic_add_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic subtraction operation, returns new value */
#define fio_atomic_sub_fetch(p_obj, value) __atomic_sub_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic AND (&) operation, returns new value */
#define fio_atomic_and_fetch(p_obj, value) __atomic_and_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic XOR (^) operation, returns new value */
#define fio_atomic_xor_fetch(p_obj, value) __atomic_xor_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic OR (|) operation, returns new value */
#define fio_atomic_or_fetch(p_obj, value) __atomic_or_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/** An atomic NOT AND ((~)&) operation, returns new value */
#define fio_atomic_nand_fetch(p_obj, value) __atomic_nand_fetch((p_obj), (value), __ATOMIC_SEQ_CST)
/* note: __ATOMIC_SEQ_CST may be safer and __ATOMIC_ACQ_REL may be faster */

/* Select the correct compiler builtin method. */
#elif __has_builtin(__sync_add_and_fetch) || (__GNUC__ > 3)
/** An atomic load operation, returns value in pointer. */
#define fio_atomic_load(dest, p_obj)                                           \
  do {                                                                         \
    dest = *(p_obj);                                                           \
  } while (!__sync_bool_compare_and_swap((p_obj), dest, dest))


/** An atomic compare and exchange operation, returns true if an exchange occured. `p_expected` MAY be overwritten with the existing value (system specific). */
#define fio_atomic_compare_exchange_p(p_obj, p_expected, p_desired) __sync_bool_compare_and_swap((p_obj), (p_expected), *(p_desired))
/** An atomic exchange operation, ruturns previous value */
#define fio_atomic_exchange(p_obj, value) __sync_val_compare_and_swap((p_obj), *(p_obj), (value))
/** An atomic addition operation, returns new value */
#define fio_atomic_add(p_obj, value) __sync_fetch_and_add((p_obj), (value))
/** An atomic subtraction operation, returns new value */
#define fio_atomic_sub(p_obj, value) __sync_fetch_and_sub((p_obj), (value))
/** An atomic AND (&) operation, returns new value */
#define fio_atomic_and(p_obj, value) __sync_fetch_and_and((p_obj), (value))
/** An atomic XOR (^) operation, returns new value */
#define fio_atomic_xor(p_obj, value) __sync_fetch_and_xor((p_obj), (value))
/** An atomic OR (|) operation, returns new value */
#define fio_atomic_or(p_obj, value) __sync_fetch_and_or((p_obj), (value))
/** An atomic NOT AND ((~)&) operation, returns new value */
#define fio_atomic_nand(p_obj, value) __sync_fetch_and_nand((p_obj), (value))
/** An atomic addition operation, returns previous value */
#define fio_atomic_add_fetch(p_obj, value) __sync_add_and_fetch((p_obj), (value))
/** An atomic subtraction operation, returns previous value */
#define fio_atomic_sub_fetch(p_obj, value) __sync_sub_and_fetch((p_obj), (value))
/** An atomic AND (&) operation, returns previous value */
#define fio_atomic_and_fetch(p_obj, value) __sync_and_and_fetch((p_obj), (value))
/** An atomic XOR (^) operation, returns previous value */
#define fio_atomic_xor_fetch(p_obj, value) __sync_xor_and_fetch((p_obj), (value))
/** An atomic OR (|) operation, returns previous value */
#define fio_atomic_or_fetch(p_obj, value) __sync_or_and_fetch((p_obj), (value))
/** An atomic NOT AND ((~)&) operation, returns previous value */
#define fio_atomic_nand_fetch(p_obj, value) __sync_nand_and_fetch((p_obj), (value))


#elif __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_ATOMICS__)
#include <stdatomic.h>
#ifdef _MSC_VER
#pragma message ("Fallback to C11 atomic header, might be missing some features.")
#undef FIO_COMPILER_GUARD
#define FIO_COMPILER_GUARD atomic_thread_fence(memory_order_seq_cst)
#else
#warning Fallback to C11 atomic header, might be missing some features.
#endif /* _MSC_VER */
/** An atomic load operation, returns value in pointer. */
#define fio_atomic_load(dest, p_obj)  (dest = atomic_load(p_obj))

/** An atomic compare and exchange operation, returns true if an exchange occured. `p_expected` MAY be overwritten with the existing value (system specific). */
#define fio_atomic_compare_exchange_p(p_obj, p_expected, p_desired) atomic_compare_exchange_strong((p_obj), (p_expected), (p_desired))
/** An atomic exchange operation, returns previous value */
#define fio_atomic_exchange(p_obj, value) atomic_exchange((p_obj), (value))
/** An atomic addition operation, returns previous value */
#define fio_atomic_add(p_obj, value) atomic_fetch_add((p_obj), (value))
/** An atomic subtraction operation, returns previous value */
#define fio_atomic_sub(p_obj, value) atomic_fetch_sub((p_obj), (value))
/** An atomic AND (&) operation, returns previous value */
#define fio_atomic_and(p_obj, value) atomic_fetch_and((p_obj), (value))
/** An atomic XOR (^) operation, returns previous value */
#define fio_atomic_xor(p_obj, value) atomic_fetch_xor((p_obj), (value))
/** An atomic OR (|) operation, returns previous value */
#define fio_atomic_or(p_obj, value) atomic_fetch_or((p_obj), (value))
/** An atomic NOT AND ((~)&) operation, returns previous value */
#define fio_atomic_nand(p_obj, value) atomic_fetch_nand((p_obj), (value))
/** An atomic addition operation, returns new value */
#define fio_atomic_add_fetch(p_obj, value) (atomic_fetch_add((p_obj), (value)), atomic_load((p_obj)))
/** An atomic subtraction operation, returns new value */
#define fio_atomic_sub_fetch(p_obj, value) (atomic_fetch_sub((p_obj), (value)), atomic_load((p_obj)))
/** An atomic AND (&) operation, returns new value */
#define fio_atomic_and_fetch(p_obj, value) (atomic_fetch_and((p_obj), (value)), atomic_load((p_obj)))
/** An atomic XOR (^) operation, returns new value */
#define fio_atomic_xor_fetch(p_obj, value) (atomic_fetch_xor((p_obj), (value)), atomic_load((p_obj)))
/** An atomic OR (|) operation, returns new value */
#define fio_atomic_or_fetch(p_obj, value) (atomic_fetch_or((p_obj), (value)), atomic_load((p_obj)))

#elif _MSC_VER
#pragma message ("WARNING: WinAPI atomics have less features, but this is what this compiler has, so...")
#include <intrin.h>
#define FIO___ATOMICS_FN_ROUTE(fn, ptr, ...)                                   \
  ((sizeof(*ptr) == 1)                                                         \
       ? fn##8((int8_t volatile *)(ptr), __VA_ARGS__)                          \
       : (sizeof(*ptr) == 2)                                                   \
             ? fn##16((int16_t volatile *)(ptr), __VA_ARGS__)                  \
             : (sizeof(*ptr) == 4)                                             \
                   ? fn((int32_t volatile *)(ptr), __VA_ARGS__)                \
                   : fn##64((int64_t volatile *)(ptr), __VA_ARGS__))

#ifndef _WIN64
#error Atomics on Windows require 64bit OS and compiler support.
#endif

/** An atomic load operation, returns value in pointer. */
#define fio_atomic_load(dest, p_obj) (dest = *(p_obj))

/** An atomic compare and exchange operation, returns true if an exchange occured. `p_expected` MAY be overwritten with the existing value (system specific). */
#define fio_atomic_compare_exchange_p(p_obj, p_expected, p_desired) (FIO___ATOMICS_FN_ROUTE(_InterlockedCompareExchange, (p_obj),(*(p_desired)),(*(p_expected))), (*(p_obj) == *(p_desired)))
/** An atomic exchange operation, returns previous value */
#define fio_atomic_exchange(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedExchange, (p_obj), (value))

/** An atomic addition operation, returns previous value */
#define fio_atomic_add(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedExchangeAdd, (p_obj), (value))
/** An atomic subtraction operation, returns previous value */
#define fio_atomic_sub(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedExchangeAdd, (p_obj), (0ULL - (value)))
/** An atomic AND (&) operation, returns previous value */
#define fio_atomic_and(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedAnd, (p_obj), (value))
/** An atomic XOR (^) operation, returns previous value */
#define fio_atomic_xor(p_obj, value) FIO___ATOMICS_FN_ROUTE(_InterlockedXor, (p_obj), (value))
/** An atomic OR (|) operation, returns previous value */
#define fio_atomic_or(p_obj, value)  FIO___ATOMICS_FN_ROUTE(_InterlockedOr, (p_obj), (value))

/** An atomic addition operation, returns new value */
#define fio_atomic_add_fetch(p_obj, value) (fio_atomic_add((p_obj), (value)), (*(p_obj)))
/** An atomic subtraction operation, returns new value */
#define fio_atomic_sub_fetch(p_obj, value) (fio_atomic_sub((p_obj), (value)), (*(p_obj)))
/** An atomic AND (&) operation, returns new value */
#define fio_atomic_and_fetch(p_obj, value) (fio_atomic_and((p_obj), (value)), (*(p_obj)))
/** An atomic XOR (^) operation, returns new value */
#define fio_atomic_xor_fetch(p_obj, value) (fio_atomic_xor((p_obj), (value)), (*(p_obj)))
/** An atomic OR (|) operation, returns new value */
#define fio_atomic_or_fetch(p_obj, value) (fio_atomic_or((p_obj), (value)), (*(p_obj)))
#else
#error Required atomics not found (__STDC_NO_ATOMICS__) and older __sync_add_and_fetch is also missing.

#endif
// clang-format on

#define FIO_LOCK_INIT         0
#define FIO_LOCK_SUBLOCK(sub) ((uint8_t)(1U) << ((sub)&7))
typedef volatile unsigned char fio_lock_i;

/** Tries to lock a specific sublock. Returns 0 on success and 1 on failure. */
FIO_IFUNC uint8_t fio_trylock_sublock(fio_lock_i *lock, uint8_t sub) {
  FIO_COMPILER_GUARD;
  sub &= 7;
  uint8_t sub_ = 1U << sub;
  return ((fio_atomic_or(lock, sub_) & sub_) >> sub);
}

/** Busy waits for a specific sublock to become available - not recommended. */
FIO_IFUNC void fio_lock_sublock(fio_lock_i *lock, uint8_t sub) {
  while (fio_trylock_sublock(lock, sub)) {
    FIO_THREAD_RESCHEDULE();
  }
}

/** Unlocks the specific sublock, no matter which thread owns the lock. */
FIO_IFUNC void fio_unlock_sublock(fio_lock_i *lock, uint8_t sub) {
  sub = 1U << (sub & 7);
  fio_atomic_and(lock, (~(fio_lock_i)sub));
}

/**
 * Tries to lock a group of sublocks.
 *
 * Combine a number of sublocks using OR (`|`) and the FIO_LOCK_SUBLOCK(i)
 * macro. i.e.:
 *
 *      if(!fio_trylock_group(&lock,
 *                            FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(2))) {
 *         // act in lock
 *      }
 *
 * Returns 0 on success and non-zero on failure.
 */
FIO_IFUNC uint8_t fio_trylock_group(fio_lock_i *lock, uint8_t group) {
  if (!group)
    group = 1;
  FIO_COMPILER_GUARD;
  uint8_t state = fio_atomic_or(lock, group);
  if (!(state & group))
    return 0;
  /* release the locks we aquired, which are: ((~state) & group) */
  fio_atomic_and(lock, ~((~state) & group));
  return 1;
}

/**
 * Busy waits for a group lock to become available - not recommended.
 *
 * See `fio_trylock_group` for details.
 */
FIO_IFUNC void fio_lock_group(fio_lock_i *lock, uint8_t group) {
  while (fio_trylock_group(lock, group)) {
    FIO_THREAD_RESCHEDULE();
  }
}

/** Unlocks a sublock group, no matter which thread owns which sublock. */
FIO_IFUNC void fio_unlock_group(fio_lock_i *lock, uint8_t group) {
  if (!group)
    group = 1;
  fio_atomic_and(lock, (~group));
}

/** Tries to lock all sublocks. Returns 0 on success and 1 on failure. */
FIO_IFUNC uint8_t fio_trylock_full(fio_lock_i *lock) {
  FIO_COMPILER_GUARD;
  fio_lock_i old = fio_atomic_or(lock, ~(fio_lock_i)0);
  if (!old)
    return 0;
  fio_atomic_and(lock, old);
  return 1;
}

/** Busy waits for all sub lock to become available - not recommended. */
FIO_IFUNC void fio_lock_full(fio_lock_i *lock) {
  while (fio_trylock_full(lock)) {
    FIO_THREAD_RESCHEDULE();
  }
}

/** Unlocks all sub locks, no matter which thread owns the lock. */
FIO_IFUNC void fio_unlock_full(fio_lock_i *lock) { fio_atomic_and(lock, 0); }

/**
 * Tries to acquire the default lock (sublock 0).
 *
 * Returns 0 on success and 1 on failure.
 */
FIO_IFUNC uint8_t fio_trylock(fio_lock_i *lock) {
  return fio_trylock_sublock(lock, 0);
}

/** Busy waits for the default lock to become available - not recommended. */
FIO_IFUNC void fio_lock(fio_lock_i *lock) {
  while (fio_trylock(lock)) {
    FIO_THREAD_RESCHEDULE();
  }
}

/** Unlocks the default lock, no matter which thread owns the lock. */
FIO_IFUNC void fio_unlock(fio_lock_i *lock) { fio_unlock_sublock(lock, 0); }

/** Returns 1 if the lock is locked, 0 otherwise. */
FIO_IFUNC uint8_t FIO_NAME_BL(fio, locked)(fio_lock_i *lock) {
  return *lock & 1;
}

/** Returns 1 if the lock is locked, 0 otherwise. */
FIO_IFUNC uint8_t FIO_NAME_BL(fio, sublocked)(fio_lock_i *lock, uint8_t sub) {
  uint8_t bit = 1U << (sub & 7);
  return (((*lock) & bit) >> (sub & 7));
}

/* *****************************************************************************
Atomic operations - test
***************************************************************************** */
#if defined(FIO_TEST_CSTL)

FIO_SFUNC void FIO_NAME_TEST(stl, atomics)(void) {
  fprintf(stderr, "* Testing atomic operation macros.\n");
  struct fio___atomic_test_s {
    size_t w;
    unsigned long l;
    unsigned short s;
    unsigned char c;
  } s = {0}, r1 = {0}, r2 = {0};
  fio_lock_i lock = FIO_LOCK_INIT;

  r1.c = fio_atomic_add(&s.c, 1);
  r1.s = fio_atomic_add(&s.s, 1);
  r1.l = fio_atomic_add(&s.l, 1);
  r1.w = fio_atomic_add(&s.w, 1);
  FIO_ASSERT(r1.c == 0 && s.c == 1, "fio_atomic_add failed for c");
  FIO_ASSERT(r1.s == 0 && s.s == 1, "fio_atomic_add failed for s");
  FIO_ASSERT(r1.l == 0 && s.l == 1, "fio_atomic_add failed for l");
  FIO_ASSERT(r1.w == 0 && s.w == 1, "fio_atomic_add failed for w");
  r2.c = fio_atomic_add_fetch(&s.c, 1);
  r2.s = fio_atomic_add_fetch(&s.s, 1);
  r2.l = fio_atomic_add_fetch(&s.l, 1);
  r2.w = fio_atomic_add_fetch(&s.w, 1);
  FIO_ASSERT(r2.c == 2 && s.c == 2, "fio_atomic_add_fetch failed for c");
  FIO_ASSERT(r2.s == 2 && s.s == 2, "fio_atomic_add_fetch failed for s");
  FIO_ASSERT(r2.l == 2 && s.l == 2, "fio_atomic_add_fetch failed for l");
  FIO_ASSERT(r2.w == 2 && s.w == 2, "fio_atomic_add_fetch failed for w");
  r1.c = fio_atomic_sub(&s.c, 1);
  r1.s = fio_atomic_sub(&s.s, 1);
  r1.l = fio_atomic_sub(&s.l, 1);
  r1.w = fio_atomic_sub(&s.w, 1);
  FIO_ASSERT(r1.c == 2 && s.c == 1, "fio_atomic_sub failed for c");
  FIO_ASSERT(r1.s == 2 && s.s == 1, "fio_atomic_sub failed for s");
  FIO_ASSERT(r1.l == 2 && s.l == 1, "fio_atomic_sub failed for l");
  FIO_ASSERT(r1.w == 2 && s.w == 1, "fio_atomic_sub failed for w");
  r2.c = fio_atomic_sub_fetch(&s.c, 1);
  r2.s = fio_atomic_sub_fetch(&s.s, 1);
  r2.l = fio_atomic_sub_fetch(&s.l, 1);
  r2.w = fio_atomic_sub_fetch(&s.w, 1);
  FIO_ASSERT(r2.c == 0 && s.c == 0, "fio_atomic_sub_fetch failed for c");
  FIO_ASSERT(r2.s == 0 && s.s == 0, "fio_atomic_sub_fetch failed for s");
  FIO_ASSERT(r2.l == 0 && s.l == 0, "fio_atomic_sub_fetch failed for l");
  FIO_ASSERT(r2.w == 0 && s.w == 0, "fio_atomic_sub_fetch failed for w");
  fio_atomic_add(&s.c, 1);
  fio_atomic_add(&s.s, 1);
  fio_atomic_add(&s.l, 1);
  fio_atomic_add(&s.w, 1);
  r1.c = fio_atomic_exchange(&s.c, 99);
  r1.s = fio_atomic_exchange(&s.s, 99);
  r1.l = fio_atomic_exchange(&s.l, 99);
  r1.w = fio_atomic_exchange(&s.w, 99);
  FIO_ASSERT(r1.c == 1 && s.c == 99, "fio_atomic_exchange failed for c");
  FIO_ASSERT(r1.s == 1 && s.s == 99, "fio_atomic_exchange failed for s");
  FIO_ASSERT(r1.l == 1 && s.l == 99, "fio_atomic_exchange failed for l");
  FIO_ASSERT(r1.w == 1 && s.w == 99, "fio_atomic_exchange failed for w");
  // clang-format off
  FIO_ASSERT(!fio_atomic_compare_exchange_p(&s.c, &r1.c, &r1.c), "fio_atomic_compare_exchange_p didn't fail for c");
  FIO_ASSERT(!fio_atomic_compare_exchange_p(&s.s, &r1.s, &r1.s), "fio_atomic_compare_exchange_p didn't fail for s");
  FIO_ASSERT(!fio_atomic_compare_exchange_p(&s.l, &r1.l, &r1.l), "fio_atomic_compare_exchange_p didn't fail for l");
  FIO_ASSERT(!fio_atomic_compare_exchange_p(&s.w, &r1.w, &r1.w), "fio_atomic_compare_exchange_p didn't fail for w");
  r1.c = 1;s.c = 99; r1.s = 1;s.s = 99; r1.l = 1;s.l = 99; r1.w = 1;s.w = 99; /* ignore system spefcific behavior. */
  r1.c = fio_atomic_compare_exchange_p(&s.c,&s.c, &r1.c);
  r1.s = fio_atomic_compare_exchange_p(&s.s,&s.s, &r1.s);
  r1.l = fio_atomic_compare_exchange_p(&s.l,&s.l, &r1.l);
  r1.w = fio_atomic_compare_exchange_p(&s.w,&s.w, &r1.w);
  FIO_ASSERT(r1.c == 1 && s.c == 1, "fio_atomic_compare_exchange_p failed for c (%zu got %zu)", (size_t)s.c, (size_t)r1.c);
  FIO_ASSERT(r1.s == 1 && s.s == 1, "fio_atomic_compare_exchange_p failed for s (%zu got %zu)", (size_t)s.s, (size_t)r1.s);
  FIO_ASSERT(r1.l == 1 && s.l == 1, "fio_atomic_compare_exchange_p failed for l (%zu got %zu)", (size_t)s.l, (size_t)r1.l);
  FIO_ASSERT(r1.w == 1 && s.w == 1, "fio_atomic_compare_exchange_p failed for w (%zu got %zu)", (size_t)s.w, (size_t)r1.w);
  // clang-format on

  uint64_t val = 1;
  FIO_ASSERT(fio_atomic_and(&val, 2) == 1,
             "fio_atomic_and should return old value");
  FIO_ASSERT(val == 0, "fio_atomic_and should update value");
  FIO_ASSERT(fio_atomic_xor(&val, 1) == 0,
             "fio_atomic_xor should return old value");
  FIO_ASSERT(val == 1, "fio_atomic_xor_fetch should update value");
  FIO_ASSERT(fio_atomic_xor_fetch(&val, 1) == 0,
             "fio_atomic_xor_fetch should return new value");
  FIO_ASSERT(val == 0, "fio_atomic_xor should update value");
  FIO_ASSERT(fio_atomic_or(&val, 2) == 0,
             "fio_atomic_or should return old value");
  FIO_ASSERT(val == 2, "fio_atomic_or should update value");
  FIO_ASSERT(fio_atomic_or_fetch(&val, 1) == 3,
             "fio_atomic_or_fetch should return new value");
  FIO_ASSERT(val == 3, "fio_atomic_or_fetch should update value");
#if !_MSC_VER /* don't test missing MSVC features */
  FIO_ASSERT(fio_atomic_nand_fetch(&val, 4) == ~0ULL,
             "fio_atomic_nand_fetch should return new value");
  FIO_ASSERT(val == ~0ULL, "fio_atomic_nand_fetch should update value");
  val = 3ULL;
  FIO_ASSERT(fio_atomic_nand(&val, 4) == 3ULL,
             "fio_atomic_nand should return old value");
  FIO_ASSERT(val == ~0ULL, "fio_atomic_nand_fetch should update value");
#endif /* !_MSC_VER */
  FIO_ASSERT(!fio_is_locked(&lock),
             "lock should be initialized in unlocked state");
  FIO_ASSERT(!fio_trylock(&lock), "fio_trylock should succeed");
  FIO_ASSERT(fio_trylock(&lock), "fio_trylock should fail");
  FIO_ASSERT(fio_is_locked(&lock), "lock should be engaged");
  fio_unlock(&lock);
  FIO_ASSERT(!fio_is_locked(&lock), "lock should be released");
  fio_lock(&lock);
  FIO_ASSERT(fio_is_locked(&lock), "lock should be engaged (fio_lock)");
  for (uint8_t i = 1; i < 8; ++i) {
    FIO_ASSERT(!fio_is_sublocked(&lock, i),
               "sublock flagged, but wasn't engaged (%u - %p)",
               (unsigned int)i,
               (void *)(uintptr_t)lock);
  }
  fio_unlock(&lock);
  FIO_ASSERT(!fio_is_locked(&lock), "lock should be released");
  lock = FIO_LOCK_INIT;
  for (size_t i = 0; i < 8; ++i) {
    FIO_ASSERT(!fio_is_sublocked(&lock, i),
               "sublock should be initialized in unlocked state");
    FIO_ASSERT(!fio_trylock_sublock(&lock, i),
               "fio_trylock_sublock should succeed");
    FIO_ASSERT(fio_trylock_sublock(&lock, i), "fio_trylock should fail");
    FIO_ASSERT(fio_trylock_full(&lock), "fio_trylock_full should fail");
    FIO_ASSERT(fio_is_sublocked(&lock, i), "sub-lock %d should be engaged", i);
    {
      uint8_t g =
          fio_trylock_group(&lock, FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(3));
      FIO_ASSERT((i != 1 && i != 3 && !g) || ((i == 1 || i == 3) && g),
                 "fio_trylock_group should succeed / fail");
      if (!g)
        fio_unlock_group(&lock, FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(3));
    }
    for (uint8_t j = 1; j < 8; ++j) {
      FIO_ASSERT(i == j || !fio_is_sublocked(&lock, j),
                 "another sublock was flagged, though it wasn't engaged");
    }
    FIO_ASSERT(fio_is_sublocked(&lock, i), "lock should remain engaged");
    fio_unlock_sublock(&lock, i);
    FIO_ASSERT(!fio_is_sublocked(&lock, i), "sublock should be released");
    FIO_ASSERT(!fio_trylock_full(&lock), "fio_trylock_full should succeed");
    fio_unlock_full(&lock);
    FIO_ASSERT(!lock, "fio_unlock_full should unlock all");
  }
}

#endif /* FIO_TEST_CSTL */

/* *****************************************************************************
Atomics - cleanup
***************************************************************************** */
#endif /* FIO_ATOMIC */
#undef FIO_ATOMIC

/* *****************************************************************************




                      Multi-Lock with Mutex Emulation




***************************************************************************** */
#if defined(FIO_LOCK2) && !defined(H___FIO_LOCK2___H)
#define H___FIO_LOCK2___H 1

#ifndef FIO_THREAD_T
#include <pthread.h>
#define FIO_THREAD_T pthread_t
#endif

#ifndef FIO_THREAD_ID
#define FIO_THREAD_ID() pthread_self()
#endif

#ifndef FIO_THREAD_PAUSE
#define FIO_THREAD_PAUSE(id)                                                   \
  do {                                                                         \
    sigset_t set___;                                                           \
    int got___sig;                                                             \
    sigemptyset(&set___);                                                      \
    sigaddset(&set___, SIGINT);                                                \
    sigaddset(&set___, SIGTERM);                                               \
    sigaddset(&set___, SIGCONT);                                               \
    sigwait(&set___, &got___sig);                                              \
  } while (0)
#endif

#ifndef FIO_THREAD_RESUME
#define FIO_THREAD_RESUME(id) pthread_kill((id), SIGCONT)
#endif

typedef struct fio___lock2_wait_s fio___lock2_wait_s;

/* *****************************************************************************
Public API
***************************************************************************** */

/**
 * The fio_lock2 variation is a Mutex style multi-lock.
 *
 * Thread functions and types are managed by the following macros:
 * * the `FIO_THREAD_T` macro should return a thread type, default: `pthread_t`
 * * the `FIO_THREAD_ID()` macro should return this thread's FIO_THREAD_T.
 * * the `FIO_THREAD_PAUSE(id)` macro should temporarily pause thread execution.
 * * the `FIO_THREAD_RESUME(id)` macro should resume thread execution.
 */
typedef struct {
  volatile size_t lock;
  fio___lock2_wait_s *volatile waiting;
} fio_lock2_s;

/**
 * Tries to lock a multilock.
 *
 * Combine a number of sublocks using OR (`|`) and the FIO_LOCK_SUBLOCK(i)
 * macro. i.e.:
 *
 *      if(!fio_trylock2(&lock,
 *                            FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(2))) {
 *         // act in lock
 *      }
 *
 * Returns 0 on success and non-zero on failure.
 */
FIO_IFUNC uint8_t fio_trylock2(fio_lock2_s *lock, size_t group);

/**
 * Locks a multilock, waiting as needed.
 *
 * Combine a number of sublocks using OR (`|`) and the FIO_LOCK_SUBLOCK(i)
 * macro. i.e.:
 *
 *      fio_lock2(&lock, FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(2)));
 *
 * Doesn't return until a successful lock was acquired.
 */
SFUNC void fio_lock2(fio_lock2_s *lock, size_t group);

/**
 * Unlocks a multilock, regardless of who owns the locked group.
 *
 * Combine a number of sublocks using OR (`|`) and the FIO_LOCK_SUBLOCK(i)
 * macro. i.e.:
 *
 *      fio_unlock2(&lock, FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(2));
 *
 */
SFUNC void fio_unlock2(fio_lock2_s *lock, size_t group);

/* *****************************************************************************
Implementation - Inline
***************************************************************************** */

/**
 * Tries to lock a multilock.
 *
 * Combine a number of sublocks using OR (`|`) and the FIO_LOCK_SUBLOCK(i)
 * macro. i.e.:
 *
 *      if(!fio_trylock2(&lock,
 *                            FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(2))) {
 *         // act in lock
 *      }
 *
 * Returns 0 on success and non-zero on failure.
 */
FIO_IFUNC uint8_t fio_trylock2(fio_lock2_s *lock, size_t group) {
  if (!group)
    group = 1;
  FIO_COMPILER_GUARD;
  size_t state = fio_atomic_or(&lock->lock, group);
  if (!(state & group))
    return 0;
  fio_atomic_and(&lock->lock, ~((~state) & group));
  return 1;
}

/* *****************************************************************************
Implementation - Extern
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

struct fio___lock2_wait_s {
  struct fio___lock2_wait_s *next;
  struct fio___lock2_wait_s *prev;
  FIO_THREAD_T t;
};

/**
 * Locks a multilock, waiting as needed.
 *
 * Combine a number of sublocks using OR (`|`) and the FIO_LOCK_SUBLOCK(i)
 * macro. i.e.:
 *
 *      fio_lock2(&lock, FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(2)));
 *
 * Doesn't return until a successful lock was acquired.
 */
SFUNC void fio_lock2(fio_lock2_s *lock, size_t group) {
  if (!group)
    group = 1;
  FIO_COMPILER_GUARD;
  size_t state = fio_atomic_or(&lock->lock, group);
  if (!(state & group))
    return;
  /* note, we now own the part of the lock */

  /* a lock-wide (all groups) lock ID for the waitlist */
  const size_t inner_lock = (sizeof(inner_lock) >= 8)   ? ((size_t)1ULL << 63)
                            : (sizeof(inner_lock) >= 4) ? ((size_t)1UL << 31)
                            : (sizeof(inner_lock) >= 2) ? ((size_t)1UL << 15)
                                                        : ((size_t)1UL << 7);

  /* initialize self-waiting node memory (using stack memory) */
  fio___lock2_wait_s self_thread = {
      .next = &self_thread,
      .prev = &self_thread,
      .t = FIO_THREAD_ID(),
  };

  /* enter waitlist spinlock */
  while ((fio_atomic_or(&lock->lock, inner_lock) & inner_lock)) {
    FIO_THREAD_RESCHEDULE();
  }

  /* add self-thread to end of waitlist */
  if (lock->waiting) {
    FIO_LIST_PUSH(lock->waiting, &self_thread);
  } else {
    lock->waiting = &self_thread;
  }

  /* release waitlist spinlock and unlock any locks we may have aquired */
  fio_atomic_xor(&lock->lock, (((~state) & group) | inner_lock));

  for (;;) {
    if (!fio_trylock2(lock, group))
      break;
    /* it's possible the next thread is waiting for a different group */
    if (self_thread.next != lock->waiting) {
      FIO_THREAD_RESUME(self_thread.next->t);
    }
    if (!fio_trylock2(lock, group))
      break;
    FIO_THREAD_PAUSE(self_thread.t);
  }

  /* remove self from waiting list */
  while ((fio_atomic_or(&lock->lock, inner_lock) & inner_lock)) {
    FIO_THREAD_RESCHEDULE();
  }
  if (self_thread.next != lock->waiting) {
    FIO_THREAD_RESUME(self_thread.next->t);
  }
  FIO_LIST_REMOVE(&self_thread);
  fio_atomic_and(&lock->lock, ~inner_lock);
}

/**
 * Unlocks a multilock, regardless of who owns the locked group.
 *
 * Combine a number of sublocks using OR (`|`) and the FIO_LOCK_SUBLOCK(i)
 * macro. i.e.:
 *
 *      fio_unlock2(&lock, FIO_LOCK_SUBLOCK(1) | FIO_LOCK_SUBLOCK(2));
 *
 */
SFUNC void fio_unlock2(fio_lock2_s *lock, size_t group) {
  /* a lock-wide (all groups) lock ID for the waitlist */
  const size_t inner_lock = (sizeof(inner_lock) >= 8)   ? ((size_t)1ULL << 63)
                            : (sizeof(inner_lock) >= 4) ? ((size_t)1UL << 31)
                            : (sizeof(inner_lock) >= 2) ? ((size_t)1UL << 15)
                                                        : ((size_t)1UL << 7);
  fio___lock2_wait_s *waiting;
  if (!group)
    group = 1;
  /* spinlock for waitlist */
  while ((fio_atomic_or(&lock->lock, inner_lock) & inner_lock)) {
    FIO_THREAD_RESCHEDULE();
  }
  waiting = lock->waiting;
  /* unlock group & waitlist */
  fio_atomic_and(&lock->lock, ~(group | inner_lock));
  if (waiting) {
    FIO_THREAD_RESUME(waiting->t);
  }
}
#endif /* FIO_EXTERN_COMPLETE */

#endif /* FIO_LOCK2 */
#undef FIO_LOCK2
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_BITWISE    /* Development inclusion - ignore line */
#define FIO_BITMAP     /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************
More joyful ideas at:      https://graphics.stanford.edu/~seander/bithacks.html




                            Bit-Byte Operations



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */

#if defined(FIO_BITWISE) && !defined(H___BITWISE___H)
#define H___BITWISE___H

#ifndef FIO_BITWISE_USE_MEMCPY
#define FIO_BITWISE_USE_MEMCPY 1
#endif

/* *****************************************************************************
Bit rotation
***************************************************************************** */

/** Left rotation for an unknown size element, inlined. */
#define FIO_LROT(i, bits)                                                      \
  (((i) << ((bits) & ((sizeof((i)) << 3) - 1))) |                              \
   ((i) >> ((-(bits)) & ((sizeof((i)) << 3) - 1))))

/** Right rotation for an unknown size element, inlined. */
#define FIO_RROT(i, bits)                                                      \
  (((i) >> ((bits) & ((sizeof((i)) << 3) - 1))) |                              \
   ((i) << ((-(bits)) & ((sizeof((i)) << 3) - 1))))

#if __has_builtin(__builtin_rotateleft8)
/** 8Bit left rotation, inlined. */
#define fio_lrot8(i, bits) __builtin_rotateleft8(i, bits)
#else
/** 8Bit left rotation, inlined. */
FIO_IFUNC uint8_t fio_lrot8(uint8_t i, uint8_t bits) {
  return ((i << (bits & 7UL)) | (i >> ((-(bits)) & 7UL)));
}
#endif

#if __has_builtin(__builtin_rotateleft16)
/** 16Bit left rotation, inlined. */
#define fio_lrot16(i, bits) __builtin_rotateleft16(i, bits)
#else
/** 16Bit left rotation, inlined. */
FIO_IFUNC uint16_t fio_lrot16(uint16_t i, uint8_t bits) {
  return ((i << (bits & 15UL)) | (i >> ((-(bits)) & 15UL)));
}
#endif

#if __has_builtin(__builtin_rotateleft32)
/** 32Bit left rotation, inlined. */
#define fio_lrot32(i, bits) __builtin_rotateleft32(i, bits)
#else
/** 32Bit left rotation, inlined. */
FIO_IFUNC uint32_t fio_lrot32(uint32_t i, uint8_t bits) {
  return ((i << (bits & 31UL)) | (i >> ((-(bits)) & 31UL)));
}
#endif

#if __has_builtin(__builtin_rotateleft64)
/** 64Bit left rotation, inlined. */
#define fio_lrot64(i, bits) __builtin_rotateleft64(i, bits)
#else
/** 64Bit left rotation, inlined. */
FIO_IFUNC uint64_t fio_lrot64(uint64_t i, uint8_t bits) {
  return ((i << ((bits)&63UL)) | (i >> ((-(bits)) & 63UL)));
}
#endif

#if __has_builtin(__builtin_rotatrightt8)
/** 8Bit right rotation, inlined. */
#define fio_rrot8(i, bits) __builtin_rotateright8(i, bits)
#else
/** 8Bit right rotation, inlined. */
FIO_IFUNC uint8_t fio_rrot8(uint8_t i, uint8_t bits) {
  return ((i >> (bits & 7UL)) | (i << ((-(bits)) & 7UL)));
}
#endif

#if __has_builtin(__builtin_rotateright16)
/** 16Bit right rotation, inlined. */
#define fio_rrot16(i, bits) __builtin_rotateright16(i, bits)
#else
/** 16Bit right rotation, inlined. */
FIO_IFUNC uint16_t fio_rrot16(uint16_t i, uint8_t bits) {
  return ((i >> (bits & 15UL)) | (i << ((-(bits)) & 15UL)));
}
#endif

#if __has_builtin(__builtin_rotateright32)
/** 32Bit right rotation, inlined. */
#define fio_rrot32(i, bits) __builtin_rotateright32(i, bits)
#else
/** 32Bit right rotation, inlined. */
FIO_IFUNC uint32_t fio_rrot32(uint32_t i, uint8_t bits) {
  return ((i >> (bits & 31UL)) | (i << ((-(bits)) & 31UL)));
}
#endif

#if __has_builtin(__builtin_rotateright64)
/** 64Bit right rotation, inlined. */
#define fio_rrot64(i, bits) __builtin_rotateright64(i, bits)
#else
/** 64Bit right rotation, inlined. */
FIO_IFUNC uint64_t fio_rrot64(uint64_t i, uint8_t bits) {
  return ((i >> ((bits)&63UL)) | (i << ((-(bits)) & 63UL)));
}
#endif

#ifdef __SIZEOF_INT128__
#if __has_builtin(__builtin_rotateright128) &&                                 \
    __has_builtin(__builtin_rotateleft128)
/** 128Bit left rotation, inlined. */
#define fio_lrot128(i, bits) __builtin_rotateleft128(i, bits)
/** 128Bit right rotation, inlined. */
#define fio_rrot128(i, bits) __builtin_rotateright128(i, bits)
#else
/** 128Bit left rotation, inlined. */
FIO_IFUNC __uint128_t fio_lrot128(__uint128_t i, uint8_t bits) {
  return ((i << ((bits)&127UL)) | (i >> ((-(bits)) & 127UL)));
}
/** 128Bit right rotation, inlined. */
FIO_IFUNC __uint128_t fio_rrot128(__uint128_t i, uint8_t bits) {
  return ((i >> ((bits)&127UL)) | (i << ((-(bits)) & 127UL)));
}
#endif
#endif /* __SIZEOF_INT128__ */

/* *****************************************************************************
Unaligned memory read / write operations
***************************************************************************** */

/** Converts an unaligned byte stream to a 16 bit number (local byte order). */
FIO_IFUNC uint16_t FIO_NAME2(fio_buf, u16_local)(const void *c) {
  uint16_t tmp; /* fio_buf2u16 */
  fio_memcpy2(&tmp, c);
  return tmp;
}
/** Converts an unaligned byte stream to a 32 bit number (local byte order). */
FIO_IFUNC uint32_t FIO_NAME2(fio_buf, u32_local)(const void *c) {
  uint32_t tmp; /* fio_buf2u32 */
  fio_memcpy4(&tmp, c);
  return tmp;
}
/** Converts an unaligned byte stream to a 64 bit number (local byte order). */
FIO_IFUNC uint64_t FIO_NAME2(fio_buf, u64_local)(const void *c) {
  uint64_t tmp; /* fio_buf2u64 */
  fio_memcpy8(&tmp, c);
  return tmp;
}

/** Writes a local 16 bit number to an unaligned buffer. */
FIO_IFUNC void FIO_NAME2(fio_u, buf16_local)(void *buf, uint16_t i) {
  fio_memcpy2(buf, &i); /* fio_u2buf16 */
}
/** Writes a local 32 bit number to an unaligned buffer. */
FIO_IFUNC void FIO_NAME2(fio_u, buf32_local)(void *buf, uint32_t i) {
  fio_memcpy4(buf, &i); /* fio_u2buf32 */
}
/** Writes a local 64 bit number to an unaligned buffer. */
FIO_IFUNC void FIO_NAME2(fio_u, buf64_local)(void *buf, uint64_t i) {
  fio_memcpy8(buf, &i); /* fio_u2buf64 */
}

#ifdef __SIZEOF_INT128__
/** Converts an unaligned byte stream to a 128 bit number (local byte order). */
FIO_IFUNC __uint128_t FIO_NAME2(fio_buf, u128_local)(const void *c) {
  __uint128_t tmp; /* fio_buf2u1128 */
  fio_memcpy16(&tmp, c);
  return tmp;
}

/** Writes a local 128 bit number to an unaligned buffer. */
FIO_IFUNC void FIO_NAME2(fio_u, buf128_local)(void *buf, __uint128_t i) {
  fio_memcpy16(buf, &i); /* fio_u2buf128 */
}
#endif /* __SIZEOF_INT128__ */

/** Converts an unaligned byte stream to a 16 bit number (reversed order). */
FIO_IFUNC uint16_t FIO_NAME2(fio_buf, u16_bswap)(const void *c) {
  return fio_bswap16(FIO_NAME2(fio_buf, u16_local)(c)); /* fio_buf2u16 */
}
/** Converts an unaligned byte stream to a 32 bit number (reversed order). */
FIO_IFUNC uint32_t FIO_NAME2(fio_buf, u32_bswap)(const void *c) {
  return fio_bswap32(FIO_NAME2(fio_buf, u32_local)(c)); /* fio_buf2u32 */
}
/** Converts an unaligned byte stream to a 64 bit number (reversed order). */
FIO_IFUNC uint64_t FIO_NAME2(fio_buf, u64_bswap)(const void *c) {
  return fio_bswap64(FIO_NAME2(fio_buf, u64_local)(c)); /* fio_buf2u64 */
}

/** Writes a local 16 bit number to an unaligned buffer in reversed order. */
FIO_IFUNC void FIO_NAME2(fio_u, buf16_bswap)(void *buf, uint16_t i) {
  FIO_NAME2(fio_u, buf16_local)(buf, fio_bswap16(i));
}
/** Writes a local 32 bit number to an unaligned buffer in reversed order. */
FIO_IFUNC void FIO_NAME2(fio_u, buf32_bswap)(void *buf, uint32_t i) {
  FIO_NAME2(fio_u, buf32_local)(buf, fio_bswap32(i));
}
/** Writes a local 64 bit number to an unaligned buffer in reversed order. */
FIO_IFUNC void FIO_NAME2(fio_u, buf64_bswap)(void *buf, uint64_t i) {
  FIO_NAME2(fio_u, buf64_local)(buf, fio_bswap64(i));
}

#ifdef __SIZEOF_INT128__
/** Writes a local 64 bit number to an unaligned buffer in reversed order. */
FIO_IFUNC void FIO_NAME2(fio_u, buf128_bswap)(void *buf, __uint128_t i) {
  FIO_NAME2(fio_u, buf128_local)(buf, fio_bswap128(i));
}
#endif /* __SIZEOF_INT128__ */

/** Converts an unaligned byte stream to a 16 bit number (Big Endian). */
FIO_IFUNC uint16_t FIO_NAME2(fio_buf, u16)(const void *c) { /* fio_buf2u16 */
  uint16_t i = FIO_NAME2(fio_buf, u16_local)(c);
  return fio_lton16(i);
}
/** Converts an unaligned byte stream to a 32 bit number (Big Endian). */
FIO_IFUNC uint32_t FIO_NAME2(fio_buf, u32)(const void *c) { /* fio_buf2u32 */
  uint32_t i = FIO_NAME2(fio_buf, u32_local)(c);
  return fio_lton32(i);
}
/** Converts an unaligned byte stream to a 64 bit number (Big Endian). */
FIO_IFUNC uint64_t FIO_NAME2(fio_buf, u64)(const void *c) { /* fio_buf2u64 */
  uint64_t i = FIO_NAME2(fio_buf, u64_local)(c);
  return fio_lton64(i);
}

/** Writes a local 16 bit number to an unaligned buffer in Big Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf16)(void *buf, uint16_t i) {
  FIO_NAME2(fio_u, buf16_local)(buf, fio_ntol16(i));
}
/** Writes a local 32 bit number to an unaligned buffer in Big Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf32)(void *buf, uint32_t i) {
  FIO_NAME2(fio_u, buf32_local)(buf, fio_ntol32(i));
}
/** Writes a local 64 bit number to an unaligned buffer in Big Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf64)(void *buf, uint64_t i) {
  FIO_NAME2(fio_u, buf64_local)(buf, fio_ntol64(i));
}

#ifdef __SIZEOF_INT128__
/** Converts an unaligned byte stream to a 128 bit number (Big Endian). */
FIO_IFUNC __uint128_t FIO_NAME2(fio_buf,
                                u128)(const void *c) { /* fio_buf2u64 */
  __uint128_t i = FIO_NAME2(fio_buf, u128_local)(c);
  return fio_lton128(i);
}
/** Writes a local 128 bit number to an unaligned buffer in Big Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf128)(void *buf, __uint128_t i) {
  FIO_NAME2(fio_u, buf128_local)(buf, fio_ntol128(i));
}
#endif /* __SIZEOF_INT128__ */

#if __LITTLE_ENDIAN__

/** Converts an unaligned byte stream to a 16 bit number (Little Endian). */
FIO_IFUNC uint16_t FIO_NAME2(fio_buf, u16_little)(const void *c) {
  return FIO_NAME2(fio_buf, u16_local)(c); /* fio_buf2u16 */
}
/** Converts an unaligned byte stream to a 32 bit number (Little Endian). */
FIO_IFUNC uint32_t FIO_NAME2(fio_buf, u32_little)(const void *c) {
  return FIO_NAME2(fio_buf, u32_local)(c); /* fio_buf2u32 */
}
/** Converts an unaligned byte stream to a 64 bit number (Little Endian). */
FIO_IFUNC uint64_t FIO_NAME2(fio_buf, u64_little)(const void *c) {
  return FIO_NAME2(fio_buf, u64_local)(c); /* fio_buf2u64 */
}

/** Writes a local 16 bit number to an unaligned buffer in Little Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf16_little)(void *buf, uint16_t i) {
  FIO_NAME2(fio_u, buf16_local)(buf, i);
}
/** Writes a local 32 bit number to an unaligned buffer in Little Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf32_little)(void *buf, uint32_t i) {
  FIO_NAME2(fio_u, buf32_local)(buf, i);
}
/** Writes a local 64 bit number to an unaligned buffer in Little Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf64_little)(void *buf, uint64_t i) {
  FIO_NAME2(fio_u, buf64_local)(buf, i);
}

#ifdef __SIZEOF_INT128__
/** Converts an unaligned byte stream to a 128 bit number (Little Endian). */
FIO_IFUNC __uint128_t FIO_NAME2(fio_buf, u128_little)(const void *c) {
  return FIO_NAME2(fio_buf, u128_local)(c); /* fio_buf2u64 */
}
/** Writes a local 128 bit number to an unaligned buffer in Little Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf128_little)(void *buf, __uint128_t i) {
  FIO_NAME2(fio_u, buf128_local)(buf, i);
}
#endif /* __SIZEOF_INT128__ */

#else /* !__LITTLE_ENDIAN__ */

/** Converts an unaligned byte stream to a 16 bit number (Little Endian). */
FIO_IFUNC uint16_t FIO_NAME2(fio_buf, u16_little)(const void *c) {
  return FIO_NAME2(fio_buf, u16_bswap)(c); /* fio_buf2u16 */
}
/** Converts an unaligned byte stream to a 32 bit number (Little Endian). */
FIO_IFUNC uint32_t FIO_NAME2(fio_buf, u32_little)(const void *c) {
  return FIO_NAME2(fio_buf, u32_bswap)(c); /* fio_buf2u32 */
}
/** Converts an unaligned byte stream to a 64 bit number (Little Endian). */
FIO_IFUNC uint64_t FIO_NAME2(fio_buf, u64_little)(const void *c) {
  return FIO_NAME2(fio_buf, u64_bswap)(c); /* fio_buf2u64 */
}

/** Writes a local 16 bit number to an unaligned buffer in Little Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf16_little)(void *buf, uint16_t i) {
  FIO_NAME2(fio_u, buf16_bswap)(buf, i);
}
/** Writes a local 32 bit number to an unaligned buffer in Little Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf32_little)(void *buf, uint32_t i) {
  FIO_NAME2(fio_u, buf32_bswap)(buf, i);
}
/** Writes a local 64 bit number to an unaligned buffer in Little Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf64_little)(void *buf, uint64_t i) {
  FIO_NAME2(fio_u, buf64_bswap)(buf, i);
}

#ifdef __SIZEOF_INT128__
/** Converts an unaligned byte stream to a 128 bit number (Little Endian). */
FIO_IFUNC __uint128_t FIO_NAME2(fio_buf, u128_little)(const void *c) {
  return FIO_NAME2(fio_buf, u128_bswap)(c); /* fio_buf2u64 */
}
/** Writes a local 128 bit number to an unaligned buffer in Little Endian. */
FIO_IFUNC void FIO_NAME2(fio_u, buf128_little)(void *buf, __uint128_t i) {
  FIO_NAME2(fio_u, buf128_bswap)(buf, i);
}
#endif /* __SIZEOF_INT128__ */

#endif /* __LITTLE_ENDIAN__ */

/** Convenience function for reading 1 byte (8 bit) from a buffer. */
FIO_IFUNC uint8_t FIO_NAME2(fio_buf, u8_local)(const void *c) {
  const uint8_t *tmp = (const uint8_t *)c; /* fio_buf2u16 */
  return *tmp;
}

/** Convinience function for writing 1 byte (8 bit) to a buffer. */
FIO_IFUNC void FIO_NAME2(fio_u, buf8_local)(void *buf, uint8_t i) {
  *((uint8_t *)buf) = i; /* fio_u2buf16 */
}

/** Convinience function for reading 1 byte (8 bit) from a buffer. */
FIO_IFUNC uint8_t FIO_NAME2(fio_buf, u8_bswap)(const void *c) {
  const uint8_t *tmp = (const uint8_t *)c; /* fio_buf2u16 */
  return *tmp;
}

/** Convinience function for writing 1 byte (8 bit) to a buffer. */
FIO_IFUNC void FIO_NAME2(fio_u, buf8_bswap)(void *buf, uint8_t i) {
  *((uint8_t *)buf) = i; /* fio_u2buf16 */
}

/** Convinience function for reading 1 byte (8 bit) from a buffer. */
FIO_IFUNC uint8_t FIO_NAME2(fio_buf, u8_little)(const void *c) {
  const uint8_t *tmp = (const uint8_t *)c; /* fio_buf2u16 */
  return *tmp;
}

/** Convinience function for writing 1 byte (8 bit) to a buffer. */
FIO_IFUNC void FIO_NAME2(fio_u, buf8_little)(void *buf, uint8_t i) {
  *((uint8_t *)buf) = i; /* fio_u2buf16 */
}

/** Convinience function for reading 1 byte (8 bit) from a buffer. */
FIO_IFUNC uint8_t FIO_NAME2(fio_buf, u8)(const void *c) {
  const uint8_t *tmp = (const uint8_t *)c; /* fio_buf2u16 */
  return *tmp;
}

/** Convinience function for writing 1 byte (8 bit) to a buffer. */
FIO_IFUNC void FIO_NAME2(fio_u, buf8)(void *buf, uint8_t i) {
  *((uint8_t *)buf) = i; /* fio_u2buf16 */
}

/* *****************************************************************************
Constant-Time Selectors
***************************************************************************** */

/** Returns 1 if the expression is true (input isn't zero). */
FIO_IFUNC uintptr_t fio_ct_true(uintptr_t cond) {
  // promise that the highest bit is set if any bits are set, than shift.
  return ((cond | (0 - cond)) >> ((sizeof(cond) << 3) - 1));
}

/** Returns 1 if the expression is false (input is zero). */
FIO_IFUNC uintptr_t fio_ct_false(uintptr_t cond) {
  // fio_ct_true returns only one bit, XOR will inverse that bit.
  return fio_ct_true(cond) ^ 1;
}

/** Returns `a` if `cond` is boolean and true, returns b otherwise. */
FIO_IFUNC uintptr_t fio_ct_if_bool(uint8_t cond, uintptr_t a, uintptr_t b) {
  // b^(a^b) cancels b out. 0-1 => sets all bits.
  return (b ^ ((0 - (cond & 1)) & (a ^ b)));
}

/** Returns `a` if `cond` isn't zero (uses fio_ct_true), returns b otherwise. */
FIO_IFUNC uintptr_t fio_ct_if(uintptr_t cond, uintptr_t a, uintptr_t b) {
  // b^(a^b) cancels b out. 0-1 => sets all bits.
  return fio_ct_if_bool(fio_ct_true(cond), a, b);
}

/** Returns `a` if a >= `b`. */
FIO_IFUNC intptr_t fio_ct_max(intptr_t a_, intptr_t b_) {
  // if b - a is negative, a > b, unless both / one are negative.
  const uintptr_t a = a_, b = b_;
  return (
      intptr_t)fio_ct_if_bool(((a - b) >> ((sizeof(a) << 3) - 1)) & 1, b, a);
}

/* *****************************************************************************
SIMD emulation helpers
***************************************************************************** */

/**
 * Detects a byte where all the bits are set (255) within a 4 byte vector.
 *
 * The full byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC uint32_t fio_has_full_byte32(uint32_t row) {
  return ((row & UINT32_C(0x7F7F7F7F)) + UINT32_C(0x01010101)) &
         (row & UINT32_C(0x80808080));
}

/**
 * Detects a byte where no bits are set (0) within a 4 byte vector.
 *
 * The zero byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC uint32_t fio_has_zero_byte32(uint32_t row) {
  return (row - UINT32_C(0x01010101)) & (~row & UINT32_C(0x80808080));
}

/**
 * Detects if `byte` exists within a 4 byte vector.
 *
 * The requested byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC uint32_t fio_has_byte32(uint32_t row, uint8_t byte) {
  return fio_has_zero_byte32((row ^ (UINT32_C(0x01010101) * byte)));
}

/**
 * Detects a byte where all the bits are set (255) within an 8 byte vector.
 *
 * The full byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC uint64_t fio_has_full_byte64(uint64_t row) {
  return ((row & UINT64_C(0x7F7F7F7F7F7F7F7F)) + UINT64_C(0x0101010101010101)) &
         (row & UINT64_C(0x8080808080808080));
}

/**
 * Detects a byte where no bits are set (0) within an 8 byte vector.
 *
 * The zero byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC uint64_t fio_has_zero_byte64(uint64_t row) {
  return (row - UINT64_C(0x0101010101010101)) &
         ((~row) & UINT64_C(0x8080808080808080));
}

/**
 * Detects if `byte` exists within an 8 byte vector.
 *
 * The requested byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC uint64_t fio_has_byte64(uint64_t row, uint8_t byte) {
  return fio_has_zero_byte64((row ^ (UINT64_C(0x0101010101010101) * byte)));
}

#ifdef __SIZEOF_INT128__
/**
 * Detects a byte where all the bits are set (255) within an 16 byte vector.
 *
 * The full byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC __uint128_t fio_has_full_byte128(__uint128_t row) {
  const __uint128_t allF7 = ((__uint128_t)(0x7F7F7F7F7F7F7F7FULL) << 64) |
                            (__uint128_t)(0x7F7F7F7F7F7F7F7FULL);
  const __uint128_t all80 = ((__uint128_t)(0x8080808080808080) << 64) |
                            (__uint128_t)(0x8080808080808080);
  const __uint128_t all01 = ((__uint128_t)(0x0101010101010101) << 64) |
                            (__uint128_t)(0x0101010101010101);
  return ((row & allF7) + all01) & (row & all80);
}

/**
 * Detects a byte where no bits are set (0) within an 8 byte vector.
 *
 * The zero byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC __uint128_t fio_has_zero_byte128(__uint128_t row) {
  const __uint128_t all80 = ((__uint128_t)(0x8080808080808080) << 64) |
                            (__uint128_t)(0x8080808080808080);
  const __uint128_t all01 = ((__uint128_t)(0x0101010101010101) << 64) |
                            (__uint128_t)(0x0101010101010101);
  return ((row - all01) & ((~row) & all80));
}

/**
 * Detects if `byte` exists within an 8 byte vector.
 *
 * The requested byte will be be set to 0x80, all other bytes will be 0x0.
 */
FIO_IFUNC __uint128_t fio_has_byte128(__uint128_t row, uint8_t byte) {
  const __uint128_t all01 = ((__uint128_t)(0x0101010101010101) << 64) |
                            (__uint128_t)(0x0101010101010101);
  return fio_has_zero_byte128((row ^ (all01 * byte)));
}
#endif /* __SIZEOF_INT128__ */

/** Converts a `fio_has_byteX` result to a bitmap. */
FIO_IFUNC uint64_t fio_has_byte2bitmap(uint64_t result) {
  result >>= 7;             /* move result to first bit of each byte */
  result |= (result >> 7);  /* combine 2 bytes of result */
  result |= (result >> 14); /* combine 4 bytes of result */
  result |= (result >> 28); /* combine 8 bytes of result */
  return result & 0xFFULL;
}

/** Isolates the least significant (lowest) bit. */
FIO_IFUNC uint64_t fio_bits_lsb(uint64_t i) { return (i & ((~i) + 1)); }

/** Isolates the most significant (highest) bit. */
FIO_IFUNC uint64_t fio_bits_msb(uint64_t i) {
  i |= i >> 1;
  i |= i >> 2;
  i |= i >> 4;
  i |= i >> 8;
  i |= i >> 16;
  i |= i >> 32;
  i = ((i + 1) >> 1) | (i & ((uint64_t)1ULL << 63));
  return i;
}

/** Returns the index of the most significant (highest) bit. */
FIO_IFUNC size_t fio_bits_msb_index(uint64_t i) {
  if (!i)
    goto zero;
  return fio___msb_index_unsafe(i);
zero:
  return (size_t)-1;
}

/** Returns the index of the least significant (lowest) bit. */
FIO_IFUNC size_t fio_bits_lsb_index(uint64_t i) {
  if (!i)
    goto zero;
  return fio___lsb_index_unsafe(i);
zero:
  return (size_t)-1;
}

/* *****************************************************************************
Byte masking (XOR) with nonce (counter mode)
***************************************************************************** */

/**
 * Masks data using a 64 bit mask and a counter mode nonce. When the buffer's
 * memory is aligned, the function may perform significantly better.
 *
 * Returns the end state of the mask.
 */
FIO_IFUNC uint64_t fio_xmask2(char *buf_,
                              size_t len,
                              uint64_t mask,
                              uint64_t nonce) {
  register char *buf = (char *)buf_;
  uint64_t tmp;
  for (size_t i = 7; i < len; i += 8) {
    fio_memcpy8(&tmp, buf);
    tmp ^= mask;
    fio_memcpy8(buf, &tmp);
    buf += 8;
    mask += nonce;
  }
  fio_memcpy7x(&tmp, buf, len);
  tmp ^= mask;
  fio_memcpy7x(buf, &tmp, len);
  mask += nonce;
  return mask;
}

/* *****************************************************************************
Byte masking (XOR) - no nonce
***************************************************************************** */

/**
 * Masks data using a persistent 64 bit mask.
 *
 * When the buffer's memory is aligned, the function may perform significantly
 * better.
 */
FIO_IFUNC void fio_xmask(char *buf_, size_t len, uint64_t mask) {
  register char *buf = (char *)buf_;
  uint64_t m[4] FIO_ALIGN(16) = {mask, mask, mask, mask};
  uint64_t tmp[4] FIO_ALIGN(16);
  for (size_t i = 31; i < len; i += 32) {
    fio_memcpy32(tmp, buf);
    tmp[0] ^= m[0];
    tmp[1] ^= m[1];
    tmp[2] ^= m[2];
    tmp[3] ^= m[3];
    fio_memcpy32(buf, tmp);
    buf += 32;
  }
  fio_memcpy31x(tmp, buf, len);
  tmp[0] ^= m[0];
  tmp[1] ^= m[1];
  tmp[2] ^= m[2];
  tmp[3] ^= m[3];
  fio_memcpy31x(buf, tmp, len);
}

/* *****************************************************************************
Hemming Distance and bit counting
***************************************************************************** */

#if __has_builtin(__builtin_popcountll)
/** performs a `popcount` operation to count the set bits. */
#define fio_popcount(n) __builtin_popcountll(n)
#else
FIO_IFUNC int fio_popcount(uint64_t n) {
  /* for logic, see Wikipedia: https://en.wikipedia.org/wiki/Hamming_weight */
  n = n - ((n >> 1) & 0x5555555555555555);
  n = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);
  n = (n + (n >> 4)) & 0x0f0f0f0f0f0f0f0f;
  n = n + (n >> 8);
  n = n + (n >> 16);
  n = n + (n >> 32);
  return n & 0x7f;
}
#endif

#define fio_hemming_dist(n1, n2) fio_popcount(((uint64_t)(n1) ^ (uint64_t)(n2)))

/* *****************************************************************************
Bitewise helpers cleanup
***************************************************************************** */
#endif /* FIO_BITWISE */
#undef FIO_BITWISE

/* *****************************************************************************




                                Bitmap Helpers




***************************************************************************** */
#if defined(FIO_BITMAP) && !defined(H___FIO_BITMAP_H)
#define H___FIO_BITMAP_H
/* *****************************************************************************
Bitmap access / manipulation
***************************************************************************** */

/** Gets the state of a bit in a bitmap. */
FIO_IFUNC uint8_t fio_bitmap_get(void *map, size_t bit) {
  return ((((uint8_t *)(map))[(bit) >> 3] >> ((bit)&7)) & 1);
}

/** Sets the a bit in a bitmap (sets to 1). */
FIO_IFUNC void fio_bitmap_set(void *map, size_t bit) {
  fio_atomic_or((uint8_t *)(map) + ((bit) >> 3), (1UL << ((bit)&7)));
}

/** Unsets the a bit in a bitmap (sets to 0). */
FIO_IFUNC void fio_bitmap_unset(void *map, size_t bit) {
  fio_atomic_and((uint8_t *)(map) + ((bit) >> 3),
                 (uint8_t)(~(1UL << ((bit)&7))));
}

/** Flips the a bit in a bitmap (sets to 0 if 1, sets to 1 if 0). */
FIO_IFUNC void fio_bitmap_flip(void *map, size_t bit) {
  fio_atomic_xor((uint8_t *)(map) + ((bit) >> 3), (1UL << ((bit)&7)));
}

/* *****************************************************************************
Bit-Byte operations - testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

/* used in the test, defined later */
SFUNC uint64_t fio_rand64(void);
SFUNC void fio_rand_bytes(void *target, size_t len);

FIO_SFUNC void FIO_NAME_TEST(stl, bitwise)(void) {
  fprintf(stderr, "* Testing fio_memcpy primitives.\n");
  {
    struct {
      void *(*fn)(void *, const void *, size_t);
      const char *name;
      size_t len;
    } tests[] = {
        {fio_memcpy7x, "fio_memcpy7x", 7},
        {fio_memcpy15x, "fio_memcpy15x", 15},
        {fio_memcpy31x, "fio_memcpy31x", 31},
        {fio_memcpy63x, "fio_memcpy63x", 63},
        {fio_memcpy127x, "fio_memcpy127x", 127},
        {fio_memcpy255x, "fio_memcpy255x", 255},
        {fio_memcpy511x, "fio_memcpy511x", 511},
        {fio_memcpy1023x, "fio_memcpy1023x", 1023},
        {fio_memcpy2047x, "fio_memcpy2047x", 2047},
        {fio_memcpy4095x, "fio_memcpy4095x", 4095},
        {NULL},
    };
    char buf[(4096 << 1) + 64];
    fio_rand_bytes(buf + (4096 + 32), (4096 + 32));
    for (size_t ifn = 0; tests[ifn].fn; ++ifn) {
      /* test all x primitives */
      size_t len = tests[ifn].len;
      for (size_t i = 0; i < 31; ++i) {
        memset(buf, 0, 4096 + 32);
        buf[i + len] = '\xFF';
        tests[ifn].fn(buf + i, buf + (4096 + 32), len);
        FIO_ASSERT(!memcmp(buf + i, buf + (4096 + 32), len),
                   "%s failed @ %zu\n",
                   tests[ifn].name,
                   i);
        FIO_ASSERT(buf[i + len] == '\xFF', "%s overflow?", tests[ifn].name);
      }
    }
  }
  fprintf(stderr, "* Testing fio_bswapX macros.\n");
  FIO_ASSERT(fio_bswap16(0x0102) == (uint16_t)0x0201, "fio_bswap16 failed");
  FIO_ASSERT(fio_bswap32(0x01020304) == (uint32_t)0x04030201,
             "fio_bswap32 failed");
  FIO_ASSERT(fio_bswap64(0x0102030405060708ULL) == 0x0807060504030201ULL,
             "fio_bswap64 failed");

  fprintf(stderr, "* Testing fio_lrotX and fio_rrotX macros.\n");
  {
    uint64_t tmp = 1;
    tmp = FIO_RROT(tmp, 1);
    FIO_COMPILER_GUARD;
    FIO_ASSERT(tmp == ((uint64_t)1 << ((sizeof(uint64_t) << 3) - 1)),
               "fio_rrot failed");
    tmp = FIO_LROT(tmp, 3);
    FIO_COMPILER_GUARD;
    FIO_ASSERT(tmp == ((uint64_t)1 << 2), "fio_lrot failed");
    tmp = 1;
    tmp = fio_rrot32(tmp, 1);
    FIO_COMPILER_GUARD;
    FIO_ASSERT(tmp == ((uint64_t)1 << 31), "fio_rrot32 failed");
    tmp = fio_lrot32(tmp, 3);
    FIO_COMPILER_GUARD;
    FIO_ASSERT(tmp == ((uint64_t)1 << 2), "fio_lrot32 failed");
    tmp = 1;
    tmp = fio_rrot64(tmp, 1);
    FIO_COMPILER_GUARD;
    FIO_ASSERT(tmp == ((uint64_t)1 << 63), "fio_rrot64 failed");
    tmp = fio_lrot64(tmp, 3);
    FIO_COMPILER_GUARD;
    FIO_ASSERT(tmp == ((uint64_t)1 << 2), "fio_lrot64 failed");
  }
  for (size_t i = 0; i < 63; ++i) {
#if !defined(__has_builtin) || !__has_builtin(__builtin_ctzll) ||              \
    !__has_builtin(__builtin_clzll)
    FIO_ASSERT(fio___single_bit_index_unsafe((1ULL << i)) == i,
               "bit index map[%zu] error != %zu",
               (size_t)(1ULL << i),
               i);
#endif
    FIO_ASSERT(fio_bits_msb_index(((1ULL << i) | 1)) == i,
               "fio_bits_msb_index(%zu) != %zu",
               ((1ULL << i)),
               (size_t)fio_bits_msb_index(((1ULL << i) | 1)));
    FIO_ASSERT(fio_bits_lsb_index(((~0ULL) << i)) == i,
               "fio_bits_lsb_index(%zu) != %zu",
               1,
               (size_t)fio_bits_lsb_index(((~0ULL) << i)));
  }

  fprintf(stderr, "* Testing fio_buf2uX and fio_u2bufX helpers.\n");
#define FIO___BITMAP_TEST_BITS(itype, utype, bits)                             \
  for (size_t i = 0; i < (bits); ++i) {                                        \
    char tmp_buf[32];                                                          \
    itype n = ((utype)1 << i);                                                 \
    FIO_NAME2(fio_u, buf##bits##_local)(tmp_buf, n);                           \
    itype r = FIO_NAME2(fio_buf, u##bits##_local)(tmp_buf);                    \
    FIO_ASSERT(r == n,                                                         \
               "roundtrip failed for U" #bits " at bit %zu\n\t%zu != %zu",     \
               i,                                                              \
               (size_t)n,                                                      \
               (size_t)r);                                                     \
    FIO_ASSERT(!memcmp(tmp_buf, &n, (bits) >> 3),                              \
               "memory ordering implementation error for U" #bits "!");        \
  }
  FIO___BITMAP_TEST_BITS(int8_t, uint8_t, 8);
  FIO___BITMAP_TEST_BITS(int16_t, uint16_t, 16);
  FIO___BITMAP_TEST_BITS(int32_t, uint32_t, 32);
  FIO___BITMAP_TEST_BITS(int64_t, uint64_t, 64);
#ifdef __SIZEOF_INT128__
  FIO___BITMAP_TEST_BITS(__int128_t, __uint128_t, 128);
#endif
#undef FIO___BITMAP_TEST_BITS

  fprintf(stderr, "* Testing constant-time helpers.\n");
  FIO_ASSERT(fio_ct_true(0) == 0, "fio_ct_true(0) should be zero!");
  for (uintptr_t i = 1; i; i <<= 1) {
    FIO_ASSERT(fio_ct_true(i) == 1,
               "fio_ct_true(%p) should be true!",
               (void *)i);
  }
  for (uintptr_t i = 1; i + 1 != 0; i = (i << 1) | 1) {
    FIO_ASSERT(fio_ct_true(i) == 1,
               "fio_ct_true(%p) should be true!",
               (void *)i);
  }
  FIO_ASSERT(fio_ct_true(((uintptr_t)~0ULL)) == 1,
             "fio_ct_true(%p) should be true!",
             (void *)(uintptr_t)(~0ULL));

  FIO_ASSERT(fio_ct_false(0) == 1, "fio_ct_false(0) should be true!");
  for (uintptr_t i = 1; i; i <<= 1) {
    FIO_ASSERT(fio_ct_false(i) == 0,
               "fio_ct_false(%p) should be zero!",
               (void *)i);
  }
  for (uintptr_t i = 1; i + 1 != 0; i = (i << 1) | 1) {
    FIO_ASSERT(fio_ct_false(i) == 0,
               "fio_ct_false(%p) should be zero!",
               (void *)i);
  }
  FIO_ASSERT(fio_ct_false(((uintptr_t)~0ULL)) == 0,
             "fio_ct_false(%p) should be zero!",
             (void *)(uintptr_t)(~0ULL));
  FIO_ASSERT(fio_ct_true(8), "fio_ct_true should be true.");
  FIO_ASSERT(!fio_ct_true(0), "fio_ct_true should be false.");
  FIO_ASSERT(!fio_ct_false(8), "fio_ct_false should be false.");
  FIO_ASSERT(fio_ct_false(0), "fio_ct_false should be true.");
  FIO_ASSERT(fio_ct_if_bool(0, 1, 2) == 2,
             "fio_ct_if_bool selection error (false).");
  FIO_ASSERT(fio_ct_if_bool(1, 1, 2) == 1,
             "fio_ct_if_bool selection error (true).");
  FIO_ASSERT(fio_ct_if(0, 1, 2) == 2, "fio_ct_if selection error (false).");
  FIO_ASSERT(fio_ct_if(8, 1, 2) == 1, "fio_ct_if selection error (true).");
  FIO_ASSERT(fio_ct_max(1, 2) == 2, "fio_ct_max error.");
  FIO_ASSERT(fio_ct_max(2, 1) == 2, "fio_ct_max error.");
  FIO_ASSERT(fio_ct_max(-1, 2) == 2, "fio_ct_max error.");
  FIO_ASSERT(fio_ct_max(2, -1) == 2, "fio_ct_max error.");
  FIO_ASSERT(fio_ct_max(1, -2) == 1, "fio_ct_max error.");
  FIO_ASSERT(fio_ct_max(-2, 1) == 1, "fio_ct_max error.");
  FIO_ASSERT(fio_ct_max(-1, -2) == -1, "fio_ct_max error.");
  FIO_ASSERT(fio_ct_max(-2, -1) == -1, "fio_ct_max error.");
  {
    uint8_t bitmap[1024];
    FIO_MEMSET(bitmap, 0, 1024);
    fprintf(stderr, "* Testing bitmap helpers.\n");
    FIO_ASSERT(!fio_bitmap_get(bitmap, 97), "fio_bitmap_get should be 0.");
    fio_bitmap_set(bitmap, 97);
    FIO_ASSERT(fio_bitmap_get(bitmap, 97) == 1,
               "fio_bitmap_get should be 1 after being set");
    FIO_ASSERT(!fio_bitmap_get(bitmap, 96),
               "other bits shouldn't be effected by set.");
    FIO_ASSERT(!fio_bitmap_get(bitmap, 98),
               "other bits shouldn't be effected by set.");
    fio_bitmap_flip(bitmap, 96);
    fio_bitmap_flip(bitmap, 97);
    FIO_ASSERT(!fio_bitmap_get(bitmap, 97),
               "fio_bitmap_get should be 0 after flip.");
    FIO_ASSERT(fio_bitmap_get(bitmap, 96) == 1,
               "other bits shouldn't be effected by flip");
    fio_bitmap_unset(bitmap, 96);
    fio_bitmap_flip(bitmap, 97);
    FIO_ASSERT(!fio_bitmap_get(bitmap, 96),
               "fio_bitmap_get should be 0 after unset.");
    FIO_ASSERT(fio_bitmap_get(bitmap, 97) == 1,
               "other bits shouldn't be effected by unset");
    fio_bitmap_unset(bitmap, 96);
  }
  {
    fprintf(stderr, "* Testing popcount and hemming distance calculation.\n");
    for (int i = 0; i < 64; ++i) {
      FIO_ASSERT(fio_popcount((uint64_t)1 << i) == 1,
                 "fio_popcount error for 1 bit");
    }
    for (int i = 0; i < 63; ++i) {
      FIO_ASSERT(fio_popcount((uint64_t)3 << i) == 2,
                 "fio_popcount error for 2 bits");
    }
    for (int i = 0; i < 62; ++i) {
      FIO_ASSERT(fio_popcount((uint64_t)7 << i) == 3,
                 "fio_popcount error for 3 bits");
    }
    for (int i = 0; i < 59; ++i) {
      FIO_ASSERT(fio_popcount((uint64_t)21 << i) == 3,
                 "fio_popcount error for 3 alternating bits");
    }
    for (int i = 0; i < 64; ++i) {
      FIO_ASSERT(fio_hemming_dist(((uint64_t)1 << i) - 1, 0) == i,
                 "fio_hemming_dist error at %d",
                 i);
    }
  }
  {
    struct test_s {
      int a;
      char force_padding;
      int b;
    } stst = {.a = 1};

    struct test_s *stst_p = FIO_PTR_FROM_FIELD(struct test_s, b, &stst.b);
    FIO_ASSERT(stst_p == &stst, "FIO_PTR_FROM_FIELD failed to retrace pointer");
  }
  {
    fprintf(stderr, "* Testing fio_xmask and fio_xmask2.\n");
    char data[128], buf[256];
    uint64_t mask;
    uint64_t counter;
    do {
      mask = fio_rand64();
      counter = fio_rand64();
    } while (!mask || !counter);
    fio_rand_bytes(data, 128);
    const size_t len = 127;
    for (uint8_t i = 0; i < 16; ++i) {
      FIO_MEMCPY(buf + i, data, len);
      buf[len + i] = '\xFF';
      fio_xmask(buf + i, len, mask);
      FIO_ASSERT(buf[len + i] == '\xFF', "fio_xmask overflow?");
      FIO_ASSERT(memcmp(buf + i, data, len), "fio_xmask masking error");
      FIO_ASSERT(memcmp(buf + i, data, 8), "fio_xmask didn't mask data head?");
      FIO_ASSERT(
          !(len & 7) ||
              memcmp(buf + i + (len & (~7U)), data + (len & (~7U)), (len & 7)),
          "fio_xmask mask didn't mask data's tail?");
      fio_xmask(buf + i, len, mask);
      FIO_ASSERT(!memcmp(buf + i, data, len), "fio_xmask rountrip error");
      fio_xmask(buf + i, len, mask);
      FIO_MEMMOVE(buf + i + 1, buf + i, len);
      fio_xmask(buf + i + 1, len, mask);
      FIO_ASSERT(!memcmp(buf + i + 1, data, len),
                 "fio_xmask rountrip (with move) error");
    }
    for (uint8_t i = 0; i < 16; ++i) {
      FIO_MEMCPY(buf + i, data, len);
      buf[len + i] = '\xFF';
      fio_xmask2(buf + i, len, mask, counter);
      FIO_ASSERT(buf[len + i] == '\xFF', "fio_xmask2 overflow?");
      FIO_ASSERT(memcmp(buf + i, data, len), "fio_xmask2 (CM) masking error");
      FIO_ASSERT(memcmp(buf + i, data, 8), "fio_xmask2 didn't mask data head?");
      FIO_ASSERT(memcmp(buf + i + (len - 8), data + (len - 8), 8),
                 "fio_xmask2 mask didn't mask string tail?");
      fio_xmask2(buf + i, len, mask, counter);
      FIO_ASSERT(!memcmp(buf + i, data, len), "fio_xmask2 rountrip error");
      fio_xmask2(buf + i, len, mask, counter);
      FIO_MEMMOVE(buf + i + 1, buf + i, len);
      fio_xmask2(buf + i + 1, len, mask, counter);
      FIO_ASSERT(!memcmp(buf + i + 1, data, len), "fio_xmask2 with move error");
    }
  }
}
#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Bit-Byte operations - cleanup
***************************************************************************** */
#endif /* FIO_BITMAP */
#undef FIO_BITMAP
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_MATH       /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                    Basic Math Operations and Multi-Precision
                        Constant Time (when possible)



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_MATH) && !defined(H___FIO_MATH___H)
#define H___FIO_MATH___H 1

/* *****************************************************************************
Useful math unions.
***************************************************************************** */

/** An unsigned 128bit union type. */
typedef union {
  uint8_t u8[16];
  uint16_t u16[8];
  uint32_t u32[4];
  uint64_t u64[2];
#if defined(__SIZEOF_INT128__)
  __uint128_t u128[1];
#endif
} fio_128u;

/** An unsigned 256bit union type. */
typedef union {
  uint8_t u8[32];
  uint16_t u16[16];
  uint32_t u32[8];
  uint64_t u64[4];
#if defined(__SIZEOF_INT128__)
  __uint128_t u128[2];
#endif
#if defined(__SIZEOF_INT256__)
  __uint256_t u256[1];
#endif

} fio_256u;

/** An unsigned 512bit union type. */
typedef union {
  uint8_t u8[64];
  uint16_t u16[32];
  uint32_t u32[16];
  uint64_t u64[8];
#if defined(__SIZEOF_INT128__)
  __uint128_t u128[4];
#endif
#if defined(__SIZEOF_INT256__)
  __uint256_t u256[2];
#endif
} fio_512u;

/** An unsigned 1024bit union type. */
typedef union {
  uint8_t u8[128];
  uint16_t u16[64];
  uint32_t u32[32];
  uint64_t u64[16];
#if defined(__SIZEOF_INT128__)
  __uint128_t u128[8];
#endif
#if defined(__SIZEOF_INT256__)
  __uint256_t u256[4];
#endif
} fio_1024u;

/** An unsigned 2048bit union type. */
typedef union {
  uint8_t u8[256];
  uint16_t u16[128];
  uint32_t u32[64];
  uint64_t u64[32];
#if defined(__SIZEOF_INT128__)
  __uint128_t u128[8];
#endif
#if defined(__SIZEOF_INT256__)
  __uint256_t u256[4];
#endif
} fio_2048u;

/** An unsigned 4096bit union type. */
typedef union {
  uint8_t u8[512];
  uint16_t u16[256];
  uint32_t u32[128];
  uint64_t u64[64];
#if defined(__SIZEOF_INT128__)
  __uint128_t u128[32];
#endif
#if defined(__SIZEOF_INT256__)
  __uint256_t u256[16];
#endif
} fio_4096u;

/* *****************************************************************************
64bit addition (ADD) / subtraction (SUB) / multiplication (MUL) with carry.
***************************************************************************** */

/** Add with carry. */
FIO_IFUNC uint64_t fio_math_addc64(uint64_t a,
                                   uint64_t b,
                                   uint64_t carry_in,
                                   uint64_t *carry_out);
/** Subtract with carry. */
FIO_IFUNC uint64_t fio_math_subc64(uint64_t a,
                                   uint64_t b,
                                   uint64_t carry_in,
                                   uint64_t *carry_out);
/** Multiply with carry out. */
FIO_IFUNC uint64_t fio_math_mulc64(uint64_t a, uint64_t b, uint64_t *carry_out);

/* *****************************************************************************
Multi-precision, little endian helpers.

Works with little endian uint64_t arrays or 64 bit numbers.
***************************************************************************** */

/** Multi-precision ADD for `len*64` bit long a + b. Returns the carry. */
FIO_IFUNC uint64_t fio_math_add(uint64_t *dest,
                                const uint64_t *a,
                                const uint64_t *b,
                                const size_t number_array_length);

/** Multi-precision SUB for `len*64` bit long a + b. Returns the carry. */
FIO_IFUNC uint64_t fio_math_sub(uint64_t *dest,
                                const uint64_t *a,
                                const uint64_t *b,
                                const size_t number_array_length);

/** Multi-precision MUL for `len*64` bit long a, b. `dest` must be `len*2` .*/
FIO_IFUNC void fio_math_mul(uint64_t *restrict dest,
                            const uint64_t *a,
                            const uint64_t *b,
                            const size_t number_array_length);

/**
 * Multi-precision DIV for `len*64` bit long a, b.
 *
 * This is NOT constant time.
 *
 * The algorithm might be slow, as my math isn't that good and I couldn't
 * understand faster division algorithms (such as Newton–Raphson division)... so
 * this is sort of a factorized variation on long division.
 */
FIO_IFUNC void fio_math_div(uint64_t *dest,
                            uint64_t *reminder,
                            const uint64_t *a,
                            const uint64_t *b,
                            const size_t number_array_length);

/** Multi-precision shift right for `len` word number `n`. */
FIO_IFUNC void fio_math_shr(uint64_t *dest,
                            uint64_t *n,
                            const size_t right_shift_bits,
                            size_t number_array_length);

/** Multi-precision shift left for `len*64` bit number `n`. */
FIO_IFUNC void fio_math_shl(uint64_t *dest,
                            uint64_t *n,
                            const size_t left_shift_bits,
                            const size_t number_array_length);

/** Multi-precision Inverse for `len*64` bit number `n` (turn `1` into `-1`). */
FIO_IFUNC void fio_math_inv(uint64_t *dest, uint64_t *n, size_t len);

/** Multi-precision - returns the index for the most significant bit or -1. */
FIO_IFUNC size_t fio_math_msb_index(uint64_t *n, const size_t len);

/** Multi-precision - returns the index for the least significant bit or -1. */
FIO_IFUNC size_t fio_math_lsb_index(uint64_t *n, const size_t len);

/* *****************************************************************************
64bit addition (ADD) / subtraction (SUB) / multiplication (MUL) with carry.
***************************************************************************** */

/** Add with carry. */
FIO_IFUNC uint64_t fio_math_addc64(uint64_t a,
                                   uint64_t b,
                                   uint64_t carry_in,
                                   uint64_t *carry_out) {
  FIO_ASSERT_DEBUG(carry_out, "fio_math_addc64 requires a carry pointer");
#if __has_builtin(__builtin_addcll)
  return __builtin_addcll(a, b, carry_in, carry_out);
#elif defined(__SIZEOF_INT128__) && 0
  /* This is actually slower as it occupies more CPU registers */
  __uint128_t u = (__uint128_t)a + b + carry_in;
  *carry_out = (uint64_t)(u >> 64U);
  return (uint64_t)u;
#else
  uint64_t u = a + (b += carry_in);
  *carry_out = (b < carry_in) + (u < a);
  return u;
#endif
}

/** Subtract with carry. */
FIO_IFUNC uint64_t fio_math_subc64(uint64_t a,
                                   uint64_t b,
                                   uint64_t carry_in,
                                   uint64_t *carry_out) {
  FIO_ASSERT_DEBUG(carry_out, "fio_math_subc64 requires a carry pointer");
#if __has_builtin(__builtin_subcll)
  uint64_t u = __builtin_subcll(a, b, carry_in, carry_out);
#elif defined(__SIZEOF_INT128__)
  __uint128_t u = (__uint128_t)a - b - carry_in;
  if (carry_out)
    *carry_out = (uint64_t)(u >> 127U);
#else
  uint64_t u = a - b;
  a = u > a;
  b = u < carry_in;
  u -= carry_in;
  if (carry_out)
    *carry_out = a + b;
#endif
  return (uint64_t)u;
}

/** Multiply with carry out. */
FIO_IFUNC uint64_t fio_math_mulc64(uint64_t a,
                                   uint64_t b,
                                   uint64_t *carry_out) {
#if defined(__SIZEOF_INT128__)
  __uint128_t r = (__uint128_t)a * b;
  *carry_out = (uint64_t)(r >> 64U);
#elif 1 /* At this point long multiplication makes sense... */
  uint64_t r, midc = 0, lowc = 0;
  const uint64_t al = a & 0xFFFFFFFF;
  const uint64_t ah = a >> 32;
  const uint64_t bl = b & 0xFFFFFFFF;
  const uint64_t bh = b >> 32;
  const uint64_t lo = al * bl;
  const uint64_t hi = ah * bh;
  const uint64_t mid = fio_math_addc64(al * bh, ah * bl, 0, &midc);
  r = fio_math_addc64(lo, (mid << 32), 0, &lowc);
  *carry_out = hi + (mid >> 32) + (midc << 32) + lowc;
#elif 1 /* Using Karatsuba Multiplication will degrade performance */
  uint64_t r, c;
  const uint64_t al = a & 0xFFFFFFFF;
  const uint64_t ah = a >> 32;
  const uint64_t bl = b & 0xFFFFFFFF;
  const uint64_t bh = b >> 32;
  const uint64_t asum = al + ah;
  const uint64_t bsum = bl + bh;
  const uint64_t lo = al * bl;
  const uint64_t hi = ah * bh;
  /* asum * bsum might overflow, but we know each value is <= 0x100000000 */
  uint64_t midlo = (asum & 0xFFFFFFFF) * (bsum & 0xFFFFFFFF);
  uint64_t midhi = (asum & bsum) >> 32;
  uint64_t midmid = (bsum & (((uint64_t)0ULL - (asum >> 32)) >> 32)) +
                    (asum & (((uint64_t)0ULL - (bsum >> 32)) >> 32));
  midlo = fio_math_addc64(midlo, (midmid << 32), 0, &c);
  midhi += c + (midmid >> 32);
  midlo = fio_math_subc64(midlo, lo, 0, &c);
  midhi -= c;
  midlo = fio_math_subc64(midlo, hi, 0, &c);
  midhi -= c;
  r = fio_math_addc64(lo, midlo << 32, 0, &c);
  *carry_out = c + hi + (midlo >> 32) + (midhi << 32);
#else   /* never use binary for MUL... so slow... */
  uint64_t r, c = 0;
  r = a & ((uint64_t)0ULL - (b & 1));
  for (uint_fast8_t i = 1; i < 64; ++i) {
    uint64_t mask = ((uint64_t)0ULL - ((b >> i) & 1));
    uint64_t tmp = a & mask;
    uint64_t al = (tmp << i);
    uint64_t ah = (tmp >> (64 - i));
    r = fio_math_addc64(r, al, 0, &tmp);
    c += ah + tmp;
  }
  *carry_out = c;
#endif
  return (uint64_t)r;
}

/* *****************************************************************************
Multi-precision, little endian helpers. Works with full uint64_t arrays.
***************************************************************************** */

/** Multi-precision ADD for `bits` long a + b. Returns the carry. */
FIO_IFUNC uint64_t fio_math_add(uint64_t *dest,
                                const uint64_t *a,
                                const uint64_t *b,
                                const size_t len) {
  uint64_t c = 0;
  for (size_t i = 0; i < len; ++i) {
    dest[i] = fio_math_addc64(a[i], b[i], c, &c);
  }
  return c;
}

/** Multi-precision SUB for `bits` long a + b. Returns the carry. */
FIO_IFUNC uint64_t fio_math_sub(uint64_t *dest,
                                const uint64_t *a,
                                const uint64_t *b,
                                const size_t len) {
  uint64_t c = 0;
  for (size_t i = 0; i < len; ++i) {
    dest[i] = fio_math_subc64(a[i], b[i], c, &c);
  }
  return c;
}

/** Multi-precision Inverse for `bits` number `n`. */
FIO_IFUNC void fio_math_inv(uint64_t *dest, uint64_t *n, const size_t len) {
  uint64_t c = 1;
  for (size_t i = 0; i < len; ++i) {
    uint64_t tmp = ~n[i] + c;
    c = (tmp ^ n[i]) >> 63;
    dest[i] = tmp;
  }
}

/** Multi-precision shift right for `bits` number `n`. */
FIO_IFUNC void fio_math_shr(uint64_t *dest,
                            uint64_t *n,
                            size_t bits,
                            size_t len) {
  const size_t offset = len - (bits >> 6);
  bits &= 63;
  // FIO_LOG_DEBUG("Shift Light of %zu bytes and %zu bits", len - offset, bits);
  uint64_t c = 0, trash;
  uint64_t *p_select[] = {dest + offset, &trash};
  if (bits) {
    while (len--) {
      --p_select[0];
      uint64_t ntmp = n[len];
      uint64_t ctmp = (ntmp << (64 - bits));
      dest[len] &= (uint64_t)0ULL - (len < offset);
      p_select[p_select[0] < dest][0] = ((ntmp >> bits) | c);
      c = ctmp;
    }
    return;
  }
  while (len--) {
    --p_select[0];
    uint64_t ntmp = n[len];
    dest[len] &= (uint64_t)0ULL - (len < offset);
    p_select[p_select[0] < dest][0] = ntmp;
  }
}

/** Multi-precision shift left for `bits` number `n`. */
FIO_IFUNC void fio_math_shl(uint64_t *dest,
                            uint64_t *n,
                            size_t bits,
                            const size_t len) {
  if (!len || !bits || !n || !dest)
    return;
  const size_t offset = bits >> 6;
  bits &= 63;
  uint64_t c = 0, trash;
  uint64_t *p_select[] = {dest + offset, &trash};
  if (bits) {
    for (size_t i = 0; i < len; (++i), ++p_select[0]) {
      uint64_t ntmp = n[i];
      uint64_t ctmp = (ntmp >> (64 - bits)) & ((uint64_t)0ULL - (!!bits));
      ;
      dest[i] &= (uint64_t)0ULL - (i >= offset);
      p_select[p_select[0] >= (dest + len)][0] = ((ntmp << bits) | c);
      c = ctmp;
    }
    return;
  }
  for (size_t i = 0; i < len; (++i), ++p_select[0]) {
    uint64_t ntmp = n[i];
    dest[i] &= (uint64_t)0ULL - (i >= offset);
    p_select[p_select[0] >= (dest + len)][0] = ntmp;
  }
}

/** Multi-precision - returns the index for the most significant bit. */
FIO_IFUNC size_t fio_math_msb_index(uint64_t *n, size_t len) {
  size_t r[2] = {0, (size_t)-1};
  uint64_t a = 0;
  while (len--) {
    const uint64_t mask = ((uint64_t)0ULL - (!a));
    a |= (mask & n[len]);
    r[0] += (64 & (~mask));
  }
  r[0] += fio_bits_msb_index(a);
  return r[!a];
}

/** Multi-precision - returns the index for the least significant bit. */
FIO_IFUNC size_t fio_math_lsb_index(uint64_t *n, const size_t len) {
  size_t r[2] = {0, (size_t)-1};
  uint64_t a = 0;
  uint64_t mask = (~(uint64_t)0ULL);
  for (size_t i = 0; i < len; ++i) {
    a |= mask & n[i];
    mask = ((uint64_t)0ULL - (!a));
    r[0] += (64 & mask);
  }
  r[0] += fio_bits_lsb_index(a);
  return r[!a];
}

/** Multi-precision MUL for `bits` long a + b. `dest` must be `len * 2`. */
FIO_IFUNC void fio_math_mul(uint64_t *restrict dest,
                            const uint64_t *a,
                            const uint64_t *b,
                            const size_t len) {
  if (!len)
    return;
  if (len == 1) { /* route to the correct function */
    dest[0] = fio_math_mulc64(a[0], b[0], dest + 1);
    return;
  } else if (len == 2) { /* long MUL is faster */
    uint64_t tmp[2], c;
    dest[0] = fio_math_mulc64(a[0], b[0], dest + 1);
    tmp[0] = fio_math_mulc64(a[0], b[1], dest + 2);
    dest[1] = fio_math_addc64(dest[1], tmp[0], 0, &c);
    dest[2] += c;

    tmp[0] = fio_math_mulc64(a[1], b[0], tmp + 1);
    dest[1] = fio_math_addc64(dest[1], tmp[0], 0, &c);
    dest[2] = fio_math_addc64(dest[2], tmp[1], c, &c);
    dest[3] = c;
    tmp[0] = fio_math_mulc64(a[1], b[1], tmp + 1);
    dest[2] = fio_math_addc64(dest[2], tmp[0], 0, &c);
    dest[3] += tmp[1] + c;
    return;
  } else if (len == 3) { /* long MUL is still faster */
    uint64_t tmp[2], c;
    dest[0] = fio_math_mulc64(a[0], b[0], dest + 1);
    tmp[0] = fio_math_mulc64(a[0], b[1], dest + 2);
    dest[1] = fio_math_addc64(dest[1], tmp[0], 0, &c);
    dest[2] += c;
    tmp[0] = fio_math_mulc64(a[0], b[2], dest + 3);
    dest[2] = fio_math_addc64(dest[2], tmp[0], 0, &c);
    dest[3] += c;

    tmp[0] = fio_math_mulc64(a[1], b[0], tmp + 1);
    dest[1] = fio_math_addc64(dest[1], tmp[0], 0, &c);
    dest[2] = fio_math_addc64(dest[2], tmp[1], c, &c);
    dest[3] += c;
    tmp[0] = fio_math_mulc64(a[1], b[1], tmp + 1);
    dest[2] = fio_math_addc64(dest[2], tmp[0], 0, &c);
    dest[3] = fio_math_addc64(dest[3], tmp[1], c, &c);
    dest[4] = c;
    tmp[0] = fio_math_mulc64(a[1], b[2], tmp + 1);
    dest[3] = fio_math_addc64(dest[3], tmp[0], 0, &c);
    dest[4] = fio_math_addc64(dest[4], tmp[1], c, &c);
    dest[5] = c;

    tmp[0] = fio_math_mulc64(a[2], b[0], tmp + 1);
    dest[2] = fio_math_addc64(dest[2], tmp[0], 0, &c);
    dest[3] = fio_math_addc64(dest[3], tmp[1], c, &c);
    dest[4] = fio_math_addc64(dest[4], c, 0, &c);
    dest[5] += c;
    tmp[0] = fio_math_mulc64(a[2], b[1], tmp + 1);
    dest[3] = fio_math_addc64(dest[3], tmp[0], 0, &c);
    dest[4] = fio_math_addc64(dest[4], tmp[1], c, &c);
    dest[5] += c;
    tmp[0] = fio_math_mulc64(a[2], b[2], tmp + 1);
    dest[4] = fio_math_addc64(dest[4], tmp[0], 0, &c);
    dest[5] += tmp[1] + c;
  } else { /* long MUL is just too long to write */
    uint64_t c = 0;
#if !defined(_MSC_VER) && (!defined(__cplusplus) || __cplusplus > 201402L)
    uint64_t abwmul[len * 2];
#else
    uint64_t abwmul[512];
    FIO_ASSERT(
        len <= 256,
        "Multi Precision MUL (fio_math_mul) overflows at 16384 bit numbers");
#endif
    for (size_t i = 0; i < len; ++i) { // clang-format off
     dest[(i << 1)]     = abwmul[(i << 1)]     = fio_math_mulc64(a[i], b[i], &c);
     dest[(i << 1) + 1] = abwmul[(i << 1) + 1] = c;
    } // clang-format on
    c = 0;
    for (size_t i = 0; i < len - 1; ++i) {
      dest[(i + 1) << 1] += c;
      for (size_t j = i + 1; j < len; ++j) {
        /* calculate the "middle" word sum */
        uint64_t mid0, mid1, mid2, ac, bc;
        uint64_t asum = fio_math_addc64(a[i], a[j], 0, &ac);
        uint64_t bsum = fio_math_addc64(b[i], b[j], 0, &bc);
        mid0 = fio_math_mulc64(asum, bsum, &mid1);
        mid2 = ac & bc;
        mid1 = fio_math_addc64(mid1, (asum & ((uint64_t)0ULL - bc)), 0, &c);
        mid2 += c;
        mid1 = fio_math_addc64(mid1, (bsum & ((uint64_t)0ULL - ac)), 0, &c);
        mid2 += c;
        mid0 = fio_math_subc64(mid0, abwmul[(i << 1)], 0, &c);
        mid1 = fio_math_subc64(mid1, abwmul[(i << 1) + 1], c, &c);
        mid2 -= c;
        mid0 = fio_math_subc64(mid0, abwmul[(j << 1)], 0, &c);
        mid1 = fio_math_subc64(mid1, abwmul[(j << 1) + 1], c, &c);
        mid2 -= c;
        dest[i + j] = fio_math_addc64(dest[i + j], mid0, 0, &c);
        dest[i + j + 1] = fio_math_addc64(dest[i + j + 1], mid1, c, &c);
        c += mid2;
      }
    }
  }
}

/** Multi-precision DIV for `len*64` bit long a, b. NOT constant time. */
FIO_IFUNC void fio_math_div(uint64_t *dest,
                            uint64_t *reminder,
                            const uint64_t *a,
                            const uint64_t *b,
                            const size_t len) {
  if (!len)
    return;
#if !defined(_MSC_VER) && (!defined(__cplusplus) || __cplusplus > 201402L)
  uint64_t t[len];
  uint64_t r[len];
  uint64_t q[len];
#else
  uint64_t t[256];
  uint64_t r[256];
  uint64_t q[256];
  FIO_ASSERT(
      len <= 256,
      "Multi Precision DIV (fio_math_div) overflows at 16384 bit numbers");
#endif
  FIO_MEMCPY(r, a, sizeof(uint64_t) * len);
  FIO_MEMSET(q, 0, sizeof(uint64_t) * len);
  size_t rlen;
  uint64_t c, mask, imask;
  const size_t blen = fio_math_msb_index((uint64_t *)b, len) + 1;
  if (!blen)
    goto divide_by_zero; /* divide by zero! */
  while ((rlen = fio_math_msb_index((uint64_t *)r, len)) >= blen) {
    const size_t delta = rlen - blen;
    fio_math_shl(t, (uint64_t *)b, delta, len);
    fio_math_sub(r, (uint64_t *)r, t, len);
    q[delta >> 6] |= (1ULL << (delta & 63)); /* set the bit used */
  }
  fio_math_sub(t, (uint64_t *)r, (uint64_t *)b, len);
  mask = (uint64_t)0ULL -
         ((t[len - 1] ^ (b[len - 1] ^ a[len - 1])) >> 63); /* SUB overflowed */
  imask = ~mask;                                           /* r was >= b */
  q[0] = fio_math_addc64(q[0], (imask & 1), 0, &c);
  for (size_t i = 1; i < len; ++i) {
    q[i] = fio_math_addc64(q[i], 0, c, &c);
  }
  if (dest) {
    FIO_MEMCPY(dest, q, len * sizeof(uint64_t));
  }
  if (reminder) {
    for (size_t i = 0; i < len; ++i) {
      reminder[i] = (t[i] & imask) | (r[i] & mask);
    }
  }
  return;
divide_by_zero:
  FIO_LOG_ERROR("divide by zero!");
  if (dest)
    FIO_MEMSET(dest, 0xFFFFFFFF, sizeof(*dest) * len);
  if (reminder)
    FIO_MEMSET(reminder, 0xFFFFFFFF, sizeof(*dest) * len);
  return;
}

/* *****************************************************************************
Common Math operations - test
***************************************************************************** */
#if defined(FIO_TEST_CSTL)

FIO_SFUNC void FIO_NAME_TEST(stl, math)(void) {
  fprintf(stderr, "* Testing multi-precision math operations (partial).\n");

  { /* Test add/sub carry */
    uint64_t a, c;
    a = fio_math_addc64(1ULL, 1ULL, 1ULL, &c);
    FIO_ASSERT(a == 3 && c == 0,
               "fio_math_addc64(1ULL, 1ULL, 1ULL, &c) failed");
    a = fio_math_addc64(~(uint64_t)0ULL, 1ULL, 0ULL, &c);
    FIO_ASSERT(!a && c == 1,
               "fio_math_addc64(~(uint64_t)0ULL, 1ULL, 0ULL, &c) failed");
    c = 0;
    a = fio_math_addc64(~(uint64_t)0ULL, 1ULL, 1ULL, &c);
    FIO_ASSERT(a == 1 && c == 1,
               "fio_math_addc64(~(uint64_t)0ULL, 1ULL, 1ULL, &c) failed");
    c = 0;
    a = fio_math_addc64(~(uint64_t)0ULL, 0ULL, 1ULL, &c);
    FIO_ASSERT(!a && c == 1,
               "fio_math_addc64(~(uint64_t)0ULL, 0ULL, 1ULL, &c) failed");
    a = fio_math_subc64(3ULL, 1ULL, 1ULL, &c);
    FIO_ASSERT(a == 1 && c == 0, "fio_math_subc64 failed");
    a = fio_math_subc64(~(uint64_t)0ULL, 1ULL, 0ULL, &c);
    FIO_ASSERT(c == 0,
               "fio_math_subc64(~(uint64_t)0ULL, 1ULL, 0ULL, &c) failed");
    a = fio_math_subc64(0ULL, ~(uint64_t)0ULL, 1ULL, &c);
    FIO_ASSERT(!a && c == 1,
               "fio_math_subc64(0ULL, ~(uint64_t)0ULL, 1ULL, &c) failed "
               "(%llu, %llu)",
               a,
               c);
    a = fio_math_subc64(0ULL, 1ULL, 0ULL, &c);
    FIO_ASSERT(a == ~(uint64_t)0ULL && c == 1,
               "fio_math_subc64(0ULL, 1ULL, 0ULL, &c) failed");
  }

  for (size_t k = 0; k < 16; ++k) { /* Test multiplication */
    for (size_t j = 0; j < 16; ++j) {
      uint64_t a = (j << (k << 1)), b = (j << k);
      {
        for (int i = 0; i < 16; ++i) {
          uint64_t r0, r1, c0, c1;
          // FIO_LOG_DEBUG("Test MUL a = %p; b = %p", (void *)a, (void *)b);
          r0 = fio_math_mulc64(a, b, &c0); /* implementation for the system. */
          // FIO_LOG_DEBUG("Sys  Mul      MUL = %p, carry = %p",
          //               (void *)r0,
          //               (void *)c0);

          { /* long multiplication (school algorithm). */
            uint64_t midc = 0, lowc = 0;
            const uint64_t al = a & 0xFFFFFFFF;
            const uint64_t ah = a >> 32;
            const uint64_t bl = b & 0xFFFFFFFF;
            const uint64_t bh = b >> 32;
            const uint64_t lo = al * bl;
            const uint64_t hi = ah * bh;
            const uint64_t mid = fio_math_addc64(al * bh, ah * bl, 0, &midc);
            const uint64_t r = fio_math_addc64(lo, (mid << 32), 0, &lowc);
            const uint64_t c = hi + (mid >> 32) + (midc << 32) + lowc;
            // FIO_LOG_DEBUG("Long Mul      MUL = %p, carry = %p",
            //               (void *)r,
            //               (void *)c);
            r1 = r;
            c1 = c;
          }
          FIO_ASSERT((r0 == r1) && (c0 == c1), "fail");
          {
            uint64_t r2[2];
            fio_math_mul(r2, &a, &b, 1);
            // FIO_LOG_DEBUG("multi Mul     MUL = %p, carry = %p",
            //               (void *)r2[0],
            //               (void *)r2[1]);
            FIO_ASSERT((r0 == r2[0]) && (c0 == r2[1]),
                       "fail Xlen MUL with len == 1");
          }
          {
            uint64_t a2[4] = {a, 0, 0, a};
            uint64_t b2[4] = {b, 0, 0, 0};
            uint64_t r2[8];
            fio_math_mul(r2, a2, b2, 4);
            // FIO_LOG_DEBUG("multi4 Mul    MUL = %p, carry = %p",
            //               (void *)r2[3],
            //               (void *)r2[4]);
            FIO_ASSERT((r0 == r2[0]) && (c0 == r2[1]),
                       "fail Xlen MUL (1) with len == 4");
            FIO_ASSERT((r0 == r2[3]) && (c0 == r2[4]),
                       "fail Xlen MUL (2) with len == 4");
          }

          a <<= 8;
          b <<= 8;
          a += 0xFAFA;
          b += 0xAFAF;
        }
      }
    }
  }
  { /* Test division */
    uint64_t n = 0, d = 1;
    for (size_t i = 0; i < 64; ++i) {
      n = (n << 7) ^ 0xAA;
      for (size_t j = 0; j < 64; ++j) {
        d = (d << 3) ^ 0xAA;
        uint64_t q, r;
        FIO_COMPILER_GUARD;
        fio_math_div(&q, &r, &n, &d, 1);
        FIO_COMPILER_GUARD;
        FIO_ASSERT(q == (n / d),
                   "fio_math_div failed quotient for 0x%llX / 0x%llX (Q=0x%llX "
                   "R=0x%llX)",
                   (long long)n,
                   (long long)d,
                   (long long)q,
                   (long long)r);
        FIO_ASSERT(
            (q * d) + r == n,
            "fio_math_div failed remainder for 0x%llX / 0x%llX (Q=0x%llX "
            "R=0x%llX)",
            (long long)n,
            (long long)d,
            (long long)q,
            (long long)r);
      }
    }
  }
  { /* Test bit shifting */
    uint64_t a[] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0};
    uint64_t b[] = {0xFFFFFFFFFFFFFFFE, 0xFFFFFFFFFFFFFFFF, 1};
    uint64_t c[3];
    fio_math_shl(c, a, 1, 3);
    FIO_ASSERT(!memcmp(b, c, sizeof(c)),
               "left shift failed, %llX:%llX:%llX",
               c[0],
               c[1],
               c[2]);
    fio_math_shr(c, c, 1, 3);
    FIO_ASSERT(!memcmp(a, c, sizeof(c)),
               "right shift failed, %llX:%llX:%llX",
               c[0],
               c[1],
               c[2]);
    fio_math_shl(c, a, 128, 3);
    FIO_ASSERT(!c[0] && !c[1] && !(~c[2]),
               "left shift failed, %llX:%llX:%llX",
               c[0],
               c[1],
               c[2]);
    FIO_ASSERT(fio_math_msb_index(a, 3) == 127,
               "fio_math_msb_index(a) failed %zu",
               fio_math_msb_index(a, 3));
    FIO_ASSERT(fio_math_lsb_index(a, 3) == 0,
               "fio_math_lsb_index(a) failed %zu",
               fio_math_lsb_index(a, 3));
    FIO_ASSERT(fio_math_msb_index(b, 3) == 128,
               "fio_math_msb_index(b) failed %zu",
               fio_math_msb_index(b, 3));
    FIO_ASSERT(fio_math_lsb_index(b, 3) == 1,
               "fio_math_lsb_index(b) failed %zu",
               fio_math_lsb_index(b, 3));
  }
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Math - cleanup
***************************************************************************** */
#endif /* FIO_MATH */
#undef FIO_MATH
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_ATOL       /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                            String <=> Number helpers



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_ATOL) && !defined(H___FIO_ATOL_H)
#define H___FIO_ATOL_H
#include <inttypes.h>
#include <math.h>

/* *****************************************************************************
Strings to Signed Numbers - API
***************************************************************************** */
/**
 * A helper function that converts between String data to a signed int64_t.
 *
 * Numbers are assumed to be in base 10. Octal (`0###`), Hex (`0x##`/`x##`) and
 * binary (`0b##`/ `b##`) are recognized as well. For binary Most Significant
 * Bit must come first.
 *
 * The most significant difference between this function and `strtol` (aside of
 * API design), is the added support for binary representations.
 */
SFUNC int64_t fio_atol(char **pstr);

/** A helper function that converts between String data to a signed double. */
SFUNC double fio_atof(char **pstr);

/* *****************************************************************************
Signed Numbers to Strings - API
***************************************************************************** */

/**
 * A helper function that writes a signed int64_t to a string.
 *
 * No overflow guard is provided, make sure there's at least 68 bytes available
 * (for base 2).
 *
 * Offers special support for base 2 (binary), base 8 (octal), base 10 and base
 * 16 (hex) where prefixes are automatically added if required (i.e.,`"0x"` for
 * hex and `"0b"` for base 2, and `"0"` for octal).
 *
 * Supports any base up to base 36 (using 0-9,A-Z).
 *
 * An unsupported base will log an error and print zero.
 *
 * Returns the number of bytes actually written (excluding the NUL terminator).
 */
SFUNC size_t fio_ltoa(char *dest, int64_t num, uint8_t base);

/**
 * A helper function that converts between a double to a string.
 *
 * No overflow guard is provided, make sure there's at least 130 bytes
 * available (for base 2).
 *
 * Supports base 2, base 10 and base 16. An unsupported base will silently
 * default to base 10. Prefixes aren't added (i.e., no "0x" or "0b" at the
 * beginning of the string).
 *
 * Returns the number of bytes actually written (excluding the NUL
 * terminator).
 */
SFUNC size_t fio_ftoa(char *dest, double num, uint8_t base);

/* *****************************************************************************
Unsigned Numbers, Building Blocks and Helpers
***************************************************************************** */
/**
 * Maps characters to alphanumerical value, where numbers have their natural
 * values (0-9) and `A-Z` (or `a-z`) are the values 10-35.
 *
 * Out of bound values return 255.
 *
 * This allows parsing of numeral strings for up to base 36.
 */
IFUNC uint8_t fio_c2i(unsigned char c);

/**
 * Maps numeral values to alphanumerical characters, where numbers have their
 * natural values (0-9) and `A-Z` are the values 10-35.
 *
 * Accepts values up to 63. Returns zero for values over 35. Out of bound values
 * produce undefined behavior.
 *
 * This allows printing of numerals for up to base 36.
 */
IFUNC uint8_t fio_i2c(unsigned char i);

/** Returns the number of digits in base 10. */
FIO_IFUNC size_t fio_digits10(int64_t i);
/** Returns the number of digits in base 10 for an unsigned number. */
FIO_SFUNC size_t fio_digits10u(uint64_t i);

/** Returns the number of digits in base 8 for an unsigned number. */
FIO_SFUNC size_t fio_digits8u(uint64_t i);
/** Returns the number of digits in base 16 for an unsigned number. */
FIO_SFUNC size_t fio_digits16u(uint64_t i);
/** Returns the number of digits in base 2 for an unsigned number. */
FIO_SFUNC size_t fio_digits_bin(uint64_t i);
/** Returns the number of digits in any base X<65 for an unsigned number. */
FIO_SFUNC size_t fio_digits_xbase(uint64_t i, size_t base);

/** Writes a signed number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa10(char *dest, int64_t i, size_t digits);
/** Reads a signed base 10 formatted number. */
SFUNC int64_t fio_atol10(char **pstr);

/** Writes unsigned number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa10u(char *dest, uint64_t i, size_t digits);
/** Writes unsigned number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa16u(char *dest, uint64_t i, size_t digits);
/** Writes unsigned number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa_bin(char *dest, uint64_t i, size_t digits);
/** Writes unsigned number to `dest` using `digits` bytes (+ `NUL`) */
FIO_IFUNC void fio_ltoa_xbase(char *dest,
                              uint64_t i,
                              size_t digits,
                              size_t base);

/** Reads a signed base 8 formatted number. */
SFUNC uint64_t fio_atol8u(char **pstr);
/** Reads a signed base 10 formatted number. */
SFUNC uint64_t fio_atol10u(char **pstr);
/** Reads an unsigned hex formatted number (possibly prefixed with "0x"). */
SFUNC uint64_t fio_atol16u(char **pstr);
/** Reads an unsigned binary formatted number (possibly prefixed with "0b"). */
SFUNC uint64_t fio_atol_bin(char **pstr);
/** Read an unsigned number in any base up to base 36. */
SFUNC uint64_t fio_atol_xbase(char **pstr, size_t base);

/** Converts an unsigned `val` to a signed `val`, with overflow protection. */
FIO_IFUNC int64_t fio_u2i_limit(uint64_t val, size_t invert);

/* *****************************************************************************


Implementation - inlined


***************************************************************************** */

/** Returns the number of digits in base 10. */
FIO_IFUNC size_t fio_digits10(int64_t i) {
  if (i >= 0)
    return fio_digits10u(i);
  return fio_digits10u((0ULL - (uint64_t)i)) + 1;
}

/** Returns the number of digits in base 2 for an unsigned number. */
FIO_SFUNC size_t fio_digits_bin(uint64_t i) {
  size_t r = 1;
  if (!i)
    return r;
  r = fio___msb_index_unsafe(i) + 1;
  r += (r & 1); /* binary is written 2 zeros at a time */
  return r;
}

/** Returns the number of digits in base 8 for an unsigned number. */
FIO_SFUNC size_t fio_digits8u(uint64_t i) {
  size_t r = 1;
  for (;;) {
    if (i < 8)
      return r;
    if (i < 64)
      return r + 1;
    if (i < 512)
      return r + 2;
    if (i < 4096)
      return r + 3;
    if (i < 32768)
      return r + 4;
    if (i < 262144)
      return r + 5;
    if (i < 2097152)
      return r + 6;
    if (i < 16777216)
      return r + 7;
    r += 8;
    i >>= 24;
  }
}

/** Returns the number of digits in base 10 for an unsigned number. */
FIO_SFUNC size_t fio_digits10u(uint64_t i) {
  size_t r = 1;
  for (;;) {
    if (i < 10ULL)
      return r;
    if (i < 100ULL)
      return r + 1;
    if (i < 1000ULL)
      return r + 2;
    if (i < 10000ULL)
      return r + 3;
    r += 4;
    i /= 10000ULL;
  }
}

/** Returns the number of digits in base 16 for an unsigned number. */
FIO_SFUNC size_t fio_digits16u(uint64_t i) {
  if (i < 0x100ULL)
    return 2;
  if (i < 0x10000ULL)
    return 4;
  if (i < 0x1000000ULL)
    return 6;
  if (i < 0x100000000ULL)
    return 8;
  if (i < 0x10000000000ULL)
    return 10;
  if (i < 0x1000000000000ULL)
    return 12;
  if (i < 0x100000000000000ULL)
    return 14;
  return 16;
}

/** Returns the number of digits in base X<65 for an unsigned number. */
FIO_SFUNC size_t fio_digits_xbase(uint64_t i, size_t base) {
  size_t base2 = base * base;
  size_t base3 = base2 * base;
  size_t base4 = base3 * base;
  size_t base5 = base4 * base;
  size_t r = 1;
  for (;;) {
    if (i < base)
      return r;
    if (i < base2)
      return r + 1;
    if (i < base3)
      return r + 2;
    if (i < base4)
      return r + 3;
    r += 4;
    i /= base5;
  }
}

FIO_IFUNC void fio_ltoa10(char *dest, int64_t i, size_t digits) {
  size_t inv = i < 0;
  dest[0] = '-';
  dest += inv;
  if (inv)
    i = (int64_t)((uint64_t)0 - (uint64_t)i);
  fio_ltoa10u(dest, (uint64_t)i, digits - inv);
}

FIO_IFUNC void fio_ltoa8u(char *dest, uint64_t i, size_t digits) {
  dest += digits;
  *dest-- = 0;
  while (i > 7) {
    *dest-- = '0' + (i & 7);
    i >>= 3;
  }
  *dest = '0' + i;
}

FIO_IFUNC void fio_ltoa10u(char *dest, uint64_t i, size_t digits) {
  dest += digits;
  *dest-- = 0;
  while (i > 9) {
    uint64_t nxt = i / 10;
    *dest-- = '0' + (i - (nxt * 10ULL));
    i = nxt;
  }
  *dest = '0' + (unsigned char)i;
}

FIO_IFUNC void fio_ltoa16u(char *dest, uint64_t i, size_t digits) {
  dest += digits;
  *dest-- = 0;
  while (i > 255) {
    *dest-- = fio_i2c(i & 15);
    i >>= 4;
    *dest-- = fio_i2c(i & 15);
    i >>= 4;
  }
  *dest-- = fio_i2c(i & 15);
  i >>= 4;
  *dest = fio_i2c(i);
}

FIO_IFUNC void fio_ltoa_bin(char *dest, uint64_t i, size_t digits) {
  dest += digits;
  *dest-- = 0;
  switch (digits & 7) { /* last use of `digits` */
    while (i) {
      *dest-- = '0' + (i & 1);
      i >>= 1;                                /* fall through */
    case 7: *dest-- = '0' + (i & 1); i >>= 1; /* fall through */
    case 6: *dest-- = '0' + (i & 1); i >>= 1; /* fall through */
    case 5: *dest-- = '0' + (i & 1); i >>= 1; /* fall through */
    case 4: *dest-- = '0' + (i & 1); i >>= 1; /* fall through */
    case 3: *dest-- = '0' + (i & 1); i >>= 1; /* fall through */
    case 2: *dest-- = '0' + (i & 1); i >>= 1; /* fall through */
    case 1: *dest-- = '0' + (i & 1); i >>= 1; /* fall through */
    case 0:;
    }
  }
}

FIO_IFUNC void fio_ltoa_xbase(char *dest,
                              uint64_t i,
                              size_t digits,
                              size_t base) {
  dest += digits;
  *dest-- = 0;
  while (i >= base) {
    uint64_t nxt = i / base;
    *dest-- = fio_i2c(i - (nxt * 10ULL));
    i = nxt;
  }
  *dest = fio_i2c(i);
}

/** Converts an unsigned `val` to a signed `val`, with overflow protection. */
FIO_IFUNC int64_t fio_u2i_limit(uint64_t val, size_t to_negative) {
  if (!to_negative) {
    /* overflow? */
    if (!(val & 0x8000000000000000ULL))
      return val;
    errno = E2BIG;
    val = 0x7FFFFFFFFFFFFFFFULL;
    return val;
  }
  if (!(val & 0x8000000000000000ULL)) {
    val = (int64_t)0LL - (int64_t)val;
    return val;
  }
  /* read overflow */
  errno = E2BIG;
  return (int64_t)(val = 0x8000000000000000ULL);
}

/* *****************************************************************************
Implementation - possibly externed
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

typedef struct {
  uint64_t val;
  int64_t expo;
  uint8_t sign;
} fio___number_s;

/* *****************************************************************************
Unsigned core and helpers
***************************************************************************** */

/**
 * Maps characters to alphanumerical value, where numbers have their natural
 * values (0-9) and `A-Z` (or `a-z`) are the values 10-35.
 *
 * Out of bound values return 255.
 *
 * This allows parsing of numeral strings for up to base 36.
 */
IFUNC uint8_t fio_c2i(unsigned char c) {
  static const uint8_t fio___alphanumeric_map[256] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   255, 255,
      255, 255, 255, 255, 255, 10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
      20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,  33,  34,
      35,  255, 255, 255, 255, 255, 255, 10,  11,  12,  13,  14,  15,  16,  17,
      18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,  32,
      33,  34,  35,  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255};
  return fio___alphanumeric_map[c];
}

/**
 * Maps numeral values to alphanumerical characters, where numbers have their
 * natural values (0-9) and `A-Z` are the values 10-35.
 *
 * Accepts values up to 63. Returns zero for values over 35. Out of bound values
 * produce undefined behavior.
 *
 * This allows printing of numerals for up to base 36.
 */
IFUNC uint8_t fio_i2c(unsigned char i) {
  static const uint8_t fio___alphanumeric_map[64] = {
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B',
      'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
      'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
  return fio___alphanumeric_map[i & 63];
}

/** Reads a signed base 10 formatted number. */
SFUNC int64_t fio_atol10(char **pstr) {
  const uint64_t add_limit = (~(uint64_t)0ULL) - 9;
  char *pos = *pstr;
  const size_t inv = (pos[0] == '-');
  pos += inv;
  uint64_t val = 0;
  uint64_t r0;
  while (((r0 = pos[0] - '0') < 10ULL) & (val < add_limit)) {
    val *= 10;
    val += r0;
    ++pos;
  }
  if (((size_t)(pos[0] - '0') < 10ULL)) {
    errno = E2BIG;
  }
  *pstr = pos;
  return fio_u2i_limit(val, inv);
}

/** Reads a signed base 8 formatted number. */
SFUNC uint64_t fio_atol8u(char **pstr) {
  uint64_t r = 0;
  size_t d;
  while ((d = (size_t)fio_c2i((unsigned char)(**pstr))) < 8) {
    r <<= 3;
    r |= d;
    ++*pstr;
    if ((r & UINT64_C(0xE000000000000000)))
      break;
  }
  if ((fio_c2i(**pstr)) < 8)
    errno = E2BIG;
  return r;
}

/** Reads an unsigned base 10 formatted number. */
SFUNC uint64_t fio_atol10u(char **pstr) {
  uint64_t r = 0;
  const uint64_t add_limit = (~(uint64_t)0ULL) - 9;
  char *pos = *pstr;
  uint64_t r0;
  while (((r0 = (uint64_t)(pos[0] - '0')) < 10ULL) & (r < add_limit)) {
    r *= 10;
    r += r0;
    ++pos;
  }
  while (((size_t)(pos[0] - '0') < 10ULL)) {
    errno = E2BIG;
    ++pos;
  }
  *pstr = pos;
  return r;
}

/** Reads an unsigned hex formatted number (possibly prefixed with "0x"). */
SFUNC uint64_t fio_atol16u(char **pstr) {
  uint64_t r = 0;
  size_t d;
  unsigned char *p = (unsigned char *)*pstr;
  p += ((p[0] == '0') & ((p[1] | 32) == 'x')) << 1;
  if ((d = fio_c2i(*p)) > 15)
    goto possible_misread;
  for (;;) {
    r |= d;
    ++p;
    d = (size_t)fio_c2i(*p);
    if (d > 15)
      break;
    if ((r & UINT64_C(0xF000000000000000))) {
      errno = E2BIG;
      break;
    }
    r <<= 4;
  }
  *pstr = (char *)p;
  return r;
possible_misread:
  /* if 0x was read, move to X. */
  *pstr += ((pstr[0][0] == '0') & ((pstr[0][1] | 32) == 'x'));
  return r;
}

/** Reads an unsigned binary formatted number (possibly prefixed with "0b"). */
SFUNC uint64_t fio_atol_bin(char **pstr) {
  uint64_t r = 0;
  size_t d;
  *pstr += (**pstr == '0');
  *pstr += (**pstr | 32) == 'b' && ((size_t)(pstr[0][1]) - (size_t)'0') < 2;
  while ((d = (size_t)((unsigned char)(**pstr)) - (size_t)'0') < 2) {
    r <<= 1;
    r |= d;
    ++*pstr;
    if ((r & UINT64_C(0x8000000000000000)))
      break;
  }
  if ((d = (size_t)(**pstr) - (size_t)'0') < 2)
    errno = E2BIG;
  return r;
}

/** Attempts to read an unsigned number in any base up to base 36. */
SFUNC uint64_t fio_atol_xbase(char **pstr, size_t base) {
  uint64_t r = 0;
  if (base > 36)
    return r;
  if (base == 10)
    return (r = fio_atol10u(pstr));
  if (base == 16)
    return (r = fio_atol16u(pstr));
  if (base == 2)
    return (r = fio_atol_bin(pstr));
  const uint64_t limit = (~UINT64_C(0)) / base;
  size_t d;
  while ((d = (size_t)fio_c2i((unsigned char)(**pstr))) < base) {
    r *= base;
    r += d;
    ++*pstr;
    if (r > limit)
      break;
  }
  if ((fio_c2i(**pstr)) < base)
    errno = E2BIG;
  return r;
}

/* *****************************************************************************
fio_atol
***************************************************************************** */

SFUNC int64_t fio_atol(char **pstr) {
  if (!pstr || !(*pstr))
    return 0;
  uint64_t v = 0;
  uint64_t (*fn)(char **) = fio_atol10u;
  char *p = *pstr;
  unsigned inv = (p[0] == '-');
  p += inv;
  char *const s = p;
  switch (*p) {
  case 'x': /* fall through */
  case 'X': fn = fio_atol16u; goto compute;
  case 'b': /* fall through */
  case 'B': fn = fio_atol_bin; goto compute;
  case '0':
    switch (p[1]) {
    case 'x': /* fall through */
    case 'X': fn = fio_atol16u; goto compute;
    case 'b': /* fall through */
    case 'B': fn = fio_atol_bin; goto compute;
    case '0': /* fall through */
    case '1': /* fall through */
    case '2': /* fall through */
    case '3': /* fall through */
    case '4': /* fall through */
    case '5': /* fall through */
    case '6': /* fall through */
    case '7': fn = fio_atol8u;
    }
  }
compute:
  v = fn(&p);
  if (p != s)
    *pstr = p;
  if (fn == fio_atol10u)
    return fio_u2i_limit(v, inv);
  if (!inv) /* sign embedded in the representation */
    return (int64_t)v;
  return fio_u2i_limit(v, inv);
}

/* *****************************************************************************
fio_ltoa
***************************************************************************** */

SFUNC size_t fio_ltoa(char *dest, int64_t num, uint8_t base) {
  size_t len = 0;
  uint64_t n = (uint64_t)num;
  size_t digits;
  char dump[96];
  if (!dest)
    dest = dump;

  switch (base) {
  case 1: /* fall through */
  case 2: /* Base 2 */
    len += (digits = fio_digits_bin(n));
    fio_ltoa_bin(dest, n, digits); /* embedded sign bit */
    return len;
  case 8: /* Base 8 */
    if (num < 0) {
      *(dest++) = '-';
      n = 0 - n;
      ++len;
    }
    len += (digits = fio_digits8u(n));
    fio_ltoa8u(dest, n, digits);
    return len;
  case 16: /* Base 16 */
    len += (digits = fio_digits16u(n));
    fio_ltoa16u(dest, n, digits); /* embedded sign bit */
    return len;
  case 0:  /* fall through */
  case 10: /* Base 10 */
    if (num < 0) {
      *(dest++) = '-';
      n = 0 - n;
      ++len;
    }
    len += (digits = fio_digits10u(n));
    fio_ltoa10u(dest, n, digits);
    return len;
  default: /* any base up to base 36 */
    if (base > 36)
      goto base_error;
    if (num < 0) {
      *(dest++) = '-';
      n = 0 - n;
      ++len;
    }
    len += (digits = fio_digits_xbase(n, base));
    fio_ltoa_xbase(dest, n, digits, base);
    return len;
  }

base_error:
  FIO_LOG_ERROR("fio_ltoa base out of range");
  return len;
}

/* *****************************************************************************
fio_atof
***************************************************************************** */

SFUNC double fio_atof(char **pstr) {
  if (!pstr || !(*pstr))
    return 0;
  if ((*pstr)[1] == 'b' || ((*pstr)[1] == '0' && (*pstr)[1] == 'b'))
    goto binary_raw;
  return strtod(*pstr, pstr);
binary_raw:
  /* binary representation is assumed to spell an exact double */
  (void)0;
  union {
    uint64_t i;
    double d;
  } punned = {.i = (uint64_t)fio_atol(pstr)};
  return punned.d;
}

/* *****************************************************************************
fio_ftoa
***************************************************************************** */

SFUNC size_t fio_ftoa(char *dest, double num, uint8_t base) {
  if (base == 2 || base == 16) {
    /* handle binary / Hex representation the same as an int64_t */
    /* FIXME: Hex representation should use floating-point hex instead */
    union {
      int64_t i;
      double d;
    } p;
    p.d = num;
    return fio_ltoa(dest, p.i, base);
  }
  size_t written = 0;

  if (isinf(num))
    goto is_inifinity;
  if (isnan(num))
    goto is_nan;

  written = snprintf(dest, 30, "%g", num);
  /* test if we need to add a ".0" to the end of the string */
  for (char *start = dest;;) {
    switch (*start) {
    case ',':
      *start = '.'; // locale issues?
    /* fall through */
    case 'e': /* fall through */
    case '.': /* fall through */ goto finish;
    case 0: goto add_dot_zero;
    }
    ++start;
  }
add_dot_zero:
  dest[written++] = '.';
  dest[written++] = '0';

finish:
  dest[written] = 0;
  return written;

is_inifinity:
  if (num < 0)
    dest[written++] = '-';
  fio_memcpy8(dest + written, "Infinity");
  written += 8;
  dest[written] = 0;
  return written;
is_nan:
  fio_memcpy4(dest, "NaN");
  return 3;
}

/* *****************************************************************************
Numbers <=> Strings - Testing
***************************************************************************** */

#ifdef FIO_TEST_CSTL

#define FIO_ATOL_TEST_MAX 1048576

FIO_IFUNC int64_t FIO_NAME_TEST(stl, atol_time)(void) {
  struct timespec t;
  clock_gettime(CLOCK_MONOTONIC, &t);
  return ((int64_t)t.tv_sec * 1000000) + (int64_t)t.tv_nsec / 1000;
}

SFUNC size_t sprintf_wrapper(char *dest, int64_t num, uint8_t base) {
  switch (base) {
  case 2: /* overflow - unsupported */
  case 8: /* overflow - unsupported */
  case 10: return snprintf(dest, 256, "%" PRId64, num);
  case 16:
    if (num >= 0)
      return snprintf(dest, 256, "0x%.16" PRIx64, num);
    return snprintf(dest, 256, "-0x%.8" PRIx64, (0 - num));
  }
  return snprintf(dest, 256, "%" PRId64, num);
}

SFUNC int64_t strtoll_wrapper(char **pstr) { return strtoll(*pstr, pstr, 0); }

FIO_SFUNC void FIO_NAME_TEST(stl, atol_speed)(const char *name,
                                              int64_t (*a2l)(char **),
                                              size_t (*l2a)(char *,
                                                            int64_t,
                                                            uint8_t)) {
  int64_t start;
  int64_t tw = 0;
  int64_t trt = 0;
  char buf[1024];
  struct {
    const char *str;
    const char *prefix;
    uint8_t prefix_len;
    uint8_t base;
  } * pb, b[] = {
              {.str = "Base 10", .base = 10},
              {.str = "Hex    ", .prefix = "0x", .prefix_len = 2, .base = 16},
              {.str = "Binary ", .prefix = "0b", .prefix_len = 2, .base = 2},
              // {.str = "Oct    ", .prefix = "0", .prefix_len = 1, .base = 8},
              /* end marker */
              {.str = NULL},
          };
  fprintf(stderr, "    * %s test performance:\n", name);
  if (l2a == sprintf_wrapper)
    b[2].str = NULL;
  for (pb = b; pb->str; ++pb) {
    start = FIO_NAME_TEST(stl, atol_time)();
    for (int64_t i = -FIO_ATOL_TEST_MAX; i < FIO_ATOL_TEST_MAX; ++i) {
      char *bf = buf + pb->prefix_len;
      size_t len = l2a(bf, i, pb->base);
      bf[len] = 0;
      if (bf[0] == '-') {
        for (int pre_test = 0; pre_test < pb->prefix_len; ++pre_test) {
          if (bf[pre_test + 1] == pb->prefix[pre_test])
            continue;
          FIO_MEMCPY(buf, pb->prefix, pb->prefix_len);
          bf = buf;
          break;
        }
      } else {
        for (int pre_test = 0; pre_test < pb->prefix_len; ++pre_test) {
          if (bf[pre_test] == pb->prefix[pre_test])
            continue;
          FIO_MEMCPY(buf, pb->prefix, pb->prefix_len);
          bf = buf;
          break;
        }
      }
      FIO_COMPILER_GUARD; /* don't optimize this loop */
      int64_t n = a2l(&bf);
      bf = buf;
      FIO_ASSERT(n == i,
                 "roundtrip error for %s: %s != %lld (got %lld)",
                 name,
                 buf,
                 i,
                 a2l(&bf));
    }
    trt = FIO_NAME_TEST(stl, atol_time)() - start;
    start = FIO_NAME_TEST(stl, atol_time)();
    for (int64_t i = -FIO_ATOL_TEST_MAX; i < FIO_ATOL_TEST_MAX; ++i) {
      char *bf = buf + pb->prefix_len;
      size_t len = l2a(bf, i, pb->base);
      bf[len] = 0;
      if (bf[0] == '-') {
        for (int pre_test = 0; pre_test < pb->prefix_len; ++pre_test) {
          if (bf[pre_test + 1] == pb->prefix[pre_test])
            continue;
          FIO_MEMCPY(buf, pb->prefix, pb->prefix_len);
          bf = buf;
          break;
        }
      } else {
        for (int pre_test = 0; pre_test < pb->prefix_len; ++pre_test) {
          if (bf[pre_test] == pb->prefix[pre_test])
            continue;
          FIO_MEMCPY(buf, pb->prefix, pb->prefix_len);
          bf = buf;
          break;
        }
      }
      FIO_COMPILER_GUARD; /* don't optimize this loop */
    }
    tw = FIO_NAME_TEST(stl, atol_time)() - start;
    // clang-format off
    fprintf(stderr, "        - %s roundtrip   %zd us\n", pb->str, (size_t)trt);
    fprintf(stderr, "        - %s write       %zd us\n", pb->str, (size_t)tw);
    fprintf(stderr, "        - %s read (calc) %zd us\n", pb->str, (size_t)(trt - tw));
    // clang-format on
  }
}

FIO_SFUNC void FIO_NAME_TEST(stl, atol)(void) {
  fprintf(stderr, "* Testing fio_atol and fio_ltoa.\n");
  char buffer[1024];
  for (int i = 0 - FIO_ATOL_TEST_MAX; i < FIO_ATOL_TEST_MAX; ++i) {
    size_t tmp = fio_ltoa(buffer, i, 0);
    FIO_ASSERT(tmp > 0, "fio_ltoa returned length error");
    char *tmp2 = buffer;
    int i2 = fio_atol(&tmp2);
    FIO_ASSERT(tmp2 > buffer, "fio_atol pointer motion error");
    FIO_ASSERT(i == i2,
               "fio_ltoa-fio_atol roundtrip error %lld != %lld",
               i,
               i2);
  }
  for (size_t bit = 0; bit < sizeof(int64_t) * 8; ++bit) {
    uint64_t i = (uint64_t)1 << bit;
    size_t tmp = fio_ltoa(buffer, (int64_t)i, 0);
    FIO_ASSERT(tmp > 0, "fio_ltoa return length error");
    buffer[tmp] = 0;
    char *tmp2 = buffer;
    int64_t i2 = fio_atol(&tmp2);
    FIO_ASSERT(tmp2 > buffer, "fio_atol pointer motion error");
    FIO_ASSERT((int64_t)i == i2,
               "fio_ltoa-fio_atol roundtrip error %lld != %lld",
               i,
               i2);
  }
  for (unsigned char i = 0; i < 36; ++i) {
    FIO_ASSERT(i == fio_c2i(fio_i2c(i)), "fio_c2i / fio_i2c roundtrip error.");
  }
  fprintf(stderr, "* Testing fio_atol samples.\n");
#define TEST_ATOL(s_, n)                                                       \
  do {                                                                         \
    char *s = (char *)s_;                                                      \
    char *p = (char *)(s);                                                     \
    int64_t r = fio_atol(&p);                                                  \
    FIO_ASSERT(r == (n),                                                       \
               "fio_atol test error! %s => %zd (not %zd)",                     \
               ((char *)(s)),                                                  \
               (size_t)r,                                                      \
               (size_t)n);                                                     \
    FIO_ASSERT((s) + strlen((s)) == p,                                         \
               "fio_atol test error! %s reading position not at end "          \
               "(!%zu == %zu)\n\t0x%p - 0x%p",                                 \
               (s),                                                            \
               (size_t)strlen((s)),                                            \
               (size_t)(p - (s)),                                              \
               (void *)p,                                                      \
               (void *)s);                                                     \
    char buf[96];                                                              \
    buf[0] = '0';                                                              \
    buf[1] = 'b';                                                              \
    buf[fio_ltoa(buf + 2, n, 2) + 2] = 0;                                      \
    p = buf;                                                                   \
    FIO_ASSERT(fio_atol(&p) == (n),                                            \
               "fio_ltoa base 2 test error! "                                  \
               "%s != %s (%zd)",                                               \
               buf,                                                            \
               ((char *)(s)),                                                  \
               (size_t)((p = buf), fio_atol(&p)));                             \
    fio_ltoa(buf, n, 8);                                                       \
    p = buf;                                                                   \
    p += buf[0] == '-';                                                        \
    FIO_ASSERT((r = (int64_t)fio_atol8u(&p)) ==                                \
                   ((buf[0] == '-') ? (0 - (n)) : (n)),                        \
               "fio_ltoa base 8 test error! "                                  \
               "%s != %s (%zd)",                                               \
               buf,                                                            \
               ((char *)(s)),                                                  \
               (size_t)r);                                                     \
    buf[fio_ltoa(buf, n, 10)] = 0;                                             \
    p = buf;                                                                   \
    FIO_ASSERT(fio_atol(&p) == (n),                                            \
               "fio_ltoa base 10 test error! "                                 \
               "%s != %s (%zd)",                                               \
               buf,                                                            \
               ((char *)(s)),                                                  \
               (size_t)((p = buf), fio_atol(&p)));                             \
    buf[0] = '0';                                                              \
    buf[1] = 'x';                                                              \
    buf[fio_ltoa(buf + 2, n, 16) + 2] = 0;                                     \
    p = buf;                                                                   \
    FIO_ASSERT(fio_atol(&p) == (n),                                            \
               "fio_ltoa base 16 test error! "                                 \
               "%s != %s (%zd)",                                               \
               buf,                                                            \
               ((char *)(s)),                                                  \
               (size_t)((p = buf), fio_atol(&p)));                             \
  } while (0)

  TEST_ATOL("0x1", 1);
  TEST_ATOL("-0x1", -1);
  TEST_ATOL("-0xa", -10);                                  /* sign before hex */
  TEST_ATOL("0xe5d4c3b2a1908770", -1885667171979196560LL); /* sign within hex */
  TEST_ATOL("0b00000000000011", 3);
  TEST_ATOL("-0b00000000000011", -3);
  TEST_ATOL("0b0000000000000000000000000000000000000000000000000", 0);
  TEST_ATOL("0", 0);
  TEST_ATOL("1", 1);
  TEST_ATOL("2", 2);
  TEST_ATOL("-2", -2);
  TEST_ATOL("0000000000000000000000000000000000000000000000042", 34); /* oct */
  TEST_ATOL("9223372036854775807", 9223372036854775807LL); /* INT64_MAX */
  TEST_ATOL("9223372036854775808",
            9223372036854775807LL); /* INT64_MAX overflow protection */
  TEST_ATOL("9223372036854775999",
            9223372036854775807LL); /* INT64_MAX overflow protection */
  TEST_ATOL("9223372036854775806",
            9223372036854775806LL); /* almost INT64_MAX */
#undef TEST_ATOL

#define TEST_LTOA_DIGITS10(num, digits)                                        \
  FIO_ASSERT(fio_digits10(num) == digits,                                      \
             "fio_digits10 failed for " #num " != (%zu)",                      \
             (size_t)fio_digits10(num));                                       \
  {                                                                            \
    char *number_str__ = (char *)#num;                                         \
    char *pstr__ = number_str__;                                               \
    FIO_ASSERT(fio_atol10(&pstr__) == num, "fio_atol10 failed for " #num);     \
  }
  TEST_LTOA_DIGITS10(1LL, 1);
  TEST_LTOA_DIGITS10(22LL, 2);
  TEST_LTOA_DIGITS10(333LL, 3);
  TEST_LTOA_DIGITS10(4444LL, 4);
  TEST_LTOA_DIGITS10(55555LL, 5);
  TEST_LTOA_DIGITS10(666666LL, 6);
  TEST_LTOA_DIGITS10(7777777LL, 7);
  TEST_LTOA_DIGITS10(88888888LL, 8);
  TEST_LTOA_DIGITS10(999999999LL, 9);
  TEST_LTOA_DIGITS10(-1LL, (1 + 1));
  TEST_LTOA_DIGITS10(-22LL, (2 + 1));
  TEST_LTOA_DIGITS10(-333LL, (3 + 1));
  TEST_LTOA_DIGITS10(-4444LL, (4 + 1));
  TEST_LTOA_DIGITS10(-55555LL, (5 + 1));
  TEST_LTOA_DIGITS10(-666666LL, (6 + 1));
  TEST_LTOA_DIGITS10(-7777777LL, (7 + 1));
  TEST_LTOA_DIGITS10(-88888888LL, (8 + 1));
  TEST_LTOA_DIGITS10(-999999999LL, (9 + 1));
  TEST_LTOA_DIGITS10(-9223372036854775807LL, (19 + 1));
#undef TEST_LTOA_DIGITS10

#define TEST_LTOA_DIGITS16(num, digits)                                        \
  FIO_ASSERT(fio_digits16u(num) == digits,                                     \
             "fio_digits16u failed for " #num " != (%zu)",                     \
             (size_t)fio_digits16u(num));                                      \
  {                                                                            \
    char *number_str__ = (char *)#num;                                         \
    char *pstr__ = number_str__;                                               \
    FIO_ASSERT(fio_atol16u(&pstr__) == (uint64_t)(num),                        \
               "fio_atol16u failed for " #num " != %zu",                       \
               ((pstr__ = number_str__), (size_t)fio_atol16u(&pstr__)));       \
  }
  TEST_LTOA_DIGITS16(0x00ULL, 2);
  TEST_LTOA_DIGITS16(0x10ULL, 2);
  TEST_LTOA_DIGITS16(0x100ULL, 4);
  TEST_LTOA_DIGITS16(0x10000ULL, 6);
  TEST_LTOA_DIGITS16(0xFFFFFFULL, 6);
  TEST_LTOA_DIGITS16(0x1000000ULL, 8);
  TEST_LTOA_DIGITS16(0x10000000ULL, 8);
  TEST_LTOA_DIGITS16(0x100000000ULL, 10);
  TEST_LTOA_DIGITS16(0x10000000000ULL, 12);
  TEST_LTOA_DIGITS16(0x1000000000000ULL, 14);
  TEST_LTOA_DIGITS16(0x100000000000000ULL, 16);
  TEST_LTOA_DIGITS16(0xFF00000000000000ULL, 16);
#undef TEST_LTOA_DIGITS16

#define TEST_LTOA_DIGITS_BIN(num, digits)                                      \
  FIO_ASSERT(fio_digits_bin(num) == digits,                                    \
             "fio_digits_bin failed for " #num " != (%zu)",                    \
             (size_t)fio_digits_bin(num));

  TEST_LTOA_DIGITS_BIN(0x00ULL, 1);
  TEST_LTOA_DIGITS_BIN(-0x01ULL, 64);
  TEST_LTOA_DIGITS_BIN(0x10ULL, 6);
  TEST_LTOA_DIGITS_BIN(0x100ULL, 10);
  TEST_LTOA_DIGITS_BIN(0x10000ULL, 18);
  TEST_LTOA_DIGITS_BIN(0x20000ULL, 18);
  TEST_LTOA_DIGITS_BIN(0xFFFFFFULL, 24);
  TEST_LTOA_DIGITS_BIN(0x1000000ULL, 26);
  TEST_LTOA_DIGITS_BIN(0x10000000ULL, 30);
  TEST_LTOA_DIGITS_BIN(0x100000000ULL, 34);
  TEST_LTOA_DIGITS_BIN(0x10000000000ULL, 42);
  TEST_LTOA_DIGITS_BIN(0x1000000000000ULL, 50);
  TEST_LTOA_DIGITS_BIN(0x100000000000000ULL, 58);
  TEST_LTOA_DIGITS_BIN(0xFF00000000000000ULL, 64);
#undef TEST_LTOA_DIGITS_BIN

  FIO_NAME_TEST(stl, atol_speed)("fio_atol/fio_ltoa", fio_atol, fio_ltoa);
  FIO_NAME_TEST(stl, atol_speed)
  ("system strtoll/sprintf", strtoll_wrapper, sprintf_wrapper);

#ifdef FIO_ATOF_ALT
#define TEST_DOUBLE(s, d, stop)                                                \
  do {                                                                         \
    union {                                                                    \
      double d_;                                                               \
      uint64_t as_i;                                                           \
    } pn, pn2;                                                                 \
    pn2.d_ = d;                                                                \
    char *p = (char *)(s);                                                     \
    char *p2 = (char *)(s);                                                    \
    double r = fio_atof(&p);                                                   \
    double std = strtod(p2, &p2);                                              \
    (void)std;                                                                 \
    pn.d_ = r;                                                                 \
    FIO_ASSERT(*p == stop || p == p2,                                          \
               "float parsing didn't stop at correct possition! %x != %x",     \
               *p,                                                             \
               stop);                                                          \
    if ((double)d == r || r == std) {                                          \
      /** fprintf(stderr, "Okay for %s\n", s); */                              \
    } else if ((pn2.as_i + 1) == (pn.as_i) || (pn.as_i + 1) == pn2.as_i) {     \
      fprintf(stderr,                                                          \
              "* WARNING: Single bit rounding error detected: %s\n",           \
              s);                                                              \
    } else if (r == 0.0 && d != 0.0) {                                         \
      fprintf(stderr, "* WARNING: float range limit marked before: %s\n", s);  \
    } else {                                                                   \
      char f_buf[164];                                                         \
      pn.d_ = std;                                                             \
      pn2.d_ = r;                                                              \
      size_t tmp_pos = fio_ltoa(f_buf, pn.as_i, 2);                            \
      f_buf[tmp_pos] = '\n';                                                   \
      fio_ltoa(f_buf + tmp_pos + 1, pn2.as_i, 2);                              \
      FIO_ASSERT(0,                                                            \
                 "Float error bigger than a single bit rounding error. exp. "  \
                 "vs. act.:\n%.19g\n%.19g\nBinary:\n%s",                       \
                 std,                                                          \
                 r,                                                            \
                 f_buf);                                                       \
    }                                                                          \
  } while (0)

  fprintf(stderr, "* Testing fio_atof samples.\n");

  /* A few hex-float examples  */
  TEST_DOUBLE("0x10.1p0", 0x10.1p0, 0);
  TEST_DOUBLE("0x1.8p1", 0x1.8p1, 0);
  TEST_DOUBLE("0x1.8p5", 0x1.8p5, 0);
  TEST_DOUBLE("0x4.0p5", 0x4.0p5, 0);
  TEST_DOUBLE("0x1.0p50a", 0x1.0p50, 'a');
  TEST_DOUBLE("0x1.0p500", 0x1.0p500, 0);
  TEST_DOUBLE("0x1.0P-1074", 0x1.0P-1074, 0);
  TEST_DOUBLE("0x3a.0P-1074", 0x3a.0P-1074, 0);

  /* These numbers were copied from https://gist.github.com/mattn/1890186 */
  TEST_DOUBLE(".1", 0.1, 0);
  TEST_DOUBLE("  .", 0, 0);
  TEST_DOUBLE("  1.2e3", 1.2e3, 0);
  TEST_DOUBLE(" +1.2e3", 1.2e3, 0);
  TEST_DOUBLE("1.2e3", 1.2e3, 0);
  TEST_DOUBLE("+1.2e3", 1.2e3, 0);
  TEST_DOUBLE("+1.e3", 1000, 0);
  TEST_DOUBLE("-1.2e3", -1200, 0);
  TEST_DOUBLE("-1.2e3.5", -1200, '.');
  TEST_DOUBLE("-1.2e", -1.2, 0);
  TEST_DOUBLE("--1.2e3.5", 0, '-');
  TEST_DOUBLE("--1-.2e3.5", 0, '-');
  TEST_DOUBLE("-a", 0, 'a');
  TEST_DOUBLE("a", 0, 'a');
  TEST_DOUBLE(".1e", 0.1, 0);
  TEST_DOUBLE(".1e3", 100, 0);
  TEST_DOUBLE(".1e-3", 0.1e-3, 0);
  TEST_DOUBLE(".1e-", 0.1, 0);
  TEST_DOUBLE(" .e-", 0, 0);
  TEST_DOUBLE(" .e", 0, 0);
  TEST_DOUBLE(" e", 0, 0);
  TEST_DOUBLE(" e0", 0, 0);
  TEST_DOUBLE(" ee", 0, 'e');
  TEST_DOUBLE(" -e", 0, 0);
  TEST_DOUBLE(" .9", 0.9, 0);
  TEST_DOUBLE(" ..9", 0, '.');
  TEST_DOUBLE("009", 9, 0);
  TEST_DOUBLE("0.09e02", 9, 0);
  /* http://thread.gmane.org/gmane.editors.vim.devel/19268/ */
  TEST_DOUBLE("0.9999999999999999999999999999999999", 1, 0);
  TEST_DOUBLE("2.2250738585072010e-308", 2.225073858507200889e-308, 0);
  TEST_DOUBLE("2.2250738585072013e-308", 2.225073858507201383e-308, 0);
  TEST_DOUBLE("9214843084008499", 9214843084008499, 0);
  TEST_DOUBLE("30078505129381147446200", 3.007850512938114954e+22, 0);

  /* These numbers were copied from https://github.com/miloyip/rapidjson */
  TEST_DOUBLE("0.0", 0.0, 0);
  TEST_DOUBLE("-0.0", -0.0, 0);
  TEST_DOUBLE("1.0", 1.0, 0);
  TEST_DOUBLE("-1.0", -1.0, 0);
  TEST_DOUBLE("1.5", 1.5, 0);
  TEST_DOUBLE("-1.5", -1.5, 0);
  TEST_DOUBLE("3.1416", 3.1416, 0);
  TEST_DOUBLE("1E10", 1E10, 0);
  TEST_DOUBLE("1e10", 1e10, 0);
  TEST_DOUBLE("100000000000000000000000000000000000000000000000000000000000"
              "000000000000000000000",
              1E80,
              0);
  TEST_DOUBLE("1E+10", 1E+10, 0);
  TEST_DOUBLE("1E-10", 1E-10, 0);
  TEST_DOUBLE("-1E10", -1E10, 0);
  TEST_DOUBLE("-1e10", -1e10, 0);
  TEST_DOUBLE("-1E+10", -1E+10, 0);
  TEST_DOUBLE("-1E-10", -1E-10, 0);
  TEST_DOUBLE("1.234E+10", 1.234E+10, 0);
  TEST_DOUBLE("1.234E-10", 1.234E-10, 0);
  TEST_DOUBLE("1.79769e+308", 1.79769e+308, 0);
  TEST_DOUBLE("2.22507e-308", 2.22507e-308, 0);
  TEST_DOUBLE("-1.79769e+308", -1.79769e+308, 0);
  TEST_DOUBLE("-2.22507e-308", -2.22507e-308, 0);
  TEST_DOUBLE("4.9406564584124654e-324", 4.9406564584124654e-324, 0);
  TEST_DOUBLE("2.2250738585072009e-308", 2.2250738585072009e-308, 0);
  TEST_DOUBLE("2.2250738585072014e-308", 2.2250738585072014e-308, 0);
  TEST_DOUBLE("1.7976931348623157e+308", 1.7976931348623157e+308, 0);
  TEST_DOUBLE("1e-10000", 0.0, 0);
  TEST_DOUBLE("18446744073709551616", 18446744073709551616.0, 0);

  TEST_DOUBLE("-9223372036854775809", -9223372036854775809.0, 0);

  TEST_DOUBLE("0.9868011474609375", 0.9868011474609375, 0);
  TEST_DOUBLE("123e34", 123e34, 0);
  TEST_DOUBLE("45913141877270640000.0", 45913141877270640000.0, 0);
  TEST_DOUBLE("2.2250738585072011e-308", 2.2250738585072011e-308, 0);
  TEST_DOUBLE("1e-214748363", 0.0, 0);
  TEST_DOUBLE("1e-214748364", 0.0, 0);
  TEST_DOUBLE("0.017976931348623157e+310, 1", 1.7976931348623157e+308, ',');

  TEST_DOUBLE("2.2250738585072012e-308", 2.2250738585072014e-308, 0);
  TEST_DOUBLE("2.22507385850720113605740979670913197593481954635164565e-308",
              2.2250738585072014e-308,
              0);

  TEST_DOUBLE("0.999999999999999944488848768742172978818416595458984375",
              1.0,
              0);
  TEST_DOUBLE("0.999999999999999944488848768742172978818416595458984376",
              1.0,
              0);
  TEST_DOUBLE("1.00000000000000011102230246251565404236316680908203125",
              1.0,
              0);
  TEST_DOUBLE("1.00000000000000011102230246251565404236316680908203124",
              1.0,
              0);

  TEST_DOUBLE("72057594037927928.0", 72057594037927928.0, 0);
  TEST_DOUBLE("72057594037927936.0", 72057594037927936.0, 0);
  TEST_DOUBLE("72057594037927932.0", 72057594037927936.0, 0);
  TEST_DOUBLE("7205759403792793200001e-5", 72057594037927936.0, 0);

  TEST_DOUBLE("9223372036854774784.0", 9223372036854774784.0, 0);
  TEST_DOUBLE("9223372036854775808.0", 9223372036854775808.0, 0);
  TEST_DOUBLE("9223372036854775296.0", 9223372036854775808.0, 0);
  TEST_DOUBLE("922337203685477529600001e-5", 9223372036854775808.0, 0);

  TEST_DOUBLE("10141204801825834086073718800384",
              10141204801825834086073718800384.0,
              0);
  TEST_DOUBLE("10141204801825835211973625643008",
              10141204801825835211973625643008.0,
              0);
  TEST_DOUBLE("10141204801825834649023672221696",
              10141204801825835211973625643008.0,
              0);
  TEST_DOUBLE("1014120480182583464902367222169600001e-5",
              10141204801825835211973625643008.0,
              0);

  TEST_DOUBLE("5708990770823838890407843763683279797179383808",
              5708990770823838890407843763683279797179383808.0,
              0);
  TEST_DOUBLE("5708990770823839524233143877797980545530986496",
              5708990770823839524233143877797980545530986496.0,
              0);
  TEST_DOUBLE("5708990770823839207320493820740630171355185152",
              5708990770823839524233143877797980545530986496.0,
              0);
  TEST_DOUBLE("5708990770823839207320493820740630171355185152001e-3",
              5708990770823839524233143877797980545530986496.0,
              0);
#undef TEST_DOUBLE
#if !DEBUG
  {
    clock_t start, stop;
    fio_memcpy15x(buffer, "1234567890.123", 14);
    buffer[14] = 0;
    size_t r = 0;
    start = clock();
    for (int i = 0; i < (FIO_ATOL_TEST_MAX << 3); ++i) {
      char *pos = buffer;
      r += fio_atol(&pos);
      FIO_COMPILER_GUARD;
      // FIO_ASSERT(r == exp, "fio_atol failed during speed test");
    }
    stop = clock();
    fprintf(stderr,
            "* fio_atol speed test completed in %zu cycles\n",
            stop - start);
    r = 0;

    start = clock();
    for (int i = 0; i < (FIO_ATOL_TEST_MAX << 3); ++i) {
      char *pos = buffer;
      r += strtol(pos, NULL, 10);
      FIO_COMPILER_GUARD;
      // FIO_ASSERT(r == exp, "system strtol failed during speed test");
    }
    stop = clock();
    fprintf(stderr,
            "* system atol speed test completed in %zu cycles\n",
            stop - start);
  }
#endif /* !DEBUG */
#endif /* FIO_ATOF_ALT */
}
#undef FIO_ATOL_TEST_MAX
#endif /* FIO_TEST_CSTL */

/* *****************************************************************************
Numbers <=> Strings - Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_ATOL */
#undef FIO_ATOL
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_THREADS    /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                        Simple Portable Threads



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_THREADS) && !defined(H___FIO_THREADS___H)
#define H___FIO_THREADS___H

/* *****************************************************************************
Module Settings

At this point, define any MACROs and customizable settings available to the
developer.
***************************************************************************** */

#if FIO_OS_POSIX
#include <pthread.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/wait.h>
typedef pthread_t fio_thread_t;
typedef pthread_mutex_t fio_thread_mutex_t;
typedef pthread_cond_t fio_thread_cond_t;
/** Used this macro for static initialization. */
#define FIO_THREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER

#elif FIO_OS_WIN
#include <synchapi.h>
typedef HANDLE fio_thread_t;
typedef CRITICAL_SECTION fio_thread_mutex_t;
typedef CONDITION_VARIABLE fio_thread_cond_t;
/** Used this macro for static initialization. */
#define FIO_THREAD_MUTEX_INIT ((fio_thread_mutex_t){0})
#else
#error facil.io Simple Portable Threads require a POSIX system or Windows
#endif

#ifdef FIO_THREADS_BYO
#define FIO_IFUNC_T
#else
#define FIO_IFUNC_T FIO_IFUNC
#endif

#ifdef FIO_THREADS_FORK_BYO
#define FIO_IFUNC_F
#else
#define FIO_IFUNC_F FIO_IFUNC
#endif

#ifdef FIO_THREADS_MUTEX_BYO
#define FIO_IFUNC_M
#else
#define FIO_IFUNC_M FIO_IFUNC
#endif

#ifdef FIO_THREADS_COND_BYO
#define FIO_IFUNC_C
#else
#define FIO_IFUNC_C FIO_IFUNC
#endif

/* *****************************************************************************
Module API
***************************************************************************** */

/** Should behave the same as the POSIX system call `fork`. */
FIO_IFUNC_F int fio_thread_fork(void);

/** Starts a new thread, returns 0 on success and -1 on failure. */
FIO_IFUNC_T int fio_thread_create(fio_thread_t *t,
                                  void *(*fn)(void *),
                                  void *arg);

/** Waits for the thread to finish. */
FIO_IFUNC_T int fio_thread_join(fio_thread_t *t);

/** Detaches the thread, so thread resources are freed automatically. */
FIO_IFUNC_T int fio_thread_detach(fio_thread_t *t);

/** Ends the current running thread. */
FIO_IFUNC_T void fio_thread_exit(void);

/* Returns non-zero if both threads refer to the same thread. */
FIO_IFUNC_T int fio_thread_equal(fio_thread_t *a, fio_thread_t *b);

/** Returns the current thread. */
FIO_IFUNC_T fio_thread_t fio_thread_current(void);

/** Yields thread execution. */
FIO_IFUNC_T void fio_thread_yield(void);

/**
 * Initializes a simple Mutex.
 *
 * Or use the static initialization value: FIO_THREAD_MUTEX_INIT
 */
FIO_IFUNC_M int fio_thread_mutex_init(fio_thread_mutex_t *m);

/** Locks a simple Mutex, returning -1 on error. */
FIO_IFUNC_M int fio_thread_mutex_lock(fio_thread_mutex_t *m);

/** Attempts to lock a simple Mutex, returning zero on success. */
FIO_IFUNC_M int fio_thread_mutex_trylock(fio_thread_mutex_t *m);

/** Unlocks a simple Mutex, returning zero on success or -1 on error. */
FIO_IFUNC_M int fio_thread_mutex_unlock(fio_thread_mutex_t *m);

/** Destroys the simple Mutex (cleanup). */
FIO_IFUNC_M void fio_thread_mutex_destroy(fio_thread_mutex_t *m);

/**
 * Initializes a simple Mutex.
 *
 * Or use the static initialization value: FIO_THREAD_MUTEX_INIT
 */
FIO_IFUNC_M int fio_thread_mutex_init(fio_thread_mutex_t *m);

/** Locks a simple Mutex, returning -1 on error. */
FIO_IFUNC_M int fio_thread_mutex_lock(fio_thread_mutex_t *m);

/** Attempts to lock a simple Mutex, returning zero on success. */
FIO_IFUNC_M int fio_thread_mutex_trylock(fio_thread_mutex_t *m);

/** Unlocks a simple Mutex, returning zero on success or -1 on error. */
FIO_IFUNC_M int fio_thread_mutex_unlock(fio_thread_mutex_t *m);

/** Destroys the simple Mutex (cleanup). */
FIO_IFUNC_M void fio_thread_mutex_destroy(fio_thread_mutex_t *m);

/** Initializes a simple conditional variable. */
FIO_IFUNC_C int fio_thread_cond_init(fio_thread_cond_t *c);

/** Waits on a conditional variable (MUST be previously locked). */
FIO_IFUNC_C int fio_thread_cond_wait(fio_thread_cond_t *c,
                                     fio_thread_mutex_t *m);

/** Signals a simple conditional variable. */
FIO_IFUNC_C int fio_thread_cond_signal(fio_thread_cond_t *c);

/** Destroys a simple conditional variable. */
FIO_IFUNC_C void fio_thread_cond_destroy(fio_thread_cond_t *c);

/* *****************************************************************************
POSIX Implementation - inlined static functions
***************************************************************************** */
#if FIO_OS_POSIX

#ifndef FIO_THREADS_FORK_BYO
/** Should behave the same as the POSIX system call `fork`. */
FIO_IFUNC_F int fio_thread_fork(void) { return (int)fork(); }
#endif

#ifndef FIO_THREADS_BYO
// clang-format off

/** Starts a new thread, returns 0 on success and -1 on failure. */
FIO_IFUNC int fio_thread_create(fio_thread_t *t, void *(*fn)(void *), void *arg) { return pthread_create(t, NULL, fn, arg); }

FIO_IFUNC int fio_thread_join(fio_thread_t *t) { return pthread_join(*t, NULL); }

/** Detaches the thread, so thread resources are freed automatically. */
FIO_IFUNC int fio_thread_detach(fio_thread_t *t) { return pthread_detach(*t); }

/** Ends the current running thread. */
FIO_IFUNC void fio_thread_exit(void) { pthread_exit(NULL); }

/* Returns non-zero if both threads refer to the same thread. */
FIO_IFUNC int fio_thread_equal(fio_thread_t *a, fio_thread_t *b) { return pthread_equal(*a, *b); }

/** Returns the current thread. */
FIO_IFUNC fio_thread_t fio_thread_current(void) { return pthread_self(); }

/** Yields thread execution. */
FIO_IFUNC void fio_thread_yield(void) { sched_yield(); }

#endif /* FIO_THREADS_BYO */
#ifndef FIO_THREADS_MUTEX_BYO

/** Initializes a simple Mutex. */
FIO_IFUNC int fio_thread_mutex_init(fio_thread_mutex_t *m) { return pthread_mutex_init(m, NULL); }

/** Locks a simple Mutex, returning -1 on error. */
FIO_IFUNC int fio_thread_mutex_lock(fio_thread_mutex_t *m) { return pthread_mutex_lock(m); }

/** Attempts to lock a simple Mutex, returning zero on success. */
FIO_IFUNC int fio_thread_mutex_trylock(fio_thread_mutex_t *m) { return pthread_mutex_trylock(m); }

/** Unlocks a simple Mutex, returning zero on success or -1 on error. */
FIO_IFUNC int fio_thread_mutex_unlock(fio_thread_mutex_t *m) { return pthread_mutex_unlock(m); }

/** Destroys the simple Mutex (cleanup). */
FIO_IFUNC void fio_thread_mutex_destroy(fio_thread_mutex_t *m) { pthread_mutex_destroy(m); *m = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER; }

#endif /* FIO_THREADS_MUTEX_BYO */
// clang-format on

#ifndef FIO_THREADS_COND_BYO
/** Initializes a simple conditional variable. */
FIO_IFUNC_C int fio_thread_cond_init(fio_thread_cond_t *c) {
  return pthread_cond_init(c, NULL);
}

/** Waits on a conditional variable (MUST be previously locked). */
FIO_IFUNC_C int fio_thread_cond_wait(fio_thread_cond_t *c,
                                     fio_thread_mutex_t *m) {
  return pthread_cond_wait(c, m);
}

/** Signals a simple conditional variable. */
FIO_IFUNC_C int fio_thread_cond_signal(fio_thread_cond_t *c) {
  return pthread_cond_signal(c);
}

/** Destroys a simple conditional variable. */
FIO_IFUNC_C void fio_thread_cond_destroy(fio_thread_cond_t *c) {
  pthread_cond_destroy(c);
}
#endif /* FIO_THREADS_COND_BYO */

/* *****************************************************************************
Windows Implementation - inlined static functions
***************************************************************************** */
#elif FIO_OS_WIN
#include <process.h>

#ifndef FIO_THREADS_FORK_BYO
/** Should behave the same as the POSIX system call `fork`. */
#ifdef fork
FIO_IFUNC_F int fio_thread_fork(void) { return (int)fork(); }
#else
FIO_IFUNC_F int fio_thread_fork(void) { return -1; }
#endif
#endif

#ifndef FIO_THREADS_BYO
/** Starts a new thread, returns 0 on success and -1 on failure. */
FIO_IFUNC int fio_thread_create(fio_thread_t *t,
                                void *(*fn)(void *),
                                void *arg) {
  *t = (HANDLE)_beginthreadex(NULL,
                              0,
                              (_beginthreadex_proc_type)(uintptr_t)fn,
                              arg,
                              0,
                              NULL);
  return (!!t) - 1;
}

FIO_IFUNC int fio_thread_join(fio_thread_t *t) {
  int r = 0;
  if (WaitForSingleObject(*t, INFINITE) == WAIT_FAILED) {
    errno = GetLastError();
    r = -1;
  } else
    CloseHandle(*t);
  return r;
}

// clang-format off
/** Detaches the thread, so thread resources are freed automatically. */
FIO_IFUNC int fio_thread_detach(fio_thread_t *t) { return CloseHandle(*t) - 1; }

/** Ends the current running thread. */
FIO_IFUNC void fio_thread_exit(void) { _endthread(); }

/* Returns non-zero if both threads refer to the same thread. */
FIO_IFUNC int fio_thread_equal(fio_thread_t *a, fio_thread_t *b) { return GetThreadId(*a) == GetThreadId(*b); }

/** Returns the current thread. */
FIO_IFUNC fio_thread_t fio_thread_current(void) { return GetCurrentThread(); }

/** Yields thread execution. */
FIO_IFUNC void fio_thread_yield(void) { Sleep(0); }

#endif /* FIO_THREADS_BYO */
#ifndef FIO_THREADS_MUTEX_BYO

SFUNC int fio___thread_mutex_lazy_init(fio_thread_mutex_t *m);

FIO_IFUNC int fio_thread_mutex_init(fio_thread_mutex_t *m) { InitializeCriticalSection(m); return 0; }

/** Destroys the simple Mutex (cleanup). */
FIO_IFUNC void fio_thread_mutex_destroy(fio_thread_mutex_t *m) { DeleteCriticalSection(m); memset(m,0,sizeof(*m)); }
// clang-format on
/** Unlocks a simple Mutex, returning zero on success or -1 on error. */
FIO_IFUNC int fio_thread_mutex_unlock(fio_thread_mutex_t *m) {
  if (!m)
    return -1;
  LeaveCriticalSection(m);
  return 0;
}

/** Locks a simple Mutex, returning -1 on error. */
FIO_IFUNC int fio_thread_mutex_lock(fio_thread_mutex_t *m) {
  const fio_thread_mutex_t zero = {0};
  if (!FIO_MEMCMP(m, &zero, sizeof(zero)) && fio___thread_mutex_lazy_init(m))
    return -1;
  EnterCriticalSection(m);
  return 0;
}

/** Attempts to lock a simple Mutex, returning zero on success. */
FIO_IFUNC int fio_thread_mutex_trylock(fio_thread_mutex_t *m) {
  const fio_thread_mutex_t zero = {0};
  if (!FIO_MEMCMP(m, &zero, sizeof(zero)) && fio___thread_mutex_lazy_init(m))
    return -1;
  return TryEnterCriticalSection(m) - 1;
}
#endif /* FIO_THREADS_MUTEX_BYO */

#ifndef FIO_THREADS_COND_BYO
/** Initializes a simple conditional variable. */
FIO_IFUNC_C int fio_thread_cond_init(fio_thread_cond_t *c) {
  InitializeConditionVariable(c);
  return 0;
}

/** Waits on a conditional variable (MUST be previously locked). */
FIO_IFUNC_C int fio_thread_cond_wait(fio_thread_cond_t *c,
                                     fio_thread_mutex_t *m) {
  return 0 - !SleepConditionVariableCS(c, m, INFINITE);
}

/** Signals a simple conditional variable. */
FIO_IFUNC_C int fio_thread_cond_signal(fio_thread_cond_t *c) {
  WakeConditionVariable(c);
  return 0;
}

/** Destroys a simple conditional variable. */
FIO_IFUNC_C void fio_thread_cond_destroy(fio_thread_cond_t *c) { (void)(c); }
#endif /* FIO_THREADS_COND_BYO */

#endif /* FIO_OS_WIN */

/* *****************************************************************************
Multi-Threaded `memcpy`
***************************************************************************** */

#ifndef FIO_MEMCPY_THREADS
#define FIO_MEMCPY_THREADS 8
#endif
#undef FIO_MEMCPY_THREADS___MINCPY
#define FIO_MEMCPY_THREADS___MINCPY (1ULL << 23)
typedef struct {
  const char *restrict dest;
  void *restrict src;
  size_t bytes;
} fio___thread_memcpy_s;

FIO_SFUNC void *fio___thread_memcpy_task(void *v_) {
  fio___thread_memcpy_s *v = (fio___thread_memcpy_s *)v_;
  FIO_MEMCPY((void *)(v->dest), (void *)(v->src), v->bytes);
  return NULL;
}

/** Multi-threaded memcpy using up to FIO_MEMCPY_THREADS threads */
FIO_SFUNC size_t fio_thread_memcpy(const void *restrict dest,
                                   void *restrict src,
                                   size_t bytes) {
  size_t i = 0, r;
  const char *restrict d = (const char *restrict)dest;
  char *restrict s = (char *restrict)src;
  fio_thread_t threads[FIO_MEMCPY_THREADS - 1];
  fio___thread_memcpy_s info[FIO_MEMCPY_THREADS - 1];
  size_t bytes_per_thread = bytes / FIO_MEMCPY_THREADS;
  if (bytes < FIO_MEMCPY_THREADS___MINCPY)
    goto finished_creating_thread;

  for (; i < (FIO_MEMCPY_THREADS - 1); ++i) {
    info[i] = (fio___thread_memcpy_s){d, s, bytes_per_thread};
    if (fio_thread_create(threads + i, fio___thread_memcpy_task, info + i))
      goto finished_creating_thread;
    d += bytes_per_thread;
    s += bytes_per_thread;
    bytes -= bytes_per_thread;
  }
finished_creating_thread:
  r = i + 1;
  FIO_MEMCPY((void *)d, (void *)s, bytes); /* memcpy reminder */
  while (i) {
    --i;
    fio_thread_join(threads + i);
  }
  return r;
}

/* *****************************************************************************
Module Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
#if FIO_OS_WIN
#ifndef FIO_THREADS_MUTEX_BYO
/** Initializes a simple Mutex */
SFUNC int fio___thread_mutex_lazy_init(fio_thread_mutex_t *m) {
  int r = 0;
  static fio_lock_i lock = FIO_LOCK_INIT;
  /* lazy initialization */
  fio_thread_mutex_t zero = {0};
  fio_lock(&lock);
  if (!FIO_MEMCMP(m,
                  &zero,
                  sizeof(zero))) { /* retest, as this may have changed... */
    r = fio_thread_mutex_init(m);
  }
  fio_unlock(&lock);
  return r;
}
#endif /* FIO_THREADS_MUTEX_BYO */
#endif /* FIO_OS_WIN */
/* *****************************************************************************
Module Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, threads)(void) {
  /* TODO? test module here */
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_THREADS */
#undef FIO_THREADS
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_TIME       /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                                  Time Helpers



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_TIME) && !defined(H___FIO_TIME___H)
#define H___FIO_TIME___H

/* *****************************************************************************
Collecting Monotonic / Real Time
***************************************************************************** */

/** Returns human (watch) time... this value isn't as safe for measurements. */
FIO_IFUNC struct timespec fio_time_real();

/** Returns monotonic time. */
FIO_IFUNC struct timespec fio_time_mono();

/** Returns monotonic time in nano-seconds (now in 1 billionth of a second). */
FIO_IFUNC int64_t fio_time_nano();

/** Returns monotonic time in micro-seconds (now in 1 millionth of a second). */
FIO_IFUNC int64_t fio_time_micro();

/** Returns monotonic time in milliseconds. */
FIO_IFUNC int64_t fio_time_milli();

/** Converts a `struct timespec` to milliseconds. */
FIO_IFUNC int64_t fio_time2milli(struct timespec);

/**
 * A faster (yet less localized) alternative to `gmtime_r`.
 *
 * See the libc `gmtime_r` documentation for details.
 *
 * Falls back to `gmtime_r` for dates before epoch.
 */
SFUNC struct tm fio_time2gm(time_t time);

/** Converts a `struct tm` to time in seconds (assuming UTC). */
SFUNC time_t fio_gm2time(struct tm tm);

/**
 * Writes an RFC 7231 date representation (HTTP date format) to target.
 *
 * Usually requires 29 characters, although this may vary.
 */
SFUNC size_t fio_time2rfc7231(char *target, time_t time);

/**
 * Writes an RFC 2109 date representation to target.
 *
 * Usually requires 31 characters, although this may vary.
 */
SFUNC size_t fio_time2rfc2109(char *target, time_t time);

/**
 * Writes an RFC 2822 date representation to target.
 *
 * Usually requires 28 to 29 characters, although this may vary.
 */
SFUNC size_t fio_time2rfc2822(char *target, time_t time);

/**
 * Writes a date representation to target in common log format. i.e.,
 *
 *         [DD/MMM/yyyy:hh:mm:ss +0000]
 *
 * Usually requires 29 characters (includiing square brackes and NUL).
 */
SFUNC size_t fio_time2log(char *target, time_t time);

/** Adds two `struct timespec` objects. */
FIO_IFUNC struct timespec fio_time_add(struct timespec t, struct timespec t2);

/** Adds milliseconds to a `struct timespec` object. */
FIO_IFUNC struct timespec fio_time_add_milli(struct timespec t, int64_t milli);

/** Compares two `struct timespec` objects. */
FIO_IFUNC int fio_time_cmp(struct timespec t1, struct timespec t2);

/* *****************************************************************************
Time Inline Helpers
***************************************************************************** */

/** Returns human (watch) time... this value isn't as safe for measurements. */
FIO_IFUNC struct timespec fio_time_real() {
  struct timespec t;
  clock_gettime(CLOCK_REALTIME, &t);
  return t;
}

/** Returns monotonic time. */
FIO_IFUNC struct timespec fio_time_mono() {
  struct timespec t;
  clock_gettime(CLOCK_MONOTONIC, &t);
  return t;
}

/** Returns monotonic time in nano-seconds (now in 1 micro of a second). */
FIO_IFUNC int64_t fio_time_nano() {
  struct timespec t = fio_time_mono();
  return ((int64_t)t.tv_sec * 1000000000) + (int64_t)t.tv_nsec;
}

/** Returns monotonic time in micro-seconds (now in 1 millionth of a second). */
FIO_IFUNC int64_t fio_time_micro() {
  struct timespec t = fio_time_mono();
  return ((int64_t)t.tv_sec * 1000000) + (int64_t)t.tv_nsec / 1000;
}

/** Returns monotonic time in milliseconds. */
FIO_IFUNC int64_t fio_time_milli() {
  struct timespec t = fio_time_mono();
  return ((int64_t)t.tv_sec * 1000) + (int64_t)t.tv_nsec / 1000000;
}

/** Converts a `struct timespec` to milliseconds. */
FIO_IFUNC int64_t fio_time2milli(struct timespec t) {
  return ((int64_t)t.tv_sec * 1000) + (int64_t)t.tv_nsec / 1000000;
}

/* Normalizes a timespec struct after an `add` or `sub` operation. */
FIO_IFUNC void fio_time___normalize(struct timespec *t) {
  const long ns_norm[2] = {0, 1000000000LL};
  t->tv_nsec += ns_norm[(t->tv_nsec < 0)];
  t->tv_sec += (t->tv_nsec < 0);
  t->tv_nsec -= ns_norm[(1000000000LL < t->tv_nsec)];
  t->tv_sec += (1000000000LL < t->tv_nsec);
}

/** Adds to timespec. */
FIO_IFUNC struct timespec fio_time_add(struct timespec t, struct timespec t2) {
  t.tv_sec += t2.tv_sec;
  t.tv_nsec += t2.tv_nsec;
  fio_time___normalize(&t);
  return t;
}

/** Adds milliseconds to timespec. */
FIO_IFUNC struct timespec fio_time_add_milli(struct timespec t, int64_t milli) {
  t.tv_sec += milli >> 10; /* 1024 is close enough, will be normalized */
  t.tv_nsec += (milli & 1023) * 1000000;
  fio_time___normalize(&t);
  return t;
}

/** Compares two timespecs. */
FIO_IFUNC int fio_time_cmp(struct timespec t1, struct timespec t2) {
  size_t a = (t2.tv_sec < t1.tv_sec) << 1;
  a |= (t2.tv_nsec < t1.tv_nsec);
  size_t b = (t1.tv_sec < t2.tv_sec) << 1;
  b |= (t1.tv_nsec < t2.tv_nsec);
  return (0 - (a < b)) + (b < a);
}

/* *****************************************************************************
Time Implementation
***************************************************************************** */
#if !defined(FIO_EXTERN) || defined(FIO_EXTERN_COMPLETE)

/**
 * A faster (yet less localized) alternative to `gmtime_r`.
 *
 * See the libc `gmtime_r` documentation for details.
 *
 * Falls back to `gmtime_r` for dates before epoch.
 */
SFUNC struct tm fio_time2gm(time_t timer) {
  struct tm tm;
  ssize_t a, b;
#if HAVE_TM_TM_ZONE || defined(BSD)
  tm = (struct tm){
      .tm_isdst = 0,
      .tm_zone = (char *)"UTC",
  };
#else
  tm = (struct tm){
      .tm_isdst = 0,
  };
#endif

  // convert seconds from epoch to days from epoch + extract data
  if (timer >= 0) {
    // for seconds up to weekdays, we reduce the reminder every step.
    a = (ssize_t)timer;
    b = a / 60; // b == time in minutes
    tm.tm_sec = (int)(a - (b * 60));
    a = b / 60; // b == time in hours
    tm.tm_min = (int)(b - (a * 60));
    b = a / 24; // b == time in days since epoch
    tm.tm_hour = (int)(a - (b * 24));
    // b == number of days since epoch
    // day of epoch was a thursday. Add + 4 so sunday == 0...
    tm.tm_wday = (b + 4) % 7;
  } else {
    // for seconds up to weekdays, we reduce the reminder every step.
    a = (ssize_t)timer;
    b = a / 60; // b == time in minutes
    if (b * 60 != a) {
      /* seconds passed */
      tm.tm_sec = (int)((a - (b * 60)) + 60);
      --b;
    } else {
      /* no seconds */
      tm.tm_sec = 0;
    }
    a = b / 60; // b == time in hours
    if (a * 60 != b) {
      /* minutes passed */
      tm.tm_min = (int)((b - (a * 60)) + 60);
      --a;
    } else {
      /* no minutes */
      tm.tm_min = 0;
    }
    b = a / 24; // b == time in days since epoch?
    if (b * 24 != a) {
      /* hours passed */
      tm.tm_hour = (int)((a - (b * 24)) + 24);
      --b;
    } else {
      /* no hours */
      tm.tm_hour = 0;
    }
    // day of epoch was a thursday. Add + 4 so sunday == 0...
    tm.tm_wday = ((b - 3) % 7);
    if (tm.tm_wday)
      tm.tm_wday += 7;
    /* b == days from epoch */
  }

  // at this point we can apply the algorithm described here:
  // http://howardhinnant.github.io/date_algorithms.html#civil_from_days
  // Credit to Howard Hinnant.
  {
    b += 719468L; // adjust to March 1st, 2000 (post leap of 400 year era)
    // 146,097 = days in era (400 years)
    const size_t era = (b >= 0 ? b : b - 146096) / 146097;
    const uint32_t doe = (uint32_t)(b - (era * 146097)); // day of era
    const uint16_t yoe =
        (uint16_t)((doe - doe / 1460 + doe / 36524 - doe / 146096) /
                   365); // year of era
    a = yoe;
    a += era * 400; // a == year number, assuming year starts on March 1st...
    const uint16_t doy = (uint16_t)(doe - (365 * yoe + yoe / 4 - yoe / 100));
    const uint16_t mp = (uint16_t)((5U * doy + 2) / 153);
    const uint16_t d = (uint16_t)(doy - (153U * mp + 2) / 5 + 1);
    const uint8_t m = (uint8_t)(mp + (mp < 10 ? 2 : -10));
    a += (m <= 1);
    tm.tm_year = (int)(a - 1900); // tm_year == years since 1900
    tm.tm_mon = m;
    tm.tm_mday = d;
    const uint8_t is_leap = (a % 4 == 0 && (a % 100 != 0 || a % 400 == 0));
    tm.tm_yday = (doy + (is_leap) + 28 + 31) % (365 + is_leap);
  }

  return tm;
}

/** Converts a `struct tm` to time in seconds (assuming UTC). */
SFUNC time_t fio_gm2time(struct tm tm) {
  int64_t time = 0;
  // we start with the algorithm described here:
  // http://howardhinnant.github.io/date_algorithms.html#days_from_civil
  // Credit to Howard Hinnant.
  {
    const int32_t y = (tm.tm_year + 1900) - (tm.tm_mon < 2);
    const int32_t era = (y >= 0 ? y : y - 399) / 400;
    const uint16_t yoe = (y - era * 400L); // 0-399
    const uint32_t doy =
        (153L * (tm.tm_mon + (tm.tm_mon > 1 ? -2 : 10)) + 2) / 5 + tm.tm_mday -
        1;                                                       // 0-365
    const uint32_t doe = yoe * 365L + yoe / 4 - yoe / 100 + doy; // 0-146096
    time = era * 146097LL + doe - 719468LL; // time == days from epoch
  }

  /* Adjust for hour, minute and second */
  time = time * 24LL + tm.tm_hour;
  time = time * 60LL + tm.tm_min;
  time = time * 60LL + tm.tm_sec;

  if (tm.tm_isdst > 0) {
    time -= 60 * 60;
  }
#if HAVE_TM_TM_ZONE || defined(BSD)
  if (tm.tm_gmtoff) {
    time += tm.tm_gmtoff;
  }
#endif
  return (time_t)time;
}

FIO_SFUNC char *fio_time_write_day(char *dest, const struct tm *tm) {
  static const char *FIO___DAY_NAMES[] =
      {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
  dest[0] = FIO___DAY_NAMES[tm->tm_wday][0];
  dest[1] = FIO___DAY_NAMES[tm->tm_wday][1];
  dest[2] = FIO___DAY_NAMES[tm->tm_wday][2];
  return dest + 3;
}

FIO_SFUNC char *fio_time_write_month(char *dest, const struct tm *tm) {
  // clang-format off
  static const char *FIO___MONTH_NAMES[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
  // clang-format on
  dest[0] = FIO___MONTH_NAMES[tm->tm_mon][0];
  dest[1] = FIO___MONTH_NAMES[tm->tm_mon][1];
  dest[2] = FIO___MONTH_NAMES[tm->tm_mon][2];
  return dest + 3;
}

FIO_SFUNC char *fio_time_write_year(char *dest, const struct tm *tm) {
  int64_t year = tm->tm_year + 1900;
  const size_t digits = fio_digits10(year);
  fio_ltoa10(dest, year, digits);
  return dest + digits;
}

/** Writes an RFC 7231 date representation (HTTP date format) to target. */
SFUNC size_t fio_time2rfc7231(char *target, time_t time) {
  const struct tm tm = fio_time2gm(time);
  /* note: day of month is always 2 digits */
  char *pos = target;
  uint16_t tmp;
  pos = fio_time_write_day(pos, &tm);
  *pos++ = ',';
  *pos++ = ' ';
  tmp = tm.tm_mday / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_mday - (tmp * 10));
  *pos++ = ' ';
  pos = fio_time_write_month(pos, &tm);
  *pos++ = ' ';
  pos = fio_time_write_year(pos, &tm);
  *pos++ = ' ';
  tmp = tm.tm_hour / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_hour - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_min / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_min - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_sec / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_sec - (tmp * 10));
  *pos++ = ' ';
  *pos++ = 'G';
  *pos++ = 'M';
  *pos++ = 'T';
  *pos = 0;
  return pos - target;
}
/** Writes an RFC 2109 date representation to target. */
SFUNC size_t fio_time2rfc2109(char *target, time_t time) {
  const struct tm tm = fio_time2gm(time);
  /* note: day of month is always 2 digits */
  char *pos = target;
  uint16_t tmp;
  pos = fio_time_write_day(pos, &tm);
  *pos++ = ',';
  *pos++ = ' ';
  tmp = tm.tm_mday / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_mday - (tmp * 10));
  *pos++ = ' ';
  pos = fio_time_write_month(pos, &tm);
  *pos++ = ' ';
  pos = fio_time_write_year(pos, &tm);
  *pos++ = ' ';
  tmp = tm.tm_hour / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_hour - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_min / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_min - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_sec / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_sec - (tmp * 10));
  *pos++ = ' ';
  *pos++ = '-';
  *pos++ = '0';
  *pos++ = '0';
  *pos++ = '0';
  *pos++ = '0';
  *pos = 0;
  return pos - target;
}

/** Writes an RFC 2822 date representation to target. */
SFUNC size_t fio_time2rfc2822(char *target, time_t time) {
  const struct tm tm = fio_time2gm(time);
  /* note: day of month is either 1 or 2 digits */
  char *pos = target;
  uint16_t tmp;
  pos = fio_time_write_day(pos, &tm);
  *pos++ = ',';
  *pos++ = ' ';
  if (tm.tm_mday < 10) {
    *pos++ = '0' + tm.tm_mday;
  } else {
    tmp = tm.tm_mday / 10;
    *pos++ = '0' + tmp;
    *pos++ = '0' + (tm.tm_mday - (tmp * 10));
  }
  *pos++ = '-';
  pos = fio_time_write_month(pos, &tm);
  *pos++ = '-';
  pos = fio_time_write_year(pos, &tm);
  *pos++ = ' ';
  tmp = tm.tm_hour / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_hour - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_min / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_min - (tmp * 10));
  *pos++ = ':';
  tmp = tm.tm_sec / 10;
  *pos++ = '0' + tmp;
  *pos++ = '0' + (tm.tm_sec - (tmp * 10));
  *pos++ = ' ';
  *pos++ = 'G';
  *pos++ = 'M';
  *pos++ = 'T';
  *pos = 0;
  return pos - target;
}

/**
 * Writes a date representation to target in common log format. i.e.,
 *
 *         [DD/MMM/yyyy:hh:mm:ss +0000]
 *
 * Usually requires 29 characters (includiing square brackes and NUL).
 */
SFUNC size_t fio_time2log(char *target, time_t time) {
  {
    const struct tm tm = fio_time2gm(time);
    /* note: day of month is either 1 or 2 digits */
    char *pos = target;
    uint16_t tmp;
    *pos++ = '[';
    tmp = tm.tm_mday / 10;
    *pos++ = '0' + tmp;
    *pos++ = '0' + (tm.tm_mday - (tmp * 10));
    *pos++ = '/';
    pos = fio_time_write_month(pos, &tm);
    *pos++ = '/';
    pos = fio_time_write_year(pos, &tm);
    *pos++ = ':';
    tmp = tm.tm_hour / 10;
    *pos++ = '0' + tmp;
    *pos++ = '0' + (tm.tm_hour - (tmp * 10));
    *pos++ = ':';
    tmp = tm.tm_min / 10;
    *pos++ = '0' + tmp;
    *pos++ = '0' + (tm.tm_min - (tmp * 10));
    *pos++ = ':';
    tmp = tm.tm_sec / 10;
    *pos++ = '0' + tmp;
    *pos++ = '0' + (tm.tm_sec - (tmp * 10));
    *pos++ = ' ';
    *pos++ = '+';
    *pos++ = '0';
    *pos++ = '0';
    *pos++ = '0';
    *pos++ = '0';
    *pos++ = ']';
    *(pos) = 0;
    return pos - target;
  }
}

/* *****************************************************************************
Time - test
***************************************************************************** */
#ifdef FIO_TEST_CSTL

#define FIO___GMTIME_TEST_INTERVAL ((60LL * 60 * 23) + 1027) /* 23:17:07 */
#if 1 || FIO_OS_WIN
#define FIO___GMTIME_TEST_RANGE (1001LL * 376) /* test 0.5 millenia */
#else
#define FIO___GMTIME_TEST_RANGE (3003LL * 376) /* test ~3  millenia */
#endif

FIO_SFUNC void FIO_NAME_TEST(stl, time)(void) {
  fprintf(stderr, "* Testing facil.io fio_time2gm vs gmtime_r\n");
  struct tm tm1 = {0}, tm2 = {0};
  const time_t now = fio_time_real().tv_sec;
#if FIO_OS_WIN
  const time_t end = (FIO___GMTIME_TEST_RANGE * FIO___GMTIME_TEST_INTERVAL);
  time_t t = 1; /* Windows fails on some date ranges. */
#else
  const time_t end =
      now + (FIO___GMTIME_TEST_RANGE * FIO___GMTIME_TEST_INTERVAL);
  time_t t = now - (FIO___GMTIME_TEST_RANGE * FIO___GMTIME_TEST_INTERVAL);
#endif
  FIO_ASSERT(t < end, "time testing range overflowed.");
  do {
    time_t tmp = t;
    t += FIO___GMTIME_TEST_INTERVAL;
    tm2 = fio_time2gm(tmp);
    FIO_ASSERT(fio_gm2time(tm2) == tmp,
               "fio_gm2time roundtrip error (%zu != %zu)",
               (size_t)fio_gm2time(tm2),
               (size_t)tmp);
    gmtime_r(&tmp, &tm1);
    if (tm1.tm_year != tm2.tm_year || tm1.tm_mon != tm2.tm_mon ||
        tm1.tm_mday != tm2.tm_mday || tm1.tm_yday != tm2.tm_yday ||
        tm1.tm_hour != tm2.tm_hour || tm1.tm_min != tm2.tm_min ||
        tm1.tm_sec != tm2.tm_sec || tm1.tm_wday != tm2.tm_wday) {
      char buf[256];
      FIO_LOG_ERROR("system gmtime_r != fio_time2gm for %ld!\n", (long)t);
      fio_time2rfc7231(buf, tmp);
      FIO_ASSERT(0,
                 "\n"
                 "-- System:\n"
                 "\ttm_year: %d\n"
                 "\ttm_mon: %d\n"
                 "\ttm_mday: %d\n"
                 "\ttm_yday: %d\n"
                 "\ttm_hour: %d\n"
                 "\ttm_min: %d\n"
                 "\ttm_sec: %d\n"
                 "\ttm_wday: %d\n"
                 "-- facil.io:\n"
                 "\ttm_year: %d\n"
                 "\ttm_mon: %d\n"
                 "\ttm_mday: %d\n"
                 "\ttm_yday: %d\n"
                 "\ttm_hour: %d\n"
                 "\ttm_min: %d\n"
                 "\ttm_sec: %d\n"
                 "\ttm_wday: %d\n"
                 "-- As String:\n"
                 "\t%s",
                 tm1.tm_year,
                 tm1.tm_mon,
                 tm1.tm_mday,
                 tm1.tm_yday,
                 tm1.tm_hour,
                 tm1.tm_min,
                 tm1.tm_sec,
                 tm1.tm_wday,
                 tm2.tm_year,
                 tm2.tm_mon,
                 tm2.tm_mday,
                 tm2.tm_yday,
                 tm2.tm_hour,
                 tm2.tm_min,
                 tm2.tm_sec,
                 tm2.tm_wday,
                 buf);
    }
  } while (t < end);
  {
    char buf[48];
    buf[47] = 0;
    FIO_MEMSET(buf, 'X', 47);
    fio_time2rfc7231(buf, now);
    FIO_LOG_DEBUG2("fio_time2rfc7231:   %s", buf);
    FIO_MEMSET(buf, 'X', 47);
    fio_time2rfc2109(buf, now);
    FIO_LOG_DEBUG2("fio_time2rfc2109:   %s", buf);
    FIO_MEMSET(buf, 'X', 47);
    fio_time2rfc2822(buf, now);
    FIO_LOG_DEBUG2("fio_time2rfc2822:   %s", buf);
    FIO_MEMSET(buf, 'X', 47);
    fio_time2log(buf, now);
    FIO_LOG_DEBUG2("fio_time2log:       %s", buf);
  }
  {
    uint64_t start, stop;
#if DEBUG
    fprintf(stderr, "PERFOMEANCE TESTS IN DEBUG MODE ARE BIASED\n");
#endif
    fprintf(stderr, "  Performance testing fio_time2gm vs gmtime_r\n");
    start = fio_time_micro();
    for (size_t i = 0; i < (1 << 17); ++i) {
      volatile struct tm tm = fio_time2gm(now);
      FIO_COMPILER_GUARD;
      (void)tm;
    }
    stop = fio_time_micro();
    fprintf(stderr,
            "\t- fio_time2gm speed test took:\t%zuus\n",
            (size_t)(stop - start));
    start = fio_time_micro();
    for (size_t i = 0; i < (1 << 17); ++i) {
      volatile struct tm tm;
      time_t tmp = now;
      gmtime_r(&tmp, (struct tm *)&tm);
      FIO_COMPILER_GUARD;
    }
    stop = fio_time_micro();
    fprintf(stderr,
            "\t- gmtime_r speed test took:  \t%zuus\n",
            (size_t)(stop - start));
    fprintf(stderr, "\n");
    struct tm tm_now = fio_time2gm(now);
    start = fio_time_micro();
    for (size_t i = 0; i < (1 << 17); ++i) {
      tm_now = fio_time2gm(now + i);
      time_t t_tmp = fio_gm2time(tm_now);
      FIO_COMPILER_GUARD;
      (void)t_tmp;
    }
    stop = fio_time_micro();
    fprintf(stderr,
            "\t- fio_gm2time speed test took:\t%zuus\n",
            (size_t)(stop - start));
    start = fio_time_micro();
    for (size_t i = 0; i < (1 << 17); ++i) {
      tm_now = fio_time2gm(now + i);
      volatile time_t t_tmp = mktime((struct tm *)&tm_now);
      FIO_COMPILER_GUARD;
      (void)t_tmp;
    }
    stop = fio_time_micro();
    fprintf(stderr,
            "\t- mktime speed test took:    \t%zuus\n",
            (size_t)(stop - start));
    fprintf(stderr, "\n");
  }
  /* TODO: test fio_time_add, fio_time_add_milli, and fio_time_cmp */
}
#undef FIO___GMTIME_TEST_INTERVAL
#undef FIO___GMTIME_TEST_RANGE
#endif /* FIO_TEST_CSTL */

/* *****************************************************************************
Time Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_TIME
#endif /* FIO_TIME */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_RAND       /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                      Psedo-Random Generator Functions
                    and friends - risky hash / stable hash



Copyright and License: see header file (000 header.h) / top of file
***************************************************************************** */
#if defined(FIO_RAND) && !defined(H___FIO_RAND_H)
#define H___FIO_RAND_H

/* *****************************************************************************
Random - API
***************************************************************************** */

/** Returns 64 psedo-random bits. Probably not cryptographically safe. */
SFUNC uint64_t fio_rand64(void);

/** Writes `len` bytes of psedo-random bits to the target buffer. */
SFUNC void fio_rand_bytes(void *target, size_t len);

/** Feeds up to 1023 bytes of entropy to the random state. */
IFUNC void fio_rand_feed2seed(void *buf_, size_t len);

/** Reseeds the random engin using system state (rusage / jitter). */
IFUNC void fio_rand_reseed(void);

/* *****************************************************************************
Risky / Stable Hash - API
***************************************************************************** */

/** Computes a facil.io Stable Hash (will not be updated, even if broken). */
SFUNC uint64_t fio_stable_hash(const void *data, size_t len, uint64_t seed);

/** Computes a facil.io Stable Hash (will not be updated, even if broken). */
SFUNC void fio_stable_hash128(void *restrict dest,
                              const void *restrict data,
                              size_t len,
                              uint64_t seed);

/** Computes a facil.io Risky Hash (Risky v.3). */
SFUNC uint64_t fio_risky_hash(const void *buf, size_t len, uint64_t seed);

/** Adds bit of entropy to pointer values. Designed to be unsafe. */
FIO_IFUNC uint64_t fio_risky_ptr(void *ptr);

/**
 * Masks data using using `fio_xmask2` with sensible defaults for the key and
 * the counter mode nonce.
 *
 * Used for mitigating memory access attacks when storing "secret" information
 * in memory.
 *
 * This is NOT a cryptographically secure encryption. Even if the algorithm was
 * secure, it would provide no more then a 32bit level encryption for a small
 * amount of data, which isn't strong enough for any cryptographic use-case.
 *
 * However, this could be used to mitigate memory probing attacks. Secrets
 * stored in the memory might remain accessible after the program exists or
 * through core dump information. By storing "secret" information masked in this
 * way, it mitigates the risk of secret information being recognized or
 * deciphered.
 *
 * NOTE: uses the pointer as part of the key, so masked data can't be moved.
 */
FIO_IFUNC void fio_risky_mask(char *buf, size_t len);

/* *****************************************************************************
Risky Hash - Implementation

Note: I don't remember what information I used when designing this, but Risky
Hash is probably NOT cryptographically safe (though I wanted it to be).

Here's a few resources about hashes that might explain more:
- https://komodoplatform.com/cryptographic-hash-function/
- https://en.wikipedia.org/wiki/Avalanche_effect
- http://ticki.github.io/blog/designing-a-good-non-cryptographic-hash-function/

***************************************************************************** */

/* Risky Hash primes */
#define FIO_RISKY3_PRIME0 0x39664DEECA23D825ULL
#define FIO_RISKY3_PRIME1 0x48644F7B3959621FULL
#define FIO_RISKY3_PRIME2 0x613A19F5CB0D98D5ULL
#define FIO_RISKY3_PRIME3 0x84B56B93C869EA0FULL
#define FIO_RISKY3_PRIME4 0x8EE38D13E0D95A8DULL

/* Stable Hash primes */
#define FIO_STABLE_HASH_PRIME0 0x39664DEECA23D825ULL /* 32 set bits & prime */
#define FIO_STABLE_HASH_PRIME1 0x48644F7B3959621FULL /* 32 set bits & prime */
#define FIO_STABLE_HASH_PRIME2 0x613A19F5CB0D98D5ULL /* 32 set bits & prime */
#define FIO_STABLE_HASH_PRIME3 0x84B56B93C869EA0FULL /* 32 set bits & prime */
#define FIO_STABLE_HASH_PRIME4 0x8EE38D13E0D95A8DULL /* 32 set bits & prime */

/** Adds bit entropy to a pointer values. Designed to be unsafe. */
FIO_IFUNC uint64_t fio_risky_ptr(void *ptr) {
  uint64_t n = (uint64_t)(uintptr_t)ptr;
  n ^= (n + FIO_RISKY3_PRIME0) * FIO_RISKY3_PRIME1;
  n ^= fio_rrot64(n, 7);
  n ^= fio_rrot64(n, 13);
  n ^= fio_rrot64(n, 17);
  n ^= fio_rrot64(n, 31);
  return n;
}

/* *****************************************************************************
Possibly `extern` Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* Risky Hash initialization constants */
#define FIO_RISKY3_IV0 0x0000001000000001ULL
#define FIO_RISKY3_IV1 0x0000010000000010ULL
#define FIO_RISKY3_IV2 0x0000100000000100ULL
#define FIO_RISKY3_IV3 0x0001000000001000ULL
/* read u64 in local endian */
#define FIO_RISKY_BUF2U64 fio_buf2u64_local

/*  Computes a facil.io Risky Hash. */
SFUNC uint64_t fio_risky_hash(const void *data_, size_t len, uint64_t seed) {
  uint64_t v[4] FIO_ALIGN(
      32) = {FIO_RISKY3_IV0, FIO_RISKY3_IV1, FIO_RISKY3_IV2, FIO_RISKY3_IV3};
  uint64_t w[4] FIO_ALIGN(32);
  const uint8_t *data = (const uint8_t *)data_;

#define FIO_RISKY3_ROUND64(vi, w_)                                             \
  w[vi] = w_;                                                                  \
  v[vi] += w[vi];                                                              \
  v[vi] = fio_lrot64(v[vi], 29);                                               \
  v[vi] += w[vi];                                                              \
  v[vi] *= FIO_RISKY3_PRIME##vi;

#define FIO_RISKY3_ROUND256(w0, w1, w2, w3)                                    \
  FIO_RISKY3_ROUND64(0, w0);                                                   \
  FIO_RISKY3_ROUND64(1, w1);                                                   \
  FIO_RISKY3_ROUND64(2, w2);                                                   \
  FIO_RISKY3_ROUND64(3, w3);

  if (seed) {
    /* process the seed as if it was a prepended 8 Byte string. */
    v[0] *= seed;
    v[1] *= seed;
    v[2] *= seed;
    v[3] *= seed;
    v[1] ^= seed;
    v[2] ^= seed;
    v[3] ^= seed;
  }

  for (size_t i = 31; i < len; i += 32) {
    /* 32 bytes / 256 bit access */
    FIO_RISKY3_ROUND256(FIO_RISKY_BUF2U64(data),
                        FIO_RISKY_BUF2U64(data + 8),
                        FIO_RISKY_BUF2U64(data + 16),
                        FIO_RISKY_BUF2U64(data + 24));
    data += 32;
  }
  switch (len & 24) {
  case 24: FIO_RISKY3_ROUND64(2, FIO_RISKY_BUF2U64(data + 16)); /*fall through*/
  case 16: FIO_RISKY3_ROUND64(1, FIO_RISKY_BUF2U64(data + 8));  /*fall through*/
  case 8: FIO_RISKY3_ROUND64(0, FIO_RISKY_BUF2U64(data + 0)); data += len & 24;
  }

  /* add offset information to padding */
  uint64_t tmp = ((uint64_t)len & 0xFF) << 56;
  /* leftover bytes */
  switch ((len & 7)) {
  case 7: tmp |= ((uint64_t)data[6]) << 48; /* fall through */
  case 6: tmp |= ((uint64_t)data[5]) << 40; /* fall through */
  case 5: tmp |= ((uint64_t)data[4]) << 32; /* fall through */
  case 4: tmp |= ((uint64_t)data[3]) << 24; /* fall through */
  case 3: tmp |= ((uint64_t)data[2]) << 16; /* fall through */
  case 2: tmp |= ((uint64_t)data[1]) << 8;  /* fall through */
  case 1:
    tmp |= ((uint64_t)data[0]);
    switch ((len & 24)) { /* the last (now padded) byte's position */
    case 24: FIO_RISKY3_ROUND64(3, tmp); break; /*offset 24 in 32 byte segment*/
    case 16: FIO_RISKY3_ROUND64(2, tmp); break; /*offset 16 in 32 byte segment*/
    case 8: FIO_RISKY3_ROUND64(1, tmp); break;  /*offset  8 in 32 byte segment*/
    case 0: FIO_RISKY3_ROUND64(0, tmp); break;  /*offset  0 in 32 byte segment*/
    }
  }

  /* irreversible avalanche... I think */
  uint64_t r = (len) ^ ((uint64_t)len << 36);
  r += fio_lrot64(v[0], 17) + fio_lrot64(v[1], 13) + fio_lrot64(v[2], 47) +
       fio_lrot64(v[3], 57);
  r += v[0] ^ v[1];
  r ^= fio_lrot64(r, 13);
  r += v[1] ^ v[2];
  r ^= fio_lrot64(r, 29);
  r += v[2] ^ v[3];
  r += fio_lrot64(r, 33);
  r += v[3] ^ v[0];
  r ^= fio_lrot64(r, 51);
  r ^= (r >> 29) * FIO_RISKY3_PRIME4;
  return r;
}

/** Masks data using a Risky Hash and a counter mode nonce. */
IFUNC void fio_risky_mask(char *buf, size_t len) {
  static uint64_t key1 = 0, key2 = 0;
  if (!key1) { /* initialize keys on first use */
    do {
      key1 = fio_rand64();
      key2 = fio_rand64();
    } while (((!key1) | (!key2)));
    key2 >>= ((key2 + 1) & 1); /* make sure it's an odd random number */
  }
  uint64_t hash = fio_risky_ptr(buf) + key1;
  hash |= (0ULL - (!hash)) & FIO_RISKY3_PRIME0; /* avoid a zero initial key */
  fio_xmask2(buf, len, hash, key2);
}

#undef FIO_RISKY3_IV0
#undef FIO_RISKY3_IV1
#undef FIO_RISKY3_IV2
#undef FIO_RISKY3_IV3
#undef FIO_RISKY_BUF2U64
#undef FIO_RISKY3_ROUND64
#undef FIO_RISKY3_ROUND256

/* *****************************************************************************
Stable Hash (unlike Risky Hash, this can be used for non-ephemeral hashing)
***************************************************************************** */

#define FIO_STABLE_HASH_MUL_PRIME(dest)                                        \
  (dest)[0] = v[0] * prime[0]; /* FIO_STABLE_HASH_PRIME0 */                    \
  (dest)[1] = v[1] * prime[1]; /* FIO_STABLE_HASH_PRIME1 */                    \
  (dest)[2] = v[2] * prime[2]; /* FIO_STABLE_HASH_PRIME2 */                    \
  (dest)[3] = v[3] * prime[3]  /* FIO_STABLE_HASH_PRIME3 */
#define FIO_STABLE_HASH_ROUND_FULL()                                           \
  v[0] ^= w[0];                                                                \
  v[1] ^= w[1];                                                                \
  v[2] ^= w[2];                                                                \
  v[3] ^= w[3];                                                                \
  FIO_STABLE_HASH_MUL_PRIME(v);                                                \
  w[0] = fio_lrot64(w[0], 31);                                                 \
  w[1] = fio_lrot64(w[1], 31);                                                 \
  w[2] = fio_lrot64(w[2], 31);                                                 \
  w[3] = fio_lrot64(w[3], 31);                                                 \
  w[0] ^= seed;                                                                \
  w[1] ^= seed;                                                                \
  w[2] ^= seed;                                                                \
  w[3] ^= seed;                                                                \
  v[0] += w[0];                                                                \
  v[1] += w[1];                                                                \
  v[2] += w[2];                                                                \
  v[3] += w[3]

FIO_IFUNC void fio_stable_hash___inner(uint64_t *dest,
                                       const void *restrict data_,
                                       size_t len,
                                       uint64_t seed) {
  const uint8_t *data = (const uint8_t *)data_;
  /* seed selection is constant time to avoid leaking seed data */
  seed += len;
  seed ^= fio_lrot64(seed, 47);
  seed ^= FIO_STABLE_HASH_PRIME4;
  typedef uint64_t fio___shash_vec_u[4] FIO_ALIGN(16);
  fio___shash_vec_u w, v = {seed, seed, seed, seed};
  fio___shash_vec_u const prime = {FIO_STABLE_HASH_PRIME0,
                                   FIO_STABLE_HASH_PRIME1,
                                   FIO_STABLE_HASH_PRIME2,
                                   FIO_STABLE_HASH_PRIME3};

  for (size_t i = 31; i < len; i += 32) {
    /* consumes 32 bytes (256 bits) each loop */
    fio_memcpy32(w, data);
    w[0] = fio_ltole64(w[0]); /* make sure we're using little endien */
    w[1] = fio_ltole64(w[1]);
    w[2] = fio_ltole64(w[2]);
    w[3] = fio_ltole64(w[3]);
    seed ^= w[0] + w[1] + w[2] + w[3];
    FIO_STABLE_HASH_ROUND_FULL();
    data += 32;
  }
  /* copy bytes to the word block in little endian */
  if ((len & 31)) {
    w[0] = w[1] = w[2] = w[3] = 0; /* sets padding to 0 */
    fio_memcpy31x(w, data, len);   /* copies `len & 31` bytes */
    w[0] = fio_ltole64(w[0]);      /* make sure we're using little endien */
    w[1] = fio_ltole64(w[1]);
    w[2] = fio_ltole64(w[2]);
    w[3] = fio_ltole64(w[3]);
    FIO_STABLE_HASH_ROUND_FULL();
  }
  /* inner vector mini-avalanche */
  FIO_STABLE_HASH_MUL_PRIME(v);
  v[0] ^= fio_lrot64(v[0], 7);
  v[1] ^= fio_lrot64(v[1], 11);
  v[2] ^= fio_lrot64(v[2], 13);
  v[3] ^= fio_lrot64(v[3], 17);

  dest[0] = v[0];
  dest[1] = v[1];
  dest[2] = v[2];
  dest[3] = v[3];
  return;
}

/*  Computes a facil.io Stable Hash. */
SFUNC uint64_t fio_stable_hash(const void *data_, size_t len, uint64_t seed) {
  uint64_t r;
  uint64_t v[4] FIO_ALIGN(16);
  fio_stable_hash___inner(v, data_, len, seed);
  /* summing avalanche */
  r = v[0] + v[1] + v[2] + v[3];
  r ^= r >> 31;
  r *= FIO_STABLE_HASH_PRIME4;
  r ^= r >> 31;
  return r;
}

SFUNC void fio_stable_hash128(void *restrict dest,
                              const void *restrict data_,
                              size_t len,
                              uint64_t seed) {
  uint64_t FIO_ALIGN(16) v[4];
  fio_stable_hash___inner(v, data_, len, seed);
  uint64_t r[2];
  r[0] = v[0] + v[1] + v[2] + v[3];
  r[1] = v[0] ^ v[1] ^ v[2] ^ v[3];
  r[0] ^= r[0] >> 31;
  r[1] ^= r[1] >> 31;
  r[0] *= FIO_STABLE_HASH_PRIME4;
  r[1] *= FIO_STABLE_HASH_PRIME0;
  r[0] ^= r[0] >> 31;
  r[1] ^= r[1] >> 31;
  fio_memcpy16(dest, r);
}

#undef FIO_STABLE_HASH_MUL_PRIME
#undef FIO_STABLE_HASH_ROUND_FULL

/* *****************************************************************************
Random - Implementation
***************************************************************************** */

#if FIO_OS_POSIX ||                                                            \
    (__has_include("sys/resource.h") && __has_include("sys/time.h"))
#include <sys/resource.h>
#include <sys/time.h>
#endif

static volatile uint64_t fio___rand_state[4]; /* random state */
static volatile size_t fio___rand_counter;    /* seed counter */
/* feeds random data to the algorithm through this 256 bit feed. */
static volatile uint64_t fio___rand_buffer[4] = {0x9c65875be1fce7b9ULL,
                                                 0x7cc568e838f6a40d,
                                                 0x4bb8d885a0fe47d5,
                                                 0x95561f0927ad7ecd};

IFUNC void fio_rand_feed2seed(void *buf_, size_t len) {
  len &= 1023;
  uint8_t *buf = (uint8_t *)buf_;
  uint8_t offset = (fio___rand_counter & 3);
  uint64_t tmp = 0;
  for (size_t i = 0; i < (len >> 3); ++i) {
    tmp = FIO_NAME2(fio_buf, u64_local)(buf);
    fio___rand_buffer[(offset++ & 3)] ^= tmp;
    buf += 8;
  }
  switch (len & 7) {
  case 7: tmp <<= 8; tmp |= buf[6]; /* fall through */
  case 6: tmp <<= 8; tmp |= buf[5]; /* fall through */
  case 5: tmp <<= 8; tmp |= buf[4]; /* fall through */
  case 4: tmp <<= 8; tmp |= buf[3]; /* fall through */
  case 3: tmp <<= 8; tmp |= buf[2]; /* fall through */
  case 2: tmp <<= 8; tmp |= buf[1]; /* fall through */
  case 1:
    tmp <<= 8;
    tmp |= buf[1];
    fio___rand_buffer[(offset & 3)] ^= tmp;
  }
}

/* used here, defined later */
FIO_IFUNC int64_t fio_time_nano();

IFUNC void fio_rand_reseed(void) {
  const size_t jitter_samples = 16 | (fio___rand_state[0] & 15);
#if defined(RUSAGE_SELF)
  {
    struct rusage rusage;
    getrusage(RUSAGE_SELF, &rusage);
    fio___rand_state[0] ^=
        fio_risky_hash(&rusage, sizeof(rusage), fio___rand_state[0]);
  }
#endif
  for (size_t i = 0; i < jitter_samples; ++i) {
    uint64_t clk = (uint64_t)fio_time_nano();
    fio___rand_state[0] ^=
        fio_risky_hash(&clk, sizeof(clk), fio___rand_state[0] + i);
    clk = fio_time_nano();
    fio___rand_state[1] ^=
        fio_risky_hash(&clk,
                       sizeof(clk),
                       fio___rand_state[1] + fio___rand_counter);
  }
  fio___rand_state[2] ^=
      fio_risky_hash((void *)fio___rand_buffer,
                     sizeof(fio___rand_buffer),
                     fio___rand_counter + fio___rand_state[0]);
  fio___rand_state[3] ^= fio_risky_hash((void *)fio___rand_state,
                                        sizeof(fio___rand_state),
                                        fio___rand_state[1] + jitter_samples);
  fio___rand_buffer[0] = fio_lrot64(fio___rand_buffer[0], 31);
  fio___rand_buffer[1] = fio_lrot64(fio___rand_buffer[1], 29);
  fio___rand_buffer[2] ^= fio___rand_buffer[0];
  fio___rand_buffer[3] ^= fio___rand_buffer[1];
  fio___rand_counter += jitter_samples;
}

/* tested for randomness using code from: http://xoshiro.di.unimi.it/hwd.php */
SFUNC uint64_t fio_rand64(void) {
  /* modeled after xoroshiro128+, by David Blackman and Sebastiano Vigna */
  const uint64_t P[] = {0x37701261ED6C16C7ULL, 0x764DBBB75F3B3E0DULL};
  if (((fio___rand_counter++) & (((size_t)1 << 19) - 1)) == 0) {
    /* re-seed state every 524,288 requests / 2^19-1 attempts  */
    fio_rand_reseed();
  }
  fio___rand_state[0] +=
      (fio_lrot64(fio___rand_state[0], 33) + fio___rand_counter) * P[0];
  fio___rand_state[1] += fio_lrot64(fio___rand_state[1], 33) * P[1];
  fio___rand_state[2] +=
      (fio_lrot64(fio___rand_state[2], 33) + fio___rand_counter) * (~P[0]);
  fio___rand_state[3] += fio_lrot64(fio___rand_state[3], 33) * (~P[1]);
  return fio_lrot64(fio___rand_state[0], 31) +
         fio_lrot64(fio___rand_state[1], 29) +
         fio_lrot64(fio___rand_state[2], 27) +
         fio_lrot64(fio___rand_state[3], 30);
}

/* copies 64 bits of randomness (8 bytes) repeatedly. */
SFUNC void fio_rand_bytes(void *data_, size_t len) {
  if (!data_ || !len)
    return;
  uint8_t *data = (uint8_t *)data_;
  for (unsigned i = 31; i < len; i += 32) {
    uint64_t rv[4] = {fio_rand64(), fio_rand64(), fio_rand64(), fio_rand64()};
    fio_memcpy32(data, rv);
    data += 32;
  }
  if (len & 31) {
    uint64_t rv[4] = {fio_rand64(), fio_rand64(), fio_rand64(), fio_rand64()};
    fio_memcpy31x(data, rv, len);
  }
}

/* *****************************************************************************
FIO_RAND Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

/* *****************************************************************************
Playhouse hashing (next risky version)
***************************************************************************** */

typedef union {
  uint64_t v[4] FIO_ALIGN(16);
#ifdef __SIZEOF_INT128__
  __uint128_t u128[2];
#endif
} fio___r2hash_s;

FIO_IFUNC fio___r2hash_s fio_risky2_hash___inner(const void *restrict data_,
                                                 size_t len,
                                                 uint64_t seed) {
  fio___r2hash_s v = {.v = {seed, seed, seed, seed}};
  fio___r2hash_s const prime = {.v = {FIO_STABLE_HASH_PRIME0,
                                      FIO_STABLE_HASH_PRIME1,
                                      FIO_STABLE_HASH_PRIME2,
                                      FIO_STABLE_HASH_PRIME3}};
  fio___r2hash_s w;
  const uint8_t *data = (const uint8_t *)data_;
  /* seed selection is constant time to avoid leaking seed data */
  seed += len;
  seed ^= fio_lrot64(seed, 47);
  seed ^= FIO_STABLE_HASH_PRIME4;

#define FIO___R2_ROUND(i) /* this version passes all, but fast enough? */      \
  w.v[i] = fio_ltole64(w.v[i]); /* make sure we're using little endien? */     \
  v.v[i] ^= w.v[i];                                                            \
  v.v[i] *= prime.v[i];                                                        \
  w.v[i] = fio_lrot64(w.v[i], 31);                                             \
  v.v[i] += w.v[i];                                                            \
  v.v[i] ^= seed;

  /* consumes 32 bytes (256 bits) blocks (no padding needed) */
  for (size_t pos = 31; pos < len; pos += 32) {
    for (size_t i = 0; i < 4; ++i) {
      fio_memcpy8(w.v + i, data + (i << 3));
      FIO___R2_ROUND(i);
    }
    seed += w.v[0] + w.v[1] + w.v[2] + w.v[3];
    data += 32;
  }
#if (FIO___R2_PERFORM_FULL_BLOCK + 1) && 1
  if (len & 31) { // pad with zeros
    uint64_t tmp_buf[4] = {0};
    fio_memcpy31x(tmp_buf, data, len);
    for (size_t i = 0; i < 4; ++i) {
      w.v[0] = tmp_buf[1];
      FIO___R2_ROUND(i);
    }
  }
#else
  switch (len & 24) { /* only performed if data exits in these positions */
  case 24: fio_memcpy8(w.v + 2, data + 16); FIO___R2_ROUND(2); /*fall through*/
  case 16: fio_memcpy8(w.v + 1, data + 8); FIO___R2_ROUND(1);  /*fall through*/
  case 8:
    fio_memcpy8(w.v + 0, data);
    FIO___R2_ROUND(0);
    data += len & 24;
  }
  if (len & 7) {
    uint64_t i = (len & 24) >> 3;
    w.v[i] = 0;
    fio_memcpy7x(w.v + i, data, len);
    FIO___R2_ROUND(i);
  }
#endif

  /* inner vector mini-avalanche */
  for (size_t i = 0; i < 4; ++i)
    v.v[i] *= prime.v[i];
  v.v[0] ^= fio_lrot64(v.v[0], 7);
  v.v[1] ^= fio_lrot64(v.v[1], 11);
  v.v[2] ^= fio_lrot64(v.v[2], 13);
  v.v[3] ^= fio_lrot64(v.v[3], 17);
  return v;
#undef FIO___R2_ROUND
}

/*  Computes a facil.io Stable Hash. */
FIO_SFUNC uint64_t fio_risky2_hash(const void *data_,
                                   size_t len,
                                   uint64_t seed) {
  uint64_t r;
  fio___r2hash_s v = fio_risky2_hash___inner(data_, len, seed);
  /* summing avalanche */
  r = v.v[0] + v.v[1] + v.v[2] + v.v[3];
  r ^= r >> 31;
  r *= FIO_STABLE_HASH_PRIME4;
  r ^= r >> 31;
  return r;
}

FIO_SFUNC void fio_risky2_hash128(void *restrict dest,
                                  const void *restrict data_,
                                  size_t len,
                                  uint64_t seed) {
  fio___r2hash_s v = fio_risky2_hash___inner(data_, len, seed);
  uint64_t r[2];
  r[0] = v.v[0] + v.v[1] + v.v[2] + v.v[3];
  r[1] = v.v[0] ^ v.v[1] ^ v.v[2] ^ v.v[3];
  r[0] ^= r[0] >> 31;
  r[1] ^= r[1] >> 31;
  r[0] *= FIO_STABLE_HASH_PRIME4;
  r[1] *= FIO_STABLE_HASH_PRIME0;
  r[0] ^= r[0] >> 31;
  r[1] ^= r[1] >> 31;
  fio_memcpy16(dest, r);
}

#undef FIO___R2_HASH_MUL_PRIME
#undef FIO___R2_HASH_ROUND_FULL

/* *****************************************************************************
Hashing speed test
***************************************************************************** */
#include <math.h>

typedef uintptr_t (*fio__hashing_func_fn)(char *, size_t);

FIO_SFUNC void fio_test_hash_function(fio__hashing_func_fn h,
                                      char *name,
                                      uint8_t size_log,
                                      uint8_t mem_alignment_offset,
                                      uint8_t fast) {
  /* test based on code from BearSSL with credit to Thomas Pornin */
  if (size_log >= 21 || ((sizeof(uint64_t) - 1) >> size_log)) {
    FIO_LOG_ERROR("fio_test_hash_function called with a log size too big.");
    return;
  }
  mem_alignment_offset &= 7;
  size_t const buffer_len = (1ULL << size_log) - mem_alignment_offset;
  uint64_t cycles_start_at = (1ULL << (14 + (fast * 3)));
  if (size_log < 13)
    cycles_start_at <<= (13 - size_log);
  else if (size_log > 13)
    cycles_start_at >>= (size_log - 13);

#ifdef DEBUG
  fprintf(stderr,
          "* Testing %s speed with %zu byte blocks"
          "(DEBUG mode detected - speed may be affected).\n",
          name,
          buffer_len);
#else
  fprintf(stderr,
          "* Testing %s speed with %zu byte blocks.\n",
          name,
          buffer_len);
#endif

  uint8_t *buffer_mem = (uint8_t *)
      FIO_MEM_REALLOC(NULL, 0, (buffer_len + mem_alignment_offset) + 64, 0);
  uint8_t *buffer = buffer_mem + mem_alignment_offset;

  FIO_MEMSET(buffer, 'T', buffer_len);
  /* warmup */
  uint64_t hash = 0;
  for (size_t i = 0; i < 4; i++) {
    hash += h((char *)buffer, buffer_len);
    fio_memcpy8(buffer, &hash);
  }
  /* loop until test runs for more than 2 seconds */
  for (uint64_t cycles = cycles_start_at;;) {
    clock_t start, end;
    start = clock();
    for (size_t i = cycles; i > 0; i--) {
      hash += h((char *)buffer, buffer_len);
      FIO_COMPILER_GUARD;
    }
    end = clock();
    fio_memcpy8(buffer, &hash);
    if ((end - start) > CLOCKS_PER_SEC || cycles >= ((uint64_t)1 << 62)) {
      fprintf(stderr,
              "\t%-40s %8.2f MB/s\n",
              name,
              (double)(buffer_len * cycles) /
                  (((end - start) * (1000000.0 / CLOCKS_PER_SEC))));
      break;
    }
    cycles <<= 1;
  }
  FIO_MEM_FREE(buffer_mem, (buffer_len + mem_alignment_offset) + 64);
}

FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, risky_wrapper)(char *buf, size_t len) {
  return fio_risky_hash(buf, len, 1);
}
FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, stable_wrapper)(char *buf, size_t len) {
  return fio_stable_hash(buf, len, 1);
}
FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, risky2_wrapper)(char *buf, size_t len) {
  return fio_risky2_hash(buf, len, 1);
}

FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, risky_mask_wrapper)(char *buf,
                                                           size_t len) {
  fio_risky_mask(buf, len);
  return len;
}

FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, xmask_wrapper)(char *buf, size_t len) {
  fio_xmask(buf, len, fio_rand64());
  return len;
}

/* tests Risky Hash and Stable Hash... takes a while (speed tests as well) */
FIO_SFUNC void FIO_NAME_TEST(stl, risky)(void) {
  fprintf(stderr, "* Testing Risky Hash and Risky Mask (sanity).\n");
  {
    char *str = (char *)"testing that risky hash is always the same hash";
    const size_t len = strlen(str);
    char buf[128];
    FIO_MEMCPY(buf, str, len);
    uint64_t org_hash = fio_risky_hash(buf, len, 0);
    FIO_ASSERT(!memcmp(buf, str, len), "hashing shouldn't touch data");
    for (int i = 0; i < 8; ++i) {
      char *tmp = buf + i;
      FIO_MEMCPY(tmp, str, len);
      uint64_t tmp_hash = fio_risky_hash(tmp, len, 0);
      FIO_ASSERT(tmp_hash == fio_risky_hash(tmp, len, 0),
                 "hash should be consistent!");
      FIO_ASSERT(tmp_hash == org_hash, "memory address shouldn't effect hash!");
    }
  }
  {
    char buf[64];
    const char *str = (char *)"this is a short text, to test risky masking, ok";
    const size_t len = strlen(str); /* 47 */
    for (int i = 0; i < 8; ++i) {
      char *tmp = buf + i;
      FIO_MEMCPY(tmp, str, len);
      tmp[len] = '\xFF';
      FIO_ASSERT(!memcmp(tmp, str, len),
                 "Risky Hash test failed to copy String?!");
      fio_risky_mask(tmp, len);
      FIO_ASSERT(tmp[len] == '\xFF', "Risky Hash overflow corruption!");
      FIO_ASSERT(memcmp(tmp, str, len), "Risky Hash masking failed");
      FIO_ASSERT(memcmp(tmp, str, 8),
                 "Risky Hash masking failed for head of data");
      FIO_ASSERT(memcmp(tmp + (len - 8), str + (len - 8), 8),
                 "Risky Hash mask didn't mask string tail?");
      fio_risky_mask(tmp, len);
      FIO_ASSERT(!memcmp(tmp, str, len),
                 "Risky Hash masking RT failed @ %d\n\t%.*s != %s",
                 i,
                 (int)len,
                 tmp,
                 str);
    }
  }
#if !DEBUG
  fio_test_hash_function(FIO_NAME_TEST(stl, risky_wrapper),
                         (char *)"fio_risky_hash",
                         7,
                         0,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, risky_wrapper),
                         (char *)"fio_risky_hash",
                         13,
                         0,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, risky_wrapper),
                         (char *)"fio_risky_hash (unaligned)",
                         6,
                         3,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, risky_wrapper),
                         (char *)"fio_risky_hash (unaligned)",
                         5,
                         3,
                         2);
  fprintf(stderr, "\n");
  fio_test_hash_function(FIO_NAME_TEST(stl, stable_wrapper),
                         (char *)"fio_stable_hash (64 bit)",
                         7,
                         0,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, stable_wrapper),
                         (char *)"fio_stable_hash (64 bit)",
                         13,
                         0,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, stable_wrapper),
                         (char *)"fio_stable_hash (64 bit unaligned)",
                         6,
                         3,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, stable_wrapper),
                         (char *)"fio_stable_hash (64 bit unaligned)",
                         5,
                         3,
                         2);
  fprintf(stderr, "\n");
  fio_test_hash_function(FIO_NAME_TEST(stl, risky_mask_wrapper),
                         (char *)"fio_risky_mask (Risky XOR + counter)",
                         13,
                         0,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, risky_mask_wrapper),
                         (char *)"fio_risky_mask (unaligned)",
                         13,
                         1,
                         2);
  if (0) {
    fprintf(stderr, "\n");
    fio_test_hash_function(FIO_NAME_TEST(stl, xmask_wrapper),
                           (char *)"fio_xmask (XOR, NO counter)",
                           13,
                           0,
                           2);
    fio_test_hash_function(FIO_NAME_TEST(stl, xmask_wrapper),
                           (char *)"fio_xmask (unaligned)",
                           13,
                           1,
                           2);
  }
  /* playground speed testing */
  fprintf(stderr, "\n");
  fio_test_hash_function(FIO_NAME_TEST(stl, risky2_wrapper),
                         (char *)"rXtest (64 bit)",
                         7,
                         0,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, risky2_wrapper),
                         (char *)"rXtest (64 bit)",
                         13,
                         0,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, risky2_wrapper),
                         (char *)"rXtest (64 bit unaligned)",
                         6,
                         3,
                         2);
  fio_test_hash_function(FIO_NAME_TEST(stl, risky2_wrapper),
                         (char *)"rXtest (64 bit unaligned)",
                         5,
                         3,
                         2);
  fprintf(stderr, "\n");
#endif
}

FIO_SFUNC void FIO_NAME_TEST(stl, random_buffer)(uint64_t *stream,
                                                 size_t len,
                                                 const char *name,
                                                 size_t clk) {
  size_t totals[2] = {0};
  size_t freq[256] = {0};
  const size_t total_bits = (len * sizeof(*stream) * 8);
  uint64_t hemming = 0;
  /* collect data */
  for (size_t i = 1; i < len; i += 2) {
    hemming += fio_hemming_dist(stream[i], stream[i - 1]);
    for (size_t byte = 0; byte < (sizeof(*stream) << 1); ++byte) {
      uint8_t val = ((uint8_t *)(stream + (i - 1)))[byte];
      ++freq[val];
      for (int bit = 0; bit < 8; ++bit) {
        ++totals[(val >> bit) & 1];
      }
    }
  }
  hemming /= len;
  fprintf(stderr, "\n");
#if DEBUG
  fprintf(stderr,
          "\t- \x1B[1m%s\x1B[0m (%zu CPU cycles NOT OPTIMIZED):\n",
          name,
          clk);
#else
  fprintf(stderr, "\t- \x1B[1m%s\x1B[0m (%zu CPU cycles):\n", name, clk);
#endif
  fprintf(stderr,
          "\t  zeros / ones (bit frequency)\t%.05f\n",
          ((float)1.0 * totals[0]) / totals[1]);
  if (!(totals[0] < totals[1] + (total_bits / 20) &&
        totals[1] < totals[0] + (total_bits / 20)))
    FIO_LOG_ERROR("randomness isn't random?");
  fprintf(stderr,
          "\t  avarage hemming distance\t%zu (should be: 14-18)\n",
          (size_t)hemming);
  /* expect avarage hemming distance of 25% == 16 bits */
  if (!(hemming >= 14 && hemming <= 18))
    FIO_LOG_ERROR("randomness isn't random (hemming distance failed)?");
  /* test chi-square ... I think */
  if (len * sizeof(*stream) > 2560) {
    double n_r = (double)1.0 * ((len * sizeof(*stream)) / 256);
    double chi_square = 0;
    for (unsigned int i = 0; i < 256; ++i) {
      double f = freq[i] - n_r;
      chi_square += (f * f);
    }
    chi_square /= n_r;
    double chi_square_r_abs =
        (chi_square - 256 >= 0) ? chi_square - 256 : (256 - chi_square);
    fprintf(
        stderr,
        "\t  chi-sq. variation\t\t%.02lf - %s (expect <= %0.2lf)\n",
        chi_square_r_abs,
        ((chi_square_r_abs <= 2 * (sqrt(n_r)))
             ? "good"
             : ((chi_square_r_abs <= 3 * (sqrt(n_r))) ? "not amazing"
                                                      : "\x1B[1mBAD\x1B[0m")),
        2 * (sqrt(n_r)));
  }
}

FIO_SFUNC void FIO_NAME_TEST(stl, random)(void) {
  fprintf(stderr,
          "* Testing randomness "
          "- bit frequency / hemming distance / chi-square.\n");
  const size_t test_len = (FIO_TEST_REPEAT << 7);
  uint64_t *rs =
      (uint64_t *)FIO_MEM_REALLOC(NULL, 0, sizeof(*rs) * test_len, 0);
  clock_t start, end;
  FIO_ASSERT_ALLOC(rs);

  rand(); /* warmup */
  if (sizeof(int) < sizeof(uint64_t)) {
    start = clock();
    for (size_t i = 0; i < test_len; ++i) {
      rs[i] = ((uint64_t)rand() << 32) | (uint64_t)rand();
    }
    end = clock();
  } else {
    start = clock();
    for (size_t i = 0; i < test_len; ++i) {
      rs[i] = (uint64_t)rand();
    }
    end = clock();
  }
  FIO_NAME_TEST(stl, random_buffer)
  (rs, test_len, "rand (system - naive, ignoring missing bits)", end - start);

  FIO_MEMSET(rs, 0, sizeof(*rs) * test_len);
  {
    if (RAND_MAX == ~(uint64_t)0ULL) {
      /* RAND_MAX fills all bits */
      start = clock();
      for (size_t i = 0; i < test_len; ++i) {
        rs[i] = (uint64_t)rand();
      }
      end = clock();
    } else if (RAND_MAX >= (~(uint32_t)0UL)) {
      /* RAND_MAX fill at least 32 bits per call */
      uint32_t *rs_adjusted = (uint32_t *)rs;

      start = clock();
      for (size_t i = 0; i < (test_len << 1); ++i) {
        rs_adjusted[i] = (uint32_t)rand();
      }
      end = clock();
    } else if (RAND_MAX >= (~(uint16_t)0U)) {
      /* RAND_MAX fill at least 16 bits per call */
      uint16_t *rs_adjusted = (uint16_t *)rs;

      start = clock();
      for (size_t i = 0; i < (test_len << 2); ++i) {
        rs_adjusted[i] = (uint16_t)rand();
      }
      end = clock();
    } else {
      /* assume RAND_MAX fill at least 8 bits per call */
      uint8_t *rs_adjusted = (uint8_t *)rs;

      start = clock();
      for (size_t i = 0; i < (test_len << 2); ++i) {
        rs_adjusted[i] = (uint8_t)rand();
      }
      end = clock();
    }
    /* test RAND_MAX value */
    uint8_t rand_bits = 63;
    while (rand_bits) {
      if (RAND_MAX <= (~(0ULL)) >> rand_bits)
        break;
      --rand_bits;
    }
    rand_bits = 64 - rand_bits;

    char buffer[128] = {0};
    snprintf(buffer,
             128 - 14,
             "rand (system - fixed, testing %d random bits)",
             (int)rand_bits);
    FIO_NAME_TEST(stl, random_buffer)(rs, test_len, buffer, end - start);
  }

  FIO_MEMSET(rs, 0, sizeof(*rs) * test_len);
  fio_rand64(); /* warmup */
  start = clock();
  for (size_t i = 0; i < test_len; ++i) {
    rs[i] = fio_rand64();
  }
  end = clock();
  FIO_NAME_TEST(stl, random_buffer)(rs, test_len, "fio_rand64", end - start);
  FIO_MEMSET(rs, 0, sizeof(*rs) * test_len);
  start = clock();
  fio_rand_bytes(rs, test_len * sizeof(*rs));
  end = clock();
  FIO_NAME_TEST(stl, random_buffer)
  (rs, test_len, "fio_rand_bytes", end - start);

  fio_rand_feed2seed(rs, sizeof(*rs) * test_len);
  FIO_MEM_FREE(rs, sizeof(*rs) * test_len);
  fprintf(stderr, "\n");
#if DEBUG
  fprintf(stderr,
          "\t- to compare CPU cycles, test randomness with optimization.\n\n");
#endif /* DEBUG */
}
#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Random - Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_RAND */
#undef FIO_RAND
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_SHA1       /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                                    SHA 1



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_SHA1) && !defined(H___FIO_SHA1___H)
#define H___FIO_SHA1___H
/* *****************************************************************************
SHA 1
***************************************************************************** */

/** The data type containing the SHA1 digest (result). */
typedef union {
#ifdef __SIZEOF_INT128__
  __uint128_t align__;
#else
  uint64_t align__;
#endif
  uint32_t v[5];
  uint8_t digest[20];
} fio_sha1_s;

/**
 * A simple, non streaming, implementation of the SHA1 hashing algorithm.
 *
 * Do NOT use - SHA1 is broken... but for some reason some protocols still
 * require it's use (i.e., WebSockets), so it's here for your convenience.
 */
SFUNC fio_sha1_s fio_sha1(const void *data, uint64_t len);

/** returns the digest length of SHA1 in bytes */
FIO_IFUNC size_t fio_sha1_len(void);

/** returns the digest of a SHA1 object. */
FIO_IFUNC uint8_t *fio_sha1_digest(fio_sha1_s *s);

/* *****************************************************************************
SHA 1 Implementation - inlined static functions
***************************************************************************** */

/** returns the digest length of SHA1 in bytes */
FIO_IFUNC size_t fio_sha1_len(void) { return 20; }

/** returns the digest of a SHA1 object. */
FIO_IFUNC uint8_t *fio_sha1_digest(fio_sha1_s *s) { return s->digest; }

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_IFUNC void fio___sha1_round512(fio_sha1_s *old, /* state */
                                   uint32_t *w /* 16 words */) {

  register uint32_t v0 = old->v[0];
  register uint32_t v1 = old->v[1];
  register uint32_t v2 = old->v[2];
  register uint32_t v3 = old->v[3];
  register uint32_t v4 = old->v[4];
  register uint32_t v5;

#define FIO___SHA1_ROTATE(K, F, i)                                             \
  v5 = fio_lrot32(v0, 5) + v4 + F + (uint32_t)K + w[(i)&15];                   \
  v4 = v3;                                                                     \
  v3 = v2;                                                                     \
  v2 = fio_lrot32(v1, 30);                                                     \
  v1 = v0;                                                                     \
  v0 = v5;
#define FIO___SHA1_CALC_WORD(i)                                                \
  fio_lrot32(                                                                  \
      (w[(i + 13) & 15] ^ w[(i + 8) & 15] ^ w[(i + 2) & 15] ^ w[(i)&15]),      \
      1);

#define FIO___SHA1_ROUND4(K, F, i)                                             \
  FIO___SHA1_ROUND((K), (F), i);                                               \
  FIO___SHA1_ROUND((K), (F), i + 1);                                           \
  FIO___SHA1_ROUND((K), (F), i + 2);                                           \
  FIO___SHA1_ROUND((K), (F), i + 3);
#define FIO___SHA1_ROUND16(K, F, i)                                            \
  FIO___SHA1_ROUND4((K), (F), i);                                              \
  FIO___SHA1_ROUND4((K), (F), i + 4);                                          \
  FIO___SHA1_ROUND4((K), (F), i + 8);                                          \
  FIO___SHA1_ROUND4((K), (F), i + 12);
#define FIO___SHA1_ROUND20(K, F, i)                                            \
  FIO___SHA1_ROUND16(K, F, i);                                                 \
  FIO___SHA1_ROUND4((K), (F), i + 16);

#define FIO___SHA1_ROUND(K, F, i)                                              \
  w[i] = fio_ntol32(w[i]);                                                     \
  FIO___SHA1_ROTATE(K, F, i);

  FIO___SHA1_ROUND16(0x5A827999, ((v1 & v2) | ((~v1) & (v3))), 0);

#undef FIO___SHA1_ROUND
#define FIO___SHA1_ROUND(K, F, i)                                              \
  w[(i)&15] = FIO___SHA1_CALC_WORD(i);                                         \
  FIO___SHA1_ROTATE(K, F, i);

  FIO___SHA1_ROUND4(0x5A827999, ((v1 & v2) | ((~v1) & (v3))), 16);

  FIO___SHA1_ROUND20(0x6ED9EBA1, (v1 ^ v2 ^ v3), 20);
  FIO___SHA1_ROUND20(0x8F1BBCDC, ((v1 & (v2 | v3)) | (v2 & v3)), 40);
  FIO___SHA1_ROUND20(0xCA62C1D6, (v1 ^ v2 ^ v3), 60);

  old->v[0] += v0;
  old->v[1] += v1;
  old->v[2] += v2;
  old->v[3] += v3;
  old->v[4] += v4;

#undef FIO___SHA1_ROTATE
#undef FIO___SHA1_CALC_WORD
#undef FIO___SHA1_ROUND
#undef FIO___SHA1_ROUND4
#undef FIO___SHA1_ROUND16
#undef FIO___SHA1_ROUND20
}

/**
 * A simple, non streaming, implementation of the SHA1 hashing algorithm.
 *
 * Do NOT use - SHA1 is broken... but for some reason some protocols still
 * require it's use (i.e., WebSockets), so it's here for your convinience.
 */
SFUNC fio_sha1_s fio_sha1(const void *data, uint64_t len) {
  fio_sha1_s s = (fio_sha1_s){
      .v =
          {
              0x67452301,
              0xEFCDAB89,
              0x98BADCFE,
              0x10325476,
              0xC3D2E1F0,
          },
  };

  const uint8_t *buf = (const uint8_t *)data;

  uint32_t vec[16];

  for (size_t i = 63; i < len; i += 64) {
    fio_memcpy64(vec, buf);
    fio___sha1_round512(&s, vec);
    buf += 64;
  }
  FIO_MEMSET(vec, 0, sizeof(vec));
  if ((len & 63)) {
    fio_memcpy63x(vec, buf, len);
  }
  ((uint8_t *)vec)[(len & 63)] = 0x80;

  if ((len & 63) > 55) {
    fio___sha1_round512(&s, vec);
    FIO_MEMSET(vec, 0, sizeof(vec));
  }

  fio_u2buf64((void *)(vec + 14), (len << 3));
  fio___sha1_round512(&s, vec);

  s.v[0] = fio_ntol32(s.v[0]);
  s.v[1] = fio_ntol32(s.v[1]);
  s.v[2] = fio_ntol32(s.v[2]);
  s.v[3] = fio_ntol32(s.v[3]);
  s.v[4] = fio_ntol32(s.v[4]);
  return s;
}

/* *****************************************************************************
SHA1 Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, __sha1_wrapper)(char *data, size_t len) {
  fio_sha1_s h = fio_sha1((const void *)data, (uint64_t)len);
  return *(uintptr_t *)h.digest;
}

#if HAVE_OPENSSL
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/ssl.h>

FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, __sha1_open_ssl_wrapper)(char *data,
                                                                size_t len) {
  fio_256u result;
  SHA1((const unsigned char *)data, len, result.u8);
  return result.u64[0];
}

#endif

FIO_SFUNC void FIO_NAME_TEST(stl, sha1)(void) {
  fprintf(stderr, "* Testing SHA-1\n");
  struct {
    const char *str;
    const char *sha1;
  } data[] = {
      {
          .str = "",
          .sha1 = "\xda\x39\xa3\xee\x5e\x6b\x4b\x0d\x32\x55\xbf\xef\x95\x60\x18"
                  "\x90\xaf\xd8\x07\x09",
      },
      {
          .str = "The quick brown fox jumps over the lazy dog",
          .sha1 = "\x2f\xd4\xe1\xc6\x7a\x2d\x28\xfc\xed\x84\x9e\xe1\xbb\x76\xe7"
                  "\x39\x1b\x93\xeb\x12",
      },
      {
          .str = "The quick brown fox jumps over the lazy cog",
          .sha1 = "\xde\x9f\x2c\x7f\xd2\x5e\x1b\x3a\xfa\xd3\xe8\x5a\x0b\xd1\x7d"
                  "\x9b\x10\x0d\xb4\xb3",
      },
  };
  for (size_t i = 0; i < sizeof(data) / sizeof(data[0]); ++i) {
    fio_sha1_s sha1 = fio_sha1(data[i].str, strlen(data[i].str));

    FIO_ASSERT(!memcmp(sha1.digest, data[i].sha1, fio_sha1_len()),
               "SHA1 mismatch for \"%s\"",
               data[i].str);
  }
#if !DEBUG
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha1_wrapper),
                         (char *)"fio_sha1",
                         5,
                         0,
                         0);
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha1_wrapper),
                         (char *)"fio_sha1",
                         13,
                         0,
                         1);
#if HAVE_OPENSSL
  fprintf(stderr, "* Comparing to " OPENSSL_VERSION_TEXT "\n");
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha1_open_ssl_wrapper),
                         (char *)"OpenSSL SHA-1",
                         5,
                         0,
                         0);
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha1_open_ssl_wrapper),
                         (char *)"OpenSSL SHA-1",
                         13,
                         0,
                         1);
#endif /* HAVE_OPENSSL */
#endif /* !DEBUG */
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_SHA1 */
#undef FIO_SHA1
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_SHA2       /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                                    SHA 2
                        SHA-256 / SHA-512 and variations



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_SHA2) && !defined(H___FIO_SHA2___H)
#define H___FIO_SHA2___H
/* *****************************************************************************
SHA 2 API
***************************************************************************** */

/** Streaming SHA-256 type. */
typedef struct {
  fio_256u hash;
  fio_512u cache;
  uint64_t total_len;
} fio_sha256_s;

/** A simple, non streaming, implementation of the SHA-256 hashing algorithm. */
FIO_IFUNC fio_256u fio_sha256(const void *data, uint64_t len);

/** initializes a fio_256u so the hash can consume streaming data. */
FIO_IFUNC fio_sha256_s fio_sha256_init();
/** Feed data into the hash */
SFUNC void fio_sha256_consume(fio_sha256_s *h, const void *data, uint64_t len);
/** finalizes a fio_256u with the SHA 256 hash. */
SFUNC fio_256u fio_sha256_finalize(fio_sha256_s *h);

/** Streaming SHA-512 type. */
typedef struct {
  fio_512u hash;
  fio_1024u cache;
  uint64_t total_len;
} fio_sha512_s;

/** A simple, non streaming, implementation of the SHA-512 hashing algorithm. */
FIO_IFUNC fio_512u fio_sha512(const void *data, uint64_t len);

/** initializes a fio_512u so the hash can consume streaming data. */
FIO_IFUNC fio_sha512_s fio_sha512_init();
/** Feed data into the hash */
SFUNC void fio_sha512_consume(fio_sha512_s *h, const void *data, uint64_t len);
/** finalizes a fio_512u with the SHA 512 hash. */
SFUNC fio_512u fio_sha512_finalize(fio_sha512_s *h);

/* *****************************************************************************
Implementation - static / inline functions.
***************************************************************************** */

/** initializes a fio_256u so the hash can be consumed. */
FIO_IFUNC fio_sha256_s fio_sha256_init() {
  fio_sha256_s h = {.hash.u32 = {0x6A09E667ULL,
                                 0xBB67AE85ULL,
                                 0x3C6EF372ULL,
                                 0xA54FF53AULL,
                                 0x510E527FULL,
                                 0x9B05688CULL,
                                 0x1F83D9ABULL,
                                 0x5BE0CD19ULL}};
  return h;
}

/** A simple, non streaming, implementation of the SHA-256 hashing algorithm. */
FIO_IFUNC fio_256u fio_sha256(const void *data, uint64_t len) {
  fio_sha256_s h = fio_sha256_init();
  fio_sha256_consume(&h, data, len);
  return fio_sha256_finalize(&h);
}

/** initializes a fio_256u so the hash can be consumed. */
FIO_IFUNC fio_sha512_s fio_sha512_init() {
  fio_sha512_s h = {.hash.u64 = {0ULL}}; /* TODO! */
  return h;
}

/** A simple, non streaming, implementation of the SHA-256 hashing algorithm. */
FIO_IFUNC fio_512u fio_sha512(const void *data, uint64_t len) {
  fio_sha512_s h = fio_sha512_init();
  fio_sha512_consume(&h, data, len);
  return fio_sha512_finalize(&h);
}

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Implementation - SHA-256
***************************************************************************** */

FIO_IFUNC void fio___sha256_round(fio_256u *h, const uint8_t *block) {
  const uint32_t sha256_consts[64] = {
      0x428A2F98ULL, 0x71374491ULL, 0xB5C0FBCFULL, 0xE9B5DBA5ULL, 0x3956C25BULL,
      0x59F111F1ULL, 0x923F82A4ULL, 0xAB1C5ED5ULL, 0xD807AA98ULL, 0x12835B01ULL,
      0x243185BEULL, 0x550C7DC3ULL, 0x72BE5D74ULL, 0x80DEB1FEULL, 0x9BDC06A7ULL,
      0xC19BF174ULL, 0xE49B69C1ULL, 0xEFBE4786ULL, 0x0FC19DC6ULL, 0x240CA1CCULL,
      0x2DE92C6FULL, 0x4A7484AAULL, 0x5CB0A9DCULL, 0x76F988DAULL, 0x983E5152ULL,
      0xA831C66DULL, 0xB00327C8ULL, 0xBF597FC7ULL, 0xC6E00BF3ULL, 0xD5A79147ULL,
      0x06CA6351ULL, 0x14292967ULL, 0x27B70A85ULL, 0x2E1B2138ULL, 0x4D2C6DFCULL,
      0x53380D13ULL, 0x650A7354ULL, 0x766A0ABBULL, 0x81C2C92EULL, 0x92722C85ULL,
      0xA2BFE8A1ULL, 0xA81A664BULL, 0xC24B8B70ULL, 0xC76C51A3ULL, 0xD192E819ULL,
      0xD6990624ULL, 0xF40E3585ULL, 0x106AA070ULL, 0x19A4C116ULL, 0x1E376C08ULL,
      0x2748774CULL, 0x34B0BCB5ULL, 0x391C0CB3ULL, 0x4ED8AA4AULL, 0x5B9CCA4FULL,
      0x682E6FF3ULL, 0x748F82EEULL, 0x78A5636FULL, 0x84C87814ULL, 0x8CC70208ULL,
      0x90BEFFFAULL, 0xA4506CEBULL, 0xBEF9A3F7ULL, 0xC67178F2ULL};
  const fio_256u old = *h;
  /* read data as an array of 16 big endian 32 bit integers. */
  uint32_t w[16];
  fio_memcpy64(w, block);
  for (size_t i = 0; i < 16; ++i) {
    w[i] = fio_lton32(w[i]); /* no-op on big endien systems */
  }

#define FIO___SHA256_ROUND_INNER_COMMON()                                      \
  const uint32_t t2 = ((h->u32[0] & h->u32[1]) ^ (h->u32[0] & h->u32[2]) ^     \
                       (h->u32[1] & h->u32[2])) +                              \
                      (fio_rrot32(h->u32[0], 2) ^ fio_rrot32(h->u32[0], 13) ^  \
                       fio_rrot32(h->u32[0], 22));                             \
  h->u32[7] = h->u32[6];                                                       \
  h->u32[6] = h->u32[5];                                                       \
  h->u32[5] = h->u32[4];                                                       \
  h->u32[4] = h->u32[3];                                                       \
  h->u32[3] = h->u32[2];                                                       \
  h->u32[2] = h->u32[1];                                                       \
  h->u32[1] = h->u32[0];                                                       \
  h->u32[4] += t1;                                                             \
  h->u32[0] = t1 + t2
  for (size_t i = 0; i < 16; ++i) {
    const uint32_t t1 = h->u32[7] + sha256_consts[i] + w[i] +
                        ((h->u32[4] & h->u32[5]) ^ ((~h->u32[4]) & h->u32[6])) +
                        (fio_rrot32(h->u32[4], 6) ^ fio_rrot32(h->u32[4], 11) ^
                         fio_rrot32(h->u32[4], 25));
    FIO___SHA256_ROUND_INNER_COMMON();
  }
  for (size_t i = 0; i < 48; ++i) { /* expand block */
    w[(i & 15)] =
        (fio_rrot32(w[((i + 14) & 15)], 17) ^
         fio_rrot32(w[((i + 14) & 15)], 19) ^ (w[((i + 14) & 15)] >> 10)) +
        w[((i + 9) & 15)] + w[(i & 15)] +
        (fio_rrot32(w[((i + 1) & 15)], 7) ^ fio_rrot32(w[((i + 1) & 15)], 18) ^
         (w[((i + 1) & 15)] >> 3));
    const uint32_t t1 = h->u32[7] + sha256_consts[i + 16] + w[(i & 15)] +
                        ((h->u32[4] & h->u32[5]) ^ ((~h->u32[4]) & h->u32[6])) +
                        (fio_rrot32(h->u32[4], 6) ^ fio_rrot32(h->u32[4], 11) ^
                         fio_rrot32(h->u32[4], 25));
    FIO___SHA256_ROUND_INNER_COMMON();
  }
  for (size_t i = 0; i < 8; ++i)
    h->u32[i] += old.u32[i]; /* compress block with previous state */
#undef FIO___SHA256_ROUND_INNER_COMMON
}

/** consume data and feed it to hash. */
SFUNC void fio_sha256_consume(fio_sha256_s *h, const void *data, uint64_t len) {
  const uint8_t *r = (const uint8_t *)data;
  const size_t old_total = h->total_len;
  const size_t new_total = len + h->total_len;
  h->total_len = new_total;
  /* manage cache */
  if (old_total & 63) {
    const size_t offset = (old_total & 63);
    if (len + offset < 64) { /* not enough - copy to cache */
      fio_memcpy63x((h->cache.u8 + offset), r, len);
      return;
    }
    /* consume cache */
    const size_t byte2copy = 64UL - offset;
    fio_memcpy63x(h->cache.u8 + offset, r, byte2copy);
    fio___sha256_round(&h->hash, h->cache.u8);
    FIO_MEMSET(h->cache.u8, 0, 64);
    r += byte2copy;
    len -= byte2copy;
  }
  const uint8_t *end = r + (len & (~(uint64_t)63ULL));
  while ((uintptr_t)r < (uintptr_t)end) {
    fio___sha256_round(&h->hash, r);
    r += 64;
  }
  fio_memcpy63x(h->cache.u64, r, len);
}

SFUNC fio_256u fio_sha256_finalize(fio_sha256_s *h) {
  if (h->total_len == ((uint64_t)0ULL - 1ULL))
    return h->hash;
  const size_t total = h->total_len;
  const size_t remainder = total & 63;
  h->cache.u8[remainder] = 0x80U; /* set the 1 bit at the left most position */
  if ((remainder) > 47) { /* make sure there's room to attach `total_len` */
    fio___sha256_round(&h->hash, h->cache.u8);
    FIO_MEMSET(h->cache.u8, 0, 64);
  }
  h->cache.u64[7] = fio_lton64((total << 3));
  fio___sha256_round(&h->hash, h->cache.u8);
  for (size_t i = 0; i < 8; ++i)
    h->hash.u32[i] = fio_ntol32(h->hash.u32[i]); /* back to big endien */
  h->total_len = ((uint64_t)0ULL - 1ULL);
  return h->hash;
}

/* *****************************************************************************
Implementation - SHA-512
***************************************************************************** */

FIO_IFUNC void fio___sha512_round(fio_512u *h, const uint8_t *block) {
  /* TODO! */
  (void)h;
  (void)block;
}

/** Feed data into the hash */
SFUNC void fio_sha512_consume(fio_sha512_s *h, const void *data, uint64_t len) {
  (void)h;
  (void)data;
  (void)len;
  /* TODO! */

  const uint8_t *r = (const uint8_t *)data;
  const size_t old_total = h->total_len;
  const size_t new_total = len + h->total_len;
  h->total_len = new_total;
  /* manage cache */
  if (old_total & 127) {
    const size_t offset = (old_total & 127);
    if (len + offset < 128) { /* not enough - copy to cache */
      fio_memcpy127x((h->cache.u8 + offset), r, len);
      return;
    }
    /* consume cache */
    const size_t byte2copy = 128UL - offset;
    fio_memcpy127x(h->cache.u8 + offset, r, byte2copy);
    fio___sha512_round(&h->hash, h->cache.u8);
    FIO_MEMSET(h->cache.u8, 0, 128);
    r += byte2copy;
    len -= byte2copy;
  }
  const uint8_t *end = r + (len & (~(uint64_t)127ULL));
  while ((uintptr_t)r < (uintptr_t)end) {
    fio___sha512_round(&h->hash, r);
    r += 128;
  }
  fio_memcpy63x(h->cache.u64, r, len);
}

/** finalizes a fio_512u with the SHA 512 hash. */
SFUNC fio_512u fio_sha512_finalize(fio_sha512_s *h) {
  /* TODO! */
  if (h->total_len == ((uint64_t)0ULL - 1ULL))
    return h->hash;
  const size_t total = h->total_len;
  const size_t remainder = total & 127;
  h->cache.u8[remainder] = 0x80U; /* set the 1 bit at the left most position */
  if ((remainder) > 119) { /* make sure there's room to attach `total_len` */
    fio___sha512_round(&h->hash, h->cache.u8);
    FIO_MEMSET(h->cache.u8, 0, 128);
  }
  h->cache.u64[15] = fio_lton64((total << 3));
  fio___sha512_round(&h->hash, h->cache.u8);
  for (size_t i = 0; i < 8; ++i)
    h->hash.u64[i] = fio_ntol64(h->hash.u64[i]); /* back to big endien */
  h->total_len = ((uint64_t)0ULL - 1ULL);
  return h->hash;
}

/* *****************************************************************************
SHA2 Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, __sha256_wrapper)(char *data,
                                                         size_t len) {
  fio_256u h = fio_sha256((const void *)data, (uint64_t)len);
  return (uintptr_t)(h.u64[0]);
}
FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, __sha512_wrapper)(char *data,
                                                         size_t len) {
  fio_512u h = fio_sha512((const void *)data, (uint64_t)len);
  return (uintptr_t)(h.u64[0]);
}

#if HAVE_OPENSSL
#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/ssl.h>
FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, __sha256_open_ssl_wrapper)(char *data,
                                                                  size_t len) {
  fio_256u result;
  SHA256((const unsigned char *)data, len, result.u8);
  return result.u64[0];
}
FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, __sha512_open_ssl_wrapper)(char *data,
                                                                  size_t len) {
  fio_512u result;
  SHA512((const unsigned char *)data, len, result.u8);
  return result.u64[0];
}
#endif /* HAVE_OPENSSL */

FIO_SFUNC void FIO_NAME_TEST(stl, sha2)(void) {
  fprintf(stderr, "* Testing SHA-2\n");
  struct {
    const char *str;
    const char *sha256;
    const char *sha512;
  } data[] = {
      {
          .str = (char *)"abc",
          .sha256 = (char *)"\xBA\x78\x16\xBF\x8F\x01\xCF\xEA\x41\x41\x40\xDE"
                            "\x5D\xAE\x22\x23\xB0\x03\x61\xA3\x96\x17\x7A\x9C"
                            "\xB4\x10\xFF\x61\xF2\x00\x15\xAD",
      },
      {
          .str = (char *)"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnl"
                         "mnomnopnopq",
          .sha256 = (char *)"\x24\x8D\x6A\x61\xD2\x06\x38\xB8\xE5\xC0\x26"
                            "\x93\x0C\x3E\x60\x39\xA3\x3C\xE4\x59\x64\xFF"
                            "\x21\x67\xF6\xEC\xED\xD4\x19\xDB\x06\xC1",
      },
      {
          .str = (char *)"The quick brown fox jumps over the lazy dog",
          .sha256 = (char *)"\xD7\xA8\xFB\xB3\x07\xD7\x80\x94\x69\xCA\x9A\xBC"
                            "\xB0\x08\x2E\x4F\x8D\x56\x51\xE4\x6D\x3C\xDB\x76"
                            "\x2D\x02\xD0\xBF\x37\xC9\xE5\x92",
          .sha512 =
              (char *)"\x07\xE5\x47\xD9\x58\x6F\x6A\x73\xF7\x3F\xBA\xC0\x43\x5E"
                      "\xD7\x69\x51\x21\x8F\xB7\xD0\xC8\xD7\x88\xA3\x09\xD7\x85"
                      "\x43\x6B\xBB\x64\x2E\x93\xA2\x52\xA9\x54\xF2\x39\x12\x54"
                      "\x7D\x1E\x8A\x3B\x5E\xD6\xE1\xBF\xD7\x09\x78\x21\x23\x3F"
                      "\xA0\x53\x8F\x3D\xB8\x54\xFE\xE6",
      },
      {
          .str = (char *)"The quick brown fox jumps over the lazy cog",
          .sha256 = (char *)"\xE4\xC4\xD8\xF3\xBF\x76\xB6\x92\xDE\x79\x1A\x17"
                            "\x3E\x05\x32\x11\x50\xF7\xA3\x45\xB4\x64\x84\xFE"
                            "\x42\x7F\x6A\xCC\x7E\xCC\x81\xBE",
          .sha512 =
              (char *)"\x3E\xEE\xE1\xD0\xE1\x17\x33\xEF\x15\x2A\x6C\x29\x50\x3B"
                      "\x3A\xE2\x0C\x4F\x1F\x3C\xDA\x4C\xB2\x6F\x1B\xC1\xA4\x1F"
                      "\x91\xC7\xFE\x4A\xB3\xBD\x86\x49\x40\x49\xE2\x01\xC4\xBD"
                      "\x51\x55\xF3\x1E\xCB\x7A\x3C\x86\x06\x84\x3C\x4C\xC8\xDF"
                      "\xCA\xB7\xDA\x11\xC8\xAE\x50\x45",
      },
      {
          .str = (char *)"",
          .sha256 = (char *)"\xE3\xB0\xC4\x42\x98\xFC\x1C\x14\x9A\xFB\xF4\xC8"
                            "\x99\x6F\xB9\x24\x27\xAE\x41\xE4\x64\x9B\x93\x4C"
                            "\xA4\x95\x99\x1B\x78\x52\xB8\x55",
          .sha512 =
              (char *)"\xCF\x83\xE1\x35\x7E\xEF\xB8\xBD\xF1\x54\x28\x50\xD6\x6D"
                      "\x80\x07\xD6\x20\xE4\x05\x0B\x57\x15\xDC\x83\xF4\xA9\x21"
                      "\xD3\x6C\xE9\xCE\x47\xD0\xD1\x3C\x5D\x85\xF2\xB0\xFF\x83"
                      "\x18\xD2\x87\x7E\xEC\x2F\x63\xB9\x31\xBD\x47\x41\x7A\x81"
                      "\xA5\x38\x32\x7A\xF9\x27\xDA\x3E",
      },
  };
  for (size_t i = 0; i < sizeof(data) / sizeof(data[0]); ++i) {
    if (!data[i].str)
      continue;
    if (data[i].sha256) {
      fio_256u sha256 = fio_sha256(data[i].str, strlen(data[i].str));
      FIO_ASSERT(!memcmp(sha256.u8, data[i].sha256, 32),
                 "SHA256 mismatch for \"%s\":\n\t %X%X%X%X...%X%X%X%X",
                 data[i].str,
                 sha256.u8[0],
                 sha256.u8[1],
                 sha256.u8[2],
                 sha256.u8[3],
                 sha256.u8[28],
                 sha256.u8[29],
                 sha256.u8[30],
                 sha256.u8[31]);
    }
    // if (data[i].sha512) {
    //   fio_512u sha512 = fio_sha512(data[i].str, strlen(data[i].str));
    //   FIO_ASSERT(!memcmp(sha512.u8, data[i].sha512, 64),
    //              "SHA512 mismatch for \"%s\"",
    //              data[i].str);
    // }
  }
#if !DEBUG
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha256_wrapper),
                         (char *)"fio_sha256",
                         5,
                         0,
                         0);
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha256_wrapper),
                         (char *)"fio_sha256",
                         13,
                         0,
                         1);
  // fio_test_hash_function(FIO_NAME_TEST(stl, __sha512_wrapper),
  //                        (char *)"fio_sha512",
  //                        5,
  //                        0,
  //                        0);
  // fio_test_hash_function(FIO_NAME_TEST(stl, __sha512_wrapper),
  //                        (char *)"fio_sha512",
  //                        13,
  //                        0,
  //                        1);
#if HAVE_OPENSSL
  fprintf(stderr, "* Comparing to " OPENSSL_VERSION_TEXT "\n");
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha256_open_ssl_wrapper),
                         (char *)"OpenSSL SHA-256",
                         5,
                         0,
                         0);
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha256_open_ssl_wrapper),
                         (char *)"OpenSSL SHA-256",
                         13,
                         0,
                         1);
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha512_open_ssl_wrapper),
                         (char *)"OpenSSL SHA-512",
                         5,
                         0,
                         0);
  fio_test_hash_function(FIO_NAME_TEST(stl, __sha512_open_ssl_wrapper),
                         (char *)"OpenSSL SHA-512",
                         13,
                         0,
                         1);
#endif /* HAVE_OPENSSL */
#endif /* !DEBUG */
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_SHA2 */
#undef FIO_SHA2
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_CHACHA     /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                              ChaCha20 & Poly1305



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_CHACHA) && !defined(H___FIO_CHACHA___H)
#define H___FIO_CHACHA___H 1

/* *****************************************************************************
ChaCha20Poly1305 API
***************************************************************************** */

/* *****************************************************************************
Using ChaCha20 and Poly1305 separately
***************************************************************************** */

/**
 * Performs an in-place encryption/decryption of `data` using ChaCha20.
 *
 * * `key`    MUST point to a 256 bit long memory address (32 Bytes).
 * * `nounce` MUST point to a  96 bit long memory address (12 Bytes).
 * * `counter` is the block counter, usually 1 unless `data` is mid-cyphertext.
 */
SFUNC void fio_chacha20(void *restrict data,
                        size_t len,
                        const void *key,
                        const void *nounce,
                        uint32_t counter);

/**
 * Given a Poly1305 256bit (32 byte) key, writes the authentication code for the
 * poly message and additional data into `mac_dest`.
 *
 * * `key`    MUST point to a 256 bit long memory address (32 Bytes).
 */
SFUNC void fio_poly1305_auth(void *restrict mac_dest,
                             const void *key256bits,
                             void *restrict message,
                             size_t len,
                             void *restrict additional_data,
                             size_t additional_data_len);

/**
 * Performs an in-place encryption of `data` using ChaCha20 with additional
 * data, producing a 16 byte message authentication code (MAC) using Poly1305.
 *
 * * `key`    MUST point to a 256 bit long memory address (32 Bytes).
 * * `nounce` MUST point to a  96 bit long memory address (12 Bytes).
 * * `ad`     MAY be omitted, will NOT be encrypted.
 * * `data`   MAY be omitted, WILL be encrypted.
 * * `mac`    MUST point to a buffer with (at least) 16 available bytes.
 */
SFUNC void fio_chacha20_poly1305_enc(void *restrict mac,
                                     void *restrict data,
                                     size_t len,
                                     void *restrict ad, /* additional data */
                                     size_t adlen,
                                     const void *key,
                                     const void *nounce);

/**
 * Performs an in-place decryption of `data` using ChaCha20 after authenticating
 * the message authentication code (MAC) using Poly1305.
 *
 * * `key`    MUST point to a 256 bit long memory address (32 Bytes).
 * * `nounce` MUST point to a  96 bit long memory address (12 Bytes).
 * * `ad`     MAY be omitted ONLY IF originally omitted.
 * * `data`   MAY be omitted, WILL be decrypted.
 * * `mac`    MUST point to a buffer where the 16 byte MAC is placed.
 *
 * Returns `-1` on error (authentication failed).
 */
SFUNC int fio_chacha20_poly1305_dec(void *restrict mac,
                                    void *restrict data,
                                    size_t len,
                                    void *restrict ad, /* additional data */
                                    size_t adlen,
                                    const void *key,
                                    const void *nounce);

/* *****************************************************************************
ChaCha20Poly1305 Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Poly1305 (authentication)
Prime 2^130-5   = 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB
The math is mostly copied from: https://github.com/floodyberry/poly1305-donna
***************************************************************************** */
/*
 * Math copied from https://github.com/floodyberry/poly1305-donna
 *
 * With thanks to Andrew Moon.
 */
typedef struct {
  /* r (cycle key addition) is 128 bits */
  uint64_t r[3];
  /* s (final key addition) is 128 bits */
  uint64_t s[2];
  /* Accumulator should not exceed 131 bits at the end of every cycle. */
  uint64_t a[3];
} FIO_ALIGN(16) fio___poly_s;

FIO_IFUNC fio___poly_s fio___poly_init(const void *key256b) {
  uint64_t t0, t1;
  /* r &= 0xffffffc0ffffffc0ffffffc0fffffff */
  t0 = fio_buf2u64_little((uint8_t *)key256b + 0);
  t1 = fio_buf2u64_little((uint8_t *)key256b + 8);
  fio___poly_s pl = {
      .r =
          {
              ((t0)&0xffc0fffffff),
              (((t0 >> 44) | (t1 << 20)) & 0xfffffc0ffff),
              (((t1 >> 24)) & 0x00ffffffc0f),
          },
      .s =
          {
              fio_buf2u64_little(((uint8_t *)key256b + 16)),
              fio_buf2u64_little(((uint8_t *)key256b + 24)),
          },
  };
  return pl;
}
FIO_IFUNC void fio___poly_consume128bit(fio___poly_s *pl,
                                        const void *msg,
                                        uint64_t is_full) {
  uint64_t r0, r1, r2;
  uint64_t s1, s2;
  uint64_t a0, a1, a2;
  uint64_t c;
  uint64_t d0[2], d1[2], d2[2], d[2];

  r0 = pl->r[0];
  r1 = pl->r[1];
  r2 = pl->r[2];

  a0 = pl->a[0];
  a1 = pl->a[1];
  a2 = pl->a[2];

  s1 = r1 * (5 << 2);
  s2 = r2 * (5 << 2);

  {
    uint64_t t0, t1;
    t0 = fio_buf2u64_little(msg);
    t1 = fio_buf2u64_little(((uint8_t *)msg + 8));
    /* a += msg */
    a0 += ((t0)&0xFFFFFFFFFFF);
    a1 += (((t0 >> 44) | (t1 << 20)) & 0xFFFFFFFFFFF);
    a2 += (((t1 >> 24)) & 0x3FFFFFFFFFF) | (is_full << 40);
  }

  /* a *= r */
  d0[0] = fio_math_mulc64(a0, r0, d0 + 1);
  d[0] = fio_math_mulc64(a1, s2, d + 1);
  d0[0] = fio_math_addc64(d0[0], d[0], 0, &c);
  d0[1] += d[1] + c;

  d[0] = fio_math_mulc64(a2, s1, d + 1);
  d0[0] = fio_math_addc64(d0[0], d[0], 0, &c);
  d0[1] += d[1] + c;

  d1[0] = fio_math_mulc64(a0, r1, d1 + 1);
  d[0] = fio_math_mulc64(a1, r0, d + 1);
  d1[0] = fio_math_addc64(d1[0], d[0], 0, &c);
  d1[1] += d[1] + c;

  d[0] = fio_math_mulc64(a2, s2, d + 1);
  d1[0] = fio_math_addc64(d1[0], d[0], 0, &c);
  d1[1] += d[1] + c;

  d2[0] = fio_math_mulc64(a0, r2, d2 + 1);
  d[0] = fio_math_mulc64(a1, r1, d + 1);
  d2[0] = fio_math_addc64(d2[0], d[0], 0, &c);
  d2[1] += d[1] + c;

  d[0] = fio_math_mulc64(a2, r0, d + 1);
  d2[0] = fio_math_addc64(d2[0], d[0], 0, &c);
  d2[1] += d[1] + c;

  /* (partial) a %= p */
  c = (d0[0] >> 44) | (d0[1] << 20);
  a0 = d0[0] & 0xfffffffffff;
  d1[0] = fio_math_addc64(d1[0], c, 0, &c);
  d1[1] += c;

  c = (d1[0] >> 44) | (d1[1] << 20);
  a1 = d1[0] & 0xfffffffffff;
  d2[0] = fio_math_addc64(d2[0], c, 0, &c);
  d2[1] += c;

  c = (d2[0] >> 42) | (d2[1] << 22);
  a2 = d2[0] & 0x3ffffffffff;
  a0 += c * 5;
  c = a0 >> 44;
  a0 = a0 & 0xfffffffffff;
  a1 += c;

  pl->a[0] = a0;
  pl->a[1] = a1;
  pl->a[2] = a2;
}

FIO_IFUNC void fio___poly_finilize(fio___poly_s *pl) {
  uint64_t a0, a1, a2, c;
  uint64_t g0, g1, g2;
  uint64_t t0, t1;

  /* fully carry a */
  a0 = pl->a[0];
  a1 = pl->a[1];
  a2 = pl->a[2];

  c = (a1 >> 44);
  a1 &= 0xFFFFFFFFFFF;
  a2 += c;
  c = (a2 >> 42);
  a2 &= 0x3FFFFFFFFFF;
  a0 += c * 5;
  c = (a0 >> 44);
  a0 &= 0xFFFFFFFFFFF;
  a1 += c;
  c = (a1 >> 44);
  a1 &= 0xFFFFFFFFFFF;
  a2 += c;
  c = (a2 >> 42);
  a2 &= 0x3FFFFFFFFFF;
  a0 += c * 5;
  c = (a0 >> 44);
  a0 &= 0xFFFFFFFFFFF;
  a1 += c;

  /* compute a + -p */
  g0 = a0 + 5;
  c = (g0 >> 44);
  g0 &= 0xFFFFFFFFFFF;
  g1 = a1 + c;
  c = (g1 >> 44);
  g1 &= 0xFFFFFFFFFFF;
  g2 = a2 + c - ((uint64_t)1 << 42);

  /* select h if h < p, or h + -p if h >= p */
  c = (g2 >> ((sizeof(uint64_t) * 8) - 1)) - 1;
  g0 &= c;
  g1 &= c;
  g2 &= c;
  c = ~c;
  a0 = (a0 & c) | g0;
  a1 = (a1 & c) | g1;
  a2 = (a2 & c) | g2;

  /* a = (a + Poly S key) */
  t0 = pl->s[0];
  t1 = pl->s[1];

  a0 += ((t0)&0xFFFFFFFFFFF);
  c = (a0 >> 44);
  a0 &= 0xFFFFFFFFFFF;
  a1 += (((t0 >> 44) | (t1 << 20)) & 0xFFFFFFFFFFF) + c;
  c = (a1 >> 44);
  a1 &= 0xFFFFFFFFFFF;
  a2 += (((t1 >> 24)) & 0x3FFFFFFFFFF) + c;
  a2 &= 0x3FFFFFFFFFF;

  /* mac = a % (2^128) */
  a0 = ((a0) | (a1 << 44));
  a1 = ((a1 >> 20) | (a2 << 24));
  pl->a[0] = a0;
  pl->a[1] = a1;
}

FIO_IFUNC void fio___poly_consume_msg(fio___poly_s *pl,
                                      uint8_t *msg,
                                      size_t len) {
  /* read 16 byte blocks */
  uint64_t n[2];
  for (size_t i = 31; i < len; i += 32) {
    fio___poly_consume128bit(pl, msg, 1);
    fio___poly_consume128bit(pl, msg + 16, 1);
    msg += 32;
  }
  if ((len & 16)) {
    fio___poly_consume128bit(pl, msg, 1);
    msg += 16;
  }
  if ((len & 15)) {
    n[0] = 0;
    n[1] = 0;
    fio_memcpy15x(n, msg, len);
    n[0] = fio_ltole64(n[0]);
    n[1] = fio_ltole64(n[1]);
    ((uint8_t *)n)[len & 15] = 0x01;
    fio___poly_consume128bit(pl, (void *)n, 0);
  }
}

/*
 * Given a Poly1305 key, writes a MAC into `mac_dest`. */
SFUNC void fio_poly1305_auth(void *restrict mac,
                             const void *key,
                             void *restrict msg,
                             size_t len,
                             void *restrict ad,
                             size_t ad_len) {
  fio___poly_s pl = fio___poly_init(key);
  fio___poly_consume_msg(&pl, (uint8_t *)ad, ad_len);
  fio___poly_consume_msg(&pl, (uint8_t *)msg, len);
  fio___poly_finilize(&pl);
  fio_u2buf64_little(mac, pl.a[0]);
  fio_u2buf64_little(&((char *)mac)[8], pl.a[1]);
}

/* *****************************************************************************
ChaCha20 (encryption)
***************************************************************************** */

FIO_IFUNC fio_512u fio___chacha_init(const void *key,
                                     const void *nounce,
                                     uint32_t counter) {
  fio_512u o = {
      .u32 =
          {
              // clang-format off
              0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,
              fio_buf2u32_little(key),
              fio_buf2u32_little((uint8_t *)key + 4),
              fio_buf2u32_little((uint8_t *)key + 8),
              fio_buf2u32_little((uint8_t *)key + 12),
              fio_buf2u32_little((uint8_t *)key + 16),
              fio_buf2u32_little((uint8_t *)key + 20),
              fio_buf2u32_little((uint8_t *)key + 24),
              fio_buf2u32_little((uint8_t *)key + 28),
              counter,
              fio_buf2u32_little(nounce),
              fio_buf2u32_little((uint8_t *)nounce + 4),
              fio_buf2u32_little((uint8_t *)nounce + 8),
          }, // clang-format on
  };
  return o;
}

// clang-format off
#define FIO___CHACHA_QROUND_S1(a, b, c, d) do {a += b; d ^= a; d = fio_lrot32(d, 16);} while(0)
#define FIO___CHACHA_QROUND_S2(a, b, c, d) do {c += d; b ^= c; b = fio_lrot32(b, 12);} while(0)
#define FIO___CHACHA_QROUND_S3(a, b, c, d) do {a += b; d ^= a; d = fio_lrot32(d, 8);} while(0)
#define FIO___CHACHA_QROUND_S4(a, b, c, d) do {c += d; b ^= c; b = fio_lrot32(b, 7);} while(0)
// clang-format on
#define FIO___CHACHA_QROUND(a, b, c, d)                                        \
  do {                                                                         \
    FIO___CHACHA_QROUND_S1(a, b, c, d);                                        \
    FIO___CHACHA_QROUND_S2(a, b, c, d);                                        \
    FIO___CHACHA_QROUND_S3(a, b, c, d);                                        \
    FIO___CHACHA_QROUND_S4(a, b, c, d);                                        \
  } while (0)

FIO_IFUNC void fio___chacha_xor64(void *dest_,
                                  uint64_t *src,
                                  const size_t groups) {
  uint8_t *d = (uint8_t *)dest_;
  for (size_t i = 0; i < groups; (++i), d += 8) {
    uint64_t t = fio_buf2u64_local(d);
    t ^= src[i];
    fio_u2buf64_local(d, t);
  }
}

FIO_IFUNC void fio___chacha_round20(fio_512u *c) {
  fio_512u c2 = *c;
  for (size_t round = 0; round < 10; ++round) {
    for (size_t i = 0; i < 4; ++i) {
      FIO___CHACHA_QROUND(c2.u32[i],
                          c2.u32[i | 4],
                          c2.u32[i | 8],
                          c2.u32[i | 12]);
    }
    for (size_t i = 0; i < 4; ++i) {
      FIO___CHACHA_QROUND(c2.u32[i],
                          c2.u32[((i + 1) & 3) | 4],
                          c2.u32[((i + 2) & 3) | 8],
                          c2.u32[((i + 3) & 3) | 12]);
    }
  }
  for (size_t i = 0; i < 16; ++i) {
    c->u32[i] += c2.u32[i];
    c->u32[i] = fio_ltole32(c->u32[i]);
  }
}
FIO_IFUNC void fio___chacha_round20x2(uint32_t *restrict cypher,
                                      uint32_t *restrict v) {
  for (size_t b = 1; b < 2; ++b) { /* block counters increase */
    cypher[(b << 4) + 12] += b;
    v[(b << 4) + 12] += b;
  }
  for (size_t round = 0; round < 10; ++round) {
    for (size_t i = 0; i < 4; ++i)
      for (size_t b = 0; b < 2; ++b)
        FIO___CHACHA_QROUND(v[(b << 4) | (i)],
                            v[(b << 4) | ((i | 4))],
                            v[(b << 4) | ((i | 8))],
                            v[(b << 4) | ((i | 12))]);
    for (size_t i = 0; i < 4; ++i)
      for (size_t b = 0; b < 2; ++b)
        FIO___CHACHA_QROUND(v[(b << 4) | (i)],
                            v[(b << 4) | ((((i + 1) & 3) | 4))],
                            v[(b << 4) | ((((i + 2) & 3) | 8))],
                            v[(b << 4) | ((((i + 3) & 3) | 12))]);
  }
  for (size_t i = 0; i < 16; ++i)
    for (size_t b = 0; b < 2; ++b) {
      cypher[(b << 4) | i] += v[(b << 4) | i];
      cypher[(b << 4) | i] = fio_ltole32(cypher[(b << 4) | i]);
    }
}

SFUNC void fio_chacha20(void *restrict data,
                        size_t len,
                        const void *key,
                        const void *nounce,
                        uint32_t counter) {
  fio_512u c = fio___chacha_init(key, nounce, counter);
  for (size_t pos = 127; pos < len; pos += 128) {
    fio_512u cypher[4] = {c, c, c, c};
    fio___chacha_round20x2(cypher[0].u32, cypher[2].u32);
    fio___chacha_xor64(data, cypher[0].u64, 16);
    c.u32[12] += 2; /* block counter */
    data = (void *)((uint8_t *)data + 128);
  }
  if ((len & 64)) {
    fio_512u c2 = c;
    fio___chacha_round20(&c2);
    fio___chacha_xor64(data, c2.u64, 8);
    data = (void *)((uint8_t *)data + 64);
    ++c.u32[12];
  }
  if ((len & 63)) {
    fio_512u dest; /* no need to initialize, junk data disregarded. */
    fio___chacha_round20(&c);
    fio_memcpy63x(dest.u64, data, len);
    fio___chacha_xor64(dest.u64, c.u64, 8);
    fio_memcpy63x(data, dest.u64, len);
  }
}

/* *****************************************************************************
ChaCha20Poly1305 Encryption with Authentication
***************************************************************************** */

SFUNC void fio_chacha20_poly1305_enc(void *restrict mac,
                                     void *restrict data,
                                     size_t len,
                                     void *restrict ad, /* additional data */
                                     size_t adlen,
                                     const void *key,
                                     const void *nounce) {
  fio_512u c = fio___chacha_init(key, nounce, 0);
  fio___poly_s pl;
  {
    fio_512u c2 = c;
    fio___chacha_round20(&c2); /* computes poly1305 key */
    pl = fio___poly_init(&c2);
    ++c.u32[12]; /* block counter */
  }
  for (size_t i = 31; i < adlen; i += 32) {
    fio___poly_consume128bit(&pl, (uint8_t *)ad, 1);
    fio___poly_consume128bit(&pl, (uint8_t *)ad + 16, 1);
    ad = (void *)((uint8_t *)ad + 32);
  }
  if (adlen & 16) {
    fio___poly_consume128bit(&pl, (uint8_t *)ad, 1);
    ad = (void *)((uint8_t *)ad + 16);
  }
  if (adlen & 15) {
    uint64_t tmp[2] = {0}; /* 16 byte pad */
    fio_memcpy15x(tmp, ad, adlen);
    fio___poly_consume128bit(&pl, (uint8_t *)tmp, 1);
  }
  for (size_t i = 127; i < len; i += 128) {
    fio_512u c2[4] = {c, c, c, c};
    fio___chacha_round20x2(c2[0].u32, c2[2].u32);
    fio___chacha_xor64(data, c2[0].u64, 16);
    fio___poly_consume128bit(&pl, data, 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 16), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 32), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 48), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 64), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 80), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 96), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 112), 1);
    c.u32[12] += 2; /* block counter */
    data = (void *)((uint8_t *)data + 128);
  }
  if ((len & 64)) {
    fio_512u c2 = c;
    fio___chacha_round20(&c2);
    fio___chacha_xor64(data, c2.u64, 8);
    fio___poly_consume128bit(&pl, data, 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 16), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 32), 1);
    fio___poly_consume128bit(&pl, (void *)((uint8_t *)data + 48), 1);
    ++c.u32[12]; /* block counter */
    data = (void *)((uint8_t *)data + 64);
  }
  if ((len & 63)) {
    fio_512u dest;
    uint8_t *p = dest.u8;
    fio___chacha_round20(&c);
    fio_memcpy63x(dest.u64, data, len);
    fio___chacha_xor64(dest.u64, c.u64, 8);
    fio_memcpy63x(data, dest.u64, len);
    if ((len & 32)) {
      fio___poly_consume128bit(&pl, p, 1);
      fio___poly_consume128bit(&pl, (p + 16), 1);
      p += 32;
    }
    if ((len & 16)) {
      fio___poly_consume128bit(&pl, p, 1);
      p += 16;
    }
    if ((len & 15)) {
      /* zero out poly padding */
      for (size_t i = (len & 15UL); i < 16; i++)
        p[i] = 0;
      fio___poly_consume128bit(&pl, p, 1);
    }
  }
  {
    uint64_t mac_data[2] = {fio_ltole64(adlen), fio_ltole64(len)};
    fio___poly_consume128bit(&pl, (uint8_t *)mac_data, 1);
  }
  fio___poly_finilize(&pl);
  fio_u2buf64_little(mac, pl.a[0]);
  fio_u2buf64_little(&((char *)mac)[8], pl.a[1]);
}

SFUNC void fio_chacha20_poly1305_auth(void *restrict mac,
                                      void *restrict data,
                                      size_t len,
                                      void *restrict ad, /* additional data */
                                      size_t adlen,
                                      const void *key,
                                      const void *nounce) {
  fio_512u c = fio___chacha_init(key, nounce, 0);
  fio___chacha_round20(&c); /* computes poly1305 key */
  fio___poly_s pl = fio___poly_init(&c);
  for (size_t i = 31; i < adlen; i += 32) {
    fio___poly_consume128bit(&pl, (uint8_t *)ad, 1);
    fio___poly_consume128bit(&pl, (uint8_t *)ad + 16, 1);
    ad = (void *)((uint8_t *)ad + 32);
  }
  if (adlen & 16) {
    fio___poly_consume128bit(&pl, (uint8_t *)ad, 1);
    ad = (void *)((uint8_t *)ad + 16);
  }
  if (adlen & 15) {
    uint64_t tmp[2] = {0}; /* 16 byte pad */
    fio_memcpy15x(tmp, ad, adlen);
    fio___poly_consume128bit(&pl, (uint8_t *)tmp, 1);
  }
  fio___poly_consume_msg(&pl, (uint8_t *)data, (len & (~15ULL)));
  if ((len & 15)) {
    fio_128u dest = {0}; /* 16 byte pad */
    fio_memcpy15x(dest.u64, (uint8_t *)data + (len & (~15ULL)), len);
    fio___poly_consume128bit(&pl, (uint8_t *)(dest.u64), 1);
  }
  {
    uint64_t mac_data[2] = {fio_ltole64(adlen), fio_ltole64(len)};
    fio___poly_consume128bit(&pl, (uint8_t *)mac_data, 1);
  }
  fio___poly_finilize(&pl);
  fio_u2buf64_little(mac, pl.a[0]);
  fio_u2buf64_little(&((char *)mac)[8], pl.a[1]);
}

SFUNC int fio_chacha20_poly1305_dec(void *restrict mac,
                                    void *restrict data,
                                    size_t len,
                                    void *restrict ad, /* additional data */
                                    size_t adlen,
                                    const void *key,
                                    const void *nounce) {
  uint64_t auth[2];
  fio_chacha20_poly1305_auth(&auth, data, len, ad, adlen, key, nounce);
  if (((auth[0] != fio_buf2u64_little(mac)) |
       (auth[1] != fio_buf2u64_little(((char *)mac + 8)))))
    return -1;
  fio_chacha20(data, len, key, nounce, 1);
  return 0;
}
/* *****************************************************************************
Module Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

#if HAVE_OPENSSL
// #include <openssl/bio.h>
// #include <openssl/err.h>
// #include <openssl/ssl.h>
// FIO_SFUNC uintptr_t FIO_NAME_TEST(stl, __poly1305_open_ssl_wrapper)(char
// *data,
//                                                                   size_t len)
//                                                                   {
// }
#endif /* HAVE_OPENSSL */

FIO_SFUNC uintptr_t fio__poly1305_speed_wrapper(char *msg, size_t len) {
  uint64_t result[2] = {0};
  char *key = (char *)"\x85\xd6\xbe\x78\x57\x55\x6d\x33\x7f\x44\x52\xfe\x42"
                      "\xd5\x06\xa8"
                      "\x01\x03\x80\x8a\xfb\x0d\xb2\xfd\x4a\xbf\xf6\xaf\x41"
                      "\x49\xf5\x1b";
  fio_poly1305_auth(result, key, msg, len, NULL, 0);
  return (uintptr_t)result[0];
}

FIO_SFUNC uintptr_t fio__chacha20_speed_wrapper(char *msg, size_t len) {
  uint64_t result[2] = {0};
  char *key = (char *)"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c"
                      "\x0d\x0e\x0f"
                      "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c"
                      "\x1d\x1e\x1f";
  char *nounce = (char *)"\x00\x00\x00\x00\x00\x00\x00\x4a\x00\x00\x00\x00";
  fio_chacha20(msg, len, key, nounce, 1);
  result[0] = fio_buf2u64_local(msg);
  return (uintptr_t)result[0];
}

FIO_SFUNC uintptr_t fio__chacha20poly1305_speed_wrapper(char *msg, size_t len) {
  uint64_t result[2] = {0};
  char *key = (char *)"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c"
                      "\x0d\x0e\x0f"
                      "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c"
                      "\x1d\x1e\x1f";
  char *nounce = (char *)"\x00\x00\x00\x00\x00\x00\x00\x4a\x00\x00\x00\x00";
  fio_chacha20_poly1305_enc(result, msg, len, NULL, 0, key, nounce);
  return (uintptr_t)result[0];
}

FIO_SFUNC uintptr_t fio__chacha20poly1305dec_speed_wrapper(char *msg,
                                                           size_t len) {
  uint64_t result[2] = {0};
  char *key = (char *)"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c"
                      "\x0d\x0e\x0f"
                      "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c"
                      "\x1d\x1e\x1f";
  char *nounce = (char *)"\x00\x00\x00\x00\x00\x00\x00\x4a\x00\x00\x00\x00";
  fio_poly1305_auth(result, key, msg, len, NULL, 0);
  fio_chacha20(msg, len, key, nounce, 1);
  return (uintptr_t)result[0];
}

FIO_SFUNC void FIO_NAME_TEST(stl, chacha)(void) {
  fprintf(stderr, "* Testing ChaCha20 Poly1305\n");
  {
    uint32_t tv1[4] = {
        0x11111111,
        0x01020304,
        0x9b8d6f43,
        0x01234567,
    };
    FIO___CHACHA_QROUND(tv1[0], tv1[1], tv1[2], tv1[3]);
    FIO_ASSERT((tv1[0] == 0xea2a92f4 && tv1[1] == 0xcb1cf8ce &&
                tv1[2] == 0x4581472e && tv1[3] == 0x5881c4bb),
               "ChaCha quarter round example error");
  }
  { /* test ChaCha20 independently */
    struct {
      char key[33];
      char nounce[13];
      char *src;
      char *expected;
    } tests[] = {
        {
            .key = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d"
                   "\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b"
                   "\x1c\x1d\x1e\x1f",
            .nounce = "\x00\x00\x00\x00\x00\x00\x00\x4a\x00\x00\x00\x00",
            .src =
                (char *)"\x4c\x61\x64\x69\x65\x73\x20\x61\x6e\x64\x20\x47\x65"
                        "\x6e\x74\x6c\x65\x6d\x65\x6e\x20\x6f\x66\x20\x74\x68"
                        "\x65\x20\x63\x6c\x61\x73\x73\x20\x6f\x66\x20\x27\x39"
                        "\x39\x3a\x20\x49\x66\x20\x49\x20\x63\x6f\x75\x6c\x64"
                        "\x20\x6f\x66\x66\x65\x72\x20\x79\x6f\x75\x20\x6f\x6e"
                        "\x6c\x79\x20\x6f\x6e\x65\x20\x74\x69\x70\x20\x66\x6f"
                        "\x72\x20\x74\x68\x65\x20\x66\x75\x74\x75\x72\x65\x2c"
                        "\x20\x73\x75\x6e\x73\x63\x72\x65\x65\x6e\x20\x77\x6f"
                        "\x75\x6c\x64\x20\x62\x65\x20\x69\x74\x2e",
            .expected =
                (char *)"\x6e\x2e\x35\x9a\x25\x68\xf9\x80\x41\xba\x07\x28\xdd"
                        "\x0d\x69\x81\xe9\x7e\x7a\xec\x1d\x43\x60\xc2\x0a\x27"
                        "\xaf\xcc\xfd\x9f\xae\x0b\xf9\x1b\x65\xc5\x52\x47\x33"
                        "\xab\x8f\x59\x3d\xab\xcd\x62\xb3\x57\x16\x39\xd6\x24"
                        "\xe6\x51\x52\xab\x8f\x53\x0c\x35\x9f\x08\x61\xd8\x07"
                        "\xca\x0d\xbf\x50\x0d\x6a\x61\x56\xa3\x8e\x08\x8a\x22"
                        "\xb6\x5e\x52\xbc\x51\x4d\x16\xcc\xf8\x06\x81\x8c\xe9"
                        "\x1a\xb7\x79\x37\x36\x5a\xf9\x0b\xbf\x74\xa3\x5b\xe6"
                        "\xb4\x0b\x8e\xed\xf2\x78\x5e\x42\x87\x4d",
        },
        {
            .key = {0},
            .nounce = {0},
            .src =
                (char *)"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
                        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
            .expected =
                (char *)"\x3a\xeb\x52\x24\xec\xf8\x49\x92\x9b\x9d\x82\x8d\xb1"
                        "\xce\xd4\xdd\x83\x20\x25\xe8\x01\x8b\x81\x60\xb8\x22"
                        "\x84\xf3\xc9\x49\xaa\x5a\x8e\xca\x00\xbb\xb4\xa7\x3b"
                        "\xda\xd1\x92\xb5\xc4\x2f\x73\xf2\xfd\x4e\x27\x36\x44"
                        "\xc8\xb3\x61\x25\xa6\x4a\xdd\xeb\x00\x6c\x13\xa0",
        },
        {.expected = NULL}};
    for (size_t i = 0; tests[i].expected; ++i) {
      size_t len = strlen(tests[i].src);
      char buffer[4096];
      FIO_MEMCPY(buffer, tests[i].src, len);
      fio_chacha20(buffer, len, tests[i].key, tests[i].nounce, 1);
      FIO_ASSERT(!memcmp(buffer, tests[i].expected, len),
                 "ChaCha20 encoding failed");
      fio_chacha20(buffer, len, tests[i].key, tests[i].nounce, 1);
      FIO_ASSERT(!memcmp(buffer, tests[i].src, len),
                 "ChaCha20 decoding failed");
    }
  }
  { /* test Poly1305 independently */
    struct {
      char key[33];
      char *msg;
      char *expected;
    } tests[] = {{
                     .key = "\x85\xd6\xbe\x78\x57\x55\x6d\x33\x7f\x44\x52\xfe"
                            "\x42\xd5\x06\xa8\x01\x03\x80\x8a\xfb\x0d\xb2\xfd"
                            "\x4a\xbf\xf6\xaf\x41\x49\xf5\x1b",
                     .msg = (char *)"Cryptographic Forum Research Group",
                     .expected =
                         (char *)"\xa8\x06\x1d\xc1\x30\x51\x36\xc6\xc2\x2b\x8b"
                                 "\xaf\x0c\x01\x27\xa9",
                 },
                 {.expected = NULL}};
    char auth[16] = {0};
    char buf1[33] = {0};
    char buf2[33] = {0};
    for (size_t t = 0; tests[t].expected; ++t) {
      fio_poly1305_auth(auth,
                        tests[t].key,
                        tests[t].msg,
                        strlen(tests[t].msg),
                        NULL,
                        0);
      for (int i = 0; i < 16; ++i) {
        buf1[(i << 1)] = fio_i2c(((auth[i] >> 4) & 0xF));
        buf1[(i << 1) + 1] = fio_i2c(((auth[i]) & 0xF));
        buf2[(i << 1)] = fio_i2c(((tests[t].expected[i] >> 4) & 0xF));
        buf2[(i << 1) + 1] = fio_i2c(((tests[t].expected[i]) & 0xF));
      }
      FIO_ASSERT(!memcmp(auth, tests[t].expected, 16),
                 "Poly1305 example authentication failed:\n\t%s != %s",
                 buf1,
                 buf2);
    }
  }
  { /* test ChaCha20Poly1305 */
    struct {
      char key[33];
      char nounce[13];
      char *ad;
      size_t ad_len;
      char *msg;
      char *expected;
      char mac[17];
    } tests[] = {
        {
            .key = "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d"
                   "\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b"
                   "\x9c\x9d\x9e\x9f",
            .nounce = "\x07\x00\x00\x00\x40\x41\x42\x43\x44\x45\x46\x47",
            .ad = (char *)"\x50\x51\x52\x53\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7",
            .ad_len = 12,
            .msg =
                (char *)"\x4c\x61\x64\x69\x65\x73\x20\x61\x6e\x64\x20\x47\x65"
                        "\x6e\x74\x6c\x65\x6d\x65\x6e\x20\x6f\x66\x20\x74\x68"
                        "\x65\x20\x63\x6c\x61\x73\x73\x20\x6f\x66\x20\x27\x39"
                        "\x39\x3a\x20\x49\x66\x20\x49\x20\x63\x6f\x75\x6c\x64"
                        "\x20\x6f\x66\x66\x65\x72\x20\x79\x6f\x75\x20\x6f\x6e"
                        "\x6c\x79\x20\x6f\x6e\x65\x20\x74\x69\x70\x20\x66\x6f"
                        "\x72\x20\x74\x68\x65\x20\x66\x75\x74\x75\x72\x65\x2c"
                        "\x20\x73\x75\x6e\x73\x63\x72\x65\x65\x6e\x20\x77\x6f"
                        "\x75\x6c\x64\x20\x62\x65\x20\x69\x74\x2e",
            .expected =
                (char *)"\xd3\x1a\x8d\x34\x64\x8e\x60\xdb\x7b\x86\xaf\xbc\x53"
                        "\xef\x7e\xc2\xa4\xad\xed\x51\x29\x6e\x08\xfe\xa9\xe2"
                        "\xb5\xa7\x36\xee\x62\xd6\x3d\xbe\xa4\x5e\x8c\xa9\x67"
                        "\x12\x82\xfa\xfb\x69\xda\x92\x72\x8b\x1a\x71\xde\x0a"
                        "\x9e\x06\x0b\x29\x05\xd6\xa5\xb6\x7e\xcd\x3b\x36\x92"
                        "\xdd\xbd\x7f\x2d\x77\x8b\x8c\x98\x03\xae\xe3\x28\x09"
                        "\x1b\x58\xfa\xb3\x24\xe4\xfa\xd6\x75\x94\x55\x85\x80"
                        "\x8b\x48\x31\xd7\xbc\x3f\xf4\xde\xf0\x8e\x4b\x7a\x9d"
                        "\xe5\x76\xd2\x65\x86\xce\xc6\x4b\x61\x16",
            .mac = "\x1a\xe1\x0b\x59\x4f\x09\xe2\x6a\x7e\x90\x2e\xcb\xd0\x60"
                   "\x06\x91",
        },
        {
            .key = "\x1c\x92\x40\xa5\xeb\x55\xd3\x8a\xf3\x33\x88\x86\x04\xf6"
                   "\xb5\xf0\x47\x39\x17\xc1\x40\x2b\x80\x09\x9d\xca\x5c\xbc"
                   "\x20\x70\x75\xc0",
            .nounce = "\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08",
            .ad = (char *)"\xf3\x33\x88\x86\x00\x00\x00\x00\x00\x00\x4e\x91",
            .ad_len = 12,
            .msg =
                (char *)"\x49\x6e\x74\x65\x72\x6e\x65\x74\x2d\x44\x72\x61\x66"
                        "\x74\x73\x20\x61\x72\x65\x20\x64\x72\x61\x66\x74\x20"
                        "\x64\x6f\x63\x75\x6d\x65\x6e\x74\x73\x20\x76\x61\x6c"
                        "\x69\x64\x20\x66\x6f\x72\x20\x61\x20\x6d\x61\x78\x69"
                        "\x6d\x75\x6d\x20\x6f\x66\x20\x73\x69\x78\x20\x6d\x6f"
                        "\x6e\x74\x68\x73\x20\x61\x6e\x64\x20\x6d\x61\x79\x20"
                        "\x62\x65\x20\x75\x70\x64\x61\x74\x65\x64\x2c\x20\x72"
                        "\x65\x70\x6c\x61\x63\x65\x64\x2c\x20\x6f\x72\x20\x6f"
                        "\x62\x73\x6f\x6c\x65\x74\x65\x64\x20\x62\x79\x20\x6f"
                        "\x74\x68\x65\x72\x20\x64\x6f\x63\x75\x6d\x65\x6e\x74"
                        "\x73\x20\x61\x74\x20\x61\x6e\x79\x20\x74\x69\x6d\x65"
                        "\x2e\x20\x49\x74\x20\x69\x73\x20\x69\x6e\x61\x70\x70"
                        "\x72\x6f\x70\x72\x69\x61\x74\x65\x20\x74\x6f\x20\x75"
                        "\x73\x65\x20\x49\x6e\x74\x65\x72\x6e\x65\x74\x2d\x44"
                        "\x72\x61\x66\x74\x73\x20\x61\x73\x20\x72\x65\x66\x65"
                        "\x72\x65\x6e\x63\x65\x20\x6d\x61\x74\x65\x72\x69\x61"
                        "\x6c\x20\x6f\x72\x20\x74\x6f\x20\x63\x69\x74\x65\x20"
                        "\x74\x68\x65\x6d\x20\x6f\x74\x68\x65\x72\x20\x74\x68"
                        "\x61\x6e\x20\x61\x73\x20\x2f\xe2\x80\x9c\x77\x6f\x72"
                        "\x6b\x20\x69\x6e\x20\x70\x72\x6f\x67\x72\x65\x73\x73"
                        "\x2e\x2f\xe2\x80\x9d",
            .expected =
                (char *)"\x64\xa0\x86\x15\x75\x86\x1a\xf4\x60\xf0\x62\xc7\x9b"
                        "\xe6\x43\xbd\x5e\x80\x5c\xfd\x34\x5c\xf3\x89\xf1\x08"
                        "\x67\x0a\xc7\x6c\x8c\xb2\x4c\x6c\xfc\x18\x75\x5d\x43"
                        "\xee\xa0\x9e\xe9\x4e\x38\x2d\x26\xb0\xbd\xb7\xb7\x3c"
                        "\x32\x1b\x01\x00\xd4\xf0\x3b\x7f\x35\x58\x94\xcf\x33"
                        "\x2f\x83\x0e\x71\x0b\x97\xce\x98\xc8\xa8\x4a\xbd\x0b"
                        "\x94\x81\x14\xad\x17\x6e\x00\x8d\x33\xbd\x60\xf9\x82"
                        "\xb1\xff\x37\xc8\x55\x97\x97\xa0\x6e\xf4\xf0\xef\x61"
                        "\xc1\x86\x32\x4e\x2b\x35\x06\x38\x36\x06\x90\x7b\x6a"
                        "\x7c\x02\xb0\xf9\xf6\x15\x7b\x53\xc8\x67\xe4\xb9\x16"
                        "\x6c\x76\x7b\x80\x4d\x46\xa5\x9b\x52\x16\xcd\xe7\xa4"
                        "\xe9\x90\x40\xc5\xa4\x04\x33\x22\x5e\xe2\x82\xa1\xb0"
                        "\xa0\x6c\x52\x3e\xaf\x45\x34\xd7\xf8\x3f\xa1\x15\x5b"
                        "\x00\x47\x71\x8c\xbc\x54\x6a\x0d\x07\x2b\x04\xb3\x56"
                        "\x4e\xea\x1b\x42\x22\x73\xf5\x48\x27\x1a\x0b\xb2\x31"
                        "\x60\x53\xfa\x76\x99\x19\x55\xeb\xd6\x31\x59\x43\x4e"
                        "\xce\xbb\x4e\x46\x6d\xae\x5a\x10\x73\xa6\x72\x76\x27"
                        "\x09\x7a\x10\x49\xe6\x17\xd9\x1d\x36\x10\x94\xfa\x68"
                        "\xf0\xff\x77\x98\x71\x30\x30\x5b\xea\xba\x2e\xda\x04"
                        "\xdf\x99\x7b\x71\x4d\x6c\x6f\x2c\x29\xa6\xad\x5c\xb4"
                        "\x02\x2b\x02\x70\x9b",
            .mac = "\xee\xad\x9d\x67\x89\x0c\xbb\x22\x39\x23\x36\xfe\xa1\x85"
                   "\x1f\x38",
        },
        {.expected = NULL}};
    for (size_t i = 0; tests[i].expected; ++i) {
      size_t len = strlen(tests[i].msg);
      char buffer[1024];
      char mac[16], mac2[16];
      FIO_MEMCPY(buffer, tests[i].msg, len);
      fio_chacha20_poly1305_enc(mac,
                                buffer,
                                len,
                                tests[i].ad,
                                tests[i].ad_len,
                                tests[i].key,
                                tests[i].nounce);
      FIO_ASSERT(!memcmp(buffer, tests[i].expected, len),
                 "ChaCha20Poly1305 encoding failed");
      fio_chacha20_poly1305_auth(mac2,
                                 buffer,
                                 len,
                                 tests[i].ad,
                                 tests[i].ad_len,
                                 tests[i].key,
                                 tests[i].nounce);
      FIO_ASSERT(!memcmp(mac, mac2, 16),
                 "ChaCha20Poly1305 authentication != Poly1305 code");
      FIO_ASSERT(!memcmp(mac, tests[i].mac, 16),
                 "ChaCha20Poly1305 authentication code failed");
      FIO_ASSERT(!fio_chacha20_poly1305_dec(mac,
                                            buffer,
                                            len,
                                            tests[i].ad,
                                            tests[i].ad_len,
                                            tests[i].key,
                                            tests[i].nounce),
                 "fio_chacha20_poly1305_dec returned error for %s",
                 tests[i].msg);
      FIO_ASSERT(
          !memcmp(buffer, tests[i].msg, len),
          "ChaCha20Poly1305 decoding failed for %s\nshould have been %.*s",
          tests[i].msg,
          (int)len,
          buffer);
    }
  }

#if !DEBUG
  fio_test_hash_function(fio__poly1305_speed_wrapper,
                         (char *)"Poly1305",
                         7,
                         0,
                         0);
  fio_test_hash_function(fio__poly1305_speed_wrapper,
                         (char *)"Poly1305",
                         13,
                         0,
                         0);
  fio_test_hash_function(fio__poly1305_speed_wrapper,
                         (char *)"Poly1305 (unaligned)",
                         13,
                         3,
                         0);
#if HAVE_OPENSSL && 0
  fio_test_hash_function(__poly1305_open_ssl_wrapper,
                         (char *)"Poly1305",
                         7,
                         0,
                         0);
  fio_test_hash_function(__poly1305_open_ssl_wrapper,
                         (char *)"Poly1305",
                         13,
                         0,
                         0);
  fio_test_hash_function(__poly1305_open_ssl_wrapper,
                         (char *)"Poly1305 (unaligned)",
                         13,
                         3,
                         0);
#endif /* HAVE_OPENSSL */
  fprintf(stderr, "\n");
  fio_test_hash_function(fio__chacha20_speed_wrapper,
                         (char *)"ChaCha20",
                         7,
                         0,
                         0);
  fio_test_hash_function(fio__chacha20_speed_wrapper,
                         (char *)"ChaCha20",
                         13,
                         0,
                         0);
  fio_test_hash_function(fio__chacha20_speed_wrapper,
                         (char *)"ChaCha20 (unaligned)",
                         13,
                         3,
                         0);
  fprintf(stderr, "\n");
  fio_test_hash_function(fio__chacha20poly1305dec_speed_wrapper,
                         (char *)"ChaCha20Poly1305 (auth+decrypt)",
                         7,
                         0,
                         0);
  fio_test_hash_function(fio__chacha20poly1305dec_speed_wrapper,
                         (char *)"ChaCha20Poly1305 (auth+decrypt)",
                         13,
                         0,
                         0);
  fprintf(stderr, "\n");
  fio_test_hash_function(fio__chacha20poly1305_speed_wrapper,
                         (char *)"ChaCha20Poly1305 (encrypt+MAC)",
                         7,
                         0,
                         0);
  fio_test_hash_function(fio__chacha20poly1305_speed_wrapper,
                         (char *)"ChaCha20Poly1305 (encrypt+MAC)",
                         13,
                         0,
                         0);
#endif
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
*****************************************************************************
*/

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_CHACHA
#endif /* FIO_CHACHA */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_ED25519    /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                          Elliptic Curve ED25519 (WIP)




Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_ED25519) && !defined(H___FIO_ED25519___H)
#define H___FIO_ED25519___H

/* *****************************************************************************
TODO: ED 25519, ED 448

ED-25519 key generation, key exchange and signatures are crucial to complete the
minimal building blocks that would allow to secure inter-machine communication
in mostly secure environments. Of course the use of a tested cryptographic
library (where accessible) might be preferred, but some security is better than
none.
***************************************************************************** */

/* *****************************************************************************
ED25519 API
***************************************************************************** */

/* *****************************************************************************
Implementation - inlined static functions
***************************************************************************** */

/* *****************************************************************************
Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* prevent ED25519 keys from having a small period (cyclic value). */
FIO_IFUNC void fio___ed25519_clamp_on_key(fio_256u *k) {
  k->u8[0] &= 0xF8U;  /* zero out 3 least significant bits (emulate mul by 8) */
  k->u8[31] &= 0x7FU; /* unset most significant bit (constant time fix) */
  k->u8[31] |= 0x40U; /* set the 255th bit (making sure the value is big) */
}

/* *****************************************************************************
Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, FIO_ED25519)(void) {
  /*
   * TODO: test module here
   */
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_ED25519
#endif /* FIO_ED25519 */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_IMAP_CORE  /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




            Index Maps (mapping a partial hash to an Array object)
        Maps a Log 2 sized index map to a position in a Log 2 sized Array



Copyright: Boaz Segev, 2019-2021; License: ISC / MIT (choose your license)
***************************************************************************** */
#if defined(FIO_IMAP_CORE) && !defined(H___FIO_IMAP_CORE___H)
#define H___FIO_IMAP_CORE___H

/* *****************************************************************************
iMap Creation Macro
***************************************************************************** */
/**
 * This MACRO defines the type and functions needed for an indexed array.
 *
 * This is used internally and documentation is poor.
 *
 * An indexed array is simple ordered array who's objects are indexed using an
 * almost-hash map, allowing for easy seeking while also enjoying an array's
 * advantages.
 *
 * The index map uses one `imap_type` (i.e., `uint64_t`) to store both the index
 * in array and any leftover hash data (the first half being tested during the
 * random access and the leftover during comparison). The reserved value `0`
 * indicates a free slot. The reserved value `~0` indicates a freed item (a free
 * slot that was previously used).
 *
 * - `array_name_s`        the main array container (.ary is the array itself)
 * - `array_name_seeker_s` is a seeker type that finds objects.
 * - `array_name_seek`     finds an object or its future position.
 *
 * - `array_name_capa`     the imap's theoretical storage capacity.
 * - `array_name_set`      writes or overwrites data to the array.
 * - `array_name_get`      returns a pointer to the object within the array.
 * - `array_name_remove`   removes an object and resets its memory to zero.
 * - `array_name_reserve`  reserves a minimum imap storage capacity.
 * - `array_name_rehash`   re-builds the imap (use after sorting).
 */
#define FIO_TYPEDEF_IMAP_ARRAY(array_name,                                     \
                               array_type,                                     \
                               imap_type,                                      \
                               hash_fn,                                        \
                               cmp_fn,                                         \
                               is_valid_fn)                                    \
  typedef struct {                                                             \
    array_type *ary;                                                           \
    imap_type count;                                                           \
    imap_type w;                                                               \
    imap_type capa_bits;                                                       \
  } FIO_NAME(array_name, s);                                                   \
  typedef struct {                                                             \
    imap_type pos;                                                             \
    imap_type ipos;                                                            \
    imap_type set_val;                                                         \
  } FIO_NAME(array_name, seeker_s);                                            \
  /** Returns the theoretical capacity for the indexed array. */               \
  FIO_IFUNC int FIO_NAME(array_name, is_valid)(array_type * pobj) {            \
    return pobj && (!!is_valid_fn(pobj));                                      \
  }                                                                            \
  /** Returns the theoretical capacity for the indexed array. */               \
  FIO_IFUNC imap_type FIO_NAME(array_name,                                     \
                               capa)(FIO_NAME(array_name, s) * a) {            \
    if (!a || !a->capa_bits)                                                   \
      return 0;                                                                \
    return ((imap_type)1ULL << a->capa_bits);                                  \
  }                                                                            \
  /** Returns a pointer to the index map. */                                   \
  FIO_IFUNC imap_type *FIO_NAME(array_name,                                    \
                                imap)(FIO_NAME(array_name, s) * a) {           \
    return (imap_type *)(a->ary + ((imap_type)1ULL << a->capa_bits));          \
  }                                                                            \
  /** Deallocates dynamic memory. */                                           \
  FIO_IFUNC void FIO_NAME(array_name, destroy)(FIO_NAME(array_name, s) * a) {  \
    size_t capa = FIO_NAME(array_name, capa)(a);                               \
    FIO_MEM_FREE(a->ary,                                                       \
                 (capa * (sizeof(*a->ary)) + (capa * (sizeof(imap_type)))));   \
    *a = (FIO_NAME(array_name, s)){0};                                         \
    (void)capa; /* if unused */                                                \
  }                                                                            \
  /** Allocates dynamic memory. */                                             \
  FIO_IFUNC int FIO_NAME(array_name, __alloc)(FIO_NAME(array_name, s) * a,     \
                                              size_t bits) {                   \
    if (!bits || bits > ((sizeof(imap_type) << 3) - 2))                        \
      return -1;                                                               \
    size_t capa = 1ULL << bits;                                                \
    size_t old_capa = FIO_NAME(array_name, capa)(a);                           \
    array_type *tmp = (array_type *)FIO_MEM_REALLOC(                           \
        a->ary,                                                                \
        (a->bits ? (old_capa * (sizeof(array_type)) +                          \
                    (old_capa * (sizeof(imap_type))))                          \
                 : 0),                                                         \
        (capa * (sizeof(array_type)) + (capa * (sizeof(imap_type)))),          \
        (a->w * (sizeof(array_type))));                                        \
    (void)old_capa; /* if unused */                                            \
    if (!tmp)                                                                  \
      return -1;                                                               \
    a->capa_bits = bits;                                                       \
    a->ary = tmp;                                                              \
    if (!FIO_MEM_REALLOC_IS_SAFE)                                              \
      FIO_MEMSET((tmp + capa), 0, (capa * (sizeof(imap_type))));               \
    return 0;                                                                  \
  }                                                                            \
  /** Returns the index map position and array position of a value, if any. */ \
  FIO_SFUNC FIO_NAME(array_name, seeker_s)                                     \
      FIO_NAME(array_name, seek)(FIO_NAME(array_name, s) * a,                  \
                                 array_type * pobj) {                          \
    FIO_NAME(array_name, seeker_s) r = {0, (~(imap_type)0), (~(imap_type)0)};  \
    if (!a || ((!a->capa_bits) | (!a->ary)))                                   \
      return r;                                                                \
    r.pos = a->w;                                                              \
    imap_type capa = (imap_type)1UL << a->capa_bits;                           \
    imap_type *imap = (imap_type *)(a->ary + capa);                            \
    const imap_type pos_mask = capa - 1;                                       \
    const imap_type hash_mask = ~pos_mask;                                     \
    const imap_type hash = hash_fn(pobj);                                      \
    imap_type tester = hash & hash_mask;                                       \
    tester += (!tester) << a->capa_bits;                                       \
    tester -= (hash_mask == tester) << a->capa_bits;                           \
    size_t attempts = 11;                                                      \
    imap_type pos = hash;                                                      \
    for (;;) {                                                                 \
      /* test up to 3 groups of 4 bytes (uint32_t) within a 64 byte group */   \
      for (size_t mini_steps = 0;;) {                                          \
        pos &= pos_mask;                                                       \
        const imap_type pos_hash = imap[pos] & hash_mask;                      \
        const imap_type pos_index = imap[pos] & pos_mask;                      \
        if ((pos_hash == tester) && cmp_fn((a->ary + pos_index), pobj)) {      \
          r.ipos = pos;                                                        \
          r.pos = pos_index;                                                   \
          r.set_val = tester | pos_index;                                      \
          return r;                                                            \
        }                                                                      \
        if (!imap[pos]) {                                                      \
          r.ipos = pos;                                                        \
          r.set_val = tester | r.pos; /* r.pos == a->w */                      \
          return r;                                                            \
        }                                                                      \
        if (imap[pos] == (imap_type)(~(imap_type)0)) {                         \
          r.ipos = pos;                                                        \
          r.set_val = tester | r.pos; /* r.pos == a->w */                      \
        }                                                                      \
        if (!((--attempts)))                                                   \
          return r;                                                            \
        if (mini_steps == 2)                                                   \
          break;                                                               \
        pos += 3 + mini_steps; /* 0, 3, 7 =  max of 56 byte distance */        \
        ++mini_steps;                                                          \
      }                                                                        \
      pos += 0x43F82D0BUL; /* big step */                                      \
    }                                                                          \
  }                                                                            \
  /** fills an empty imap with the info about existing elements. */            \
  FIO_SFUNC int FIO_NAME(array_name,                                           \
                         __fill_imap)(FIO_NAME(array_name, s) * a) {           \
    if (!a->count) {                                                           \
      a->w = 0;                                                                \
      return 0;                                                                \
    }                                                                          \
    imap_type *imap = FIO_NAME(array_name, imap)(a);                           \
    if (a->count != a->w) {                                                    \
      a->count = 0;                                                            \
      for (size_t i = 0; i < a->w; ++i) {                                      \
        if (!is_valid_fn(a->ary + i))                                          \
          continue;                                                            \
        if (a->count != i)                                                     \
          a->ary[a->count] = a->ary[i];                                        \
        ++a->count;                                                            \
      }                                                                        \
    }                                                                          \
    for (a->w = 0; a->w < a->count; ++(a->w)) {                                \
      FIO_NAME(array_name, seeker_s)                                           \
      s = FIO_NAME(array_name, seek)(a, a->ary + a->w);                        \
      if (s.pos != a->w || s.ipos == (~(imap_type)0)) {                        \
        a->w = a->count;                                                       \
        return -1; /* destination not big enough to contain collisions! */     \
      }                                                                        \
      imap[s.ipos] = s.set_val;                                                \
    }                                                                          \
    a->w = a->count;                                                           \
    return 0;                                                                  \
  }                                                                            \
  /** expands the existing array & imap storage capacity. */                   \
  FIO_IFUNC int FIO_NAME(array_name, __expand)(FIO_NAME(array_name, s) * a) {  \
    for (;;) {                                                                 \
      if (FIO_NAME(array_name, __alloc)(a,                                     \
                                        a->capa_bits + 1 + (!a->capa_bits)))   \
        return -1;                                                             \
      if (!FIO_NAME(array_name, __fill_imap)(a))                               \
        return 0;                                                              \
    }                                                                          \
  }                                                                            \
  /** Reserves a minimum imap storage capacity. */                             \
  FIO_IFUNC int FIO_NAME(array_name, reserve)(FIO_NAME(array_name, s) * a,     \
                                              imap_type min) {                 \
    imap_type bits = 2;                                                        \
    if (min > ((imap_type)~0ULL) >> 1)                                         \
      return -1;                                                               \
    while ((1ULL << bits) < min)                                               \
      ++bits;                                                                  \
    if (bits <= a->capa_bits)                                                  \
      return 0;                                                                \
    if (FIO_NAME(array_name, __alloc)(a, bits))                                \
      return -1;                                                               \
    if (!FIO_NAME(array_name, __fill_imap)(a))                                 \
      return 0;                                                                \
    return FIO_NAME(array_name, __expand)(a);                                  \
  }                                                                            \
  /** Rehashes the array and fills the imap (use after sorting). */            \
  FIO_IFUNC int FIO_NAME(array_name, rehash)(FIO_NAME(array_name, s) * a) {    \
    if (!a || !a->ary)                                                         \
      return -1;                                                               \
    size_t bytes = sizeof(imap_type) * ((size_t)1ULL << a->capa_bits);         \
    imap_type *imap = FIO_NAME(array_name, imap)(a);                           \
    FIO_MEMSET(imap, 0, bytes);                                                \
    if (!FIO_NAME(array_name, __fill_imap)(a))                                 \
      return -1;                                                               \
    return 0;                                                                  \
  }                                                                            \
  /** Sets an object in the Array. Optionally overwrites existing data. */     \
  FIO_IFUNC array_type *FIO_NAME(array_name, set)(FIO_NAME(array_name, s) * a, \
                                                  array_type obj,              \
                                                  int overwrite) {             \
    if (!a || !is_valid_fn(&obj))                                              \
      return NULL;                                                             \
    {                                                                          \
      size_t capa = FIO_NAME(array_name, capa)(a);                             \
      if (a->w == capa)                                                        \
        FIO_NAME(array_name, __expand)(a);                                     \
      else if (a->count != a->w &&                                             \
               (a->w + (a->w >> 1)) > FIO_NAME(array_name, capa)(a)) {         \
        FIO_MEMSET((a->ary + capa), 0, (capa * (sizeof(imap_type))));          \
        FIO_NAME(array_name, __fill_imap)(a);                                  \
      }                                                                        \
    }                                                                          \
    for (;;) {                                                                 \
      FIO_NAME(array_name, seeker_s) s = FIO_NAME(array_name, seek)(a, &obj);  \
      if (s.ipos == (imap_type)(~(imap_type)0)) { /* no room in the imap */    \
        FIO_NAME(array_name, __expand)(a);                                     \
        continue;                                                              \
      }                                                                        \
      if (s.pos == a->w) { /* new object */                                    \
        a->ary[a->w] = obj;                                                    \
        ++a->w;                                                                \
        ++a->count;                                                            \
        FIO_NAME(array_name, imap)(a)[s.ipos] = s.set_val;                     \
        return a->ary + s.pos;                                                 \
      }                                                                        \
      FIO_ASSERT_DEBUG(s.pos < a->w && s.ipos < FIO_NAME(array_name, capa)(a), \
                       "WTF?");                                                \
      if (!overwrite)                                                          \
        return a->ary + s.pos;                                                 \
      a->ary[s.pos] = obj;                                                     \
      return a->ary + s.pos;                                                   \
    }                                                                          \
  }                                                                            \
  /** Finds an object in the Array using the index map. */                     \
  FIO_IFUNC array_type *FIO_NAME(array_name, get)(FIO_NAME(array_name, s) * a, \
                                                  array_type obj) {            \
    if (!a || !is_valid_fn(&obj))                                              \
      return NULL;                                                             \
    FIO_NAME(array_name, seeker_s) s = FIO_NAME(array_name, seek)(a, &obj);    \
    if (s.pos >= a->w)                                                         \
      return NULL;                                                             \
    return a->ary + s.pos;                                                     \
  }                                                                            \
  /** Removes an object in the Array's index map, zeroing out its memory. */   \
  FIO_IFUNC int FIO_NAME(array_name, remove)(FIO_NAME(array_name, s) * a,      \
                                             array_type obj) {                 \
    if (!a || !is_valid_fn(&obj))                                              \
      return -1;                                                               \
    FIO_NAME(array_name, seeker_s) s = FIO_NAME(array_name, seek)(a, &obj);    \
    if (s.pos >= a->w)                                                         \
      return -1;                                                               \
    a->ary[s.pos] = (array_type){0};                                           \
    FIO_NAME(array_name, imap)(a)[s.ipos] = (~(imap_type)0);                   \
    --a->count;                                                                \
    while (a->w && !is_valid_fn(a->ary + a->w - 1))                            \
      --a->w;                                                                  \
    return 0;                                                                  \
  }

#define FIO_IMAP_EACH(array_name, map_ptr, i)                                  \
  for (size_t i = 0; i < map_ptr->w; ++i)                                      \
    if (!FIO_NAME(array_name, is_valid)(map_ptr->ary + i))                     \
      continue;                                                                \
    else

/** Helper macro for simple imap array types. */
#define FIO_IMAP_ALWAYS_VALID(o) 1
/** Helper macro for simple imap array types. */
#define FIO_IMAP_SIMPLE_CMP(a, b) ((a)[0] == (b)[0])

/* *****************************************************************************
iMap Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

#define FIO_IMAP_TESTER_IMAP_HASH(n)   ((n)[0] | ((n)[0] << 9))
#define FIO_IMAP_TESTER_IMAP_CMP(a, b) (*(a) == *(b))
#define FIO_IMAP_TESTER_IMAP_VALID(n)  ((n)[0])
FIO_TYPEDEF_IMAP_ARRAY(fio_imap_tester,
                       size_t,
                       uint32_t, /* good for up to 65K objects */
                       FIO_IMAP_TESTER_IMAP_HASH,
                       FIO_IMAP_TESTER_IMAP_CMP,
                       FIO_IMAP_TESTER_IMAP_VALID)

#undef FIO_IMAP_TESTER_IMAP_HASH
#undef FIO_IMAP_TESTER_IMAP_CMP
#undef FIO_IMAP_TESTER_IMAP_VALID

FIO_SFUNC void FIO_NAME_TEST(stl, imap_core)(void) {
  fprintf(stderr, "* Testing core indexed array type (imap).\n");
  fio_imap_tester_s a = {0};
  fio_imap_tester_reserve(&a, 1024);
  FIO_ASSERT(fio_imap_tester_capa(&a) >= 1024 &&
                 fio_imap_tester_capa(&a) < 4096,
             "fio_imap_tester_reserve failed");
  for (size_t val = 1; val < 4096; ++val) {
    size_t *pobj = fio_imap_tester_set(&a, val, 1);
    FIO_ASSERT(a.count == val, "imap array count failed at set %zu!", val);
    size_t *ptmp = fio_imap_tester_set(&a, val, 0);
    FIO_ASSERT(ptmp == pobj,
               "fio_imap_tester_set should return pointer to existing item");
    ptmp = fio_imap_tester_set(&a, val, 0);
    FIO_ASSERT(ptmp == pobj,
               "fio_imap_tester_set should return pointer to existing item");
    ptmp = fio_imap_tester_set(&a, val, 0);
    FIO_ASSERT(ptmp == pobj,
               "fio_imap_tester_set should return pointer to existing item");
    FIO_ASSERT(a.count == val, "imap array double-set error %zu!", val);
    FIO_ASSERT(fio_imap_tester_get(&a, val) == pobj &&
                   fio_imap_tester_get(&a, val)[0] == val,
               "imap array get failed for %zu!",
               val);
  }
  for (size_t val = 1; val < 4096; ++val) {
    FIO_ASSERT(fio_imap_tester_get(&a, val) &&
                   fio_imap_tester_get(&a, val)[0] == val,
               "imap array get failed for %zu (2)!",
               val);
  }
  for (size_t val = 4096; --val;) {
    FIO_ASSERT(fio_imap_tester_get(&a, val) &&
                   fio_imap_tester_get(&a, val)[0] == val,
               "imap array get failed for %zu (2)!",
               val);
    fio_imap_tester_remove(&a, val);
    FIO_ASSERT((size_t)(a.count + 1) == val,
               "imap array count failed at remove %zu!",
               val);
    FIO_ASSERT(!fio_imap_tester_get(&a, val),
               "imap array get should fail after remove for %zu!",
               val);
  }
  fio_imap_tester_destroy(&a);
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
iMap Cleanup
***************************************************************************** */
#endif /* FIO_IMAP_CORE */
#undef FIO_IMAP_CORE
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_URL        /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                                  URI Parsing



Copyright: Boaz Segev, 2019-2021; License: ISC / MIT (choose your license)
***************************************************************************** */
#if (defined(FIO_URL) || defined(FIO_URI)) && !defined(H___FIO_URL___H)
#define H___FIO_URL___H
/** the result returned by `fio_url_parse` */
typedef struct {
  fio_buf_info_s scheme;
  fio_buf_info_s user;
  fio_buf_info_s password;
  fio_buf_info_s host;
  fio_buf_info_s port;
  fio_buf_info_s path;
  fio_buf_info_s query;
  fio_buf_info_s target;
} fio_url_s;

/**
 * Parses the URI returning it's components and their lengths (no decoding
 * performed, doesn't accept decoded URIs).
 *
 * The returned string are NOT NUL terminated, they are merely locations within
 * the original string.
 *
 * This function attempts to accept many different formats, including any of the
 * following:
 *
 * * `/complete_path?query#target`
 *
 *   i.e.: /index.html?page=1#list
 *
 * * `host:port/complete_path?query#target`
 *
 *   i.e.:
 *      example.com
 *      example.com:8080
 *      example.com/index.html
 *      example.com:8080/index.html
 *      example.com:8080/index.html?key=val#target
 *
 * * `user:password@host:port/path?query#target`
 *
 *   i.e.: user:1234@example.com:8080/index.html
 *
 * * `username[:password]@host[:port][...]`
 *
 *   i.e.: john:1234@example.com
 *
 * * `schema://user:password@host:port/path?query#target`
 *
 *   i.e.: http://example.com/index.html?page=1#list
 *
 * Invalid formats might produce unexpected results. No error testing performed.
 *
 * NOTE: the `unix`, `file` and `priv` schemas are reserved for file paths.
 */
SFUNC fio_url_s fio_url_parse(const char *url, size_t len);

/* *****************************************************************************
FIO_URL - Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/**
 * Parses the URI returning it's components and their lengths (no decoding
 * performed, doesn't accept decoded URIs).
 *
 * The returned string are NOT NUL terminated, they are merely locations within
 * the original string.
 *
 * This function expects any of the following formats:
 *
 * * `/complete_path?query#target`
 *
 *   i.e.: /index.html?page=1#list
 *
 * * `host:port/complete_path?query#target`
 *
 *   i.e.:
 *      example.com/index.html
 *      example.com:8080/index.html
 *
 * * `schema://user:password@host:port/path?query#target`
 *
 *   i.e.: http://example.com/index.html?page=1#list
 *
 * Invalid formats might produce unexpected results. No error testing performed.
 */
SFUNC fio_url_s fio_url_parse(const char *url, size_t len) {
  /*
  Intention:
  [schema://][user[:]][password[@]][host.com[:/]][:port/][/path][?quary][#target]
  */
  const char *end = url + len;
  const char *pos = url;
  fio_url_s r = {.scheme = {.buf = (char *)url}};
  if (len == 0) {
    goto finish;
  }

  if (pos[0] == '/') {
    /* start at path */
    goto start_path;
  }

  while (pos < end && pos[0] != ':' && pos[0] != '/' && pos[0] != '@' &&
         pos[0] != '#' && pos[0] != '?')
    ++pos;

  if (pos == end) {
    /* was only host (path starts with '/') */
    r.host = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    goto finish;
  }

  switch (pos[0]) {
  case '@':
    /* username@[host] */
    r.user = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    ++pos;
    goto start_host;
  case '/':
    /* host[/path] */
    r.host = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    goto start_path;
  case '?':
    /* host?[query] */
    r.host = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    ++pos;
    goto start_query;
  case '#':
    /* host#[target] */
    r.host = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    ++pos;
    goto start_target;
  case ':':
    if (pos + 2 <= end && pos[1] == '/' && pos[2] == '/') {
      /* scheme:// */
      r.scheme.len = pos - url;
      pos += 3;
    } else {
      /* username:[password] OR */
      /* host:[port] */
      r.user = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
      ++pos;
      goto start_password;
    }
    break;
  }

  // start_username:
  url = pos;
  while (pos < end && pos[0] != ':' && pos[0] != '/' && pos[0] != '@'
         /* && pos[0] != '#' && pos[0] != '?' */)
    ++pos;

  if (pos >= end) { /* scheme://host */
    r.host = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    goto finish;
  }

  switch (pos[0]) {
  case '/':
    /* scheme://host[/path] */
    r.host = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    goto start_path;
  case '@':
    /* scheme://username@[host]... */
    r.user = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    ++pos;
    goto start_host;
  case ':':
    /* scheme://username:[password]@[host]... OR */
    /* scheme://host:[port][/...] */
    r.user = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    ++pos;
    break;
  }

start_password:
  url = pos;
  while (pos < end && pos[0] != '/' && pos[0] != '@')
    ++pos;

  if (pos >= end) {
    /* was host:port */
    r.port = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    r.host = r.user;
    r.user.len = 0;
    goto finish;
    ;
  }

  switch (pos[0]) {
  case '/':
    r.port = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    r.host = r.user;
    r.user.len = 0;
    goto start_path;
  case '@':
    r.password =
        (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
    ++pos;
    break;
  }

start_host:
  url = pos;
  while (pos < end && pos[0] != '/' && pos[0] != ':' && pos[0] != '#' &&
         pos[0] != '?')
    ++pos;

  r.host = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
  if (pos >= end) {
    goto finish;
  }
  switch (pos[0]) {
  case '/':
    /* scheme://[...@]host[/path] */
    goto start_path;
  case '?':
    /* scheme://[...@]host?[query] (bad)*/
    ++pos;
    goto start_query;
  case '#':
    /* scheme://[...@]host#[target] (bad)*/
    ++pos;
    goto start_target;
    // case ':':
    /* scheme://[...@]host:[port] */
  }
  ++pos;

  // start_port:
  url = pos;
  while (pos < end && pos[0] != '/' && pos[0] != '#' && pos[0] != '?')
    ++pos;

  r.port = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};

  if (pos >= end) {
    /* scheme://[...@]host:port */
    goto finish;
  }
  switch (pos[0]) {
  case '?':
    /* scheme://[...@]host:port?[query] (bad)*/
    ++pos;
    goto start_query;
  case '#':
    /* scheme://[...@]host:port#[target] (bad)*/
    ++pos;
    goto start_target;
    // case '/':
    /* scheme://[...@]host:port[/path] */
  }

start_path:
  url = pos;
  while (pos < end && pos[0] != '#' && pos[0] != '?')
    ++pos;

  r.path = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};

  if (pos >= end) {
    goto finish;
  }
  ++pos;
  if (pos[-1] == '#')
    goto start_target;

start_query:
  url = pos;
  while (pos < end && pos[0] != '#')
    ++pos;

  r.query = (fio_buf_info_s){.buf = (char *)url, .len = (size_t)(pos - url)};
  ++pos;

  if (pos >= end)
    goto finish;

start_target:
  r.target = (fio_buf_info_s){.buf = (char *)pos, .len = (size_t)(end - pos)};

finish:

  if (r.scheme.len == 4 && r.host.buf) {
    uint32_t s, file_str, unix_str, priv_str;
    fio_memcpy4(&file_str, "file");
    fio_memcpy4(&unix_str, "unix");
    fio_memcpy4(&priv_str, "priv");
    fio_memcpy4(&s, r.scheme.buf);
    s |= 0x20202020U; /* downcase */
    if (s == file_str || s == unix_str || s == priv_str) {
      r.path.len = end - (r.scheme.buf + 7);
      r.path.buf = r.scheme.buf + 7;
      r.user.len = r.password.len = r.port.len = r.host.len = r.query.len =
          r.target.len = 0;
    }
  } else if (!r.scheme.len && r.host.buf && r.host.buf[0] == '.') {
    r.path.len = end - r.host.buf;
    r.path.buf = r.host.buf;
    r.query.len = r.target.len = r.host.len = 0;
  }

  /* set any empty values to NULL */
  if (!r.scheme.len)
    r.scheme.buf = NULL;
  if (!r.user.len)
    r.user.buf = NULL;
  if (!r.password.len)
    r.password.buf = NULL;
  if (!r.host.len)
    r.host.buf = NULL;
  if (!r.port.len)
    r.port.buf = NULL;
  if (!r.path.len)
    r.path.buf = NULL;
  if (!r.query.len)
    r.query.buf = NULL;
  if (!r.target.len)
    r.target.buf = NULL;

  return r;
}

/* *****************************************************************************
URL parsing - Test
***************************************************************************** */
#ifdef FIO_TEST_CSTL

/* Test for URI variations:
 *
 * * `/complete_path?query#target`
 *
 *   i.e.: /index.html?page=1#list
 *
 * * `host:port/complete_path?query#target`
 *
 *   i.e.:
 *      example.com
 *      example.com:8080
 *      example.com/index.html
 *      example.com:8080/index.html
 *      example.com:8080/index.html?key=val#target
 *
 * * `user:password@host:port/path?query#target`
 *
 *   i.e.: user:1234@example.com:8080/index.html
 *
 * * `username[:password]@host[:port][...]`
 *
 *   i.e.: john:1234@example.com
 *
 * * `schema://user:password@host:port/path?query#target`
 *
 *   i.e.: http://example.com/index.html?page=1#list
 */
FIO_SFUNC void FIO_NAME_TEST(stl, url)(void) {
  fprintf(stderr, "* Testing URL (URI) parser.\n");
  struct {
    char *url;
    size_t len;
    fio_url_s expected;
  } tests[] = {
      {
          .url = (char *)"file://go/home/",
          .len = 15,
          .expected =
              {
                  .scheme = {.buf = (char *)"file", .len = 4},
                  .path = {.buf = (char *)"go/home/", .len = 8},
              },
      },
      {
          .url = (char *)"unix:///go/home/",
          .len = 16,
          .expected =
              {
                  .scheme = {.buf = (char *)"unix", .len = 4},
                  .path = {.buf = (char *)"/go/home/", .len = 9},
              },
      },
      {
          .url = (char *)"schema://user:password@host:port/path?query#target",
          .len = 50,
          .expected =
              {
                  .scheme = {.buf = (char *)"schema", .len = 6},
                  .user = {.buf = (char *)"user", .len = 4},
                  .password = {.buf = (char *)"password", .len = 8},
                  .host = {.buf = (char *)"host", .len = 4},
                  .port = {.buf = (char *)"port", .len = 4},
                  .path = {.buf = (char *)"/path", .len = 5},
                  .query = {.buf = (char *)"query", .len = 5},
                  .target = {.buf = (char *)"target", .len = 6},
              },
      },
      {
          .url = (char *)"schema://user@host:port/path?query#target",
          .len = 41,
          .expected =
              {
                  .scheme = {.buf = (char *)"schema", .len = 6},
                  .user = {.buf = (char *)"user", .len = 4},
                  .host = {.buf = (char *)"host", .len = 4},
                  .port = {.buf = (char *)"port", .len = 4},
                  .path = {.buf = (char *)"/path", .len = 5},
                  .query = {.buf = (char *)"query", .len = 5},
                  .target = {.buf = (char *)"target", .len = 6},
              },
      },
      {
          .url = (char *)"http://localhost.com:3000/home?is=1",
          .len = 35,
          .expected =
              {
                  .scheme = {.buf = (char *)"http", .len = 4},
                  .host = {.buf = (char *)"localhost.com", .len = 13},
                  .port = {.buf = (char *)"3000", .len = 4},
                  .path = {.buf = (char *)"/home", .len = 5},
                  .query = {.buf = (char *)"is=1", .len = 4},
              },
      },
      {
          .url = (char *)"/complete_path?query#target",
          .len = 27,
          .expected =
              {
                  .path = {.buf = (char *)"/complete_path", .len = 14},
                  .query = {.buf = (char *)"query", .len = 5},
                  .target = {.buf = (char *)"target", .len = 6},
              },
      },
      {
          .url = (char *)"/index.html?page=1#list",
          .len = 23,
          .expected =
              {
                  .path = {.buf = (char *)"/index.html", .len = 11},
                  .query = {.buf = (char *)"page=1", .len = 6},
                  .target = {.buf = (char *)"list", .len = 4},
              },
      },
      {
          .url = (char *)"example.com",
          .len = 11,
          .expected =
              {
                  .host = {.buf = (char *)"example.com", .len = 11},
              },
      },

      {
          .url = (char *)"example.com:8080",
          .len = 16,
          .expected =
              {
                  .host = {.buf = (char *)"example.com", .len = 11},
                  .port = {.buf = (char *)"8080", .len = 4},
              },
      },
      {
          .url = (char *)"example.com/index.html",
          .len = 22,
          .expected =
              {
                  .host = {.buf = (char *)"example.com", .len = 11},
                  .path = {.buf = (char *)"/index.html", .len = 11},
              },
      },
      {
          .url = (char *)"example.com:8080/index.html",
          .len = 27,
          .expected =
              {
                  .host = {.buf = (char *)"example.com", .len = 11},
                  .port = {.buf = (char *)"8080", .len = 4},
                  .path = {.buf = (char *)"/index.html", .len = 11},
              },
      },
      {
          .url = (char *)"example.com:8080/index.html?key=val#target",
          .len = 42,
          .expected =
              {
                  .host = {.buf = (char *)"example.com", .len = 11},
                  .port = {.buf = (char *)"8080", .len = 4},
                  .path = {.buf = (char *)"/index.html", .len = 11},
                  .query = {.buf = (char *)"key=val", .len = 7},
                  .target = {.buf = (char *)"target", .len = 6},
              },
      },
      {
          .url = (char *)"user:1234@example.com:8080/index.html",
          .len = 37,
          .expected =
              {
                  .user = {.buf = (char *)"user", .len = 4},
                  .password = {.buf = (char *)"1234", .len = 4},
                  .host = {.buf = (char *)"example.com", .len = 11},
                  .port = {.buf = (char *)"8080", .len = 4},
                  .path = {.buf = (char *)"/index.html", .len = 11},
              },
      },
      {
          .url = (char *)"user@example.com:8080/index.html",
          .len = 32,
          .expected =
              {
                  .user = {.buf = (char *)"user", .len = 4},
                  .host = {.buf = (char *)"example.com", .len = 11},
                  .port = {.buf = (char *)"8080", .len = 4},
                  .path = {.buf = (char *)"/index.html", .len = 11},
              },
      },
      {.url = NULL},
  };
  for (size_t i = 0; tests[i].url; ++i) {
    fio_url_s result = fio_url_parse(tests[i].url, tests[i].len);
    FIO_LOG_DEBUG2("Result for: %s"
                   "\n\t     scheme   (%zu bytes):  %.*s"
                   "\n\t     user     (%zu bytes):  %.*s"
                   "\n\t     password (%zu bytes):  %.*s"
                   "\n\t     host     (%zu bytes):  %.*s"
                   "\n\t     port     (%zu bytes):  %.*s"
                   "\n\t     path     (%zu bytes):  %.*s"
                   "\n\t     query    (%zu bytes):  %.*s"
                   "\n\t     target   (%zu bytes):  %.*s\n",
                   tests[i].url,
                   result.scheme.len,
                   (int)result.scheme.len,
                   result.scheme.buf,
                   result.user.len,
                   (int)result.user.len,
                   result.user.buf,
                   result.password.len,
                   (int)result.password.len,
                   result.password.buf,
                   result.host.len,
                   (int)result.host.len,
                   result.host.buf,
                   result.port.len,
                   (int)result.port.len,
                   result.port.buf,
                   result.path.len,
                   (int)result.path.len,
                   result.path.buf,
                   result.query.len,
                   (int)result.query.len,
                   result.query.buf,
                   result.target.len,
                   (int)result.target.len,
                   result.target.buf);
    FIO_ASSERT(
        result.scheme.len == tests[i].expected.scheme.len &&
            (!result.scheme.len || !memcmp(result.scheme.buf,
                                           tests[i].expected.scheme.buf,
                                           tests[i].expected.scheme.len)),
        "scheme result failed for:\n\ttest[%zu]: %s\n\texpected: "
        "%s\n\tgot: %.*s",
        i,
        tests[i].url,
        tests[i].expected.scheme.buf,
        (int)result.scheme.len,
        result.scheme.buf);
    FIO_ASSERT(
        result.user.len == tests[i].expected.user.len &&
            (!result.user.len || !memcmp(result.user.buf,
                                         tests[i].expected.user.buf,
                                         tests[i].expected.user.len)),
        "user result failed for:\n\ttest[%zu]: %s\n\texpected: %s\n\tgot: %.*s",
        i,
        tests[i].url,
        tests[i].expected.user.buf,
        (int)result.user.len,
        result.user.buf);
    FIO_ASSERT(
        result.password.len == tests[i].expected.password.len &&
            (!result.password.len || !memcmp(result.password.buf,
                                             tests[i].expected.password.buf,
                                             tests[i].expected.password.len)),
        "password result failed for:\n\ttest[%zu]: %s\n\texpected: %s\n\tgot: "
        "%.*s",
        i,
        tests[i].url,
        tests[i].expected.password.buf,
        (int)result.password.len,
        result.password.buf);
    FIO_ASSERT(
        result.host.len == tests[i].expected.host.len &&
            (!result.host.len || !memcmp(result.host.buf,
                                         tests[i].expected.host.buf,
                                         tests[i].expected.host.len)),
        "host result failed for:\n\ttest[%zu]: %s\n\texpected: %s\n\tgot: %.*s",
        i,
        tests[i].url,
        tests[i].expected.host.buf,
        (int)result.host.len,
        result.host.buf);
    FIO_ASSERT(
        result.port.len == tests[i].expected.port.len &&
            (!result.port.len || !memcmp(result.port.buf,
                                         tests[i].expected.port.buf,
                                         tests[i].expected.port.len)),
        "port result failed for:\n\ttest[%zu]: %s\n\texpected: %s\n\tgot: %.*s",
        i,
        tests[i].url,
        tests[i].expected.port.buf,
        (int)result.port.len,
        result.port.buf);
    FIO_ASSERT(
        result.path.len == tests[i].expected.path.len &&
            (!result.path.len || !memcmp(result.path.buf,
                                         tests[i].expected.path.buf,
                                         tests[i].expected.path.len)),
        "path result failed for:\n\ttest[%zu]: %s\n\texpected: %s\n\tgot: %.*s",
        i,
        tests[i].url,
        tests[i].expected.path.buf,
        (int)result.path.len,
        result.path.buf);
    FIO_ASSERT(result.query.len == tests[i].expected.query.len &&
                   (!result.query.len || !memcmp(result.query.buf,
                                                 tests[i].expected.query.buf,
                                                 tests[i].expected.query.len)),
               "query result failed for:\n\ttest[%zu]: %s\n\texpected: "
               "%s\n\tgot: %.*s",
               i,
               tests[i].url,
               tests[i].expected.query.buf,
               (int)result.query.len,
               result.query.buf);
    FIO_ASSERT(
        result.target.len == tests[i].expected.target.len &&
            (!result.target.len || !memcmp(result.target.buf,
                                           tests[i].expected.target.buf,
                                           tests[i].expected.target.len)),
        "target result failed for:\n\ttest[%zu]: %s\n\texpected: "
        "%s\n\tgot: %.*s",
        i,
        tests[i].url,
        tests[i].expected.target.buf,
        (int)result.target.len,
        result.target.buf);
  }
}
#endif /* FIO_TEST_CSTL */

/* *****************************************************************************
FIO_URL - Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_URL || FIO_URI */
#undef FIO_URL
#undef FIO_URI
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_JSON       /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                                JSON Parsing


Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_JSON) && !defined(H___FIO_JSON_H)
#define H___FIO_JSON_H

#ifndef JSON_MAX_DEPTH
/** Maximum allowed JSON nesting level. Values above 64K might fail. */
#define JSON_MAX_DEPTH 512
#endif

/** The JSON parser type. Memory must be initialized to 0 before first uses. */
typedef struct {
  /** level of nesting. */
  uint32_t depth;
  /** expectation bit flag: 0=key, 1=colon, 2=value, 4=comma/closure . */
  uint8_t expect;
  /** nesting bit flags - dictionary bit = 0, array bit = 1. */
  uint8_t nesting[(JSON_MAX_DEPTH + 7) >> 3];
} fio_json_parser_s;

#define FIO_JSON_INIT                                                          \
  { .depth = 0 }

/**
 * The facil.io JSON parser is a non-strict parser, with support for trailing
 * commas in collections, new-lines in strings, extended escape characters and
 * octal, hex and binary numbers.
 *
 * The parser allows for streaming data and decouples the parsing process from
 * the resulting data-structure by calling static callbacks for JSON related
 * events.
 *
 * Returns the number of bytes consumed before parsing stopped (due to either
 * error or end of data). Stops as close as possible to the end of the buffer or
 * once an object parsing was completed.
 */
SFUNC size_t fio_json_parse(fio_json_parser_s *parser,
                            const char *buffer,
                            const size_t len);

/* *****************************************************************************
JSON Parsing - Implementation - Helpers and Callbacks


Note: static Callacks must be implemented in the C file that uses the parser

Note: a Helper API is provided for the parsing implementation.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/** common FIO_JSON callback function properties */
#define FIO_JSON_CB static inline __attribute__((unused))

/* *****************************************************************************
JSON Parsing - Helpers API
***************************************************************************** */

/** Tests the state of the JSON parser. Returns 1 for true and 0 for false. */
FIO_JSON_CB uint8_t fio_json_parser_is_in_array(fio_json_parser_s *parser);

/** Tests the state of the JSON parser. Returns 1 for true and 0 for false. */
FIO_JSON_CB uint8_t fio_json_parser_is_in_object(fio_json_parser_s *parser);

/** Tests the state of the JSON parser. Returns 1 for true and 0 for false. */
FIO_JSON_CB uint8_t fio_json_parser_is_key(fio_json_parser_s *parser);

/** Tests the state of the JSON parser. Returns 1 for true and 0 for false. */
FIO_JSON_CB uint8_t fio_json_parser_is_value(fio_json_parser_s *parser);

/* *****************************************************************************
JSON Parsing - Implementation - Callbacks
***************************************************************************** */

/** a NULL object was detected */
FIO_JSON_CB void fio_json_on_null(fio_json_parser_s *p);
/** a TRUE object was detected */
static inline void fio_json_on_true(fio_json_parser_s *p);
/** a FALSE object was detected */
FIO_JSON_CB void fio_json_on_false(fio_json_parser_s *p);
/** a Number was detected (long long). */
FIO_JSON_CB void fio_json_on_number(fio_json_parser_s *p, long long i);
/** a Float was detected (double). */
FIO_JSON_CB void fio_json_on_float(fio_json_parser_s *p, double f);
/** a String was detected (int / float). update `pos` to point at ending */
FIO_JSON_CB void fio_json_on_string(fio_json_parser_s *p,
                                    const void *start,
                                    size_t len);
/** a dictionary object was detected, should return 0 unless error occurred. */
FIO_JSON_CB int fio_json_on_start_object(fio_json_parser_s *p);
/** a dictionary object closure detected */
FIO_JSON_CB void fio_json_on_end_object(fio_json_parser_s *p);
/** an array object was detected, should return 0 unless error occurred. */
FIO_JSON_CB int fio_json_on_start_array(fio_json_parser_s *p);
/** an array closure was detected */
FIO_JSON_CB void fio_json_on_end_array(fio_json_parser_s *p);
/** the JSON parsing is complete */
FIO_JSON_CB void fio_json_on_json(fio_json_parser_s *p);
/** the JSON parsing encountered an error */
FIO_JSON_CB void fio_json_on_error(fio_json_parser_s *p);

/* *****************************************************************************
JSON Parsing - Implementation - Helpers and Parsing


Note: static Callacks must be implemented in the C file that uses the parser
***************************************************************************** */

/** Tests the state of the JSON parser. Returns 1 for true and 0 for false. */
FIO_JSON_CB uint8_t fio_json_parser_is_in_array(fio_json_parser_s *p) {
  return p->depth && fio_bitmap_get(p->nesting, p->depth);
}

/** Tests the state of the JSON parser. Returns 1 for true and 0 for false. */
FIO_JSON_CB uint8_t fio_json_parser_is_in_object(fio_json_parser_s *p) {
  return p->depth && !fio_bitmap_get(p->nesting, p->depth);
}

/** Tests the state of the JSON parser. Returns 1 for true and 0 for false. */
FIO_JSON_CB uint8_t fio_json_parser_is_key(fio_json_parser_s *p) {
  return fio_json_parser_is_in_object(p) && !p->expect;
}

/** Tests the state of the JSON parser. Returns 1 for true and 0 for false. */
FIO_JSON_CB uint8_t fio_json_parser_is_value(fio_json_parser_s *p) {
  return !fio_json_parser_is_key(p);
}

FIO_IFUNC const char *fio___json_skip_comments(const char *buffer,
                                               const char *stop) {
  if (*buffer == '#' ||
      ((stop - buffer) > 2 && buffer[0] == '/' && buffer[1] == '/')) {
    /* EOL style comment, C style or Bash/Ruby style*/
    buffer = (const char *)FIO_MEMCHR(buffer + 1, '\n', stop - (buffer + 1));
    return buffer;
  }
  if (((stop - buffer) > 3 && buffer[0] == '/' && buffer[1] == '*')) {
    while ((buffer = (const char *)FIO_MEMCHR(buffer, '/', stop - buffer)) &&
           buffer && ++buffer && buffer[-2] != '*')
      ;
    return buffer;
  }
  return NULL;
}

FIO_IFUNC const char *fio___json_consume_string(fio_json_parser_s *p,
                                                const char *buffer,
                                                const char *stop) {
  const char *start = ++buffer;
  for (;;) {
    buffer = (const char *)FIO_MEMCHR(buffer, '\"', stop - buffer);
    if (!buffer)
      return NULL;
    int escaped = 1;
    while (buffer[0 - escaped] == '\\')
      ++escaped;
    if (escaped & 1)
      break;
    ++buffer;
  }
  fio_json_on_string(p, start, buffer - start);
  return buffer + 1;
}

FIO_IFUNC const char *fio___json_consume_number(fio_json_parser_s *p,
                                                const char *buffer,
                                                const char *stop) {

  const char *const was = buffer;
  errno = 0; /* testo for E2BIG on number parsing */
  long long i = fio_atol((char **)&buffer);

  if (buffer < stop &&
      ((*buffer) == '.' || (*buffer | 32) == 'e' || (*buffer | 32) == 'x' ||
       (*buffer | 32) == 'p' || (*buffer | 32) == 'i' || errno)) {
    buffer = was;
    double f = fio_atof((char **)&buffer);
    fio_json_on_float(p, f);
  } else {
    fio_json_on_number(p, i);
  }
  return buffer;
}

FIO_IFUNC const char *fio___json_identify(fio_json_parser_s *p,
                                          const char *buffer,
                                          const char *stop) {
  /* Use `break` to change separator requirement status.
   * Use `continue` to keep separator requirement the same.
   */
  switch (*buffer) {
  case 0x09: /* fall through */
  case 0x0A: /* fall through */
  case 0x0D: /* fall through */
  case 0x20:
    /* consume whitespace */
    ++buffer;
    while (buffer + 8 < stop && (buffer[0] == 0x20 || buffer[0] == 0x09 ||
                                 buffer[0] == 0x0A || buffer[0] == 0x0D)) {
      const uint64_t w = fio_buf2u64_local(buffer);
      const uint64_t w1 = 0x0101010101010101 * 0x09; /* '\t' (tab) */
      const uint64_t w2 = 0x0101010101010101 * 0x0A; /* '\n' (new line) */
      const uint64_t w3 = 0x0101010101010101 * 0x0D; /* '\r' (CR) */
      const uint64_t w4 = 0x0101010101010101 * 0x20; /* ' '  (space) */
      uint64_t b = fio_has_zero_byte64(w1 ^ w) | fio_has_zero_byte64(w2 ^ w) |
                   fio_has_zero_byte64(w3 ^ w) | fio_has_zero_byte64(w4 ^ w);
      if (b == 0x8080808080808080ULL) {
        buffer += 8;
        continue;
      }
      while ((b & UINT64_C(0x80))) {
        b >>= 8;
        ++buffer;
      }
      break;
    }

    return buffer;
  case ',': /* comma separator */
    if (!p->depth || !(p->expect & 4))
      goto unexpected_separator;
    ++buffer;
    p->expect = (fio_bitmap_get(p->nesting, p->depth) << 1);
    return buffer;
  case ':': /* colon separator */
    if (!p->depth || !(p->expect & 1))
      goto unexpected_separator;
    ++buffer;
    p->expect = 2;
    return buffer;
    /*
     *
     * JSON Strings
     *
     */
  case '"':
    if (p->depth && (p->expect & ((uint8_t)5)))
      goto missing_separator;
    buffer = fio___json_consume_string(p, buffer, stop);
    if (!buffer)
      goto unterminated_string;
    break;
    /*
     *
     * JSON Objects
     *
     */
  case '{':
    if (p->depth && !(p->expect & 2))
      goto missing_separator;
    if (p->depth == JSON_MAX_DEPTH)
      goto too_deep;
    ++p->depth;
    fio_bitmap_unset(p->nesting, p->depth);
    fio_json_on_start_object(p);
    p->expect = 0;
    return buffer + 1;
  case '}':
    if (fio_bitmap_get(p->nesting, p->depth) || !p->depth || (p->expect & 3))
      goto object_closure_unexpected;
    fio_bitmap_unset(p->nesting, p->depth);
    p->expect = 4; /* expect comma */
    --p->depth;
    fio_json_on_end_object(p);
    return buffer + 1;
    /*
     *
     * JSON Arrays
     *
     */
  case '[':
    if (p->depth && !(p->expect & 2))
      goto missing_separator;
    if (p->depth == JSON_MAX_DEPTH)
      goto too_deep;
    ++p->depth;
    fio_json_on_start_array(p);
    fio_bitmap_set(p->nesting, p->depth);
    p->expect = 2;
    return buffer + 1;
  case ']':
    if (!fio_bitmap_get(p->nesting, p->depth) || !p->depth)
      goto array_closure_unexpected;
    fio_bitmap_unset(p->nesting, p->depth);
    p->expect = 4; /* expect comma */
    --p->depth;
    fio_json_on_end_array(p);
    return buffer + 1;
    /*
     *
     * JSON Primitives (true / false / null (NaN))
     *
     */
  case 'N': /* NaN or null? - fall through */
  case 'n':
    if (p->depth && !(p->expect & 2))
      goto missing_separator;
    if (buffer + 4 > stop || buffer[1] != 'u' || buffer[2] != 'l' ||
        buffer[3] != 'l') {
      if (buffer + 3 > stop || (buffer[1] | 32) != 'a' ||
          (buffer[2] | 32) != 'n')
        return NULL;
      char *nan_str = (char *)"NaN";
      fio_json_on_float(p, fio_atof(&nan_str));
      buffer += 3;
      break;
    }
    fio_json_on_null(p);
    buffer += 4;
    break;
  case 't': /* true */
    if (p->depth && !(p->expect & 2))
      goto missing_separator;
    if (buffer + 4 > stop || buffer[1] != 'r' || buffer[2] != 'u' ||
        buffer[3] != 'e')
      return NULL;
    fio_json_on_true(p);
    buffer += 4;
    break;
  case 'f': /* false */
    if (p->depth && !(p->expect & 2))
      goto missing_separator;
    if (buffer + 5 > stop || buffer[1] != 'a' || buffer[2] != 'l' ||
        buffer[3] != 's' || buffer[4] != 'e')
      return NULL;
    fio_json_on_false(p);
    buffer += 5;
    break;
    /*
     *
     * JSON Numbers (Integers / Floats)
     *
     */
  case '+': /* fall through */
  case '-': /* fall through */
  case '0': /* fall through */
  case '1': /* fall through */
  case '2': /* fall through */
  case '3': /* fall through */
  case '4': /* fall through */
  case '5': /* fall through */
  case '6': /* fall through */
  case '7': /* fall through */
  case '8': /* fall through */
  case '9': /* fall through */
  case 'x': /* fall through */
  case '.': /* fall through */
  case 'e': /* fall through */
  case 'E': /* fall through */
  case 'i': /* fall through */
  case 'I':
    if (p->depth && !(p->expect & 2))
      goto missing_separator;
    buffer = fio___json_consume_number(p, buffer, stop);
    if (!buffer)
      goto bad_number_format;
    break;
    /*
     *
     * Comments
     *
     */
  case '#': /* fall through */
  case '/': /* fall through */
    return fio___json_skip_comments(buffer, stop);
    /*
     *
     * Unrecognized Data Handling
     *
     */
  default:
    FIO_LOG_DEBUG("unrecognized JSON identifier at:\n%.*s",
                  ((stop - buffer > 48) ? (int)48 : ((int)(stop - buffer))),
                  buffer);
    return NULL;
  }
  /* p->expect should be either 0 (key) or 2 (value) */
  p->expect = (p->expect << 1) + ((p->expect ^ 2) >> 1);
  return buffer;

missing_separator:
  FIO_LOG_DEBUG("missing JSON separator '%c' at (%d):\n%.*s",
                (p->expect == 2 ? ':' : ','),
                p->expect,
                ((stop - buffer > 48) ? 48 : ((int)(stop - buffer))),
                buffer);
  fio_json_on_error(p);
  return NULL;
unexpected_separator:
  FIO_LOG_DEBUG("unexpected JSON separator at:\n%.*s",
                ((stop - buffer > 48) ? 48 : ((int)(stop - buffer))),
                buffer);
  fio_json_on_error(p);
  return NULL;
unterminated_string:
  FIO_LOG_DEBUG("unterminated JSON string at:\n%.*s",
                ((stop - buffer > 48) ? 48 : ((int)(stop - buffer))),
                buffer);
  fio_json_on_error(p);
  return NULL;
bad_number_format:
  FIO_LOG_DEBUG("bad JSON numeral format at:\n%.*s",
                ((stop - buffer > 48) ? 48 : ((int)(stop - buffer))),
                buffer);
  fio_json_on_error(p);
  return NULL;
array_closure_unexpected:
  FIO_LOG_DEBUG("JSON array closure unexpected at:\n%.*s",
                ((stop - buffer > 48) ? 48 : ((int)(stop - buffer))),
                buffer);
  fio_json_on_error(p);
  return NULL;
object_closure_unexpected:
  FIO_LOG_DEBUG("JSON object closure unexpected at (%d):\n%.*s",
                p->expect,
                ((stop - buffer > 48) ? 48 : ((int)(stop - buffer))),
                buffer);
  fio_json_on_error(p);
  return NULL;
too_deep:
  FIO_LOG_DEBUG("JSON object nesting too deep at:\n%.*s",
                p->expect,
                ((stop - buffer > 48) ? 48 : ((int)(stop - buffer))),
                buffer);
  fio_json_on_error(p);
  return NULL;
}

/**
 * Returns the number of bytes consumed. Stops as close as possible to the end
 * of the buffer or once an object parsing was completed.
 */
SFUNC size_t fio_json_parse(fio_json_parser_s *p,
                            const char *buffer,
                            const size_t len) {
  const char *start = buffer;
  const char *stop = buffer + len;
  const char *last;
  /* skip BOM, if exists */
  if (len >= 3 && buffer[0] == (char)0xEF && buffer[1] == (char)0xBB &&
      buffer[2] == (char)0xBF) {
    buffer += 3;
    if (len == 3)
      goto finish;
  }
  /* loop until the first JSON data was read */
  do {
    last = buffer;
    buffer = fio___json_identify(p, buffer, stop);
    if (!buffer)
      goto failed;
  } while (!p->expect && buffer < stop);
  /* loop until the JSON object (nesting) is closed */
  while (p->depth && buffer < stop) {
    last = buffer;
    buffer = fio___json_identify(p, buffer, stop);
    if (!buffer)
      goto failed;
  }
  if (!p->depth) {
    p->expect = 0;
    fio_json_on_json(p);
  }
finish:
  return buffer - start;
failed:
  FIO_LOG_DEBUG("JSON parsing failed after:\n%.*s",
                ((stop - last > 48) ? 48 : ((int)(stop - last))),
                last);
  return last - start;
}

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_JSON
#endif /* FIO_JSON */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_STATE      /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                      State Callback Management API



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_STATE) && !defined(H__FIO_STATE__H) && !defined(FIO_STL_KEEP__)
#define H__FIO_STATE__H
/* *****************************************************************************
State Callback API
***************************************************************************** */

/* *****************************************************************************
Startup / State Callbacks (fork, start up, idle, etc')
***************************************************************************** */

/** a callback type enum */
typedef enum {
  /** Called once during library initialization. */
  FIO_CALL_ON_INITIALIZE,
  /** Called once before starting up the IO reactor. */
  FIO_CALL_PRE_START,
  /** Called before each time the IO reactor forks a new worker. */
  FIO_CALL_BEFORE_FORK,
  /** Called after each fork (both parent and child), before FIO_CALL_IN_XXX */
  FIO_CALL_AFTER_FORK,
  /** Called by a worker process right after forking. */
  FIO_CALL_IN_CHILD,
  /** Called by the master process after spawning a worker (after forking). */
  FIO_CALL_IN_MASTER,
  /** Called every time a *Worker* process starts. */
  FIO_CALL_ON_START,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED1,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED2,
  /** User state event queue (unused, available for the user). */
  FIO_CALL_ON_USER1,
  /** User state event queue (unused, available for the user). */
  FIO_CALL_ON_USER2,
  /** Called when facil.io enters idling mode. */
  FIO_CALL_ON_IDLE,
  /** A reversed user state event queue (unused, available for the user). */
  FIO_CALL_ON_USER1_REVERSE,
  /** A reversed user state event queue (unused, available for the user). */
  FIO_CALL_ON_USER2_REVERSE,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED1_REVERSED,
  /** Reserved for internal use. */
  FIO_CALL_RESERVED2_REVERSED,
  /** Called before starting the shutdown sequence. */
  FIO_CALL_ON_SHUTDOWN,
  /** Called by each worker the moment it detects the master process crashed. */
  FIO_CALL_ON_PARENT_CRUSH,
  /** Called by the parent (master) after a worker process crashed. */
  FIO_CALL_ON_CHILD_CRUSH,
  /** Called just before finishing up (both on child and parent processes). */
  FIO_CALL_ON_FINISH,
  /** An alternative to the system's at_exit. */
  FIO_CALL_AT_EXIT,
  /** used for testing and array allocation - must be last. */
  FIO_CALL_NEVER
} fio_state_event_type_e;

/** Adds a callback to the list of callbacks to be called for the event. */
SFUNC void fio_state_callback_add(fio_state_event_type_e,
                                  void (*func)(void *),
                                  void *arg);

/** Removes a callback from the list of callbacks to be called for the event. */
SFUNC int fio_state_callback_remove(fio_state_event_type_e,
                                    void (*func)(void *),
                                    void *arg);

/**
 * Forces all the existing callbacks to run, as if the event occurred.
 *
 * Callbacks for all initialization / idling tasks are called in order of
 * creation (where fio_state_event_type_e <= FIO_CALL_ON_IDLE).
 *
 * Callbacks for all cleanup oriented tasks are called in reverse order of
 * creation (where fio_state_event_type_e >= FIO_CALL_ON_SHUTDOWN).
 *
 * During an event, changes to the callback list are ignored (callbacks can't
 * add or remove other callbacks for the same event).
 */
SFUNC void fio_state_callback_force(fio_state_event_type_e);

/* *****************************************************************************
State Callback Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/*
REMEMBER:
========

All memory allocations should use:
* FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)
* FIO_MEM_FREE_(ptr, size)

*/

/* *****************************************************************************
State Callback Map - I'd use the global mapping types...
(Ordered Hash Map)   but we can't depend on types yet, possible collisions.
***************************************************************************** */

typedef struct {
  void (*func)(void *);
  void *arg;
} fio___state_task_s;

FIO_IFUNC uint64_t fio___state_callback_hash_fn(fio___state_task_s *t) {
  uint64_t hash = fio_risky_ptr((void *)(uintptr_t)(t->func));
  hash ^= hash + fio_risky_ptr(t->arg);
  return hash;
}

#define FIO_STATE_CALLBACK_IS_VALID(pobj) ((pobj)->func)
#define FIO_STATE_CALLBACK_CMP(a, b)                                           \
  ((a)->func == (b)->func && (a)->arg == (b)->arg)
FIO_TYPEDEF_IMAP_ARRAY(fio___state_map,
                       fio___state_task_s,
                       uint32_t,
                       fio___state_callback_hash_fn,
                       FIO_STATE_CALLBACK_CMP,
                       FIO_STATE_CALLBACK_IS_VALID)
#undef FIO_STATE_CALLBACK_CMP
#undef FIO_STATE_CALLBACK_IS_VALID

/* *****************************************************************************
State Callback Global State and Locks
***************************************************************************** */
/* use `weak` instead of `static` to make sure state in global. */
FIO_WEAK fio___state_map_s fio___state_tasks_array[FIO_CALL_NEVER + 1];
FIO_WEAK fio_lock_i fio___state_tasks_array_lock[FIO_CALL_NEVER + 1];

/** a type-to-string map for callback types */
FIO_SFUNC const char *fio___state_tasks_names[FIO_CALL_NEVER + 1] = {
    [FIO_CALL_ON_INITIALIZE] = "ON_INITIALIZE",
    [FIO_CALL_PRE_START] = "PRE_START",
    [FIO_CALL_BEFORE_FORK] = "BEFORE_FORK",
    [FIO_CALL_AFTER_FORK] = "AFTER_FORK",
    [FIO_CALL_IN_CHILD] = "IN_CHILD",
    [FIO_CALL_IN_MASTER] = "IN_MASTER",
    [FIO_CALL_ON_START] = "ON_START",
    [FIO_CALL_RESERVED1] = "RESERVED1",
    [FIO_CALL_RESERVED2] = "RESERVED2",
    [FIO_CALL_ON_USER1] = "ON_USER1",
    [FIO_CALL_ON_USER2] = "ON_USER2",
    [FIO_CALL_ON_IDLE] = "ON_IDLE",
    [FIO_CALL_ON_USER1_REVERSE] = "ON_USER1_REVERSE",
    [FIO_CALL_ON_USER2_REVERSE] = "ON_USER2_REVERSE",
    [FIO_CALL_RESERVED1_REVERSED] = "RESERVED1_REVERSED",
    [FIO_CALL_RESERVED2_REVERSED] = "RESERVED2_REVERSED",
    [FIO_CALL_ON_SHUTDOWN] = "ON_SHUTDOWN",
    [FIO_CALL_ON_PARENT_CRUSH] = "ON_PARENT_CRUSH",
    [FIO_CALL_ON_CHILD_CRUSH] = "ON_CHILD_CRUSH",
    [FIO_CALL_ON_FINISH] = "ON_FINISH",
    [FIO_CALL_AT_EXIT] = "AT_EXIT",
    [FIO_CALL_NEVER] = "NEVER",
};

FIO_IFUNC void fio_state_callback_clear_all(void) {
  for (size_t i = 0; i < FIO_CALL_NEVER; ++i) {
    fio___state_map_destroy(fio___state_tasks_array + i);
  }
}

/** Adds a callback to the list of callbacks to be called for the event. */
SFUNC void fio_state_callback_add(fio_state_event_type_e e,
                                  void (*func)(void *),
                                  void *arg) {
  if ((uintptr_t)e >= FIO_CALL_NEVER)
    return;
  fio___state_task_s t = {.func = func, .arg = arg};
  fio_lock(fio___state_tasks_array_lock + (uintptr_t)e);
  fio___state_map_set(fio___state_tasks_array + (uintptr_t)e, t, 0);
  fio_unlock(fio___state_tasks_array_lock + (uintptr_t)e);
  if (e == FIO_CALL_ON_INITIALIZE &&
      fio___state_tasks_array_lock[FIO_CALL_NEVER]) {
    /* initialization tasks already performed, perform this without delay */
    func(arg);
  }
}

/** Removes a callback from the list of callbacks to be called for the event. */
SFUNC int fio_state_callback_remove(fio_state_event_type_e e,
                                    void (*func)(void *),
                                    void *arg) {
  if ((uintptr_t)e >= FIO_CALL_NEVER)
    return -1;
  int ret;
  fio___state_task_s t = {.func = func, .arg = arg};
  fio_lock(fio___state_tasks_array_lock + (uintptr_t)e);
  ret = fio___state_map_remove(fio___state_tasks_array + (uintptr_t)e, t);
  fio_unlock(fio___state_tasks_array_lock + (uintptr_t)e);
  return ret;
}

/** Clears all the existing callbacks for the event. */
SFUNC void fio_state_callback_clear(fio_state_event_type_e e) {
  if ((uintptr_t)e >= FIO_CALL_NEVER)
    return;
  fio_lock(fio___state_tasks_array_lock + (uintptr_t)e);
  fio___state_map_destroy(fio___state_tasks_array + (uintptr_t)e);
  fio_unlock(fio___state_tasks_array_lock + (uintptr_t)e);
}

FIO_SFUNC void fio_state_callback_force___task(void *fn_p, void *arg) {
  union {
    void *p;
    void (*fn)(void *);
  } u = {.p = fn_p};
  u.fn(arg);
}
/**
 * Forces all the existing callbacks to run, as if the event occurred.
 *
 * Callbacks are called from last to first (last callback executes first).
 *
 * During an event, changes to the callback list are ignored (callbacks can't
 * remove other callbacks for the same event).
 */
SFUNC void fio_state_callback_force(fio_state_event_type_e e) {
  if ((uintptr_t)e >= FIO_CALL_NEVER)
    return;
  if (e == FIO_CALL_AFTER_FORK) {
    /* make sure the `after_fork` events re-initializes all locks. */
    for (size_t i = 0; i < FIO_CALL_NEVER; ++i) {
      fio___state_tasks_array_lock[i] = FIO_LOCK_INIT;
    }
  }
  if (e == FIO_CALL_IN_CHILD)
    fio_rand_reseed(); /* re-seed random state in child processes */
  fio___state_task_s *ary = NULL;
  size_t ary_capa = (sizeof(*ary) * fio___state_tasks_array[e].count);
  size_t len = 0;
  if (e == FIO_CALL_ON_INITIALIZE) {
    fio_trylock(fio___state_tasks_array_lock + FIO_CALL_NEVER);
  }

  FIO_LOG_DDEBUG2("(%d) Scheduling %s callbacks.",
                  (int)(getpid()),
                  fio___state_tasks_names[e]);

  /* copy task queue */
  fio_lock(fio___state_tasks_array_lock + (uintptr_t)e);
  if (fio___state_tasks_array[e].w) {
    ary = (fio___state_task_s *)FIO_MEM_REALLOC(NULL, 0, ary_capa, 0);
    FIO_ASSERT_ALLOC(ary);
    for (size_t i = 0; i < fio___state_tasks_array[e].w; ++i) {
      if (!fio___state_tasks_array[e].ary[i].func)
        continue;
      ary[len++] = fio___state_tasks_array[e].ary[i];
    }
  }
  fio_unlock(fio___state_tasks_array_lock + (uintptr_t)e);

  if (e <= FIO_CALL_PRE_START) {
    /* perform copied tasks immediately within system thread */
    for (size_t i = 0; i < len; ++i)
      ary[i].func(ary[i].arg);
  } else if (e <= FIO_CALL_ON_IDLE) {
    /* perform tasks in order */
    for (size_t i = 0; i < len; ++i) {
      ary[i].func(ary[i].arg);
    }
  } else {
    /* perform tasks in reverse */
    while (len--) {
      ary[len].func(ary[len].arg);
    }
  }
  /* cleanup */
  FIO_MEM_FREE(ary, ary_capa);
}
/* *****************************************************************************
State constructor / destructor
***************************************************************************** */

FIO_CONSTRUCTOR(fio___state_constructor) {
  FIO_LOG_DEBUG2("fio_state_callback maps are now active.");
  fio_state_callback_force(FIO_CALL_ON_INITIALIZE);
}

FIO_DESTRUCTOR(fio___state_cleanup) {
  fio_state_callback_force(FIO_CALL_AT_EXIT);
  fio_state_callback_clear_all();
  FIO_LOG_DEBUG2("fio_state_callback maps have been cleared.");
}

/* *****************************************************************************
Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

static size_t FIO_NAME_TEST(stl, state_task_counter) = 0;
FIO_SFUNC void FIO_NAME_TEST(stl, state_task)(void *arg) {
  size_t *i = (size_t *)arg;
  ++i[0];
}
FIO_SFUNC void FIO_NAME_TEST(stl, state_task_global)(void *arg) {
  (void)arg;
  ++FIO_NAME_TEST(stl, state_task_counter);
}
FIO_SFUNC void FIO_NAME_TEST(stl, state)(void) {
  fprintf(stderr, "* Testing state callback API.\n");
  size_t count = 0;
  for (size_t i = 0; i < 1024; ++i) {
    fio_state_callback_add(FIO_CALL_RESERVED1,
                           FIO_NAME_TEST(stl, state_task),
                           &count);
    fio_state_callback_add(FIO_CALL_RESERVED1,
                           FIO_NAME_TEST(stl, state_task_global),
                           (void *)i);
  }
  FIO_ASSERT(!count && !FIO_NAME_TEST(stl, state_task_counter),
             "callbacks should NOT have been called yet");
  fio_state_callback_force(FIO_CALL_RESERVED1);
  FIO_ASSERT(count == 1, "count error for local counter callback (%zu)", count);
  FIO_ASSERT(FIO_NAME_TEST(stl, state_task_counter) == 1024,
             "count error for global counter callback (%zu)",
             FIO_NAME_TEST(stl, state_task_counter));
  for (size_t i = 0; i < 1024; ++i) {
    fio_state_callback_remove(FIO_CALL_RESERVED1,
                              FIO_NAME_TEST(stl, state_task),
                              &count);
    fio_state_callback_remove(FIO_CALL_RESERVED1,
                              FIO_NAME_TEST(stl, state_task_global),
                              (void *)i);
  }
  fio_state_callback_force(FIO_CALL_RESERVED1);
  FIO_ASSERT(count == 1,
             "count error for local counter callback (%zu) - not removed?",
             count);
  FIO_ASSERT(FIO_NAME_TEST(stl, state_task_counter) == 1024,
             "count error for global counter callback (%zu) - not removed?",
             FIO_NAME_TEST(stl, state_task_counter));
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_STATE
#endif /* FIO_STATE */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___        /* Development inclusion - ignore line */
#define FIO_MEMORY_NAME fio /* Development inclusion - ignore line */
#include "./include.h"      /* Development inclusion - ignore line */
#endif                      /* Development inclusion - ignore line */
/* *****************************************************************************




                      Custom Memory Allocator / Pooling



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */

/* *****************************************************************************
Memory Allocation - fast setup for a specific global allocators
***************************************************************************** */
/* FIO_MALLOC defines a "global" default memory allocator */
#if defined(FIO_MALLOC) && !defined(H___FIO_MALLOC___H)
#ifndef FIO_MEMORY_NAME
#define FIO_MEMORY_NAME fio
#endif
#ifndef FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG
/* for a general allocator, increase system allocation size to 8Gb */
#define FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG 23
#endif

#ifndef FIO_MEMORY_CACHE_SLOTS
/* for a general allocator, increase cache size */
#define FIO_MEMORY_CACHE_SLOTS 8
#endif

#ifndef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
/* set fragmentation cost at 0.5Mb blocks */
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 5
#endif

#ifndef FIO_MEMORY_ENABLE_BIG_ALLOC
/* support big allocations using undivided memory chunks */
#define FIO_MEMORY_ENABLE_BIG_ALLOC 1
#endif

#undef FIO_MEM_REALLOC
/** Reallocates memory, copying (at least) `copy_len` if necessary. */
#define FIO_MEM_REALLOC(ptr, old_size, new_size, copy_len)                     \
  fio_realloc2((ptr), (new_size), (copy_len))

#undef FIO_MEM_FREE
/** Frees allocated memory. */
#define FIO_MEM_FREE(ptr, size) fio_free((ptr))

#undef FIO_MEM_REALLOC_IS_SAFE
#define FIO_MEM_REALLOC_IS_SAFE fio_realloc_is_safe()

/* prevent double declaration of FIO_MALLOC */
#define H___FIO_MALLOC___H
#undef FIO_MALLOC

/* FIOBJ_MALLOC defines a FIOBJ dedicated memory allocator */
#elif defined(FIOBJ_MALLOC) && !defined(H___FIOBJ_MALLOC___H)
#define H___FIOBJ_MALLOC___H
#ifndef FIO_MEMORY_NAME
#define FIO_MEMORY_NAME fiobj_mem
#endif
#ifndef FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG
/* 4Mb per system call */
#define FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG 22
#endif
#ifndef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
/* fight fragmentation */
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 4
#endif
#ifndef FIO_MEMORY_ALIGN_LOG
/* align on 8 bytes, it's enough */
#define FIO_MEMORY_ALIGN_LOG 3
#endif
#ifndef FIO_MEMORY_CACHE_SLOTS
/* cache up to 64Mb */
#define FIO_MEMORY_CACHE_SLOTS 16
#endif
#endif /* FIOBJ_MALLOC */

/* *****************************************************************************
Memory Allocation - Setup Alignment Info
***************************************************************************** */
#if defined(FIO_MEMORY_NAME) && !defined(FIO_STL_KEEP__)

#undef FIO_MEM_ALIGN
#undef FIO_MEM_ALIGN_NEW

#ifndef FIO_MEMORY_ALIGN_LOG
/** Allocation alignment, MUST be >= 3 and <= 10*/
#define FIO_MEMORY_ALIGN_LOG 4

#elif FIO_MEMORY_ALIGN_LOG < 3 || FIO_MEMORY_ALIGN_LOG > 10
#undef FIO_MEMORY_ALIGN_LOG
#define FIO_MEMORY_ALIGN_LOG 4
#endif

/* Helper macro, don't change this */
#undef FIO_MEMORY_ALIGN_SIZE
/**
 * The maximum allocation size, after which a direct system allocation is used.
 */
#define FIO_MEMORY_ALIGN_SIZE (1UL << FIO_MEMORY_ALIGN_LOG)

/* inform the compiler that the returned value is aligned on 16 byte marker */
#if __clang__ || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 8)
#define FIO_MEM_ALIGN __attribute__((assume_aligned(FIO_MEMORY_ALIGN_SIZE)))
#define FIO_MEM_ALIGN_NEW                                                      \
  __attribute__((malloc, assume_aligned(FIO_MEMORY_ALIGN_SIZE)))
#else
#define FIO_MEM_ALIGN
#define FIO_MEM_ALIGN_NEW
#endif /* (__clang__ || __GNUC__)... */

/* *****************************************************************************
Memory Helpers - API
***************************************************************************** */
#ifndef H___FIO_MEM_INCLUDE_ONCE___H
/**
 * A somewhat naive implementation of `memset`.
 *
 * Probably slower than the one included with your compiler's C library.
 */
FIO_SFUNC void *fio_memset(void *restrict dest, uint64_t data, size_t bytes);

/**
 * A somewhat naive implementation of `memcpy`.
 *
 * Probably slower than the one included with your compiler's C library.
 */
FIO_SFUNC void *fio_memcpy(void *dest_, const void *src_, size_t bytes);

/**
 * A token seeking function. This is a fallback for `memchr`, but `memchr`
 * should be faster.
 */
FIO_SFUNC void *fio_memchr(const void *buffer, const char token, size_t len);

/**
 * A comparison function. This is a fallback for `memcmp`, but `memcmp`
 * should be faster.
 */
FIO_SFUNC int fio_memcmp(const void *a_, const void *b_, size_t len);

#endif /* H___FIO_MEM_INCLUDE_ONCE___H */
/* *****************************************************************************
Memory Allocation - API
***************************************************************************** */

/**
 * Allocates memory using a per-CPU core block memory pool.
 * Memory is zeroed out.
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 *
 * `mempool_malloc` promises a best attempt at providing locality between
 * consecutive calls, but locality can't be guaranteed.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, malloc)(size_t size);

/**
 * same as calling `fio_malloc(size_per_unit * unit_count)`;
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                       calloc)(size_t size_per_unit,
                                               size_t unit_count);

/** Frees memory that was allocated using this library. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, free)(void *ptr);

/**
 * Re-allocates memory. An attempt to avoid copying the data is made only for
 * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).
 */
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc)(void *ptr,
                                                             size_t new_size);

/**
 * Re-allocates memory. An attempt to avoid copying the data is made only for
 * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).
 *
 * This variation is slightly faster as it might copy less data.
 */
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc2)(void *ptr,
                                                              size_t new_size,
                                                              size_t copy_len);

/**
 * Allocates memory directly using `mmap`, this is preferred for objects that
 * both require almost a page of memory (or more) and expect a long lifetime.
 *
 * However, since this allocation will invoke the system call (`mmap`), it will
 * be inherently slower.
 *
 * `mempoll_free` can be used for deallocating the memory.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, mmap)(size_t size);

/**
 * When forking is called manually, call this function to reset the facil.io
 * memory allocator's locks.
 */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)(void);

/* *****************************************************************************
Memory Allocation - configuration macros

NOTE: most configuration values should be a power of 2 or a logarithmic value.
***************************************************************************** */

/** FIO_MEMORY_DISABLE disables all custom memory allocators. */
#if defined(FIO_MEMORY_DISABLE)
#ifndef FIO_MALLOC_TMP_USE_SYSTEM
#define FIO_MALLOC_TMP_USE_SYSTEM 1
#endif
#endif

/* Make sure the system's allocator is marked as unsafe. */
#if FIO_MALLOC_TMP_USE_SYSTEM
#undef FIO_MEMORY_INITIALIZE_ALLOCATIONS
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 0
#endif

#ifndef FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG
/**
 * The logarithmic size of a single allocation "chunk" (16 blocks).
 *
 * Limited to >=17 and <=24.
 *
 * By default 22, which is a ~2Mb allocation per system call, resulting in a
 * maximum allocation size of 131Kb.
 */
#define FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG 21
#endif

#ifndef FIO_MEMORY_CACHE_SLOTS
/**
 * The number of system allocation "chunks" to cache even if they are not in
 * use.
 */
#define FIO_MEMORY_CACHE_SLOTS 4
#endif

#ifndef FIO_MEMORY_INITIALIZE_ALLOCATIONS
/**
 * Forces the allocator to zero out memory early and often, so allocations
 * return initialized memory (bytes are all zeros).
 *
 * This will make the realloc2 safe for use (all data not copied is zero).
 */
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS                                      \
  FIO_MEMORY_INITIALIZE_ALLOCATIONS_DEFAULT
#elif FIO_MEMORY_INITIALIZE_ALLOCATIONS
#undef FIO_MEMORY_INITIALIZE_ALLOCATIONS
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 1
#else
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 0
#endif

#ifndef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
/**
 * The number of blocks per system allocation.
 *
 * More blocks protect against fragmentation, but lower the maximum number that
 * can be allocated without reverting to mmap.
 *
 * Range: 0-4
 * Recommended: depends on object allocation sizes, usually 1 or 2.
 */
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 2
#endif

#ifndef FIO_MEMORY_ENABLE_BIG_ALLOC
/**
 * Uses a whole system allocation to support bigger allocations.
 *
 * Could increase fragmentation costs.
 */
#define FIO_MEMORY_ENABLE_BIG_ALLOC 1
#endif

#ifndef FIO_MEMORY_ARENA_COUNT
/**
 * Memory arenas mitigate thread contention while using more memory.
 *
 * Note that at some point arenas are statistically irrelevant... except when
 * benchmarking contention in multi-core machines.
 *
 * Negative values will result in dynamic selection based on CPU core count.
 */
#define FIO_MEMORY_ARENA_COUNT -1
#endif

#ifndef FIO_MEMORY_ARENA_COUNT_FALLBACK
/*
 * Used when dynamic arena count calculations fail.
 *
 * NOTE: if FIO_MEMORY_ARENA_COUNT is negative, dynamic arena calculation is
 * performed using CPU core calculation.
 */
#define FIO_MEMORY_ARENA_COUNT_FALLBACK 24
#endif

#ifndef FIO_MEMORY_ARENA_COUNT_MAX
/*
 * Used when dynamic arena count calculations fail.
 *
 * NOTE: if FIO_MEMORY_ARENA_COUNT is negative, dynamic arena calculation is
 * performed using CPU core calculation.
 */
#define FIO_MEMORY_ARENA_COUNT_MAX 64
#endif

#ifndef FIO_MEMORY_WARMUP
#define FIO_MEMORY_WARMUP 0
#endif

#ifndef FIO_MEMORY_USE_THREAD_MUTEX
#if FIO_USE_THREAD_MUTEX_TMP
#define FIO_MEMORY_USE_THREAD_MUTEX 1
#else
#if FIO_MEMORY_ARENA_COUNT > 0
/**
 * If arena count isn't linked to the CPU count, threads might busy-spin.
 * It is better to slow wait than fast busy spin when the work in the lock is
 * longer... and system allocations are performed inside arena locks.
 */
#define FIO_MEMORY_USE_THREAD_MUTEX 1
#else
/* defaults to use a spinlock when no contention is expected. */
#define FIO_MEMORY_USE_THREAD_MUTEX 0
#endif
#endif
#endif

#ifndef FIO_MEMORY_USE_FIO_MEMSET
/** If true, uses a facil.io custom implementation. */
#define FIO_MEMORY_USE_FIO_MEMSET 1
#endif

#ifndef FIO_MEMORY_USE_FIO_MEMCOPY
/** If true, uses a facil.io custom implementation. */
#define FIO_MEMORY_USE_FIO_MEMCOPY 0
#endif

#ifndef FIO_MEM_PAGE_SIZE_LOG
#define FIO_MEM_PAGE_SIZE_LOG 12 /* 4096 bytes per page */
#endif

#if !defined(FIO_MEM_SYS_ALLOC) || !defined(FIO_MEM_SYS_REALLOC) ||            \
    !defined(FIO_MEM_SYS_FREE)
/**
 * The following MACROS, when all of them are defined, allow the memory
 * allocator to collect memory from the system using an alternative method.
 *
 * - FIO_MEM_SYS_ALLOC(pages, alignment_log)
 *
 * - FIO_MEM_SYS_REALLOC(ptr, old_pages, new_pages, alignment_log)
 *
 * - FIO_MEM_SYS_FREE(ptr, pages) FIO_MEM_SYS_FREE_def_func((ptr), (pages))
 *
 * Note that the alignment property for the allocated memory is essential and
 * may me quite large.
 */
#undef FIO_MEM_SYS_ALLOC
#undef FIO_MEM_SYS_REALLOC
#undef FIO_MEM_SYS_FREE
#endif /* undefined FIO_MEM_SYS_ALLOC... */

/* *****************************************************************************
Memory Allocation - configuration value - results and constants
***************************************************************************** */

/* Helper macros, don't change their values */
#undef FIO_MEMORY_BLOCKS_PER_ALLOCATION
#undef FIO_MEMORY_SYS_ALLOCATION_SIZE
#undef FIO_MEMORY_BLOCK_ALLOC_LIMIT

#if FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG < 0 ||                                \
    FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG > 5
#undef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG 3
#endif

/** the number of allocation blocks per system allocation. */
#define FIO_MEMORY_BLOCKS_PER_ALLOCATION                                       \
  (1UL << FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG)

/** the total number of bytes consumed per system allocation. */
#define FIO_MEMORY_SYS_ALLOCATION_SIZE                                         \
  (1UL << FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG)

/**
 * The maximum allocation size, after which a big/system allocation is used.
 */
#define FIO_MEMORY_BLOCK_ALLOC_LIMIT                                           \
  (FIO_MEMORY_SYS_ALLOCATION_SIZE >> (FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG + 2))

#if FIO_MEMORY_ENABLE_BIG_ALLOC
/** the limit of a big allocation, if enabled */
#define FIO_MEMORY_BIG_ALLOC_LIMIT                                             \
  (FIO_MEMORY_SYS_ALLOCATION_SIZE >>                                           \
   (FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG > 3                                   \
        ? 3                                                                    \
        : FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG))
#define FIO_MEMORY_ALLOC_LIMIT FIO_MEMORY_BIG_ALLOC_LIMIT
#else
#define FIO_MEMORY_ALLOC_LIMIT FIO_MEMORY_BLOCK_ALLOC_LIMIT
#endif

/* *****************************************************************************
Memory Allocation - configuration access - UNSTABLE API!!!
***************************************************************************** */

FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_sys_alloc_size)(void) {
  return FIO_MEMORY_SYS_ALLOCATION_SIZE;
}

FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_cache_slots)(void) {
  return FIO_MEMORY_CACHE_SLOTS;
}
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_alignment)(void) {
  return FIO_MEMORY_ALIGN_SIZE;
}
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_alignment_log)(void) {
  return FIO_MEMORY_ALIGN_LOG;
}

FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_alloc_limit)(void) {
  return (FIO_MEMORY_BLOCK_ALLOC_LIMIT > FIO_MEMORY_ALLOC_LIMIT)
             ? FIO_MEMORY_BLOCK_ALLOC_LIMIT
             : FIO_MEMORY_ALLOC_LIMIT;
}

FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_arena_alloc_limit)(void) {
  return FIO_MEMORY_BLOCK_ALLOC_LIMIT;
}

/* will realloc2 return junk data? */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, realloc_is_safe)(void) {
  return FIO_MEMORY_INITIALIZE_ALLOCATIONS;
}

/* Returns the calculated block size. */
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_block_size)(void);

/** Prints the allocator's data structure. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_state)(void);

/** Prints the allocator's free block list. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_free_block_list)(void);

/** Prints the settings used to define the allocator. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings)(void);

/* *****************************************************************************
Temporarily (at least) set memory allocation macros to use this allocator
***************************************************************************** */
#ifndef FIO_MALLOC_TMP_USE_SYSTEM

#undef FIO_MEM_REALLOC_
#undef FIO_MEM_FREE_
#undef FIO_MEM_REALLOC_IS_SAFE_

#define FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)                    \
  FIO_NAME(FIO_MEMORY_NAME, realloc2)((ptr), (new_size), (copy_len))
#define FIO_MEM_FREE_(ptr, size) FIO_NAME(FIO_MEMORY_NAME, free)((ptr))
#define FIO_MEM_REALLOC_IS_SAFE_ FIO_NAME(FIO_MEMORY_NAME, realloc_is_safe)()

#endif /* FIO_MALLOC_TMP_USE_SYSTEM */

/* *****************************************************************************





Memory Allocation - start implementation





***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
/* internal workings start here */

/* *****************************************************************************
memset / memcpy selectors
***************************************************************************** */

#if FIO_MEMORY_USE_FIO_MEMSET
#define FIO___MEMSET fio_memset
#else
#define FIO___MEMSET memset
#endif /* FIO_MEMORY_USE_FIO_MEMSET */

#if FIO_MEMORY_USE_FIO_MEMCOPY
#define FIO___MEMCPY2 fio_memcpy
#else
#define FIO___MEMCPY2 FIO_MEMCPY
#endif /* FIO_MEMORY_USE_FIO_MEMCOPY */

/* *****************************************************************************







Helpers and System Memory Allocation




***************************************************************************** */
#ifndef H___FIO_MEM_INCLUDE_ONCE___H
#define H___FIO_MEM_INCLUDE_ONCE___H

#define FIO_MEM_BYTES2PAGES(size)                                              \
  (((size_t)(size) + ((1UL << FIO_MEM_PAGE_SIZE_LOG) - 1)) &                   \
   ((~(size_t)0) << FIO_MEM_PAGE_SIZE_LOG))

/* *****************************************************************************



POSIX Allocation



***************************************************************************** */
#if FIO_OS_POSIX || __has_include("sys/mman.h")
#include <sys/mman.h>

/* Mitigates MAP_ANONYMOUS not being defined on older versions of MacOS */
#if !defined(MAP_ANONYMOUS)
#if defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#else
#define MAP_ANONYMOUS 0
#endif /* defined(MAP_ANONYMOUS) */
#endif /* FIO_MEM_SYS_ALLOC */

/* inform the compiler that the returned value is aligned on 16 byte marker */
#if __clang__ || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 8)
#define FIO_PAGE_ALIGN                                                         \
  __attribute__((assume_aligned((1UL << FIO_MEM_PAGE_SIZE_LOG))))
#define FIO_PAGE_ALIGN_NEW                                                     \
  __attribute__((malloc, assume_aligned((1UL << FIO_MEM_PAGE_SIZE_LOG))))
#else
#define FIO_PAGE_ALIGN
#define FIO_PAGE_ALIGN_NEW
#endif /* (__clang__ || __GNUC__)... */

/*
 * allocates memory using `mmap`, but enforces alignment.
 */
FIO_SFUNC void *FIO_MEM_SYS_ALLOC_def_func(size_t bytes,
                                           uint8_t alignment_log) {
  void *result;
  static void *next_alloc = (void *)0x01;
  const size_t alignment_mask = (1ULL << alignment_log) - 1;
  const size_t alignment_size = (1ULL << alignment_log);
  bytes = FIO_MEM_BYTES2PAGES(bytes);
  next_alloc =
      (void *)(((uintptr_t)next_alloc + alignment_mask) & alignment_mask);
/* hope for the best? */
#ifdef MAP_ALIGNED
  result = mmap(next_alloc,
                pages,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS | MAP_ALIGNED(alignment_log),
                -1,
                0);
#else
  result = mmap(next_alloc,
                bytes,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS,
                -1,
                0);
#endif /* MAP_ALIGNED */
  if (result == MAP_FAILED)
    return (void *)NULL;
  if (((uintptr_t)result & alignment_mask)) {
    munmap(result, bytes);
    result = mmap(NULL,
                  bytes + alignment_size,
                  PROT_READ | PROT_WRITE,
                  MAP_PRIVATE | MAP_ANONYMOUS,
                  -1,
                  0);
    if (result == MAP_FAILED) {
      return (void *)NULL;
    }
    const uintptr_t offset =
        (alignment_size - ((uintptr_t)result & alignment_mask));
    if (offset) {
      munmap(result, offset);
      result = (void *)((uintptr_t)result + offset);
    }
    munmap((void *)((uintptr_t)result + bytes), alignment_size - offset);
  }
  next_alloc = (void *)((uintptr_t)result + (bytes << 2));
  return result;
}

/*
 * Re-allocates memory using `mmap`, enforcing alignment.
 */
FIO_SFUNC void *FIO_MEM_SYS_REALLOC_def_func(void *mem,
                                             size_t old_len,
                                             size_t new_len,
                                             uint8_t alignment_log) {
  old_len = FIO_MEM_BYTES2PAGES(old_len);
  new_len = FIO_MEM_BYTES2PAGES(new_len);
  if (new_len > old_len) {
    void *result;
#if defined(__linux__)
    result = mremap(mem, old_len, new_len, 0);
    if (result != MAP_FAILED)
      return result;
#endif
    result = mmap((void *)((uintptr_t)mem + old_len),
                  new_len - old_len,
                  PROT_READ | PROT_WRITE,
                  MAP_PRIVATE | MAP_ANONYMOUS,
                  -1,
                  0);
    if (result == (void *)((uintptr_t)mem + old_len)) {
      result = mem;
    } else {
      /* copy and free */
      munmap(result, new_len - old_len); /* free the failed attempt */
      result =
          FIO_MEM_SYS_ALLOC_def_func(new_len,
                                     alignment_log); /* allocate new memory */
      if (!result) {
        return (void *)NULL;
      }
      FIO___MEMCPY2(result, mem, old_len); /* copy data */
      munmap(mem, old_len);                /* free original memory */
    }
    return result;
  }
  if (old_len != new_len) /* remove dangling pages */
    munmap((void *)((uintptr_t)mem + new_len), old_len - new_len);
  return mem;
}

/* frees memory using `munmap`. */
FIO_IFUNC void FIO_MEM_SYS_FREE_def_func(void *mem, size_t bytes) {
  bytes = FIO_MEM_BYTES2PAGES(bytes);
  munmap(mem, bytes);
}

/* *****************************************************************************



Windows Allocation



***************************************************************************** */
#elif FIO_OS_WIN
#include <memoryapi.h>

FIO_IFUNC void FIO_MEM_SYS_FREE_def_func(void *mem, size_t bytes) {
  bytes = FIO_MEM_BYTES2PAGES(bytes);
  if (!VirtualFree(mem, 0, MEM_RELEASE))
    FIO_LOG_ERROR("Memory address at %p couldn't be returned to the system",
                  mem);
  (void)bytes;
}

FIO_IFUNC void *FIO_MEM_SYS_ALLOC_def_func(size_t bytes,
                                           uint8_t alignment_log) {
  // return aligned_alloc((pages << 12), (1UL << alignment_log));
  void *result;
  size_t attempts = 0;
  static void *next_alloc = (void *)0x01;
  const uintptr_t alignment_rounder = (1ULL << alignment_log) - 1;
  const uintptr_t alignment_mask = ~alignment_rounder;
  bytes = FIO_MEM_BYTES2PAGES(bytes);
  do {
    next_alloc =
        (void *)(((uintptr_t)next_alloc + alignment_rounder) & alignment_mask);
    FIO_ASSERT_DEBUG(!((uintptr_t)next_alloc & alignment_rounder),
                     "alignment allocation rounding error?");
    result =
        VirtualAlloc(next_alloc, (bytes << 2), MEM_RESERVE, PAGE_READWRITE);
    next_alloc = (void *)((uintptr_t)next_alloc + (bytes << 2));
  } while (!result && (attempts++) < 1024);
  if (result) {
    result = VirtualAlloc(result, bytes, MEM_COMMIT, PAGE_READWRITE);
    FIO_ASSERT_DEBUG(result, "couldn't commit memory after reservation?!");

  } else {
    FIO_LOG_ERROR("Couldn't allocate memory from the system, error %zu."
                  "\n\t%zu attempts with final address %p",
                  GetLastError(),
                  attempts,
                  next_alloc);
  }
  return result;
}

FIO_IFUNC void *FIO_MEM_SYS_REALLOC_def_func(void *mem,
                                             size_t old_len,
                                             size_t new_len,
                                             uint8_t alignment_log) {
  if (!new_len)
    goto free_mem;
  old_len = FIO_MEM_BYTES2PAGES(old_len);
  new_len = FIO_MEM_BYTES2PAGES(new_len);
  if (new_len > old_len) {
    /* extend allocation */
    void *tmp = VirtualAlloc((void *)((uintptr_t)mem + old_len),
                             new_len - old_len,
                             MEM_COMMIT,
                             PAGE_READWRITE);
    if (tmp)
      return mem;
    /* Alloc, Copy, Free... sorry... */
    tmp = FIO_MEM_SYS_ALLOC_def_func(new_len, alignment_log);
    if (!tmp) {
      FIO_LOG_ERROR("sysem realloc failed to allocate memory.");
      return NULL;
    }
    FIO___MEMCPY2(tmp, mem, old_len);
    FIO_MEM_SYS_FREE_def_func(mem, old_len);
    mem = tmp;
  } else if (old_len > new_len) {
    /* shrink allocation */
    if (!VirtualFree((void *)((uintptr_t)mem + new_len),
                     old_len - new_len,
                     MEM_DECOMMIT))
      FIO_LOG_ERROR("failed to decommit memory range @ %p.", mem);
  }
  return mem;
free_mem:
  FIO_MEM_SYS_FREE_def_func(mem, old_len);
  mem = NULL;
  return NULL;
}

/* *****************************************************************************


Unknown OS... Unsupported?


***************************************************************************** */
#else /* FIO_OS_POSIX / FIO_OS_WIN => unknown...? */

FIO_IFUNC void *FIO_MEM_SYS_ALLOC_def_func(size_t bytes,
                                           uint8_t alignment_log) {
  // return aligned_alloc((pages << 12), (1UL << alignment_log));
  exit(-1);
  (void)bytes;
  (void)alignment_log;
}

FIO_IFUNC void *FIO_MEM_SYS_REALLOC_def_func(void *mem,
                                             size_t old_len,
                                             size_t new_len,
                                             uint8_t alignment_log) {
  (void)old_len;
  (void)alignment_log;
  new_len = FIO_MEM_BYTES2PAGES(new_len);
  return realloc(mem, new_len);
}

FIO_IFUNC void FIO_MEM_SYS_FREE_def_func(void *mem, size_t bytes) {
  free(mem);
  (void)bytes;
}

#endif /* FIO_OS_POSIX / FIO_OS_WIN */
/* *****************************************************************************
Overridable system allocation macros
***************************************************************************** */
#ifndef FIO_MEM_SYS_ALLOC
#define FIO_MEM_SYS_ALLOC(pages, alignment_log)                                \
  FIO_MEM_SYS_ALLOC_def_func((pages), (alignment_log))
#define FIO_MEM_SYS_REALLOC(ptr, old_pages, new_pages, alignment_log)          \
  FIO_MEM_SYS_REALLOC_def_func((ptr), (old_pages), (new_pages), (alignment_log))
#define FIO_MEM_SYS_FREE(ptr, pages) FIO_MEM_SYS_FREE_def_func((ptr), (pages))
#endif /* FIO_MEM_SYS_ALLOC */

#endif /* H___FIO_MEM_INCLUDE_ONCE___H */

/* *****************************************************************************
FIO_MEMORY_DISABLE - use the system allocator
***************************************************************************** */
#if defined(FIO_MEMORY_DISABLE) || defined(FIO_MALLOC_TMP_USE_SYSTEM)

SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, malloc)(size_t size) {
#if FIO_MEMORY_INITIALIZE_ALLOCATIONS
  return calloc(size, 1);
#elif defined(DEBUG) && DEBUG
  void *ret = malloc(size);
  if (ret)
    FIO___MEMSET(ret, (uint64_t)0xFAFAFAFAFAFAFAFAULL, size);
  return ret;
#else
  return malloc(size);
#endif
}
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                       calloc)(size_t size_per_unit,
                                               size_t unit_count) {
  return calloc(size_per_unit, unit_count);
}
SFUNC void FIO_NAME(FIO_MEMORY_NAME, free)(void *ptr) { free(ptr); }
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc)(void *ptr,
                                                             size_t new_size) {
  return realloc(ptr, new_size);
}
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc2)(void *ptr,
                                                              size_t new_size,
                                                              size_t copy_len) {
  return realloc(ptr, new_size);
  (void)copy_len;
}
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, mmap)(size_t size) {
  return calloc(size, 1);
}

SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)(void) {}
/** Prints the allocator's data structure. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_state)(void) {}
/** Prints the allocator's free block list. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_free_block_list)(void) {}
/** Prints the settings used to define the allocator. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings)(void) {}
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_block_size)(void) { return 0; }

#ifdef FIO_TEST_CSTL
SFUNC void FIO_NAME_TEST(FIO_NAME(stl, FIO_MEMORY_NAME), mem)(void) {
  fprintf(stderr, "* Custom memory allocator bypassed.\n");
}
#endif /* FIO_TEST_CSTL */

#else /* FIO_MEMORY_DISABLE */

/* *****************************************************************************





                  Memory allocation implementation starts here
                    helper function and setup are complete





***************************************************************************** */

/* *****************************************************************************
Lock type choice
***************************************************************************** */
#if FIO_MEMORY_USE_THREAD_MUTEX
#define FIO_MEMORY_LOCK_TYPE fio_thread_mutex_t
#define FIO_MEMORY_LOCK_TYPE_INIT(lock)                                        \
  ((lock) = (fio_thread_mutex_t)FIO_THREAD_MUTEX_INIT)
#define FIO_MEMORY_TRYLOCK(lock) fio_thread_mutex_trylock(&(lock))
#define FIO_MEMORY_LOCK(lock)    fio_thread_mutex_lock(&(lock))
#define FIO_MEMORY_UNLOCK(lock)                                                \
  do {                                                                         \
    int tmp__ = fio_thread_mutex_unlock(&(lock));                              \
    if (tmp__) {                                                               \
      FIO_LOG_ERROR("Couldn't free mutex! error (%d): %s",                     \
                    tmp__,                                                     \
                    strerror(tmp__));                                          \
    }                                                                          \
  } while (0)

#define FIO_MEMORY_LOCK_NAME "pthread_mutex"
#else
#define FIO_MEMORY_LOCK_TYPE            fio_lock_i
#define FIO_MEMORY_LOCK_TYPE_INIT(lock) ((lock) = FIO_LOCK_INIT)
#define FIO_MEMORY_TRYLOCK(lock)        fio_trylock(&(lock))
#define FIO_MEMORY_LOCK(lock)           fio_lock(&(lock))
#define FIO_MEMORY_UNLOCK(lock)         fio_unlock(&(lock))
#define FIO_MEMORY_LOCK_NAME            "facil.io spinlocks"
#endif

/* *****************************************************************************
Allocator debugging helpers
***************************************************************************** */

#if defined(DEBUG) || defined(FIO_LEAK_COUNTER)
/* maximum block allocation count. */
static size_t FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[4];

#define FIO_MEMORY_ON_CHUNK_ALLOC(ptr)                                         \
  do {                                                                         \
    FIO_LOG_DEBUG2("MEMORY SYS-ALLOC - retrieved %p from system", ptr);        \
    fio_atomic_add(                                                            \
        FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter)),        \
        1);                                                                    \
    if (FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[0] >    \
        FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[1])     \
      FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))           \
    [1] = FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[0];   \
  } while (0)
#define FIO_MEMORY_ON_CHUNK_FREE(ptr)                                          \
  do {                                                                         \
    FIO_LOG_DEBUG2("MEMORY SYS-DEALLOC- returned %p to system", ptr);          \
    fio_atomic_sub_fetch(                                                      \
        FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter)),        \
        1);                                                                    \
  } while (0)
#define FIO_MEMORY_ON_CHUNK_CACHE(ptr)                                         \
  do {                                                                         \
    FIO_LOG_DEBUG2("MEMORY CACHE-DEALLOC placed %p in cache", ptr);            \
  } while (0);
#define FIO_MEMORY_ON_CHUNK_UNCACHE(ptr)                                       \
  do {                                                                         \
    FIO_LOG_DEBUG2("MEMORY CACHE-ALLOC retrieved %p from cache", ptr);         \
  } while (0);
#define FIO_MEMORY_ON_CHUNK_DIRTY(ptr)                                         \
  do {                                                                         \
    FIO_LOG_DEBUG2("MEMORY MARK-DIRTY placed %p in dirty list", ptr);          \
  } while (0);
#define FIO_MEMORY_ON_CHUNK_UNDIRTY(ptr)                                       \
  do {                                                                         \
    FIO_LOG_DEBUG2("MEMORY UNMARK-DIRTY retrieved %p from dirty list", ptr);   \
  } while (0);
#define FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK(ptr, blk)                            \
  if (0)                                                                       \
    do {                                                                       \
      FIO_LOG_DEBUG2("MEMORY chunk %p block %zu reset in lock",                \
                     ptr,                                                      \
                     (size_t)blk);                                             \
    } while (0);

#define FIO_MEMORY_ON_BIG_BLOCK_SET(ptr)                                       \
  if (1)                                                                       \
    do {                                                                       \
      FIO_LOG_DEBUG2("MEMORY chunk %p used as big-block", ptr);                \
    } while (0);

#define FIO_MEMORY_ON_BIG_BLOCK_UNSET(ptr)                                     \
  if (1)                                                                       \
    do {                                                                       \
      FIO_LOG_DEBUG2("MEMORY chunk %p no longer used as big-block", ptr);      \
    } while (0);

#define FIO_MEMORY_PRINT_STATS()                                               \
  FIO_LOG_DEBUG2(                                                              \
      "(" FIO_MACRO2STR(FIO_NAME(                                              \
          FIO_MEMORY_NAME,                                                     \
          malloc)) "):\n          "                                            \
                   "Total memory chunks allocated before cleanup %zu\n"        \
                   "          Maximum memory blocks allocated at a single "    \
                   "time %zu",                                                 \
      FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[0],       \
      FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[1])
#define FIO_MEMORY_PRINT_STATS_END()                                           \
  do {                                                                         \
    if (FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[0] ||   \
        FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[2] !=   \
            FIO_NAME(fio___,                                                   \
                     FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[3]) {       \
      FIO_LOG_ERROR(                                                           \
          "(" FIO_MACRO2STR(                                                   \
              FIO_NAME(FIO_MEMORY_NAME,                                        \
                       malloc)) "):\n          "                               \
                                "Total memory chunks allocated "               \
                                "after cleanup (POSSIBLE LEAKS): %zd",         \
          FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[0]);  \
    }                                                                          \
    FIO_LOG_DEBUG2(                                                            \
        "(" FIO_MACRO2STR(                                                     \
            FIO_NAME(FIO_MEMORY_NAME,                                          \
                     malloc)) ") usage:"                                       \
                              "\n          malloc / calloc : %zu"              \
                              "\n          free            : %zu",             \
        FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[2],     \
        FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[3]);    \
  } while (0)
#define FIO_MEMORY_ON_ALLOC_FUNC()                                             \
  fio_atomic_add(                                                              \
      (FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter)) + 2),    \
      1)
#define FIO_MEMORY_ON_FREE_FUNC()                                               \
  do {                                                                          \
    fio_atomic_add(                                                             \
        (FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter)) + 3),   \
        1);                                                                     \
    FIO_ASSERT(                                                                 \
        FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[2] >=    \
            FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[3],  \
        FIO_MACRO2STR(FIO_NAME(                                                 \
            FIO_MEMORY_NAME,                                                    \
            free)) " called more than " FIO_MACRO2STR(FIO_NAME(FIO_MEMORY_NAME, \
                                                               malloc)));       \
  } while (0)
#else /* defined(DEBUG) || defined(FIO_LEAK_COUNTER) */
#define FIO_MEMORY_ON_CHUNK_ALLOC(ptr)              ((void)0)
#define FIO_MEMORY_ON_CHUNK_FREE(ptr)               ((void)0)
#define FIO_MEMORY_ON_CHUNK_CACHE(ptr)              ((void)0)
#define FIO_MEMORY_ON_CHUNK_UNCACHE(ptr)            ((void)0)
#define FIO_MEMORY_ON_CHUNK_DIRTY(ptr)              ((void)0)
#define FIO_MEMORY_ON_CHUNK_UNDIRTY(ptr)            ((void)0)
#define FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK(ptr, blk) ((void)0)
#define FIO_MEMORY_ON_BIG_BLOCK_SET(ptr)            ((void)0)
#define FIO_MEMORY_ON_BIG_BLOCK_UNSET(ptr)          ((void)0)
#define FIO_MEMORY_PRINT_STATS()                    ((void)0)
#define FIO_MEMORY_PRINT_STATS_END()                ((void)0)
#define FIO_MEMORY_ON_ALLOC_FUNC()                  ((void)0)
#define FIO_MEMORY_ON_FREE_FUNC()                   ((void)0)
#endif /* defined(DEBUG) || defined(FIO_LEAK_COUNTER) */

/* *****************************************************************************






Memory chunk headers and block data (in chunk header)






***************************************************************************** */

/* *****************************************************************************
Chunk and Block data / header
***************************************************************************** */

typedef struct {
  volatile int32_t ref;
  volatile int32_t pos;
} FIO_NAME(FIO_MEMORY_NAME, __mem_block_s);

typedef struct {
  /* the head of the chunk... node->next says a lot */
  uint32_t marker;
  volatile int32_t ref;
  FIO_NAME(FIO_MEMORY_NAME, __mem_block_s)
  blocks[FIO_MEMORY_BLOCKS_PER_ALLOCATION];
} FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s);

#if FIO_MEMORY_ENABLE_BIG_ALLOC
/* big-blocks consumes a chunk, sizeof header MUST be <= chunk header */
typedef struct {
  /* marker and ref MUST overlay chunk header */
  uint32_t marker;
  volatile int32_t ref;
  volatile int32_t pos;
} FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s);
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

/* *****************************************************************************
Arena type
***************************************************************************** */
typedef struct {
  void *block;
  int32_t last_pos;
  FIO_MEMORY_LOCK_TYPE lock;
} FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s);

/* *****************************************************************************
Allocator State
***************************************************************************** */

typedef struct FIO_NAME(FIO_MEMORY_NAME, __mem_state_s)
    FIO_NAME(FIO_MEMORY_NAME, __mem_state_s);

static struct FIO_NAME(FIO_MEMORY_NAME, __mem_state_s) {
#if FIO_MEMORY_CACHE_SLOTS
  /** cache array container for available memory chunks */
  struct {
    /* chunk slot array */
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * a[FIO_MEMORY_CACHE_SLOTS];
    size_t pos;
  } cache;
#endif /* FIO_MEMORY_CACHE_SLOTS */

#if FIO_MEMORY_ENABLE_BIG_ALLOC
  /** a block for big allocations, shared (no arena) */
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) * big_block;
  int32_t big_last_pos;
  /** big allocation lock */
  FIO_MEMORY_LOCK_TYPE big_lock;
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */
  /** main memory state lock */
  FIO_MEMORY_LOCK_TYPE lock;
  /** free list for available blocks */
  FIO_LIST_HEAD blocks;
  /** the arena count for the allocator */
  size_t arena_count;
  FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s) arena[];
} * FIO_NAME(FIO_MEMORY_NAME, __mem_state);

/* *****************************************************************************
Arena assignment
***************************************************************************** */

/* SublimeText marker */
void fio___mem_arena_unlock___(void);
/** Unlocks the thread's arena. */
FIO_SFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_arena_unlock)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s) * a) {
  FIO_ASSERT_DEBUG(a, "unlocking a NULL arena?!");
  FIO_MEMORY_UNLOCK(a->lock);
}

/* SublimeText marker */
void fio___mem_arena_lock___(void);

/** Locks and returns the thread's arena. */
FIO_SFUNC FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s) *
    FIO_NAME(FIO_MEMORY_NAME, __mem_arena_lock)(void) {
#if FIO_MEMORY_ARENA_COUNT == 1
  FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[0].lock);
  return FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena;

#else /* FIO_MEMORY_ARENA_COUNT != 1 */

#if defined(DEBUG) && FIO_MEMORY_ARENA_COUNT > 0 && !defined(FIO_TEST_CSTL)
  static size_t warning_printed = 0;
#define FIO___MEMORY_ARENA_LOCK_WARNING()                                      \
  do {                                                                         \
    if (!warning_printed)                                                      \
      FIO_LOG_WARNING(FIO_MACRO2STR(FIO_NAME(                                  \
          FIO_MEMORY_NAME,                                                     \
          malloc)) " high arena contention.\n"                                 \
                   "          Consider recompiling with more arenas.");        \
    warning_printed = 1;                                                       \
  } while (0)
#else
#define FIO___MEMORY_ARENA_LOCK_WARNING()
#endif
  /** thread arena value */
  size_t arena_index;
  size_t loop_count = 0;
  {
    /* select the default arena selection using a thread ID. */
    union {
      void *p;
      fio_thread_t t;
    } u = {.t = fio_thread_current()};
    arena_index = fio_risky_ptr(u.p) %
                  FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
#if defined(DEBUG)
    static void *pthread_last = NULL;
    if (pthread_last != u.p) {
      FIO_LOG_DEBUG(
          "thread %p (%p) associated with arena %zu / %zu",
          u.p,
          (void *)fio_risky_ptr(u.p),
          arena_index,
          (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count);
      pthread_last = u.p;
    }
#endif
  }
  for (;;) {
    /* rotate all arenas to find one that's available */
    if (!FIO_MEMORY_TRYLOCK(
            FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[arena_index].lock))
      return (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena + arena_index);
    ++arena_index;
    if (arena_index == FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count)
      arena_index = 0;
    if (++loop_count <
        (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count << 1))
      continue;
    FIO___MEMORY_ARENA_LOCK_WARNING();
#undef FIO___MEMORY_ARENA_LOCK_WARNING
#if FIO_MEMORY_USE_THREAD_MUTEX && FIO_OS_POSIX
    /* slow wait for last arena */
    FIO_MEMORY_LOCK(
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[arena_index].lock);
    return FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena + arena_index;
#else
    // FIO_THREAD_RESCHEDULE();
#endif /* FIO_MEMORY_USE_THREAD_MUTEX */
  }
#endif /* FIO_MEMORY_ARENA_COUNT != 1 */
}

/* *****************************************************************************
Converting between chunk & block data to pointers (and back)
***************************************************************************** */

#define FIO_MEMORY_HEADER_SIZE                                                 \
  ((sizeof(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s)) +                         \
    (FIO_MEMORY_ALIGN_SIZE - 1)) &                                             \
   (~(FIO_MEMORY_ALIGN_SIZE - 1)))

#define FIO_MEMORY_BLOCK_SIZE                                                  \
  (((FIO_MEMORY_SYS_ALLOCATION_SIZE - FIO_MEMORY_HEADER_SIZE) /                \
    FIO_MEMORY_BLOCKS_PER_ALLOCATION) &                                        \
   (~(FIO_MEMORY_ALIGN_SIZE - 1)))

#define FIO_MEMORY_UNITS_PER_BLOCK                                             \
  (FIO_MEMORY_BLOCK_SIZE / FIO_MEMORY_ALIGN_SIZE)

/* SublimeText marker */
void fio___mem_chunk2ptr___(void);
/** returns a pointer within a chunk, given it's block and offset value. */
FIO_IFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c,
    size_t block,
    size_t offset) {
  return (void *)(((uintptr_t)(c) + FIO_MEMORY_HEADER_SIZE) +
                  (block * FIO_MEMORY_BLOCK_SIZE) +
                  (offset << FIO_MEMORY_ALIGN_LOG));
}

/* SublimeText marker */
void fio___mem_ptr2chunk___(void);
/** returns a chunk given a pointer. */
FIO_IFUNC FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *
    FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(void *p) {
  return FIO_PTR_MATH_RMASK(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s),
                            p,
                            FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);
}

/* SublimeText marker */
void fio___mem_ptr2index___(void);
/** returns a pointer's block index within it's chunk. */
FIO_IFUNC size_t FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c,
    void *p) {
  FIO_ASSERT_DEBUG(c == FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(p),
                   "chunk-pointer offset argument error");
  size_t i =
      (size_t)FIO_PTR_MATH_LMASK(void, p, FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);
  i -= FIO_MEMORY_HEADER_SIZE;
  i /= FIO_MEMORY_BLOCK_SIZE;
  return i;
  (void)c;
}

/* *****************************************************************************
Allocator State Initialization & Cleanup
***************************************************************************** */
#define FIO_MEMORY_STATE_SIZE(arean_count)                                     \
  FIO_MEM_BYTES2PAGES(                                                         \
      (sizeof(*FIO_NAME(FIO_MEMORY_NAME, __mem_state)) +                       \
       (sizeof(FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s)) * (arean_count))))

/* function declarations for functions called during cleanup */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c);
FIO_IFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)(void);
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)(void *ptr);
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)(void *ptr);
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_free)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c);

/* IDE marker */
void fio___mem_state_cleanup___(void);
FIO_SFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_state_cleanup)(void *ignr_) {
  if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)) {
    FIO_LOG_DEBUG2(FIO_MACRO2STR(
        FIO_NAME(FIO_MEMORY_NAME,
                 __mem_state_cleanup)) " called more than once (NULL state).");
    return;
  }
  (void)ignr_;
#if DEBUG
  FIO_LOG_INFO("starting facil.io memory allocator cleanup for " FIO_MACRO2STR(
      FIO_NAME(FIO_MEMORY_NAME, malloc)) ".");
#endif /* DEBUG */
  FIO_MEMORY_PRINT_STATS();
  /* free arena blocks */
  for (size_t i = 0; i < FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
       ++i) {
    if (FIO_MEMORY_TRYLOCK(
            FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock)) {
      FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock);
      FIO_LOG_ERROR(FIO_MACRO2STR(
          FIO_NAME(FIO_MEMORY_NAME,
                   malloc)) "cleanup called while some arenas are in use!");
    }
    FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock);
    FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)
    (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block = NULL;
    FIO_MEMORY_LOCK_TYPE_INIT(
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock);
  }

#if FIO_MEMORY_ENABLE_BIG_ALLOC
  /* cleanup big-alloc chunk */
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block) {
    if ((uint32_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block->ref > 1) {
      FIO_LOG_WARNING("(" FIO_MACRO2STR(FIO_NAME(
          FIO_MEMORY_NAME,
          malloc)) ") active big-block reference count error at %p\n"
                   "          Possible memory leaks for big-block allocation.");
    }
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)
    (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block = NULL;
    FIO_MEMORY_LOCK_TYPE_INIT(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
  }
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

#if FIO_MEMORY_CACHE_SLOTS
  /* deallocate all chunks in the cache */
  while (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos) {
    const size_t pos = --FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos;
    FIO_MEMORY_ON_CHUNK_UNCACHE(
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.a[pos]);
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)
    (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.a[pos]);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.a[pos] = NULL;
  }
#endif /* FIO_MEMORY_CACHE_SLOTS */

  /* report any blocks in the allocation list - even if not in DEBUG mode */
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.next !=
      &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks) {
    struct t_s {
      FIO_LIST_NODE node;
    };
    void *last_chunk = NULL;
    FIO_LOG_WARNING("(" FIO_MACRO2STR(
        FIO_NAME(FIO_MEMORY_NAME,
                 malloc)) ") blocks left after cleanup - memory leaks?");
    FIO_LIST_EACH(struct t_s,
                  node,
                  &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks,
                  pos) {
      if (last_chunk == (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(pos))
        continue;
      last_chunk = (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(pos);
      FIO_LOG_WARNING(
          "(" FIO_MACRO2STR(FIO_NAME(FIO_MEMORY_NAME,
                                     malloc)) ") leaked block(s) for chunk %p",
          (void *)pos,
          last_chunk);
    }
  }

  /* dealloc the state machine */
  const size_t s = FIO_MEMORY_STATE_SIZE(
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count);
  FIO_MEM_SYS_FREE(FIO_NAME(FIO_MEMORY_NAME, __mem_state), s);
  FIO_NAME(FIO_MEMORY_NAME, __mem_state) =
      (FIO_NAME(FIO_MEMORY_NAME, __mem_state_s *))NULL;

  FIO_MEMORY_PRINT_STATS_END();
#if DEBUG && defined(FIO_LOG_INFO)
  FIO_LOG_DEBUG2(
      "finished facil.io memory allocator cleanup for " FIO_MACRO2STR(
          FIO_NAME(FIO_MEMORY_NAME, malloc)) ".");
#endif /* DEBUG */
}

FIO_SFUNC void FIO_NAME(FIO_MEMORY_NAME,
                        __malloc_after_fork_task)(void *ignr_) {
  (void)ignr_;
  FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)();
}

/* initializes (allocates) the arenas and state machine */
FIO_CONSTRUCTOR(FIO_NAME(FIO_MEMORY_NAME, __mem_state_setup)) {
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state))
    return;
  fio_state_callback_add(FIO_CALL_IN_CHILD,
                         FIO_NAME(FIO_MEMORY_NAME, __malloc_after_fork_task),
                         NULL);
  fio_state_callback_add(FIO_CALL_AT_EXIT,
                         FIO_NAME(FIO_MEMORY_NAME, __mem_state_cleanup),
                         NULL);
  /* allocate the state machine */
  {
#if FIO_MEMORY_ARENA_COUNT > 0
    size_t const arean_count = FIO_MEMORY_ARENA_COUNT;
#else
    size_t arean_count = FIO_MEMORY_ARENA_COUNT_FALLBACK;
#ifdef _SC_NPROCESSORS_ONLN
    arean_count = sysconf(_SC_NPROCESSORS_ONLN);
    if (arean_count == (size_t)-1UL)
      arean_count = FIO_MEMORY_ARENA_COUNT_FALLBACK;
    else /* arenas !> threads (birthday) */
      arean_count = (arean_count << 1) + 2;
#else
#if _MSC_VER
#pragma message(                                                               \
    "Dynamic CPU core count is unavailable - assuming FIO_MEMORY_ARENA_COUNT_FALLBACK cores.")
#else
#warning Dynamic CPU core count is unavailable - assuming FIO_MEMORY_ARENA_COUNT_FALLBACK cores.
#endif
#endif /* _SC_NPROCESSORS_ONLN */

    if (arean_count >= FIO_MEMORY_ARENA_COUNT_MAX)
      arean_count = FIO_MEMORY_ARENA_COUNT_MAX;

#endif /* FIO_MEMORY_ARENA_COUNT > 0 */

    const size_t s = FIO_MEMORY_STATE_SIZE(arean_count);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state) =
        (FIO_NAME(FIO_MEMORY_NAME, __mem_state_s *))FIO_MEM_SYS_ALLOC(s, 0);
    FIO_ASSERT_ALLOC(FIO_NAME(FIO_MEMORY_NAME, __mem_state));
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count = arean_count;
  }
  FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks =
      FIO_LIST_INIT(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks);
  FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)();

#if defined(FIO_MEMORY_WARMUP) && FIO_MEMORY_WARMUP
  for (size_t i = 0; i < (size_t)FIO_MEMORY_WARMUP &&
                     i < FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
       ++i) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block =
        FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)();
  }
#endif
#ifdef DEBUG
  FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings)();
#endif /* DEBUG */
  (void)FIO_NAME(FIO_MEMORY_NAME, malloc_print_free_block_list);
  (void)FIO_NAME(FIO_MEMORY_NAME, malloc_print_state);
  (void)FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings);
}

/* SublimeText marker */
void fio_after_fork___(void);
/**
 * When forking is called manually, call this function to reset the facil.io
 * memory allocator's locks.
 */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_after_fork)(void) {
  if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_state_setup)();
    return;
  }
  FIO_LOG_DEBUG2("MEMORY reinitializeing " FIO_MACRO2STR(
      FIO_NAME(FIO_MEMORY_NAME, malloc)) " state");
  FIO_MEMORY_LOCK_TYPE_INIT(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
#if FIO_MEMORY_ENABLE_BIG_ALLOC
  FIO_MEMORY_LOCK_TYPE_INIT(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */
  for (size_t i = 0; i < FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
       ++i) {
    FIO_MEMORY_LOCK_TYPE_INIT(
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].lock);
  }
}

/* *****************************************************************************
Memory Allocation - state printing (debug helper)
***************************************************************************** */

/* SublimeText marker */
void fio_malloc_print_state___(void);
/** Prints the allocator's data structure. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_state)(void) {
  fprintf(
      stderr,
      FIO_MACRO2STR(FIO_NAME(FIO_MEMORY_NAME, malloc)) " allocator state:\n");
  for (size_t i = 0; i < FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count;
       ++i) {
    fprintf(stderr,
            "\t* arena[%zu] block: %p\n",
            i,
            (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block);
    if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block) {
      FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
          FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(
              FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block);
      size_t b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(
          c,
          FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena[i].block);
      fprintf(stderr, "\t\tchunk-ref: %zu (%p)\n", (size_t)c->ref, (void *)c);
      fprintf(stderr,
              "\t\t- block[%zu]-ref: %zu\n"
              "\t\t- block[%zu]-pos: %zu\n",
              b,
              (size_t)c->blocks[b].ref,
              b,
              (size_t)c->blocks[b].pos);
    }
  }
#if FIO_MEMORY_ENABLE_BIG_ALLOC
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block) {
    fprintf(stderr, "\t---big allocations---\n");
    fprintf(stderr,
            "\t* big-block: %p\n"
            "\t\t ref: %zu\n"
            "\t\t pos: %zu\n",
            (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block,
            (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block->ref,
            (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block->pos);
  } else {
    fprintf(stderr,
            "\t---big allocations---\n"
            "\t* big-block: NULL\n");
  }

#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

#if FIO_MEMORY_CACHE_SLOTS
  fprintf(stderr, "\t---caches---\n");
  for (size_t i = 0; i < FIO_MEMORY_CACHE_SLOTS; ++i) {
    fprintf(stderr,
            "\t* cache[%zu] chunk: %p\n",
            i,
            (void *)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.a[i]);
  }
#endif /* FIO_MEMORY_CACHE_SLOTS */
}

void fio_malloc_print_free_block_list___(void);
/** Prints the allocator's free block list. May be used for debugging. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_free_block_list)(void) {
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.prev ==
      &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks)
    return;
  fprintf(stderr,
          FIO_MACRO2STR(FIO_NAME(FIO_MEMORY_NAME,
                                 malloc)) " allocator free block list:\n");
  FIO_LIST_NODE *n = FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.prev;
  for (size_t i = 0; n != &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks;
       ++i) {
    fprintf(stderr, "\t[%zu] %p\n", i, (void *)n);
    n = n->prev;
  }
}

/* *****************************************************************************
chunk allocation / deallocation
***************************************************************************** */

/* SublimeText marker */
void fio___mem_chunk_dealloc___(void);
/* returns memory to system */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c) {
  if (!c)
    return;
  FIO_MEM_SYS_FREE(((void *)c), FIO_MEMORY_SYS_ALLOCATION_SIZE);
  FIO_MEMORY_ON_CHUNK_FREE(c);
}

FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_cache_or_dealloc)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c) {
#if FIO_MEMORY_CACHE_SLOTS
  /* place in cache...? */
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos <
      FIO_MEMORY_CACHE_SLOTS) {
    FIO_MEMORY_ON_CHUNK_CACHE(c);
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)
        ->cache.a[FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos++] = c;
    c = NULL;
  }
#endif /* FIO_MEMORY_CACHE_SLOTS */

  FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)(c);
}

FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_free)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c) {
  /* should we free the chunk? */
  if (!c || fio_atomic_sub_fetch(&c->ref, 1)) {
    FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
    return;
  }

  /* remove all blocks from the block allocation list */
  for (size_t b = 0; b < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++b) {
    FIO_LIST_NODE *n =
        (FIO_LIST_NODE *)FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0);
    if (n->prev && n->next) {
      FIO_LIST_REMOVE(n);
      n->prev = n->next = NULL;
    }
  }
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_cache_or_dealloc)(c);
}

/* SublimeText marker */
void fio___mem_chunk_new___(void);
/* UNSAFE! returns a clean chunk (cache / allocation). */
FIO_IFUNC FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_new)(const size_t needs_lock) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c = NULL;
#if FIO_MEMORY_CACHE_SLOTS
  /* cache allocation */
  if (needs_lock) {
    FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  }
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos) {
    c = FIO_NAME(FIO_MEMORY_NAME, __mem_state)
            ->cache.a[--FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos];
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)
        ->cache.a[FIO_NAME(FIO_MEMORY_NAME, __mem_state)->cache.pos] = NULL;
  }
  if (needs_lock) {
    FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  }
  if (c) {
    FIO_MEMORY_ON_CHUNK_UNCACHE(c);
    *c = (FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s)){.ref = 1};
    return c;
  }
#endif /* FIO_MEMORY_CACHE_SLOTS */

  /* system allocation */
  c = (FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)FIO_MEM_SYS_ALLOC(
      FIO_MEMORY_SYS_ALLOCATION_SIZE,
      FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);

  if (!c)
    return c;
  FIO_MEMORY_ON_CHUNK_ALLOC(c);
  c->ref = 1;
  return c;
  (void)needs_lock; /* in case it isn't used */
}

/* *****************************************************************************
block allocation / deallocation
***************************************************************************** */

FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_block__reset_memory)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c,
    size_t b) {
#if FIO_MEMORY_INITIALIZE_ALLOCATIONS
  if (c->blocks[b].pos >= (int32_t)(FIO_MEMORY_UNITS_PER_BLOCK - 4)) {
    /* zero out the whole block */
    FIO___MEMSET(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0),
                 0,
                 FIO_MEMORY_BLOCK_SIZE);
  } else {
    /* zero out only the memory that was used */
    FIO___MEMSET(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0),
                 0,
                 (((size_t)c->blocks[b].pos) << FIO_MEMORY_ALIGN_LOG));
  }
#elif defined(DEBUG) && DEBUG
  /* set all bytes to 0xAF to better catch initialization bugs */
  FIO___MEMSET(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0),
               0xFAFAFAFAFAFAFAFAULL,
               FIO_MEMORY_BLOCK_SIZE);
#else
  /** only reset a block's free-list header */
  FIO___MEMSET(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0),
               0,
               (((FIO_MEMORY_ALIGN_SIZE - 1) + sizeof(FIO_LIST_NODE)) &
                (~(FIO_MEMORY_ALIGN_SIZE - 1))));
#endif /*FIO_MEMORY_INITIALIZE_ALLOCATIONS*/
  c->blocks[b].pos = 0;
}

/* SublimeText marker */
void fio___mem_block_free___(void);
/** frees a block / decreases it's reference count */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)(void *p) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
      FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(p);
  size_t b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(c, p);
  if (!c)
    return;
  FIO_ASSERT_DEBUG(
      (uint32_t)c->blocks[b].ref <= FIO_MEMORY_UNITS_PER_BLOCK + 1,
      "block reference count corrupted, possible double free? (%zd)",
      (size_t)c->blocks[b].ref);
  FIO_ASSERT_DEBUG(
      (uint32_t)c->blocks[b].pos <= FIO_MEMORY_UNITS_PER_BLOCK + 1,
      "block allocation position corrupted, possible double free? (%zd)",
      (size_t)c->blocks[b].pos);
  if (fio_atomic_sub_fetch(&c->blocks[b].ref, 1))
    return;

  /* reset memory */
  FIO_NAME(FIO_MEMORY_NAME, __mem_block__reset_memory)(c, b);

  /* place in free list */
  FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  FIO_LIST_NODE *n =
      (FIO_LIST_NODE *)FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0);
  FIO_LIST_PUSH(&FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks, n);
  /* free chunk reference while in locked state */
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_free)(c);
}

/* SublimeText marker */
void fio___mem_block_new___(void);
/** returns a new block with a reference count of 1 */
FIO_IFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)(void) {
  void *p = NULL;
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c = NULL;
  size_t b;

  FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);

  /* try to collect from list */
  if (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.prev !=
      &FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks) {
    FIO_LIST_NODE *n = FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks.prev;
    FIO_LIST_REMOVE(n);
    n->next = n->prev = NULL;
    c = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)((void *)n);
    fio_atomic_add_fetch(&c->ref, 1);
    p = (void *)n;
    b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(c, p);
    goto done;
  }

  /* allocate from cache / system (sets chunk reference to 1) */
  c = FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_new)(0);
  if (!c)
    goto done;

  /* use the first block in the chunk as the new block */
  p = FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, 0, 0);

  /* place the rest of the blocks in the block allocation list */
  for (b = 1; b < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++b) {
    FIO_LIST_NODE *n =
        (FIO_LIST_NODE *)FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0);
    FIO_LIST_PUSH(&FIO_NAME(FIO_MEMORY_NAME, __mem_state)->blocks, n);
  }
  /* set block index to zero */
  b = 0;

done:
  FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  if (!p)
    return p;
  /* update block reference and allocation position */
  c->blocks[b].ref = 1;
  c->blocks[b].pos = 0;
  return p;
}

/* *****************************************************************************
Small allocation internal API
***************************************************************************** */

/* SublimeText marker */
void fio___mem_slice_new___(void);
/** slice a block to allocate a set number of bytes. */
FIO_SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                           __mem_slice_new)(size_t bytes,
                                                            void *is_realloc) {
  void *p = NULL;
  bytes = (bytes + ((1UL << FIO_MEMORY_ALIGN_LOG) - 1)) >> FIO_MEMORY_ALIGN_LOG;
  FIO_NAME(FIO_MEMORY_NAME, __mem_arena_s) *a =
      FIO_NAME(FIO_MEMORY_NAME, __mem_arena_lock)();

  if (!a->block) {
    a->block = FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)();
    a->last_pos = 0;
  }
  for (;;) {
    if (!a->block)
      goto no_mem;
    void *const block = a->block;

    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *const c =
        FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(block);
    const size_t b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(c, block);

    /* add allocation reference */
    /* if we are the only thread holding a reference to this block - reset. */
    if (fio_atomic_add(&c->blocks[b].ref, 1) == 1 && c->blocks[b].pos) {
      FIO_NAME(FIO_MEMORY_NAME, __mem_block__reset_memory)(c, b);
      FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK(c, b);
      a->last_pos = 0;
    }

    /* enough space? allocate */
    if (c->blocks[b].pos + bytes < FIO_MEMORY_UNITS_PER_BLOCK) {
      /* a lucky realloc? */
      if (is_realloc &&
          is_realloc ==
              FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, a->last_pos)) {
        c->blocks[b].pos += bytes;
        fio_atomic_sub(&c->blocks[b].ref, 1); /* release reference added */
        FIO_NAME(FIO_MEMORY_NAME, __mem_arena_unlock)(a);
        return is_realloc;
      }
      p = FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, c->blocks[b].pos);
      a->last_pos = c->blocks[b].pos;
      c->blocks[b].pos += bytes;
      FIO_NAME(FIO_MEMORY_NAME, __mem_arena_unlock)(a);
      return p;
    }
    is_realloc = NULL;

    /*
     * allocate a new block before freeing the existing block
     * this prevents the last chunk from de-allocating and reallocating
     */
    a->block = FIO_NAME(FIO_MEMORY_NAME, __mem_block_new)();
    a->last_pos = 0;

    /* release allocation reference added */
    fio_atomic_sub(&c->blocks[b].ref, 1);
    /* release the reference held by the arena (allocator) */
    FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)(block);
  }

no_mem:
  FIO_NAME(FIO_MEMORY_NAME, __mem_arena_unlock)(a);
  errno = ENOMEM;
  return p;
}

/* SublimeText marker */
void fio_____mem_slice_free___(void);
/** slice a block to allocate a set number of bytes. */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_slice_free)(void *p) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_block_free)(p);
}

/* *****************************************************************************
big block allocation / de-allocation
***************************************************************************** */
#if FIO_MEMORY_ENABLE_BIG_ALLOC

#define FIO_MEMORY_BIG_BLOCK_MARKER ((~(uint32_t)0) << 2)
#define FIO_MEMORY_BIG_BLOCK_HEADER_SIZE                                       \
  (((sizeof(FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s)) +                    \
     ((FIO_MEMORY_ALIGN_SIZE - 1))) &                                          \
    ((~(0UL)) << FIO_MEMORY_ALIGN_LOG)))

#define FIO_MEMORY_BIG_BLOCK_SIZE                                              \
  (FIO_MEMORY_SYS_ALLOCATION_SIZE - FIO_MEMORY_BIG_BLOCK_HEADER_SIZE)

#define FIO_MEMORY_UNITS_PER_BIG_BLOCK                                         \
  (FIO_MEMORY_BIG_BLOCK_SIZE / FIO_MEMORY_ALIGN_SIZE)

/* SublimeText marker */
void fio___mem_big_block__reset_memory___(void);
/** zeros out a big-block's memory, keeping it's reference count at 1. */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_big_block__reset_memory)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) * b) {

#if FIO_MEMORY_INITIALIZE_ALLOCATIONS
  /* zero out memory */
  if (b->pos >= (int32_t)(FIO_MEMORY_UNITS_PER_BIG_BLOCK - 10)) {
    /* zero out everything */
    FIO___MEMSET((void *)b, 0, FIO_MEMORY_SYS_ALLOCATION_SIZE);
  } else {
    /* zero out only the used part of the memory */
    FIO___MEMSET((void *)b,
                 0,
                 (((size_t)b->pos << FIO_MEMORY_ALIGN_LOG) +
                  FIO_MEMORY_BIG_BLOCK_HEADER_SIZE));
  }
#else
#if defined(DEBUG) && DEBUG
  /* set all bytes to 0xAF to better catch initialization bugs */
  FIO___MEMSET((void *)b,
               0xFAFAFAFAFAFAFAFAULL,
               FIO_MEMORY_SYS_ALLOCATION_SIZE);
#endif /* DEBUG */
  /* reset chunk header, which is always bigger than big_block header*/
  FIO___MEMSET((void *)b, 0, sizeof(FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s)));
  /* zero out possible block memory (if required) */
  for (size_t i = 0; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_block__reset_memory)
    ((FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)b, i);
  }
#endif /* FIO_MEMORY_INITIALIZE_ALLOCATIONS */
  b->ref = 1;
}

/* SublimeText marker */
void fio___mem_big_block_free___(void);
/** frees a block / decreases it's reference count */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)(void *p) {
  // FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s)      ;
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *b =
      (FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *)
          FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(p);
  /* should we free the block? */
  if (!b || fio_atomic_sub_fetch(&b->ref, 1))
    return;
  FIO_MEMORY_ON_BIG_BLOCK_UNSET(b);

  /* zero out memory */
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block__reset_memory)(b);
#if FIO_MEMORY_CACHE_SLOTS
  /* lock for chunk de-allocation review () */
  FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->lock);
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_cache_or_dealloc)
  ((FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)b);
#else
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_dealloc)
  ((FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)b);
#endif
}

/* SublimeText marker */
void fio___mem_big_block_new___(void);
/** returns a new block with a reference count of 1 */
FIO_IFUNC FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_new)(void) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *b =
      (FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *)
          FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_new)(1);
  if (!b)
    goto no_mem;
  b->marker = FIO_MEMORY_BIG_BLOCK_MARKER;
  b->ref = 1;
  b->pos = 0;
  FIO_MEMORY_ON_BIG_BLOCK_SET(b);
  return b;
no_mem:
  errno = ENOMEM;
  return b;
}

/* *****************************************************************************
Big allocation internal API
***************************************************************************** */

/* SublimeText marker */
void fio___mem_big2ptr___(void);
/** returns a pointer within a chunk, given it's block and offset value. */
FIO_IFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_big2ptr)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) * b,
    size_t offset) {
  return (void *)(((uintptr_t)(b) + FIO_MEMORY_BIG_BLOCK_HEADER_SIZE) +
                  (offset << FIO_MEMORY_ALIGN_LOG));
}

/* SublimeText marker */
void fio___mem_big_slice_new___(void);
FIO_SFUNC void *FIO_MEM_ALIGN_NEW
FIO_NAME(FIO_MEMORY_NAME, __mem_big_slice_new)(size_t bytes, void *is_realloc) {
  void *p = NULL;
  bytes = (bytes + ((1UL << FIO_MEMORY_ALIGN_LOG) - 1)) >> FIO_MEMORY_ALIGN_LOG;
  for (;;) {
    FIO_MEMORY_LOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
    if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block) {
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block =
          FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_new)();
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos = 0;
    }

    if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block)
      goto done;
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_s) *b =
        FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block;

    /* are we the only thread holding a reference to this block... reset? */
    if (b->ref == 1 && b->pos) {
      FIO_NAME(FIO_MEMORY_NAME, __mem_big_block__reset_memory)(b);
      FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK(b, 0);
      b->marker = FIO_MEMORY_BIG_BLOCK_MARKER;
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos = 0;
    }

    /* enough space? */
    if (b->pos + bytes < FIO_MEMORY_UNITS_PER_BIG_BLOCK) {
      /* a lucky realloc? */
      if (is_realloc &&
          is_realloc ==
              FIO_NAME(FIO_MEMORY_NAME, __mem_big2ptr)(
                  b,
                  FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos)) {
        b->pos += bytes;
        FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
        return is_realloc;
      }

      p = FIO_NAME(FIO_MEMORY_NAME, __mem_big2ptr)(b, b->pos);
      fio_atomic_add(&b->ref, 1); /* keep inside lock to enable reset */
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos = b->pos;
      b->pos += bytes;
      FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
      return p;
    }

    is_realloc = NULL;
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_block = NULL;
    FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_last_pos = 0;
    FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)(b);
  }
done:
  FIO_MEMORY_UNLOCK(FIO_NAME(FIO_MEMORY_NAME, __mem_state)->big_lock);
  return p;
}

/* SublimeText marker */
void fio_____mem_big_slice_free___(void);
/** slice a block to allocate a set number of bytes. */
FIO_IFUNC void FIO_NAME(FIO_MEMORY_NAME, __mem_big_slice_free)(void *p) {
  FIO_NAME(FIO_MEMORY_NAME, __mem_big_block_free)(p);
}

#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */
/* *****************************************************************************
Memory Allocation - malloc(0) pointer
***************************************************************************** */

static long double FIO_NAME(
    FIO_MEMORY_NAME,
    malloc_zero)[((1UL << (FIO_MEMORY_ALIGN_LOG)) / sizeof(long double)) + 1];

#define FIO_MEMORY_MALLOC_ZERO_POINTER                                         \
  ((void *)(((uintptr_t)FIO_NAME(FIO_MEMORY_NAME, malloc_zero) +               \
             (FIO_MEMORY_ALIGN_SIZE - 1)) &                                    \
            ((~(uintptr_t)0) << FIO_MEMORY_ALIGN_LOG)))

/* *****************************************************************************
Memory Allocation - API implementation - debugging and info
***************************************************************************** */

/* SublimeText marker */
void fio_malloc_block_size___(void);
/* public API obligation */
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_block_size)(void) {
  return FIO_MEMORY_BLOCK_SIZE;
}

void fio_malloc_arenas___(void);
SFUNC size_t FIO_NAME(FIO_MEMORY_NAME, malloc_arenas)(void) {
  return FIO_NAME(FIO_MEMORY_NAME, __mem_state)
             ? FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count
             : 0;
}

SFUNC void FIO_NAME(FIO_MEMORY_NAME, malloc_print_settings)(void) {
  // FIO_LOG_DEBUG2(
  fprintf(
      stderr,
      "Custom memory allocator " FIO_MACRO2STR(FIO_NAME(
          FIO_MEMORY_NAME,
          malloc)) " initialized with:\n"
                   "\t* system allocation arenas:                 %zu arenas\n"
                   "\t* system allocation size:                   %zu bytes\n"
                   "\t* system allocation overhead (theoretical): %zu bytes\n"
                   "\t* system allocation overhead (actual):      %zu bytes\n"
                   "\t* cached system allocations (max):          %zu units\n"
                   "\t* memory block size:                        %zu bytes\n"
                   "\t* blocks per system allocation:             %zu blocks\n"
                   "\t* allocation units per block:               %zu units\n"
                   "\t* arena per-allocation limit:               %zu bytes\n"
                   "\t* local per-allocation limit (before mmap): %zu bytes\n"
                   "\t* malloc(0) pointer:                        %p\n"
                   "\t* always initializes memory  (zero-out):    %s\n"
                   "\t* " FIO_MEMORY_LOCK_NAME " locking system\n",
      (size_t)FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count,
      (size_t)FIO_MEMORY_SYS_ALLOCATION_SIZE,
      (size_t)FIO_MEMORY_HEADER_SIZE,
      (size_t)FIO_MEMORY_SYS_ALLOCATION_SIZE % (size_t)FIO_MEMORY_BLOCK_SIZE,
      (size_t)FIO_MEMORY_CACHE_SLOTS,
      (size_t)FIO_MEMORY_BLOCK_SIZE,
      (size_t)FIO_MEMORY_BLOCKS_PER_ALLOCATION,
      (size_t)FIO_MEMORY_UNITS_PER_BLOCK,
      (size_t)FIO_MEMORY_BLOCK_ALLOC_LIMIT,
      (size_t)FIO_MEMORY_ALLOC_LIMIT,
      FIO_MEMORY_MALLOC_ZERO_POINTER,
      (FIO_MEMORY_INITIALIZE_ALLOCATIONS ? "true" : "false"));
}

/* *****************************************************************************
Malloc implementation
***************************************************************************** */

/* SublimeText marker */
void fio___malloc__(void);
/**
 * Allocates memory using a per-CPU core block memory pool.
 * Memory is zeroed out.
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 *
 * `mempool_malloc` promises a best attempt at providing locality between
 * consecutive calls, but locality can't be guaranteed.
 */
FIO_IFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                           ___malloc)(size_t size,
                                                      void *is_realloc) {
  void *p = NULL;
  if (!size)
    goto malloc_zero;
  FIO_MEMORY_ON_ALLOC_FUNC();

#if FIO_MEMORY_ENABLE_BIG_ALLOC
  if ((is_realloc && size > (FIO_MEMORY_BIG_BLOCK_SIZE -
                             (FIO_MEMORY_BIG_BLOCK_HEADER_SIZE << 1))) ||
      (!is_realloc && size > FIO_MEMORY_ALLOC_LIMIT))
#else
  if (!is_realloc && size > FIO_MEMORY_ALLOC_LIMIT)
#endif
  {
#ifdef DEBUG
    FIO_LOG_WARNING(
        "unintended " FIO_MACRO2STR(
            FIO_NAME(FIO_MEMORY_NAME, mmap)) " allocation (slow): %zu bytes",
        FIO_MEM_BYTES2PAGES(size));
#endif
    FIO_MEMORY_ON_FREE_FUNC(); /* offset allocation counted by mmap */
    p = FIO_NAME(FIO_MEMORY_NAME, mmap)(size);
    return p;
  }
  if (!FIO_NAME(FIO_MEMORY_NAME, __mem_state)) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_state_setup)();
  }
#if FIO_MEMORY_ENABLE_BIG_ALLOC
  if ((is_realloc &&
       size > FIO_MEMORY_BLOCK_SIZE - (2 << FIO_MEMORY_ALIGN_LOG)) ||
      (!is_realloc && size > FIO_MEMORY_BLOCK_ALLOC_LIMIT)) {
    p = FIO_NAME(FIO_MEMORY_NAME, __mem_big_slice_new)(size, is_realloc);
    if (!p || p == is_realloc)
      FIO_MEMORY_ON_FREE_FUNC(); /* no allocation performed */
    return p;
  }
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

  p = FIO_NAME(FIO_MEMORY_NAME, __mem_slice_new)(size, is_realloc);
  if (!p || p == is_realloc)
    FIO_MEMORY_ON_FREE_FUNC(); /* no allocation performed */
  return p;
malloc_zero:
  p = FIO_MEMORY_MALLOC_ZERO_POINTER;
  return p;
}

/* *****************************************************************************
Memory Allocation - API implementation
***************************************************************************** */

/* SublimeText marker */
void fio_malloc__(void);
/**
 * Allocates memory using a per-CPU core block memory pool.
 * Memory is zeroed out.
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 *
 * `mempool_malloc` promises a best attempt at providing locality between
 * consecutive calls, but locality can't be guaranteed.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, malloc)(size_t size) {
  void *p = FIO_NAME(FIO_MEMORY_NAME, ___malloc)(size, NULL);
#if !FIO_MEMORY_INITIALIZE_ALLOCATIONS && defined(DEBUG) && DEBUG
  /* set all bytes to 0xAF to better catch initialization bugs */
  FIO___MEMSET(p, 0xFAFAFAFAFAFAFAFAULL, size);
#endif /* DEBUG dirtify */
  return p;
}

/* SublimeText marker */
void fio_calloc__(void);
/**
 * same as calling `fio_malloc(size_per_unit * unit_count)`;
 *
 * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT will be redirected to `mmap`,
 * as if `mempool_mmap` was called.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME,
                                       calloc)(size_t size_per_unit,
                                               size_t unit_count) {
#if FIO_MEMORY_INITIALIZE_ALLOCATIONS
  return FIO_NAME(FIO_MEMORY_NAME, malloc)(size_per_unit * unit_count);
#else
  void *p;
  /* round up to alignment size. */
  const size_t len =
      ((size_per_unit * unit_count) + (FIO_MEMORY_ALIGN_SIZE - 1)) &
      (~((size_t)FIO_MEMORY_ALIGN_SIZE - 1));
  p = FIO_NAME(FIO_MEMORY_NAME, malloc)(len);
  /* initialize memory only when required */
  FIO___MEMSET(p, 0, len);
  return p;
#endif /* FIO_MEMORY_INITIALIZE_ALLOCATIONS */
}

/* SublimeText marker */
void fio_free__(void);
/** Frees memory that was allocated using this library. */
SFUNC void FIO_NAME(FIO_MEMORY_NAME, free)(void *ptr) {
  if (!ptr || ptr == FIO_MEMORY_MALLOC_ZERO_POINTER)
    return;
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
      FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(ptr);
  if (!c) {
    FIO_LOG_ERROR(FIO_MACRO2STR(
        FIO_NAME(FIO_MEMORY_NAME,
                 free)) " attempting to free a pointer owned by a NULL chunk.");
    return;
  }
  FIO_MEMORY_ON_FREE_FUNC();

#if FIO_MEMORY_ENABLE_BIG_ALLOC
  if (c->marker == FIO_MEMORY_BIG_BLOCK_MARKER) {
    FIO_NAME(FIO_MEMORY_NAME, __mem_big_slice_free)(ptr);
    return;
  }
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */

  /* big mmap allocation? */
  if (((uintptr_t)c + FIO_MEMORY_ALIGN_SIZE) == (uintptr_t)ptr && c->marker)
    goto mmap_free;

  FIO_NAME(FIO_MEMORY_NAME, __mem_slice_free)(ptr);
  return;

mmap_free:
  /* zero out memory before returning it to the system */
  FIO___MEMSET(ptr,
               0,
               ((size_t)c->marker << FIO_MEM_PAGE_SIZE_LOG) -
                   FIO_MEMORY_ALIGN_SIZE);
  FIO_MEM_SYS_FREE(c, (size_t)c->marker << FIO_MEM_PAGE_SIZE_LOG);
  FIO_MEMORY_ON_CHUNK_FREE(c);
}

/* SublimeText marker */
void fio_realloc__(void);
/**
 * Re-allocates memory. An attempt to avoid copying the data is made only for
 * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).
 */
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc)(void *ptr,
                                                             size_t new_size) {
  return FIO_NAME(FIO_MEMORY_NAME, realloc2)(ptr, new_size, new_size);
}

/**
 * Uses system page maps for reallocation.
 */
FIO_SFUNC void *FIO_NAME(FIO_MEMORY_NAME, __mem_realloc2_big)(
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) * c,
    size_t new_size) {
  const size_t new_len = FIO_MEM_BYTES2PAGES(new_size + FIO_MEMORY_ALIGN_SIZE);
  c = (FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)FIO_MEM_SYS_REALLOC(
      c,
      (size_t)c->marker << FIO_MEM_PAGE_SIZE_LOG,
      new_len,
      FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);
  if (!c)
    return NULL;
  c->marker = (uint32_t)(new_len >> FIO_MEM_PAGE_SIZE_LOG);
  return (void *)((uintptr_t)c + FIO_MEMORY_ALIGN_SIZE);
}

/* SublimeText marker */
void fio_realloc2__(void);
/**
 * Re-allocates memory. An attempt to avoid copying the data is made only for
 * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).
 *
 * This variation is slightly faster as it might copy less data.
 */
SFUNC void *FIO_MEM_ALIGN FIO_NAME(FIO_MEMORY_NAME, realloc2)(void *ptr,
                                                              size_t new_size,
                                                              size_t copy_len) {
  void *mem = NULL;
  if (!new_size)
    goto act_as_free;
  if (!ptr || ptr == FIO_MEMORY_MALLOC_ZERO_POINTER)
    goto act_as_malloc;

  { /* test for big-paged malloc and limit copy_len */
    FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
        FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2chunk)(ptr);
    size_t b = FIO_NAME(FIO_MEMORY_NAME, __mem_ptr2index)(c, ptr);
    FIO_ASSERT(c, "cannot reallocate a pointer with a NULL system allocation");

    register size_t max_len =
        ((uintptr_t)FIO_NAME(FIO_MEMORY_NAME, __mem_chunk2ptr)(c, b, 0) +
         FIO_MEMORY_BLOCK_SIZE) -
        ((uintptr_t)ptr);
#if FIO_MEMORY_ENABLE_BIG_ALLOC
    if (c->marker == FIO_MEMORY_BIG_BLOCK_MARKER) {
      /* extend max_len to accomodate possible length */
      max_len =
          ((uintptr_t)c + FIO_MEMORY_SYS_ALLOCATION_SIZE) - ((uintptr_t)ptr);
    } else
#endif /* FIO_MEMORY_ENABLE_BIG_ALLOC */
      if ((uintptr_t)(c) + FIO_MEMORY_ALIGN_SIZE == (uintptr_t)ptr &&
          c->marker) {
        if (new_size > FIO_MEMORY_ALLOC_LIMIT)
          return (
              mem = FIO_NAME(FIO_MEMORY_NAME, __mem_realloc2_big)(c, new_size));
        max_len = new_size; /* shrinking from mmap to allocator */
      }

    if (copy_len > max_len)
      copy_len = max_len;
    if (copy_len > new_size)
      copy_len = new_size;
  }

  mem = FIO_NAME(FIO_MEMORY_NAME, ___malloc)(new_size, ptr);
  if (!mem || mem == ptr) {
    return mem;
  }

  /* when allocated from the same block, the max length might be adjusted */
  if ((uintptr_t)mem > (uintptr_t)ptr &&
      (uintptr_t)ptr + copy_len >= (uintptr_t)mem) {
    copy_len = (uintptr_t)mem - (uintptr_t)ptr;
  }

  FIO___MEMCPY2(mem,
                ptr,
                ((copy_len + (FIO_MEMORY_ALIGN_SIZE - 1)) &
                 ((~(size_t)0) << FIO_MEMORY_ALIGN_LOG)));
  // zero out leftover bytes, if any.
  while (copy_len & (FIO_MEMORY_ALIGN_SIZE - 1)) {
    ((uint8_t *)mem)[copy_len++] = 0;
  }

  FIO_NAME(FIO_MEMORY_NAME, free)(ptr);

  return mem;

act_as_malloc:
  mem = FIO_NAME(FIO_MEMORY_NAME, ___malloc)(new_size, NULL);
  return mem;

act_as_free:
  FIO_NAME(FIO_MEMORY_NAME, free)(ptr);
  mem = FIO_MEMORY_MALLOC_ZERO_POINTER;
  return mem;
}

/* SublimeText marker */
void fio_mmap__(void);
/**
 * Allocates memory directly using `mmap`, this is preferred for objects that
 * both require almost a page of memory (or more) and expect a long lifetime.
 *
 * However, since this allocation will invoke the system call (`mmap`), it will
 * be inherently slower.
 *
 * `mempoll_free` can be used for deallocating the memory.
 */
SFUNC void *FIO_MEM_ALIGN_NEW FIO_NAME(FIO_MEMORY_NAME, mmap)(size_t size) {
  if (!size)
    return FIO_NAME(FIO_MEMORY_NAME, malloc)(0);
  size_t pages = FIO_MEM_BYTES2PAGES(size + FIO_MEMORY_ALIGN_SIZE);
  if (((uint64_t)pages >> (31 + FIO_MEM_PAGE_SIZE_LOG)))
    return NULL;
  FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *c =
      (FIO_NAME(FIO_MEMORY_NAME, __mem_chunk_s) *)
          FIO_MEM_SYS_ALLOC(pages, FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG);
  if (!c)
    goto no_mem;
  FIO_MEMORY_ON_ALLOC_FUNC();
  FIO_MEMORY_ON_CHUNK_ALLOC(c);
  c->marker = (uint32_t)(pages >> FIO_MEM_PAGE_SIZE_LOG);
  return (void *)((uintptr_t)c + FIO_MEMORY_ALIGN_SIZE);
no_mem:
  errno = ENOMEM;
  return NULL;
}

/* *****************************************************************************
Override the system's malloc functions if required
***************************************************************************** */
#if defined(FIO_MALLOC_OVERRIDE_SYSTEM) && !defined(H___FIO_MALLOC_OVERRIDE___H)
#define H___FIO_MALLOC_OVERRIDE___H
void *malloc(size_t size) { return FIO_NAME(FIO_MEMORY_NAME, malloc)(size); }
void *calloc(size_t size, size_t count) {
  return FIO_NAME(FIO_MEMORY_NAME, calloc)(size, count);
}
void free(void *ptr) { FIO_NAME(FIO_MEMORY_NAME, free)(ptr); }
void *realloc(void *ptr, size_t new_size) {
  return FIO_NAME(FIO_MEMORY_NAME, realloc2)(ptr, new_size, new_size);
}
#endif /* FIO_MALLOC_OVERRIDE_SYSTEM */
#undef FIO_MALLOC_OVERRIDE_SYSTEM

/* *****************************************************************************





Memory Allocation - test





***************************************************************************** */
#ifdef FIO_TEST_CSTL

#ifndef H___FIO_TEST_MEMORY_HELPERS_H
#define H___FIO_TEST_MEMORY_HELPERS_H

FIO_IFUNC void fio___memset_test_aligned(void *restrict dest_,
                                         uint64_t data,
                                         size_t bytes,
                                         const char *msg) {
  uint8_t *r = (uint8_t *)dest_;
  uint8_t *e_group = r + (bytes & (~(size_t)63ULL));
  uint64_t d[8] = {data, data, data, data, data, data, data, data};
  while (r < e_group) {
    fio_memcpy64(d, r);
    FIO_ASSERT(d[0] == data && d[1] == data && d[2] == data && d[3] == data &&
                   d[4] == data && d[5] == data && d[6] == data && d[7] == data,
               "%s memory data was overwritten",
               msg);
    r += 64;
  }
  fio_memcpy63x(d, r, bytes);
  FIO_ASSERT(d[0] == data && d[1] == data && d[2] == data && d[3] == data &&
                 d[4] == data && d[5] == data && d[6] == data && d[7] == data,
             "%s memory data was overwritten",
             msg);
  (void)msg; /* in case FIO_ASSERT is disabled */
}

/* main test function */
FIO_SFUNC void FIO_NAME_TEST(stl, mem_helper_speeds)(void) {
  uint64_t start, end;

  { /* test fio_memcpy possible overflow. */
    uint64_t buf1[64];
    uint8_t *buf = (uint8_t *)buf1;
    fio_memset(buf1, ~(uint64_t)0, sizeof(*buf1) * 64);
    char *data =
        (char *)"This should be an uneven amount of characters, say 53";
    fio_memcpy(buf, data, strlen(data));
    FIO_ASSERT(!memcmp(buf, data, strlen(data)) && buf[strlen(data)] == 0xFF,
               "fio_memcpy should not overflow or underflow on uneven "
               "amounts of bytes.");
  }
  { /* test fio_memcpy as memmove */
    fprintf(stderr, "* testing fio_memcpy with overlapping memory (memmove)\n");
    char *msg = (char *)"fio_memcpy should work also as memmove, "
                        "so no undefined behavior should occur. "
                        "Should be true for larger offsets too. At least over "
                        "128 Bytes.";
    size_t len = strlen(msg);
    char buf[512];
    for (size_t offset = 0; offset < len; ++offset) {
      memset(buf, 0, sizeof(buf));
      memcpy(buf, msg, len);
      fio_memcpy(buf + offset, buf, len);
      FIO_ASSERT(!memcmp(buf + offset, msg, len),
                 "fio_memcpy failed on overlapping data (offset +%d, len %zu)",
                 offset,
                 len);
      memset(buf, 0, sizeof(buf));
      memcpy(buf + offset, msg, len);
      fio_memcpy(buf, buf + offset, len);
      if (memcmp(buf, msg, len)) {
        FIO_LOG_DEBUG2("break point");
      }
      FIO_ASSERT(!memcmp(buf, msg, len),
                 "fio_memcpy failed on overlapping data (offset -%d, len %zu)",
                 offset,
                 len);
    }
  }
  { /* test fio_memcmp */
    for (size_t i = 0; i < 4096; ++i) {
      uint64_t a = fio_rand64(), b = fio_rand64();
      int s = memcmp(&a, &b, sizeof(a));
      int f = fio_memcmp(&a, &b, sizeof(a));
      FIO_ASSERT((s < 0 && f < 0) || (s > 0 && f > 0) || (!s && !f),
                 "fio_memcmp != memcmp (result meaning, not value).");
    }
  }
#ifndef DEBUG
  const size_t base_repetitions = 8192;
  fprintf(stderr, "* Speed testing core memcpy primitives:\n");
  {
    struct {
      void *(*fn)(void *, const void *);
      size_t bytes;
    } tests[] = {
        {fio_memcpy8, 8},
        {fio_memcpy16, 16},
        {fio_memcpy32, 32},
        {fio_memcpy64, 64},
        {fio_memcpy128, 128},
        {fio_memcpy256, 256},
        {fio_memcpy512, 512},
        {fio_memcpy1024, 1024},
        {fio_memcpy2048, 2048},
        {fio_memcpy4096, 4096},
        {NULL},
    };
    char buf[4096 * 2];
    memset(buf, 0x80, 4096 * 2);
    for (size_t i = 0; tests[i].bytes; ++i) {
      start = fio_time_micro();
      for (size_t r = 0; r < (base_repetitions << 4); ++r) {
        tests[i].fn(buf, buf + 4096);
        FIO_COMPILER_GUARD;
      }
      end = fio_time_micro();
      fprintf(stderr,
              "\tfio_memcpy%zu\tmemcpy(a,b,%zu)   \t%zuus\t",
              tests[i].bytes,
              tests[i].bytes,
              (size_t)(end - start));
      start = fio_time_micro();
      for (size_t r = 0; r < (base_repetitions << 4); ++r) {
        memcpy(buf, buf + 4096, tests[i].bytes);
        FIO_COMPILER_GUARD;
      }
      end = fio_time_micro();
      fprintf(stderr, "%zuus\n", (size_t)(end - start));
    }
  }

  fprintf(stderr, "* Speed testing memset:\n");

  for (size_t len_i = 5; len_i < 20; ++len_i) {
    const size_t repetitions = base_repetitions
                               << (len_i < 15 ? (15 - (len_i & 15)) : 0);
    const size_t mem_len = (1ULL << len_i);
    void *mem = malloc(mem_len + 32);
    FIO_ASSERT_ALLOC(mem);
    uint64_t sig = (uintptr_t)mem;
    sig ^= sig >> 13;
    sig ^= sig << 17;
    sig ^= sig << 29;
    sig ^= sig << 31;
    for (size_t rlen = mem_len - 1; rlen < mem_len + 2; ++rlen) {
      start = fio_time_micro();
      for (size_t i = 0; i < repetitions; ++i) {
        fio_memset(mem, sig, rlen);
        FIO_COMPILER_GUARD;
      }
      end = fio_time_micro();
      fio___memset_test_aligned(mem,
                                sig,
                                rlen,
                                "fio_memset sanity test FAILED");
      fprintf(stderr,
              "\tfio_memset\t(%zu bytes):\t%zuus\t/ %zu\n",
              rlen,
              (size_t)(end - start),
              repetitions);
      start = fio_time_micro();
      for (size_t i = 0; i < repetitions; ++i) {
        memset(mem, (int)sig, rlen);
        FIO_COMPILER_GUARD;
      }
      end = fio_time_micro();
      fprintf(stderr,
              "\tsystem memset\t(%zu bytes):\t%zuus\t/ %zu\n",
              rlen,
              (size_t)(end - start),
              repetitions);
    }
    free(mem);
  }

  fprintf(stderr, "* Speed testing memcpy:\n");

  for (int len_i = 5; len_i < 21; ++len_i) {
    const size_t repetitions = base_repetitions
                               << (len_i < 15 ? (15 - (len_i & 15)) : 0);
    for (size_t mem_len = (1ULL << len_i) - 1; mem_len <= (1ULL << len_i) + 1;
         ++mem_len) {
      void *mem = malloc(mem_len << 1);
      FIO_ASSERT_ALLOC(mem);
      uint64_t sig = (uintptr_t)mem;
      sig ^= sig >> 13;
      sig ^= sig << 17;
      sig ^= sig << 29;
      sig ^= sig << 31;
      fio_memset(mem, sig, mem_len);

      start = fio_time_micro();
      for (size_t i = 0; i < repetitions; ++i) {
        fio_memcpy((char *)mem + mem_len, mem, mem_len);
        FIO_COMPILER_GUARD;
      }
      end = fio_time_micro();
      fio___memset_test_aligned((char *)mem + mem_len,
                                sig,
                                mem_len,
                                "fio_memcpy sanity test FAILED");
      fprintf(stderr,
              "\tfio_memcpy\t(%zu bytes):\t%zuus\t/ %zu\n",
              mem_len,
              (size_t)(end - start),
              repetitions);

      // size_t threads_used = 0;
      // start = fio_time_micro();
      // for (size_t i = 0; i < repetitions; ++i) {
      //   threads_used = fio_thread_memcpy((char *)mem + mem_len, mem,
      //   mem_len); if (threads_used == 1)
      //     break;
      //   FIO_COMPILER_GUARD;
      // }
      // end = fio_time_micro();
      // fio___memset_test_aligned((char *)mem + mem_len,
      //                           sig,
      //                           mem_len,
      //                           "fio_thread_memcpy sanity test FAILED");
      // fprintf(stderr,
      //         "   fio_thread_memcpy (%zut)\t(%zu bytes):\t%zu"
      //         "us\t/ %zu\n", threads_used, mem_len, (size_t)(end
      //         - start), repetitions);

      start = fio_time_micro();
      for (size_t i = 0; i < repetitions; ++i) {
        memcpy((char *)mem + mem_len, mem, mem_len);
        FIO_COMPILER_GUARD;
      }
      end = fio_time_micro();
      fprintf(stderr,
              "\tsystem memcpy\t(%zu bytes):\t%zuus\t/ %zu\n",
              mem_len,
              (size_t)(end - start),
              repetitions);
      free(mem);
    }
  }

  fprintf(stderr, "* Speed testing memchr:\n");

  for (int len_i = 2; len_i < 20; ++len_i) {
    const size_t repetitions = base_repetitions
                               << (len_i < 15 ? (15 - (len_i & 15)) : 0);
    const size_t mem_len = (1ULL << len_i) - 1;
    const size_t token_index = ((mem_len >> 1) + (mem_len >> 2)) + 1;
    void *mem = malloc(mem_len + 1);
    FIO_ASSERT_ALLOC(mem);
    fio_memset(mem, ((uint64_t)0x0101010101010101ULL * 0x80), mem_len + 1);
    ((uint8_t *)mem)[token_index >> 1] = 0xFFU;       /* edge case? */
    ((uint8_t *)mem)[(token_index >> 1) + 1] = 0x01U; /* edge case? */
    ((uint8_t *)mem)[(token_index >> 1) + 2] = 0x7FU; /* edge case? */
    ((char *)mem)[token_index] = 0;
    ((char *)mem)[token_index + 1] = 0;
    FIO_ASSERT(memchr((char *)mem + 1, 0, mem_len) ==
                   fio_memchr((char *)mem + 1, 0, mem_len),
               "fio_memchr != memchr");

    start = fio_time_micro();
    for (size_t i = 0; i < repetitions; ++i) {
      FIO_ASSERT((char *)fio_memchr((char *)mem + 1, 0, mem_len) ==
                     ((char *)mem + token_index),
                 "fio_memchr failed?");
      FIO_COMPILER_GUARD;
    }
    end = fio_time_micro();

    fprintf(stderr,
            "\tfio_memchr\t(%zu bytes):\t%zuus\t/ %zu (len: %zu)\n",
            token_index,
            (size_t)(end - start),
            repetitions,
            mem_len);

    start = fio_time_micro();
    for (size_t i = 0; i < repetitions; ++i) {
      FIO_ASSERT((char *)memchr((char *)mem + 1, 0, mem_len) ==
                     ((char *)mem + token_index),
                 "memchr failed?");
      FIO_COMPILER_GUARD;
    }
    end = fio_time_micro();
    fprintf(stderr,
            "\tsystem memchr\t(%zu bytes):\t%zuus\t/ %zu\n",
            token_index,
            (size_t)(end - start),
            repetitions);

    free(mem);
  }

  fprintf(stderr, "* Speed testing memcmp:\n");

  for (int len_i = 5; len_i < 21; ++len_i) {
    const size_t repetitions = base_repetitions
                               << (len_i < 15 ? (15 - (len_i & 15)) : 0);
    for (size_t mem_len = (1ULL << len_i) - 1; mem_len <= (1ULL << len_i) + 1;
         ++mem_len) {
      char *mem = (char *)malloc(mem_len << 1);
      FIO_ASSERT_ALLOC(mem);
      uint64_t sig = (uintptr_t)mem;
      sig ^= sig >> 13;
      sig ^= sig << 17;
      sig ^= sig << 29;
      sig ^= sig << 31;
      fio_memset(mem, sig, mem_len);
      fio_memset(mem + mem_len, sig, mem_len);

      FIO_ASSERT(!fio_memcmp(mem + mem_len, mem, mem_len),
                 "fio_memcmp sanity test FAILED (%zu)",
                 mem_len);
      mem[mem_len - 2]--;
      FIO_ASSERT(fio_memcmp(mem + mem_len, mem, mem_len),
                 "fio_memcmp sanity test FAILED (%zu)",
                 mem_len);
      mem[mem_len - 2]++;

      start = fio_time_micro();
      for (size_t i = 0; i < repetitions; ++i) {
        int cmp = fio_memcmp(mem + mem_len, mem, mem_len);
        FIO_COMPILER_GUARD;
        if (cmp)
          ++(mem[mem_len - (1 + cmp)]);
        (void)cmp;
      }
      end = fio_time_micro();
      fprintf(stderr,
              "\tfio_memcmp\t(%zu bytes):\t%zuus\t/ %zu\n",
              mem_len,
              (size_t)(end - start),
              repetitions);

      start = fio_time_micro();
      for (size_t i = 0; i < repetitions; ++i) {
        int cmp = memcmp(mem + mem_len, mem, mem_len);
        FIO_COMPILER_GUARD;
        if (cmp)
          ++(mem[mem_len - (1 + cmp)]);
        (void)cmp;
      }
      end = fio_time_micro();
      fprintf(stderr,
              "\tsystem memcmp\t(%zu bytes):\t%zuus\t/ %zu\n",
              mem_len,
              (size_t)(end - start),
              repetitions);
      free(mem);
    }
  }
#endif /* DEBUG */
  ((void)start), ((void)end);
}
#endif /* H___FIO_TEST_MEMORY_HELPERS_H */

#ifndef FIO_TEST_MULTI_THREADED
#define FIO_TEST_MULTI_THREADED 0
#endif

/* contention testing (multi-threaded) */
FIO_IFUNC void *FIO_NAME_TEST(FIO_NAME(FIO_MEMORY_NAME, fio),
                              mem_tsk)(void *i_) {
  uintptr_t cycles = (uintptr_t)i_;
  const size_t test_byte_count =
      FIO_MEMORY_SYS_ALLOCATION_SIZE + (FIO_MEMORY_SYS_ALLOCATION_SIZE >> 1);
  uint64_t marker[2];
  do {
    marker[0] = fio_rand64();
    marker[1] = fio_rand64();
  } while (!marker[0] || !marker[1] || marker[0] == marker[1]);

  const size_t limit = (test_byte_count / cycles);
  char **ary = (char **)FIO_NAME(FIO_MEMORY_NAME, calloc)(sizeof(*ary), limit);
  const uintptr_t alignment_mask = (FIO_MEMORY_ALIGN_SIZE - 1);
  FIO_ASSERT(ary, "allocation failed for test container");
  for (size_t i = 0; i < limit; ++i) {
    if (1) {
      /* add some fragmentation */
      char *tmp = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(16);
      FIO_NAME(FIO_MEMORY_NAME, free)(tmp);
      FIO_ASSERT(tmp, "small allocation failed!");
      FIO_ASSERT(!((uintptr_t)tmp & alignment_mask),
                 "allocation alignment error!");
    }
    ary[i] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
    FIO_ASSERT(ary[i], "allocation failed!");
    FIO_ASSERT(!((uintptr_t)ary[i] & alignment_mask),
               "allocation alignment error!");
    FIO_ASSERT(!FIO_MEMORY_INITIALIZE_ALLOCATIONS || !ary[i][(cycles - 1)],
               "allocated memory not zero (end): %p",
               (void *)ary[i]);
    FIO_ASSERT(!FIO_MEMORY_INITIALIZE_ALLOCATIONS || !ary[i][0],
               "allocated memory not zero (start): %p",
               (void *)ary[i]);
    fio_memset(ary[i], marker[i & 1], (cycles));
  }
  for (size_t i = 0; i < limit; ++i) {
    char *tmp = (char *)FIO_NAME(FIO_MEMORY_NAME,
                                 realloc2)(ary[i], (cycles << 1), (cycles));
    FIO_ASSERT(tmp, "re-allocation failed!");
    ary[i] = tmp;
    FIO_ASSERT(!((uintptr_t)ary[i] & alignment_mask),
               "allocation alignment error!");
    FIO_ASSERT(!FIO_MEMORY_INITIALIZE_ALLOCATIONS || !ary[i][(cycles)],
               "realloc2 copy overflow!");
    fio___memset_test_aligned(ary[i], marker[i & 1], (cycles), "realloc grow");
    tmp =
        (char *)FIO_NAME(FIO_MEMORY_NAME, realloc2)(ary[i], (cycles), (cycles));
    FIO_ASSERT(tmp, "re-allocation (shrinking) failed!");
    ary[i] = tmp;
    fio___memset_test_aligned(ary[i],
                              marker[i & 1],
                              (cycles),
                              "realloc shrink");
  }
  for (size_t i = 0; i < limit; ++i) {
    fio___memset_test_aligned(ary[i], marker[i & 1], (cycles), "mem review");
    FIO_NAME(FIO_MEMORY_NAME, free)(ary[i]);
    ary[i] = NULL;
  }

  uint64_t mark;
  void *old = &mark;
  mark = fio_risky_hash(&old, sizeof(mark), 0);

  for (int repeat_cycle_test = 0; repeat_cycle_test < 4; ++repeat_cycle_test) {
    for (size_t i = 0; i < limit - 4; i += 4) {
      if (ary[i])
        fio___memset_test_aligned(ary[i], mark, 16, "mark missing at ary[0]");
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i]);
      if (ary[i + 1])
        fio___memset_test_aligned(ary[i + 1],
                                  mark,
                                  cycles,
                                  "mark missing at ary[1]");
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 1]);
      if (ary[i + 2])
        fio___memset_test_aligned(ary[i + 2],
                                  mark,
                                  cycles,
                                  "mark missing at ary[2]");
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 2]);
      if (ary[i + 3])
        fio___memset_test_aligned(ary[i + 3],
                                  mark,
                                  cycles,
                                  "mark missing at ary[3]");
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 3]);

      ary[i] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      fio_memset(ary[i], mark, cycles);

      ary[i + 1] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 1]);
      ary[i + 1] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      fio_memset(ary[i + 1], mark, cycles);

      ary[i + 2] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      fio_memset(ary[i + 2], mark, cycles);
      ary[i + 2] = (char *)FIO_NAME(FIO_MEMORY_NAME,
                                    realloc2)(ary[i + 2], cycles * 2, cycles);

      ary[i + 3] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + 3]);
      ary[i + 3] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
      fio_memset(ary[i + 3], mark, cycles);
      ary[i + 3] = (char *)FIO_NAME(FIO_MEMORY_NAME,
                                    realloc2)(ary[i + 3], cycles * 2, cycles);

      for (int b = 0; b < 4; ++b) {
        for (size_t pos = 0; pos < (cycles / sizeof(uint64_t)); ++pos) {
          FIO_ASSERT(((uint64_t *)(ary[i + b]))[pos] == mark,
                     "memory mark corrupted at test ptr %zu",
                     i + b);
        }
      }
      for (int b = 1; b < 4; ++b) {
        FIO_NAME(FIO_MEMORY_NAME, free)(ary[b]);
        ary[b] = NULL;
        FIO_NAME(FIO_MEMORY_NAME, free)(ary[i + b]);
      }
      for (int b = 1; b < 4; ++b) {
        ary[i + b] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
        if (i) {
          ary[b] = (char *)FIO_NAME(FIO_MEMORY_NAME, malloc)(cycles);
          fio_memset(ary[b], mark, cycles);
        }
        fio_memset(ary[i + b], mark, cycles);
      }

      for (int b = 0; b < 4; ++b) {
        for (size_t pos = 0; pos < (cycles / sizeof(uint64_t)); ++pos) {
          FIO_ASSERT(((uint64_t *)(ary[b]))[pos] == mark,
                     "memory mark corrupted at test ptr %zu",
                     i + b);
          FIO_ASSERT(((uint64_t *)(ary[i + b]))[pos] == mark,
                     "memory mark corrupted at test ptr %zu",
                     i + b);
        }
      }
    }
  }
  for (size_t i = 0; i < limit; ++i) {
    FIO_NAME(FIO_MEMORY_NAME, free)(ary[i]);
    ary[i] = NULL;
  }

  FIO_NAME(FIO_MEMORY_NAME, free)(ary);
  return NULL;
}

/* main test function */
FIO_SFUNC void FIO_NAME_TEST(FIO_NAME(stl, FIO_MEMORY_NAME), mem)(void) {
  fprintf(stderr,
          "* Testing core memory allocator " FIO_MACRO2STR(
              FIO_NAME(FIO_MEMORY_NAME, malloc)) ".\n");

  const uintptr_t alignment_mask = (FIO_MEMORY_ALIGN_SIZE - 1);
  fprintf(stderr,
          "* Validating allocation alignment on %zu byte border.\n",
          (size_t)(FIO_MEMORY_ALIGN_SIZE));
  for (size_t i = 0; i < alignment_mask; ++i) {
    void *p = FIO_NAME(FIO_MEMORY_NAME, malloc)(i);
    FIO_ASSERT(!((uintptr_t)p & alignment_mask),
               "allocation alignment error allocating %zu bytes!",
               i);
    FIO_NAME(FIO_MEMORY_NAME, free)(p);
  }
  const size_t thread_count =
      FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count +
      (FIO_NAME(FIO_MEMORY_NAME, __mem_state)->arena_count >> 1);

  for (uintptr_t cycles = 16; cycles <= (FIO_MEMORY_ALLOC_LIMIT); cycles *= 2) {
    fprintf(stderr,
            "* Testing %zu byte allocation blocks, single threaded.\n",
            (size_t)(cycles));
    FIO_NAME_TEST(FIO_NAME(FIO_MEMORY_NAME, fio), mem_tsk)((void *)cycles);
  }

  if (FIO_TEST_MULTI_THREADED) {

    for (uintptr_t cycles = 16; cycles <= (FIO_MEMORY_ALLOC_LIMIT);
         cycles *= 2) {
#if _MSC_VER
      fio_thread_t threads[(FIO_MEMORY_ARENA_COUNT_MAX + 1) * 2];
      FIO_ASSERT(((FIO_MEMORY_ARENA_COUNT_MAX + 1) * 2) >= thread_count,
                 "Please use CLang or GCC to test this memory allocator");
#else
      fio_thread_t threads[thread_count];
#endif

      fprintf(stderr,
              "* Testing %zu byte allocation blocks, using %zu threads.\n",
              (size_t)(cycles),
              (thread_count + 1));
      for (size_t i = 0; i < thread_count; ++i) {
        if (fio_thread_create(
                threads + i,
                FIO_NAME_TEST(FIO_NAME(FIO_MEMORY_NAME, fio), mem_tsk),
                (void *)cycles)) {
          abort();
        }
      }
      FIO_NAME_TEST(FIO_NAME(FIO_MEMORY_NAME, fio), mem_tsk)((void *)cycles);
      for (size_t i = 0; i < thread_count; ++i) {
        fio_thread_join(threads + i);
      }
    }
  }
  fprintf(stderr,
          "* Re-validating allocation alignment on %zu byte border.\n",
          (size_t)(FIO_MEMORY_ALIGN_SIZE));
  for (size_t i = 0; i < alignment_mask; ++i) {
    void *p = FIO_NAME(FIO_MEMORY_NAME, malloc)(i);
    FIO_ASSERT(!((uintptr_t)p & alignment_mask),
               "allocation alignment error allocating %zu bytes!",
               i);
    FIO_NAME(FIO_MEMORY_NAME, free)(p);
  }

#if DEBUG
  FIO_NAME(FIO_MEMORY_NAME, malloc_print_state)();
  FIO_NAME(FIO_MEMORY_NAME, __mem_state_cleanup)(NULL);
  FIO_ASSERT(
      !FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[0] &&
          FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[2] ==
              FIO_NAME(fio___, FIO_NAME(FIO_MEMORY_NAME, state_dbg_counter))[3],
      "memory leaks?");
#endif /* DEBUG */
}
#endif /* FIO_TEST_CSTL */

/* *****************************************************************************
Memory pool cleanup
***************************************************************************** */
#undef FIO___MEMSET
#undef FIO___MEMCPY2
#undef FIO_MEM_ALIGN
#undef FIO_MEM_ALIGN_NEW
#undef FIO_MEMORY_MALLOC_ZERO_POINTER

#endif /* FIO_MEMORY_DISABLE */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_MEMORY_NAME */

#undef FIO_MEMORY_ON_CHUNK_ALLOC
#undef FIO_MEMORY_ON_CHUNK_FREE
#undef FIO_MEMORY_ON_CHUNK_CACHE
#undef FIO_MEMORY_ON_CHUNK_UNCACHE
#undef FIO_MEMORY_ON_CHUNK_DIRTY
#undef FIO_MEMORY_ON_CHUNK_UNDIRTY
#undef FIO_MEMORY_ON_BLOCK_RESET_IN_LOCK
#undef FIO_MEMORY_ON_BIG_BLOCK_SET
#undef FIO_MEMORY_ON_BIG_BLOCK_UNSET
#undef FIO_MEMORY_ON_ALLOC_FUNC
#undef FIO_MEMORY_ON_FREE_FUNC
#undef FIO_MEMORY_PRINT_STATS
#undef FIO_MEMORY_PRINT_STATS_END

#undef FIO_MEMORY_ARENA_COUNT
#undef FIO_MEMORY_SYS_ALLOCATION_SIZE_LOG
#undef FIO_MEMORY_CACHE_SLOTS
#undef FIO_MEMORY_ALIGN_LOG
#undef FIO_MEMORY_INITIALIZE_ALLOCATIONS
#undef FIO_MEMORY_USE_THREAD_MUTEX
#undef FIO_MEMORY_USE_FIO_MEMSET
#undef FIO_MEMORY_USE_FIO_MEMCOPY
#undef FIO_MEMORY_BLOCK_SIZE
#undef FIO_MEMORY_BLOCKS_PER_ALLOCATION_LOG
#undef FIO_MEMORY_BLOCKS_PER_ALLOCATION
#undef FIO_MEMORY_ENABLE_BIG_ALLOC
#undef FIO_MEMORY_ARENA_COUNT_FALLBACK
#undef FIO_MEMORY_ARENA_COUNT_MAX
#undef FIO_MEMORY_WARMUP

#undef FIO_MEMORY_LOCK_NAME
#undef FIO_MEMORY_LOCK_TYPE
#undef FIO_MEMORY_LOCK_TYPE_INIT
#undef FIO_MEMORY_TRYLOCK
#undef FIO_MEMORY_LOCK
#undef FIO_MEMORY_UNLOCK

/* don't undefine FIO_MEMORY_NAME due to possible use in allocation macros */

/* *****************************************************************************
Memory management macros
*****************************************************************************
*/

#if !defined(FIO_MEM_REALLOC_) || !defined(FIO_MEM_FREE_)
#undef FIO_MEM_REALLOC_
#undef FIO_MEM_FREE_
#undef FIO_MEM_REALLOC_IS_SAFE_

#ifdef FIO_MALLOC_TMP_USE_SYSTEM /* force malloc */
#define FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)                    \
  realloc((ptr), (new_size))
#define FIO_MEM_FREE_(ptr, size) free((ptr))
#define FIO_MEM_REALLOC_IS_SAFE_ 0

#else /* FIO_MALLOC_TMP_USE_SYSTEM */
#define FIO_MEM_REALLOC_         FIO_MEM_REALLOC
#define FIO_MEM_FREE_            FIO_MEM_FREE
#define FIO_MEM_REALLOC_IS_SAFE_ FIO_MEM_REALLOC_IS_SAFE
#endif /* FIO_MALLOC_TMP_USE_SYSTEM */

#endif /* !defined(FIO_MEM_REALLOC_)... */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_QUEUE      /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                                Task / Timer Queues
                                (Event Loop Engine)



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_QUEUE) && !defined(H___FIO_QUEUE___H)
#define H___FIO_QUEUE___H

/* *****************************************************************************
Queue Type(s)
***************************************************************************** */

/* Note: FIO_QUEUE_TASKS_PER_ALLOC can't be more than 65535 */
#ifndef FIO_QUEUE_TASKS_PER_ALLOC
#if UINTPTR_MAX <= 0xFFFFFFFF
/* fits fio_queue_s in one page on most 32 bit machines */
#define FIO_QUEUE_TASKS_PER_ALLOC 338
#else
/* fits fio_queue_s in one page on most 64 bit machines */
#define FIO_QUEUE_TASKS_PER_ALLOC 168
#endif
#endif

/** Task information */
typedef struct {
  /** The function to call */
  void (*fn)(void *, void *);
  /** User opaque data */
  void *udata1;
  /** User opaque data */
  void *udata2;
} fio_queue_task_s;

/* internal use */
typedef struct fio___task_ring_s {
  uint16_t r;   /* reader position */
  uint16_t w;   /* writer position */
  uint16_t dir; /* direction */
  struct fio___task_ring_s *next;
  fio_queue_task_s buf[FIO_QUEUE_TASKS_PER_ALLOC];
} fio___task_ring_s;

/** The queue object - should be considered opaque (or, at least, read only). */
typedef struct {
  /** task read pointer. */
  fio___task_ring_s *r;
  /** task write pointer. */
  fio___task_ring_s *w;
  /** the number of tasks waiting to be performed. */
  uint32_t count;
  /** global queue lock. */
  FIO___LOCK_TYPE lock;
  /** linked lists of consumer threads. */
  FIO_LIST_NODE consumers;
  /** main ring buffer associated with the queue. */
  fio___task_ring_s mem;
} fio_queue_s;

typedef struct {
  FIO_LIST_NODE node;
  fio_queue_s *queue;
  fio_thread_t thread;
  fio_thread_mutex_t mutex;
  fio_thread_cond_t cond;
  size_t workers;
  volatile int stop;
} fio___thread_group_s;

/* *****************************************************************************
Queue API
***************************************************************************** */

#if FIO_USE_THREAD_MUTEX_TMP
/** May be used to initialize global, static memory, queues. */
#define FIO_QUEUE_STATIC_INIT(queue)                                           \
  {                                                                            \
    .r = &(queue).mem, .w = &(queue).mem,                                      \
    .consumers = FIO_LIST_INIT((queue).consumers),                             \
    .lock = (fio_thread_mutex_t)FIO_THREAD_MUTEX_INIT                          \
  }
#else
/** May be used to initialize global, static memory, queues. */
#define FIO_QUEUE_STATIC_INIT(queue)                                           \
  {                                                                            \
    .r = &(queue).mem, .w = &(queue).mem,                                      \
    .consumers = FIO_LIST_INIT((queue).consumers), .lock = FIO_LOCK_INIT       \
  }
#endif

/** Initializes a fio_queue_s object. */
FIO_IFUNC void fio_queue_init(fio_queue_s *q);

/** Destroys a queue and re-initializes it, after freeing any used resources. */
SFUNC void fio_queue_destroy(fio_queue_s *q);

/** Creates a new queue object (allocated on the heap). */
FIO_IFUNC fio_queue_s *fio_queue_new(void);

/** Frees a queue object after calling fio_queue_destroy. */
SFUNC void fio_queue_free(fio_queue_s *q);

/** Pushes a task to the queue. Returns -1 on error. */
SFUNC int fio_queue_push(fio_queue_s *q, fio_queue_task_s task);

/**
 * Pushes a task to the queue, offering named arguments for the task.
 * Returns -1 on error.
 */
#define fio_queue_push(q, ...)                                                 \
  fio_queue_push((q), (fio_queue_task_s){__VA_ARGS__})

/** Pushes a task to the head of the queue. Returns -1 on error (no memory). */
SFUNC int fio_queue_push_urgent(fio_queue_s *q, fio_queue_task_s task);

/**
 * Pushes a task to the queue, offering named arguments for the task.
 * Returns -1 on error.
 */
#define fio_queue_push_urgent(q, ...)                                          \
  fio_queue_push_urgent((q), (fio_queue_task_s){__VA_ARGS__})

/** Pops a task from the queue (FIFO). Returns a NULL task on error. */
SFUNC fio_queue_task_s fio_queue_pop(fio_queue_s *q);

/** Performs a task from the queue. Returns -1 on error (queue empty). */
SFUNC int fio_queue_perform(fio_queue_s *q);

/** Performs all tasks in the queue. */
SFUNC void fio_queue_perform_all(fio_queue_s *q);

/** returns the number of tasks in the queue. */
FIO_IFUNC uint32_t fio_queue_count(fio_queue_s *q);

/** Adds worker / consumer threads to perform the jobs in the queue. */
SFUNC int fio_queue_workers_add(fio_queue_s *q, size_t count);

/** Signals all worker threads to stop performing tasks and terminate. */
SFUNC void fio_queue_workers_stop(fio_queue_s *q);

/** Signals all worker threads to go back to work (new tasks were). */
SFUNC void fio_queue_workers_wake(fio_queue_s *q);

/* *****************************************************************************
Timer Queue Types and API
***************************************************************************** */

typedef struct fio___timer_event_s fio___timer_event_s;

typedef struct {
  fio___timer_event_s *next;
  FIO___LOCK_TYPE lock;
} fio_timer_queue_s;

#if FIO_USE_THREAD_MUTEX_TMP
#define FIO_TIMER_QUEUE_INIT                                                   \
  { .lock = ((fio_thread_mutex_t)FIO_THREAD_MUTEX_INIT) }
#else
#define FIO_TIMER_QUEUE_INIT                                                   \
  { .lock = FIO_LOCK_INIT }
#endif

typedef struct {
  /** The timer function. If it returns a non-zero value, the timer stops. */
  int (*fn)(void *, void *);
  /** Opaque user data. */
  void *udata1;
  /** Opaque user data. */
  void *udata2;
  /** Called when the timer is done (finished). */
  void (*on_finish)(void *, void *);
  /** Timer interval, in milliseconds. */
  uint32_t every;
  /** The number of times the timer should be performed. -1 == infinity. */
  int32_t repetitions;
  /** Millisecond at which to start. If missing, filled automatically. */
  int64_t start_at;
} fio_timer_schedule_args_s;

/** Adds a time-bound event to the timer queue. */
SFUNC void fio_timer_schedule(fio_timer_queue_s *timer_queue,
                              fio_timer_schedule_args_s args);

/** A MACRO allowing named arguments to be used. See fio_timer_schedule_args_s.
 */
#define fio_timer_schedule(timer_queue, ...)                                   \
  fio_timer_schedule((timer_queue), (fio_timer_schedule_args_s){__VA_ARGS__})

/** Pushes due events from the timer queue to an event queue. */
SFUNC size_t fio_timer_push2queue(fio_queue_s *queue,
                                  fio_timer_queue_s *timer_queue,
                                  int64_t now_in_milliseconds);

/*
 * Returns the millisecond at which the next event should occur.
 *
 * If no timer is due (list is empty), returns `(uint64_t)-1`.
 *
 * NOTE: unless manually specified, millisecond timers are relative to
 * `fio_time_milli()`.
 */
FIO_IFUNC int64_t fio_timer_next_at(fio_timer_queue_s *timer_queue);

/**
 * Clears any waiting timer bound tasks.
 *
 * NOTE:
 *
 * The timer queue must NEVER be freed when there's a chance that timer tasks
 * are waiting to be performed in a `fio_queue_s`.
 *
 * This is due to the fact that the tasks may try to reschedule themselves (if
 * they repeat).
 */
SFUNC void fio_timer_destroy(fio_timer_queue_s *timer_queue);

/* *****************************************************************************
Queue Inline Helpers
***************************************************************************** */

/** Creates a new queue object (allocated on the heap). */
FIO_IFUNC fio_queue_s *fio_queue_new(void) {
  fio_queue_s *q = (fio_queue_s *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*q), 0);
  if (!q)
    return NULL;
  fio_queue_init(q);
  return q;
}

/** returns the number of tasks in the queue. */
FIO_IFUNC uint32_t fio_queue_count(fio_queue_s *q) { return q->count; }

/** Initializes a fio_queue_s object. */
FIO_IFUNC void fio_queue_init(fio_queue_s *q) {
  /* do this manually, we don't want to reset a whole page */
  q->r = &q->mem;
  q->w = &q->mem;
  q->count = 0;
  q->consumers = FIO_LIST_INIT(q->consumers);
  q->lock = FIO___LOCK_INIT;
  q->mem.next = NULL;
  q->mem.r = q->mem.w = q->mem.dir = 0;
}

/* *****************************************************************************
Timer Queue Inline Helpers
***************************************************************************** */

struct fio___timer_event_s {
  int (*fn)(void *, void *);
  void *udata1;
  void *udata2;
  void (*on_finish)(void *udata1, void *udata2);
  int64_t due;
  uint32_t every;
  int32_t repetitions;
  struct fio___timer_event_s *next;
};

/*
 * Returns the millisecond at which the next event should occur.
 *
 * If no timer is due (list is empty), returns `-1`.
 *
 * NOTE: unless manually specified, millisecond timers are relative to
 * `fio_time_milli()`.
 */
FIO_IFUNC int64_t fio_timer_next_at(fio_timer_queue_s *tq) {
  int64_t v = -1;
  if (!tq)
    goto missing_tq;
  if (!tq || !tq->next)
    return v;
  FIO___LOCK_LOCK(tq->lock);
  if (tq->next)
    v = tq->next->due;
  FIO___LOCK_UNLOCK(tq->lock);
  return v;

missing_tq:
  FIO_LOG_ERROR("`fio_timer_next_at` called with a NULL timer queue!");
  return v;
}

/* *****************************************************************************
Queue Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/** Destroys a queue and re-initializes it, after freeing any used resources. */
SFUNC void fio_queue_destroy(fio_queue_s *q) {
  for (;;) {
    FIO___LOCK_LOCK(q->lock);
    while (q->r) {
      fio___task_ring_s *tmp = q->r;
      q->r = q->r->next;
      if (tmp != &q->mem)
        FIO_MEM_FREE_(tmp, sizeof(*tmp));
    }
    if (FIO_LIST_IS_EMPTY(&q->consumers)) {
      FIO___LOCK_UNLOCK(q->lock);
      break;
    }
    FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
      pos->stop = 1;
      fio_thread_cond_signal(&pos->cond);
    }
    FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
      FIO___LOCK_UNLOCK(q->lock);
      fio_thread_join(&pos->thread);
      FIO___LOCK_LOCK(q->lock);
    }
    FIO___LOCK_UNLOCK(q->lock);
    if (FIO_LIST_IS_EMPTY(&q->consumers))
      break;
    FIO_THREAD_RESCHEDULE();
  }
  FIO___LOCK_DESTROY(q->lock);
  fio_queue_init(q);
}

/** Frees a queue object after calling fio_queue_destroy. */
SFUNC void fio_queue_free(fio_queue_s *q) {
  fio_queue_destroy(q);
  FIO_MEM_FREE_(q, sizeof(*q));
}

FIO_IFUNC int fio___task_ring_push(fio___task_ring_s *r,
                                   fio_queue_task_s task) {
  if (r->dir && r->r == r->w)
    return -1;
  r->buf[r->w] = task;
  ++(r->w);
  if (r->w == FIO_QUEUE_TASKS_PER_ALLOC) {
    r->w = 0;
    r->dir = ~r->dir;
  }
  return 0;
}

FIO_IFUNC int fio___task_ring_unpop(fio___task_ring_s *r,
                                    fio_queue_task_s task) {
  if (r->dir && r->r == r->w)
    return -1;
  if (!r->r) {
    r->r = FIO_QUEUE_TASKS_PER_ALLOC;
    r->dir = ~r->dir;
  }
  --r->r;
  r->buf[r->r] = task;
  return 0;
}

FIO_IFUNC fio_queue_task_s fio___task_ring_pop(fio___task_ring_s *r) {
  fio_queue_task_s t = {.fn = NULL};
  if (!r->dir && r->r == r->w) {
    return t;
  }
  t = r->buf[r->r];
  r->buf[r->r] = (fio_queue_task_s){.fn = NULL};
  ++r->r;
  if (r->r == FIO_QUEUE_TASKS_PER_ALLOC) {
    r->r = 0;
    r->dir = ~r->dir;
  }
  return t;
}

int fio_queue_push___(void); /* sublime text marker */
/** Pushes a task to the queue. Returns -1 on error. */
SFUNC int fio_queue_push FIO_NOOP(fio_queue_s *q, fio_queue_task_s task) {
  if (!task.fn)
    return 0;
  FIO___LOCK_LOCK(q->lock);
  if (fio___task_ring_push(q->w, task)) {
    if (q->w != &q->mem && q->mem.next == NULL) {
      q->w->next = &q->mem;
      q->mem.w = q->mem.r = q->mem.dir = 0;
    } else {
      void *tmp = (fio___task_ring_s *)
          FIO_MEM_REALLOC_(NULL, 0, sizeof(*q->w->next), 0);
      if (!tmp)
        goto no_mem;
      q->w->next = (fio___task_ring_s *)tmp;
      if (!FIO_MEM_REALLOC_IS_SAFE_) {
        q->w->next->r = q->w->next->w = q->w->next->dir = 0;

        q->w->next->next = NULL;
      }
    }
    q->w = q->w->next;
    fio___task_ring_push(q->w, task);
  }
  ++q->count;
  if (!FIO_LIST_IS_EMPTY(&q->consumers)) {
    FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
      fio_thread_cond_signal(&pos->cond);
    }
  }
  FIO___LOCK_UNLOCK(q->lock);
  return 0;
no_mem:
  FIO___LOCK_UNLOCK(q->lock);
  FIO_LOG_ERROR("No memory for Queue %p to increase task ring buffer.",
                (void *)q);
  return -1;
}

int fio_queue_push_urgent___(void); /* sublimetext marker */
/** Pushes a task to the head of the queue. Returns -1 on error (no memory). */
SFUNC int fio_queue_push_urgent FIO_NOOP(fio_queue_s *q,
                                         fio_queue_task_s task) {
  if (!task.fn)
    return 0;
  FIO___LOCK_LOCK(q->lock);
  if (fio___task_ring_unpop(q->r, task)) {
    /* such a shame... but we must allocate a while task block for one task */
    fio___task_ring_s *tmp =
        (fio___task_ring_s *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*q->w->next), 0);
    if (!tmp)
      goto no_mem;
    tmp->next = q->r;
    q->r = tmp;
    tmp->w = 1;
    tmp->dir = tmp->r = 0;
    tmp->buf[0] = task;
  }
  ++q->count;
  if (!FIO_LIST_IS_EMPTY(&q->consumers)) {
    FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
      fio_thread_cond_signal(&pos->cond);
    }
  }
  FIO___LOCK_UNLOCK(q->lock);
  return 0;
no_mem:
  FIO___LOCK_UNLOCK(q->lock);
  FIO_LOG_ERROR("No memory for Queue %p to increase task ring buffer.",
                (void *)q);
  return -1;
}

/** Pops a task from the queue (FIFO). Returns a NULL task on error. */
SFUNC fio_queue_task_s fio_queue_pop(fio_queue_s *q) {
  fio_queue_task_s t = {.fn = NULL};
  fio___task_ring_s *to_free = NULL;
  if (!q->count)
    return t;
  FIO___LOCK_LOCK(q->lock);
  if (!q->count)
    goto finish;
  if (!(t = fio___task_ring_pop(q->r)).fn) {
    to_free = q->r;
    q->r = to_free->next;
    to_free->next = NULL;
    t = fio___task_ring_pop(q->r);
  }
  if (t.fn && !(--q->count) && q->r != &q->mem) {
    if (to_free && to_free != &q->mem) { // edge case
      FIO_MEM_FREE_(to_free, sizeof(*to_free));
    }
    to_free = q->r;
    q->r = q->w = &q->mem;
    q->mem.w = q->mem.r = q->mem.dir = 0;
  }
finish:
  FIO___LOCK_UNLOCK(q->lock);
  if (to_free && to_free != &q->mem) {
    FIO_MEM_FREE_(to_free, sizeof(*to_free));
  }
  return t;
}

/** Performs a task from the queue. Returns -1 on error (queue empty). */
SFUNC int fio_queue_perform(fio_queue_s *q) {
  fio_queue_task_s t = fio_queue_pop(q);
  if (t.fn) {
    t.fn(t.udata1, t.udata2);
    return 0;
  }
  return -1;
}

/** Performs all tasks in the queue. */
SFUNC void fio_queue_perform_all(fio_queue_s *q) {
  fio_queue_task_s t;
  while ((t = fio_queue_pop(q)).fn)
    t.fn(t.udata1, t.udata2);
}

/* *****************************************************************************
Queue Consumer Threads
***************************************************************************** */

FIO_SFUNC void *fio___queue_worker_task(void *g_) {
  fio___thread_group_s *grp = (fio___thread_group_s *)g_;
  while (!grp->stop) {
    fio_queue_perform_all(grp->queue);
    fio_thread_mutex_lock(&grp->mutex);
    if (!grp->stop)
      fio_thread_cond_wait(&grp->cond, &grp->mutex);
    fio_thread_mutex_unlock(&grp->mutex);
    fio_queue_perform(grp->queue);
    fio_thread_cond_signal(&grp->cond);
    fio_queue_perform_all(grp->queue);
  }
  return NULL;
}
FIO_SFUNC void *fio___queue_worker_manager(void *g_) {
  fio_thread_t threads_buf[256];
  fio___thread_group_s grp = *(fio___thread_group_s *)g_;
  FIO_LIST_PUSH(&grp.queue->consumers, &grp.node);
  grp.stop = 0;
  fio_thread_t *threads =
      grp.workers > 256
          ? ((fio_thread_t *)
                 FIO_MEM_REALLOC_(NULL, 0, sizeof(*threads) * grp.workers, 0))
          : threads_buf;
  fio_thread_mutex_init(&grp.mutex);
  fio_thread_cond_init(&grp.cond);
  for (size_t i = 0; i < grp.workers; ++i) {
    fio_thread_create(threads + i, fio___queue_worker_task, (void *)&grp);
  }
  ((fio___thread_group_s *)g_)->stop = 0;
  /* from this point on, g_ is invalid! */
  for (size_t i = 0; i < grp.workers; ++i) {
    fio_thread_join(threads + i);
  }
  if (threads != threads_buf)
    FIO_MEM_FREE_(threads, sizeof(*threads) * grp.workers);
  FIO___LOCK_LOCK(grp.queue->lock);
  FIO_LIST_REMOVE(&grp.node);
  FIO___LOCK_UNLOCK(grp.queue->lock);
  return NULL;
}

SFUNC int fio_queue_workers_add(fio_queue_s *q, size_t workers) {
  FIO___LOCK_LOCK(q->lock);
  if (!q->consumers.next || !q->consumers.prev) {
    q->consumers = FIO_LIST_INIT(q->consumers);
  }
  fio___thread_group_s grp = {.queue = q, .workers = workers, .stop = 1};
  if (fio_thread_create(&grp.thread, fio___queue_worker_manager, &grp))
    return -1;
  while (grp.stop)
    FIO_THREAD_RESCHEDULE();
  FIO___LOCK_UNLOCK(q->lock);
  return 0;
}

SFUNC void fio_queue_workers_stop(fio_queue_s *q) {
  if (FIO_LIST_IS_EMPTY(&q->consumers))
    return;
  FIO___LOCK_LOCK(q->lock);
  FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
    pos->stop = 1;
    fio_thread_cond_signal(&pos->cond);
  }
  FIO___LOCK_UNLOCK(q->lock);
}

/** Signals all worker threads to go back to work (new tasks were). */
SFUNC void fio_queue_workers_wake(fio_queue_s *q) {
  if (FIO_LIST_IS_EMPTY(&q->consumers))
    return;
  FIO___LOCK_LOCK(q->lock);
  FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
    fio_thread_cond_signal(&pos->cond);
  }
  FIO___LOCK_UNLOCK(q->lock);
}

/* *****************************************************************************
Timer Queue Implementation
***************************************************************************** */

FIO_IFUNC void fio___timer_insert(fio___timer_event_s **pos,
                                  fio___timer_event_s *e) {
  while (*pos && e->due >= (*pos)->due)
    pos = &((*pos)->next);
  e->next = *pos;
  *pos = e;
}

FIO_IFUNC fio___timer_event_s *fio___timer_pop(fio___timer_event_s **pos,
                                               int64_t due) {
  if (!*pos || (*pos)->due > due)
    return NULL;
  fio___timer_event_s *t = *pos;
  *pos = t->next;
  return t;
}

FIO_IFUNC fio___timer_event_s *fio___timer_event_new(
    fio_timer_schedule_args_s args) {
  fio___timer_event_s *t = NULL;
  t = (fio___timer_event_s *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*t), 0);
  if (!t)
    goto init_error;
  if (!args.repetitions)
    args.repetitions = 1;
  *t = (fio___timer_event_s){
      .fn = args.fn,
      .udata1 = args.udata1,
      .udata2 = args.udata2,
      .on_finish = args.on_finish,
      .due = args.start_at + args.every,
      .every = args.every,
      .repetitions = args.repetitions,
  };
  return t;
init_error:
  if (args.on_finish)
    args.on_finish(args.udata1, args.udata2);
  return NULL;
}

FIO_IFUNC void fio___timer_event_free(fio_timer_queue_s *tq,
                                      fio___timer_event_s *t) {
  if (tq && (t->repetitions < 0 || fio_atomic_sub_fetch(&t->repetitions, 1))) {
    FIO___LOCK_LOCK(tq->lock);
    fio___timer_insert(&tq->next, t);
    FIO___LOCK_UNLOCK(tq->lock);
    return;
  }
  if (t->on_finish)
    t->on_finish(t->udata1, t->udata2);
  FIO_MEM_FREE_(t, sizeof(*t));
}

FIO_SFUNC void fio___timer_perform(void *timer_, void *t_) {
  fio_timer_queue_s *tq = (fio_timer_queue_s *)timer_;
  fio___timer_event_s *t = (fio___timer_event_s *)t_;
  if (t->fn(t->udata1, t->udata2))
    tq = NULL;
  t->due += t->every;
  fio___timer_event_free(tq, t);
}

/** Pushes due events from the timer queue to an event queue. */
SFUNC size_t fio_timer_push2queue(fio_queue_s *queue,
                                  fio_timer_queue_s *timer,
                                  int64_t start_at) {
  size_t r = 0;
  if (!start_at)
    start_at = fio_time_milli();
  if (FIO___LOCK_TRYLOCK(timer->lock))
    return 0;
  fio___timer_event_s *t;
  while ((t = fio___timer_pop(&timer->next, start_at))) {
    fio_queue_push(queue,
                   .fn = fio___timer_perform,
                   .udata1 = timer,
                   .udata2 = t);
    ++r;
  }
  FIO___LOCK_UNLOCK(timer->lock);
  return r;
}

void fio_timer_schedule___(void); /* sublimetext marker */
/** Adds a time-bound event to the timer queue. */
SFUNC void fio_timer_schedule FIO_NOOP(fio_timer_queue_s *timer,
                                       fio_timer_schedule_args_s args) {
  fio___timer_event_s *t = NULL;
  if (!timer || !args.fn || !args.every)
    goto no_timer_queue;
  if (!args.start_at)
    args.start_at = fio_time_milli();
  t = fio___timer_event_new(args);
  if (!t)
    return;
  FIO___LOCK_LOCK(timer->lock);
  fio___timer_insert(&timer->next, t);
  FIO___LOCK_UNLOCK(timer->lock);
  return;
no_timer_queue:
  if (args.on_finish)
    args.on_finish(args.udata1, args.udata2);
  FIO_LOG_ERROR("fio_timer_schedule called with illegal arguments.");
}

/**
 * Clears any waiting timer bound tasks.
 *
 * NOTE:
 *
 * The timer queue must NEVER be freed when there's a chance that timer tasks
 * are waiting to be performed in a `fio_queue_s`.
 *
 * This is due to the fact that the tasks may try to reschedule themselves (if
 * they repeat).
 */
SFUNC void fio_timer_destroy(fio_timer_queue_s *tq) {
  fio___timer_event_s *next;
  FIO___LOCK_LOCK(tq->lock);
  next = tq->next;
  tq->next = NULL;
  FIO___LOCK_UNLOCK(tq->lock);
  FIO___LOCK_DESTROY(tq->lock);
  while (next) {
    fio___timer_event_s *tmp = next;

    next = next->next;
    fio___timer_event_free(NULL, tmp);
  }
}

/* *****************************************************************************
Queue - test
***************************************************************************** */
#ifdef FIO_TEST_CSTL

#ifndef FIO___QUEUE_TEST_PRINT
#define FIO___QUEUE_TEST_PRINT 1
#endif

#define FIO___QUEUE_TOTAL_COUNT (512 * 1024)

typedef struct {
  fio_queue_s *q;
  uintptr_t count;
  uintptr_t *counter;
} fio___queue_test_s;

FIO_SFUNC void fio___queue_test_sample_task(void *i_count, void *unused2) {
  (void)(unused2);
  fio_atomic_add((uintptr_t *)i_count, 1);
}

FIO_SFUNC void fio___queue_test_counter_task(void *i_count1, void *i_count2) {
  static intptr_t counter = 0;
  if (!i_count1 && !i_count2) {
    counter = 0;
    return;
  }
  FIO_ASSERT((intptr_t)i_count1 == (intptr_t)counter + 1,
             "udata1 value error in task");
  FIO_ASSERT((intptr_t)i_count2 == (intptr_t)counter + 2,
             "udata2 value error in task");
  ++counter;
}

FIO_SFUNC void fio___queue_test_sched_sample_task(void *t_, void *i_count) {
  fio___queue_test_s *t = (fio___queue_test_s *)t_;
  size_t i = (size_t)(uintptr_t)i_count;
  FIO_ASSERT(!fio_queue_push(t->q,
                             .fn = fio___queue_test_sample_task,
                             .udata1 = t->counter),
             "Couldn't push task!");
  --i;
  if (!i)
    return;
  if ((i & 1)) {
    FIO_ASSERT(
        !fio_queue_push(t->q, fio___queue_test_sched_sample_task, t, (void *)i),
        "Couldn't push task!");
  } else {
    FIO_ASSERT(!fio_queue_push_urgent(t->q,
                                      fio___queue_test_sched_sample_task,
                                      t,
                                      (void *)i),
               "Couldn't push task!");
  }
}

FIO_SFUNC int fio___queue_test_timer_task(void *i_count, void *unused2) {
  fio_atomic_add((uintptr_t *)i_count, 1);
  return (unused2 ? -1 : 0);
}

FIO_SFUNC void FIO_NAME_TEST(stl, queue)(void) {
  fprintf(stderr, "* Testing facil.io task scheduling (fio_queue)\n");
  /* ************** testing queue ************** */
  fio_queue_s *q = fio_queue_new();
  fio_queue_s q2;

  fprintf(stderr, "\t- size of queue object (fio_queue_s): %zu\n", sizeof(*q));
  fprintf(stderr,
          "\t- size of queue ring buffer (per allocation): %zu\n",
          sizeof(q->mem));
  fprintf(stderr,
          "\t- event slots per queue allocation: %zu\n",
          (size_t)FIO_QUEUE_TASKS_PER_ALLOC);

  /* test task user data integrity. */
  fio___queue_test_counter_task(NULL, NULL);
  for (size_t i = 0; i < (FIO_QUEUE_TASKS_PER_ALLOC << 2); ++i) {
    fio_queue_push(q,
                   .fn = fio___queue_test_counter_task,
                   .udata1 = (void *)(i + 1),
                   .udata2 = (void *)(i + 2));
  }
  fio_queue_perform_all(q);
  fio_queue_perform_all(q);
  for (size_t i = (FIO_QUEUE_TASKS_PER_ALLOC << 2);
       i < (FIO_QUEUE_TASKS_PER_ALLOC << 3);
       ++i) {
    fio_queue_push(q,
                   .fn = fio___queue_test_counter_task,
                   .udata1 = (void *)(i + 1),
                   .udata2 = (void *)(i + 2));
  }
  fio_queue_perform_all(q);
  fio_queue_perform_all(q);
  FIO_ASSERT(!fio_queue_count(q) && fio_queue_perform(q) == -1,
             "fio_queue_perform_all didn't perform all");

  const size_t max_threads = 12; // assumption / pure conjuncture...
  uintptr_t i_count;
  uint64_t start, end;
  i_count = 0;
  start = fio_time_milli();
  for (size_t i = 0; i < FIO___QUEUE_TOTAL_COUNT; i++) {
    fio___queue_test_sample_task(&i_count, NULL);
  }
  end = fio_time_milli();
  if (FIO___QUEUE_TEST_PRINT) {
    fprintf(stderr,
            "\t- Queueless (direct call) counter: %lu ms with i_count = %lu\n",
            (unsigned long)(end - start),
            (unsigned long)i_count);
  }
  size_t i_count_should_be = i_count;
  i_count = 0;
  start = fio_time_milli();
  for (size_t i = 0; i < FIO___QUEUE_TOTAL_COUNT; i++) {
    fio_queue_push(q,
                   .fn = fio___queue_test_sample_task,
                   .udata1 = (void *)&i_count);
  }
  fio_queue_perform_all(q);
  fio_queue_perform_all(q);
  fio_queue_perform_all(q);
  end = fio_time_milli();
  if (FIO___QUEUE_TEST_PRINT) {
    fprintf(stderr,
            "\t- single task counter: %lu ms with i_count = %lu\n",
            (unsigned long)(end - start),
            (unsigned long)i_count);
  }
  FIO_ASSERT(i_count == i_count_should_be, "ERROR: queue count invalid\n");

  if (FIO___QUEUE_TEST_PRINT) {
    fprintf(stderr, "\n");
  }

  for (size_t i = 1; i < 32 && FIO___QUEUE_TOTAL_COUNT >> i; ++i) {
    fio___queue_test_s info = {
        .q = q,
        .count = (uintptr_t)(FIO___QUEUE_TOTAL_COUNT >> i),
        .counter = &i_count,
    };
    const size_t tasks = 1 << i;
    i_count = 0;
    start = fio_time_milli();
    for (size_t j = 0; j < tasks; ++j) {
      fio_queue_push(q,
                     fio___queue_test_sched_sample_task,
                     (void *)&info,
                     (void *)info.count);
    }
    FIO_ASSERT(fio_queue_count(q), "tasks not counted?!");
    {
      const size_t t_count = (i % max_threads) + 1;
      if (0) {
        fio_queue_workers_add(q, t_count);
        FIO___LOCK_LOCK(q->lock);
        FIO_LIST_EACH(fio___thread_group_s, node, &q->consumers, pos) {
          FIO___LOCK_UNLOCK(q->lock);
          while (!(volatile uintptr_t)i_count)
            FIO_THREAD_RESCHEDULE();
          fio_queue_workers_stop(q);
          fio_thread_join(&pos->thread);
          FIO___LOCK_LOCK(q->lock);
        }
        FIO___LOCK_UNLOCK(q->lock);
      } else {
        union {
          void *(*t)(void *);
          void (*act)(fio_queue_s *);
        } thread_tasks;
        thread_tasks.act = fio_queue_perform_all;
        fio_thread_t *threads = (fio_thread_t *)
            FIO_MEM_REALLOC_(NULL, 0, sizeof(*threads) * t_count, 0);
        for (size_t j = 0; j < t_count; ++j) {
          if (fio_thread_create(threads + j, thread_tasks.t, q)) {
            abort();
          }
        }
        for (size_t j = 0; j < t_count; ++j) {
          fio_thread_join(threads + j);
        }
        FIO_MEM_FREE(threads, sizeof(*threads) * t_count);
      }
    }

    end = fio_time_milli();
    if (FIO___QUEUE_TEST_PRINT) {
      fprintf(stderr,
              "- queue performed using %zu threads, %zu scheduling tasks (%zu "
              "each):\n"
              "    %lu ms with i_count = %lu\n",
              ((i % max_threads) + 1),
              tasks,
              info.count,
              (unsigned long)(end - start),
              (unsigned long)i_count);
    } else {
      fprintf(stderr, ".");
    }
    FIO_ASSERT(i_count == i_count_should_be, "ERROR: queue count invalid\n");
  }
  if (!(FIO___QUEUE_TEST_PRINT))
    fprintf(stderr, "\n");
  FIO_ASSERT(q->w == &q->mem,
             "queue library didn't release dynamic queue (should be static)");
  fio_queue_free(q);
  {
    fprintf(stderr, "* Testing urgent insertion\n");
    fio_queue_init(&q2);
    for (size_t i = 0; i < (FIO_QUEUE_TASKS_PER_ALLOC * 3); ++i) {
      FIO_ASSERT(!fio_queue_push_urgent(&q2,
                                        .fn = (void (*)(void *, void *))(i + 1),
                                        .udata1 = (void *)(i + 1)),
                 "fio_queue_push_urgent failed");
    }
    FIO_ASSERT(q2.r->next && q2.r->next->next && !q2.r->next->next->next,
               "should have filled only three task blocks");
    for (size_t i = 0; i < (FIO_QUEUE_TASKS_PER_ALLOC * 3); ++i) {
      fio_queue_task_s t = fio_queue_pop(&q2);
      FIO_ASSERT(
          t.fn && (size_t)t.udata1 == (FIO_QUEUE_TASKS_PER_ALLOC * 3) - i,
          "fio_queue_push_urgent pop ordering error [%zu] %zu != %zu (%p)",
          i,
          (size_t)t.udata1,
          (FIO_QUEUE_TASKS_PER_ALLOC * 3) - i,
          (void *)(uintptr_t)t.fn);
    }
    FIO_ASSERT(fio_queue_pop(&q2).fn == NULL,
               "pop overflow after urgent tasks");
    fio_queue_destroy(&q2);
  }
  /* ************** testing timers ************** */
  {
    fprintf(stderr,
            "* Testing facil.io timer scheduling (fio_timer_queue_s)\n");
    fprintf(stderr, "  Note: Errors SHOULD print out to the log.\n");
    fio_queue_init(&q2);
    uintptr_t tester = 0;
    fio_timer_queue_s tq = FIO_TIMER_QUEUE_INIT;

    /* test failuers */
    fio_timer_schedule(&tq,
                       .udata1 = &tester,
                       .on_finish = fio___queue_test_sample_task,
                       .every = 100,
                       .repetitions = -1);
    FIO_ASSERT(tester == 1,
               "fio_timer_schedule should have called `on_finish`");
    tester = 0;
    fio_timer_schedule(NULL,
                       .fn = fio___queue_test_timer_task,
                       .udata1 = &tester,
                       .on_finish = fio___queue_test_sample_task,
                       .every = 100,
                       .repetitions = -1);
    FIO_ASSERT(tester == 1,
               "fio_timer_schedule should have called `on_finish`");
    tester = 0;
    fio_timer_schedule(&tq,
                       .fn = fio___queue_test_timer_task,
                       .udata1 = &tester,
                       .on_finish = fio___queue_test_sample_task,
                       .every = 0,
                       .repetitions = -1);
    FIO_ASSERT(tester == 1,
               "fio_timer_schedule should have called `on_finish`");
    fprintf(stderr, "  Note: no more errors should print for this test.\n");

    /* test endless task */
    tester = 0;
    fio_timer_schedule(&tq,
                       .fn = fio___queue_test_timer_task,
                       .udata1 = &tester,
                       .on_finish = fio___queue_test_sample_task,
                       .every = 1,
                       .repetitions = -1,
                       .start_at = fio_time_milli() - 10);
    FIO_ASSERT(tester == 0,
               "fio_timer_schedule should have scheduled the task.");
    for (size_t i = 0; i < 10; ++i) {
      uint64_t now = fio_time_milli();
      fio_timer_push2queue(&q2, &tq, now);
      fio_timer_push2queue(&q2, &tq, now);
      FIO_ASSERT(fio_queue_count(&q2), "task should have been scheduled");
      FIO_ASSERT(fio_queue_count(&q2) == 1,
                 "task should have been scheduled only once");
      fio_queue_perform(&q2);
      FIO_ASSERT(!fio_queue_count(&q2), "queue should be empty");
      FIO_ASSERT(tester == i + 1,
                 "task should have been performed (%zu).",
                 (size_t)tester);
    }

    tester = 0;
    fio_timer_destroy(&tq);
    FIO_ASSERT(tester == 1, "fio_timer_destroy should have called `on_finish`");

    /* test single-use task */
    tester = 0;
    int64_t milli_now = fio_time_milli();
    fio_timer_schedule(&tq,
                       .fn = fio___queue_test_timer_task,
                       .udata1 = &tester,
                       .on_finish = fio___queue_test_sample_task,
                       .every = 100,
                       .repetitions = 1,
                       .start_at = milli_now - 10);
    FIO_ASSERT(tester == 0,
               "fio_timer_schedule should have scheduled the task.");
    fio_timer_schedule(&tq,
                       .fn = fio___queue_test_timer_task,
                       .udata1 = &tester,
                       .on_finish = fio___queue_test_sample_task,
                       .every = 1,
                       // .repetitions = 1, // auto-value is 1
                       .start_at = milli_now - 10);
    FIO_ASSERT(tester == 0,
               "fio_timer_schedule should have scheduled the task.");
    FIO_ASSERT(fio_timer_next_at(&tq) == milli_now - 9,
               "fio_timer_next_at value error.");
    fio_timer_push2queue(&q2, &tq, milli_now);
    FIO_ASSERT(fio_queue_count(&q2) == 1,
               "task should have been scheduled (2)");
    FIO_ASSERT(fio_timer_next_at(&tq) == milli_now + 90,
               "fio_timer_next_at value error for unscheduled task.");
    fio_queue_perform(&q2);
    FIO_ASSERT(!fio_queue_count(&q2), "queue should be empty");
    FIO_ASSERT(tester == 2,
               "task should have been performed and on_finish called (%zu).",
               (size_t)tester);
    fio_timer_destroy(&tq);
    FIO_ASSERT(
        tester == 3,
        "fio_timer_destroy should have called on_finish of future task (%zu).",
        (size_t)tester);
    FIO_ASSERT(!tq.next, "timer queue should be empty.");
    fio_queue_destroy(&q2);
  }
  fprintf(stderr, "* passed.\n");
}
#endif /* FIO_TEST_CSTL */

/* *****************************************************************************
Queue/Timer Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_QUEUE
#endif /* FIO_QUEUE */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_SOCK       /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                            Basic Socket Helpers



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_SOCK) && !defined(H___FIO_SOCK___H)
#define H___FIO_SOCK___H

/* *****************************************************************************
OS specific patches.
***************************************************************************** */
#if FIO_OS_WIN
#if _MSC_VER
#pragma comment(lib, "Ws2_32.lib")
#endif
#include <iphlpapi.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#ifdef AF_UNIX
#include <afunix.h>
#endif
#ifndef FIO_SOCK_FD_ISVALID
#define FIO_SOCK_FD_ISVALID(fd) ((size_t)fd <= (size_t)0x7FFFFFFF)
#endif
/** Acts as POSIX write. Use this macro for portability with WinSock2. */
#define fio_sock_write(fd, data, len) send((fd), (data), (len), 0)
/** Acts as POSIX read. Use this macro for portability with WinSock2. */
#define fio_sock_read(fd, buf, len) recv((fd), (buf), (len), 0)
/** Acts as POSIX close. Use this macro for portability with WinSock2. */
#define fio_sock_close(fd) closesocket(fd)
/** Protects against type size overflow on Windows, where FD > MAX_INT. */
FIO_IFUNC int fio_sock_accept(int s, struct sockaddr *addr, int *addrlen) {
  int r = -1;
  SOCKET c = accept(s, addr, addrlen);
  if (c == INVALID_SOCKET)
    return r;
  if (FIO_SOCK_FD_ISVALID(c)) {
    r = (int)c;
    return r;
  }
  closesocket(c);
  errno = ERANGE;
  FIO_LOG_ERROR("Windows SOCKET value overflowed int limits (was: %zu)",
                (size_t)c);
  return r;
}
#define accept fio_sock_accept
#define poll   WSAPoll
/** Acts as POSIX dup. Use this for portability with WinSock2. */
FIO_IFUNC int fio_sock_dup(int original) {
  int fd = -1;
  SOCKET tmpfd = INVALID_SOCKET;
  WSAPROTOCOL_INFOA info;
  if (!WSADuplicateSocketA(original, GetCurrentProcessId(), &info) &&
      (tmpfd = WSASocketA(AF_UNSPEC, SOCK_STREAM, IPPROTO_TCP, &info, 0, 0)) !=
          INVALID_SOCKET) {
    if (FIO_SOCK_FD_ISVALID(tmpfd))
      fd = (int)tmpfd;
    else
      fio_sock_close(tmpfd);
  }
  return fd;
}

#elif FIO_HAVE_UNIX_TOOLS
#include <fcntl.h>
#include <netdb.h>
#include <poll.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/un.h>
#include <unistd.h>
#ifndef FIO_SOCK_FD_ISVALID
#define FIO_SOCK_FD_ISVALID(fd) ((int)fd != (int)-1)
#endif
/** Acts as POSIX write. Use this macro for portability with WinSock2. */
#define fio_sock_write(fd, data, len) write((fd), (data), (len))
/** Acts as POSIX read. Use this macro for portability with WinSock2. */
#define fio_sock_read(fd, buf, len)   read((fd), (buf), (len))
/** Acts as POSIX close. Use this macro for portability with WinSock2. */
#define fio_sock_close(fd)            close(fd)
/** Acts as POSIX dup. Use this macro for portability with WinSock2. */
#define fio_sock_dup(fd)              dup(fd)
#else
#error FIO_SOCK requires a supported OS (Windows / POSIX).
#endif

/* *****************************************************************************
Socket OS abstraction - API
***************************************************************************** */

/** Socket type flags */
typedef enum {
  FIO_SOCK_SERVER = 0,
  FIO_SOCK_CLIENT = 1,
  FIO_SOCK_NONBLOCK = 2,
  FIO_SOCK_TCP = 4,
  FIO_SOCK_UDP = 8,
#ifdef AF_UNIX
  FIO_SOCK_UNIX = 16,
  FIO_SOCK_UNIX_PRIVATE = (16 | 32),
#else
#define FIO_SOCK_UNIX         0
#define FIO_SOCK_UNIX_PRIVATE 0
#endif
} fio_sock_open_flags_e;

/**
 * Creates a new socket according to the provided flags.
 *
 * The `port` string will be ignored when `FIO_SOCK_UNIX` is set.
 */
FIO_IFUNC int fio_sock_open(const char *restrict address,
                            const char *restrict port,
                            uint16_t flags);

/** Creates a new socket, according to the provided flags. */
SFUNC int fio_sock_open2(const char *url, uint16_t flags);

/**
 * Attempts to resolve an address to a valid IP6 / IP4 address pointer.
 *
 * The `sock_type` element should be a socket type, such as `SOCK_DGRAM` (UDP)
 * or `SOCK_STREAM` (TCP/IP).
 *
 * The address should be freed using `fio_sock_address_free`.
 */
FIO_IFUNC struct addrinfo *fio_sock_address_new(const char *restrict address,
                                                const char *restrict port,
                                                int sock_type);

/** Frees the pointer returned by `fio_sock_address_new`. */
FIO_IFUNC void fio_sock_address_free(struct addrinfo *a);

/** Creates a new network socket and binds it to a local address. */
SFUNC int fio_sock_open_local(struct addrinfo *addr, int nonblock);

/** Creates a new network socket and connects it to a remote address. */
SFUNC int fio_sock_open_remote(struct addrinfo *addr, int nonblock);

/** Creates a new Unix socket and binds it to a local address. */
SFUNC int fio_sock_open_unix(const char *address, uint16_t flags);

/** Sets a file descriptor / socket to non blocking state. */
SFUNC int fio_sock_set_non_block(int fd);

/** Attempts to maximize the allowed open file limits. returns known limit */
SFUNC size_t fio_sock_maximize_limits(void);

/**
 * Returns 0 on timeout, -1 on error or the events that are valid.
 *
 * Possible events are POLLIN | POLLOUT
 */
SFUNC short fio_sock_wait_io(int fd, short events, int timeout);

/** A helper macro that waits on a single IO with no callbacks (0 = no event) */
#define FIO_SOCK_WAIT_RW(fd, timeout_)                                         \
  fio_sock_wait_io(fd, POLLIN | POLLOUT, timeout_)

/** A helper macro that waits on a single IO with no callbacks (0 = no event) */
#define FIO_SOCK_WAIT_R(fd, timeout_) fio_sock_wait_io(fd, POLLIN, timeout_)

/** A helper macro that waits on a single IO with no callbacks (0 = no event) */
#define FIO_SOCK_WAIT_W(fd, timeout_) fio_sock_wait_io(fd, POLLOUT, timeout_)

/* *****************************************************************************
IO Poll - Implementation (always static / inlined)
***************************************************************************** */

/**
 * Creates a new socket according to the provided flags.
 *
 * The `port` string will be ignored when `FIO_SOCK_UNIX` is set.
 */
FIO_IFUNC int fio_sock_open(const char *restrict address,
                            const char *restrict port,
                            uint16_t flags) {
  struct addrinfo *addr = NULL;
  int fd;
#ifdef AF_UNIX
  if ((flags & FIO_SOCK_UNIX))
    return fio_sock_open_unix(address, flags);
#endif

  switch ((flags & ((uint16_t)FIO_SOCK_TCP | (uint16_t)FIO_SOCK_UDP))) {
  case FIO_SOCK_UDP:
    addr = fio_sock_address_new(address, port, SOCK_DGRAM);
    if (!addr) {
      FIO_LOG_ERROR("(fio_sock_open) address error: %s", strerror(errno));
      return -1;
    }
    if ((flags & FIO_SOCK_CLIENT)) {
      fd = fio_sock_open_remote(addr, (flags & FIO_SOCK_NONBLOCK));
    } else {
      fd = fio_sock_open_local(addr, (flags & FIO_SOCK_NONBLOCK));
    }
    fio_sock_address_free(addr);
    return fd;

  case FIO_SOCK_TCP:
    addr = fio_sock_address_new(address, port, SOCK_STREAM);
    if (!addr) {
      FIO_LOG_ERROR("(fio_sock_open) address error: %s", strerror(errno));
      return -1;
    }
    if ((flags & FIO_SOCK_CLIENT)) {
      fd = fio_sock_open_remote(addr, (flags & FIO_SOCK_NONBLOCK));
    } else {
      fd = fio_sock_open_local(addr, (flags & FIO_SOCK_NONBLOCK));
      if (fd != -1 && listen(fd, SOMAXCONN) == -1) {
        FIO_LOG_ERROR("(fio_sock_open) failed on call to listen: %s",
                      strerror(errno));
        fio_sock_close(fd);
        fd = -1;
      }
    }
    fio_sock_address_free(addr);
    return fd;
  }

  FIO_LOG_ERROR("(fio_sock_open) the FIO_SOCK_TCP, FIO_SOCK_UDP, and "
                "FIO_SOCK_UNIX flags are exclusive");
  return -1;
}

FIO_IFUNC struct addrinfo *fio_sock_address_new(
    const char *restrict address,
    const char *restrict port,
    int sock_type /*i.e., SOCK_DGRAM */) {
  struct addrinfo addr_hints = (struct addrinfo){0}, *a;
  int e;
  addr_hints.ai_family = AF_UNSPEC; // set to AF_INET to force IPv4
  addr_hints.ai_socktype = sock_type;
  addr_hints.ai_flags = AI_PASSIVE; // use my IP

  if ((e = getaddrinfo(address, (port ? port : "0"), &addr_hints, &a)) != 0) {
    FIO_LOG_ERROR("(fio_sock_address_new(\"%s\", \"%s\")) error: %s",
                  (address ? address : "NULL"),
                  (port ? port : "0"),
                  gai_strerror(e));
    return NULL;
  }
  return a;
}

FIO_IFUNC void fio_sock_address_free(struct addrinfo *a) { freeaddrinfo(a); }

/* *****************************************************************************
FIO_SOCK - Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/** Creates a new socket, according to the provided flags. */
SFUNC int fio_sock_open2(const char *url, uint16_t flags) {
  char buf[2048];
  char port[64];
  char *addr = buf;
  char *pr = port;

  /* parse URL */
  fio_url_s u = fio_url_parse(url, strlen(url));
#ifdef AF_UNIX
  if (!u.host.buf && !u.port.buf && u.path.buf) {
    /* Unix socket - force flag validation */
    flags &= ~((uint16_t)(FIO_SOCK_UNIX | FIO_SOCK_TCP));
    flags |= (u.scheme.len == 4 &&
              fio_buf2u32_local(u.scheme.buf) == fio_buf2u32_local("priv"))
                 ? FIO_SOCK_UNIX_PRIVATE
                 : FIO_SOCK_UNIX;
    if (u.path.len >= 2048) {
      errno = EINVAL;
      FIO_LOG_ERROR(
          "Couldn't open unix socket to %s - host name too long (%zu).",
          url,
          u.path.len);
      return -1;
    }
    FIO_MEMCPY(buf, u.path.buf, u.path.len);
    buf[u.path.len] = 0;
    pr = NULL;
    return fio_sock_open_unix(buf, flags);
  }
#endif
  if (!u.port.len)
    u.port = u.scheme;
  if (!u.port.len) {
    pr = NULL;
  } else {
    if (u.port.len >= 64) {
      errno = EINVAL;
      FIO_LOG_ERROR("Couldn't open socket to %s - port / scheme too long.",
                    url);
      return -1;
    }
    FIO_MEMCPY(port, u.port.buf, u.port.len);
    port[u.port.len] = 0;
    if (!(flags & (FIO_SOCK_TCP | FIO_SOCK_UDP))) {
      if (u.scheme.len == 3 && (u.scheme.buf[0] | 32) == 't' &&
          (u.scheme.buf[1] | 32) == 'c' && (u.scheme.buf[2] | 32) == 'p')
        flags |= FIO_SOCK_TCP;
      else if (u.scheme.len == 3 && (u.scheme.buf[0] | 32) == 'u' &&
               (u.scheme.buf[1] | 32) == 'd' && (u.scheme.buf[2] | 32) == 'p')
        flags |= FIO_SOCK_UDP;
      else if ((u.scheme.len == 4 || u.scheme.len == 5) &&
               (u.scheme.buf[0] | 32) == 'h' && (u.scheme.buf[1] | 32) == 't' &&
               (u.scheme.buf[2] | 32) == 't' && (u.scheme.buf[3] | 32) == 'p' &&
               (u.scheme.len == 4 ||
                (u.scheme.len == 5 && (u.scheme.buf[4] | 32) == 's')))
        flags |= FIO_SOCK_TCP;
    }
  }
  if (u.host.len) {
    if (u.host.len >= 2048) {
      errno = EINVAL;
      FIO_LOG_ERROR("Couldn't open socket to %s - host name too long.", url);
      return -1;
    }
    FIO_MEMCPY(buf, u.host.buf, u.host.len);
    buf[u.host.len] = 0;
  } else {
    addr = NULL;
  }
  return fio_sock_open(addr, pr, flags);
}

/** Sets a file descriptor / socket to non blocking state. */
SFUNC int fio_sock_set_non_block(int fd) {
/* If they have O_NONBLOCK, use the Posix way to do it */
#if defined(O_NONBLOCK)
  /* Fixme: O_NONBLOCK is defined but broken on SunOS 4.1.x and AIX 3.2.5. */
  int flags;
  if (-1 == (flags = fcntl(fd, F_GETFL, 0)))
    flags = 0;
#ifdef O_CLOEXEC
  return fcntl(fd, F_SETFL, flags | O_NONBLOCK | O_CLOEXEC);
#else
  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
#endif
#elif defined(FIONBIO)
  /* Otherwise, use the old way of doing it */
#if FIO_OS_WIN
  unsigned long flags = 1;
  if (ioctlsocket(fd, FIONBIO, &flags) == SOCKET_ERROR) {
    switch (WSAGetLastError()) {
    case WSANOTINITIALISED:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSANOTINITIALISED");
      break;
    case WSAENETDOWN:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSAENETDOWN");
      break;
    case WSAEINPROGRESS:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSAEINPROGRESS");
      break;
    case WSAENOTSOCK:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSAENOTSOCK");
      break;
    case WSAEFAULT:
      FIO_LOG_DEBUG("Windows non-blocking ioctl failed with WSAEFAULT");
      break;
    }
    return -1;
  }
  return 0;
#else
  int flags = 1;
  return ioctl(fd, FIONBIO, &flags);
#endif /* FIO_OS_WIN */
#else
#error No functions / argumnet macros for non-blocking sockets.
#endif
}

/** Creates a new network socket and binds it to a local address. */
SFUNC int fio_sock_open_local(struct addrinfo *addr, int nonblock) {
  int fd = -1;
  for (struct addrinfo *p = addr; p != NULL; p = p->ai_next) {
#if FIO_OS_WIN
    SOCKET fd_tmp;
    if ((fd_tmp = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) ==
        INVALID_SOCKET) {
      FIO_LOG_DEBUG("socket creation error %s", strerror(errno));
      continue;
    }
    if (!FIO_SOCK_FD_ISVALID(fd_tmp)) {
      FIO_LOG_DEBUG("windows socket value out of valid portable range.");
      errno = ERANGE;
    }
    fd = (int)fd_tmp;
#else
    if ((fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
      FIO_LOG_DEBUG("socket creation error %s", strerror(errno));
      continue;
    }
#endif
    {
      // avoid the "address taken"
      int optval = 1;
      setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void *)&optval, sizeof(optval));
    }
    if (bind(fd, p->ai_addr, p->ai_addrlen) == -1) {
      FIO_LOG_DEBUG("Failed attempt to bind socket (%d) to address %s",
                    fd,
                    strerror(errno));
      fio_sock_close(fd);
      fd = -1;
      continue;
    }
    if (nonblock && fio_sock_set_non_block(fd) == -1) {
      FIO_LOG_DEBUG("Couldn't set socket (%d) to non-blocking mode %s",
                    fd,
                    strerror(errno));
      fio_sock_close(fd);
      fd = -1;
      continue;
    }
    break;
  }
  if (fd == -1) {
    FIO_LOG_DEBUG("socket binding/creation error %s", strerror(errno));
  }
  return fd;
}

/** Creates a new network socket and connects it to a remote address. */
SFUNC int fio_sock_open_remote(struct addrinfo *addr, int nonblock) {
  int fd = -1;
  for (struct addrinfo *p = addr; p != NULL; p = p->ai_next) {
#if FIO_OS_WIN
    SOCKET fd_tmp;
    if ((fd_tmp = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) ==
        INVALID_SOCKET) {
      FIO_LOG_DEBUG("socket creation error %s", strerror(errno));
      continue;
    }
    if (!FIO_SOCK_FD_ISVALID(fd_tmp)) {
      FIO_LOG_DEBUG("windows socket value out of valid portable range.");
      errno = ERANGE;
    }
    fd = (int)fd_tmp;
#else
    if ((fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
      FIO_LOG_DEBUG("socket creation error %s", strerror(errno));
      continue;
    }
#endif

    if (nonblock && fio_sock_set_non_block(fd) == -1) {
      FIO_LOG_DEBUG(
          "Failed attempt to set client socket (%d) to non-blocking %s",
          fd,
          strerror(errno));
      fio_sock_close(fd);
      fd = -1;
      continue;
    }
    if (connect(fd, p->ai_addr, p->ai_addrlen) == -1 &&
#if FIO_OS_WIN
        (WSAGetLastError() != WSAEWOULDBLOCK || errno != EINPROGRESS)
#else
        errno != EINPROGRESS
#endif
    ) {
#if FIO_OS_WIN
      FIO_LOG_DEBUG(
          "Couldn't connect client socket (%d) to remote address %s (%d)",
          fd,
          strerror(errno),
          WSAGetLastError());
#else
      FIO_LOG_DEBUG("Couldn't connect client socket (%d) to remote address %s",
                    fd,
                    strerror(errno));
#endif
      fio_sock_close(fd);
      fd = -1;
      continue;
    }
    break;
  }
  if (fd == -1) {
    FIO_LOG_DEBUG("socket connection/creation error %s", strerror(errno));
  }
  return fd;
}

/** Returns 0 on timeout, -1 on error or the events that are valid. */
SFUNC short fio_sock_wait_io(int fd, short events, int timeout) {
  short r;
  struct pollfd pfd = {.fd = fd, .events = events};
  r = (short)poll(&pfd, 1, timeout);
  if (r == 1)
    r = pfd.revents;
  return r;
}

/** Attempts to maximize the allowed open file limits. returns known limit */
SFUNC size_t fio_sock_maximize_limits(void) {
  ssize_t capa = 0;
#if FIO_OS_POSIX

#ifdef _SC_OPEN_MAX
  capa = sysconf(_SC_OPEN_MAX);
#elif defined(FOPEN_MAX)
  capa = FOPEN_MAX;
#endif
  // try to maximize limits - collect max and set to max
  struct rlimit rlim = {.rlim_max = 0};
  if (getrlimit(RLIMIT_NOFILE, &rlim) == -1) {
    FIO_LOG_WARNING("`getrlimit` failed (%d): %s", errno, strerror(errno));
    return capa;
  }

  FIO_LOG_DEBUG2("existing / maximum open file limit detected: %zd / %zd",
                 (ssize_t)rlim.rlim_cur,
                 (ssize_t)rlim.rlim_max);

  rlim_t original = rlim.rlim_cur;
  rlim.rlim_cur = rlim.rlim_max;
  while (setrlimit(RLIMIT_NOFILE, &rlim) == -1 && rlim.rlim_cur > original)
    rlim.rlim_cur >>= 1;

  FIO_LOG_DEBUG2("new open file limit: %zd", (ssize_t)rlim.rlim_cur);

  getrlimit(RLIMIT_NOFILE, &rlim);
  capa = rlim.rlim_cur;
#elif FIO_OS_WIN
  capa = 1ULL << 10;
  while (_setmaxstdio(capa) > 0)
    capa <<= 1;
  capa >>= 1;
  FIO_LOG_DEBUG("new open file limit: %zd", (ssize_t)capa);
#else
  FIO_LOG_ERROR("No OS detected, couldn't maximize open file limit.");
#endif
  return capa;
}

#ifdef AF_UNIX
/** Creates a new Unix socket and binds it to a local address. */
SFUNC int fio_sock_open_unix(const char *address, uint16_t flags) {
  /* Unix socket */
  struct sockaddr_un addr = {0};
  size_t addr_len = strlen(address);
  if (addr_len >= sizeof(addr.sun_path)) {
    FIO_LOG_ERROR(
        "(fio_sock_open_unix) address too long (%zu bytes > %zu bytes).",
        addr_len,
        sizeof(addr.sun_path) - 1);
    errno = ENAMETOOLONG;
    return -1;
  }
  addr.sun_family = AF_UNIX;
  FIO_MEMCPY(addr.sun_path, address, addr_len + 1); /* copy the NUL byte. */
#if defined(__APPLE__)
  addr.sun_len = addr_len;
#endif
  // get the file descriptor
  int fd =
      socket(AF_UNIX, (flags & FIO_SOCK_UDP) ? SOCK_DGRAM : SOCK_STREAM, 0);
  if (fd == -1) {
    FIO_LOG_DEBUG("couldn't open unix socket (flags == %d) %s",
                  (int)flags,
                  strerror(errno));
    return -1;
  }
  if ((flags & FIO_SOCK_NONBLOCK) && fio_sock_set_non_block(fd) == -1) {
    FIO_LOG_DEBUG("couldn't set socket to non-blocking mode");
    fio_sock_close(fd);
    unlink(addr.sun_path);
    return -1;
  }
  if ((flags & FIO_SOCK_CLIENT)) {
    if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1 &&
        errno != EINPROGRESS) {
      FIO_LOG_DEBUG("couldn't connect unix client @ %s : %s",
                    addr.sun_path,
                    strerror(errno));
      fio_sock_close(fd);
      return -1;
    }
  } else {
    unlink(addr.sun_path);
    int btmp; // the bind result
#if !defined(FIO_SOCK_AVOID_UMASK)
    if ((flags & FIO_SOCK_UNIX_PRIVATE) == FIO_SOCK_UNIX) {
      int umask_org = umask(0x1FF);
      btmp = bind(fd, (struct sockaddr *)&addr, sizeof(addr));
      umask(umask_org);
      FIO_LOG_DEBUG("umask was used temporarily for Unix Socket (was 0x%04X)",
                    umask_org);
    } else
#endif /* FIO_SOCK_AVOID_UMASK */
      /* else */ btmp = bind(fd, (struct sockaddr *)&addr, sizeof(addr));
    if (btmp == -1) {
      FIO_LOG_DEBUG("couldn't bind unix socket to %s", address);
      fio_sock_close(fd);
      unlink(addr.sun_path);
      return -1;
    }
    if ((flags & FIO_SOCK_UNIX_PRIVATE) == FIO_SOCK_UNIX) {
      chmod(address, S_IRWXO | S_IRWXG | S_IRWXU);
      fchmod(fd, S_IRWXO | S_IRWXG | S_IRWXU);
    }
    if (!(flags & FIO_SOCK_UDP) && listen(fd, SOMAXCONN) < 0) {
      FIO_LOG_DEBUG("couldn't start listening to unix socket at %s", address);
      fio_sock_close(fd);
      unlink(addr.sun_path);
      return -1;
    }
  }
  return fd;
}
#else
SFUNC int fio_sock_open_unix(const char *address, uint16_t flags) {
  (void)address, (void)flags;
  FIO_ASSERT(0, "this system does not support Unix sockets.");
}
#endif /* AF_UNIX */

/* *****************************************************************************
WinSock initialization
***************************************************************************** */
#if FIO_OS_WIN
static WSADATA fio___sock_useless_windows_data;
FIO_CONSTRUCTOR(fio___sock_win_init) {
  static uint8_t flag = 0;
  if (!flag) {
    flag |= 1;
    if (WSAStartup(MAKEWORD(2, 2), &fio___sock_useless_windows_data)) {
      FIO_LOG_FATAL("WinSock2 unavailable.");
      exit(-1);
    }
    atexit((void (*)(void))(WSACleanup));
  }
}
#endif /* FIO_OS_WIN / FIO_OS_POSIX */

/* *****************************************************************************
Socket helper testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

FIO_SFUNC void FIO_NAME_TEST(stl, sock)(void) {
  fprintf(stderr,
          "* Testing socket helpers (FIO_SOCK) - partial tests only!\n");
  struct {
    const char *address;
    const char *port;
    const char *msg;
    uint16_t flag;
  } server_tests[] = {
      {"127.0.0.1", "9437", "TCP", FIO_SOCK_TCP},
#ifdef AF_UNIX
#ifdef P_tmpdir
      {P_tmpdir "/tmp_unix_testing_socket_facil_io.sock",
       NULL,
       "Unix",
       FIO_SOCK_UNIX},
#else
      {"./tmp_unix_testing_socket_facil_io.sock", NULL, "Unix", FIO_SOCK_UNIX},
#endif
#endif
      /* accept doesn't work with UDP, not like this... UDP test is seperate */
      // {"127.0.0.1", "9437", "UDP", FIO_SOCK_UDP},
      {.address = NULL},
  };
  for (size_t i = 0; server_tests[i].address; ++i) {
    short ev = (short)-1;
    errno = 0;
    fprintf(stderr, "* Testing %s socket API\n", server_tests[i].msg);
    int srv = fio_sock_open(server_tests[i].address,
                            server_tests[i].port,
                            server_tests[i].flag | FIO_SOCK_SERVER);
    FIO_ASSERT(srv != -1, "server socket failed to open: %s", strerror(errno));
    ev = fio_sock_wait_io(-1, POLLIN | POLLOUT, 0);
    FIO_ASSERT(!ev, "no error should have been returned for IO -1 (%d)", ev);
    ev = fio_sock_wait_io(srv, POLLIN, 0);
    FIO_ASSERT(!ev, "no events should have been returned (%d)", ev);
    int cl = fio_sock_open(server_tests[i].address,
                           server_tests[i].port,
                           server_tests[i].flag | FIO_SOCK_CLIENT);
    FIO_ASSERT(FIO_SOCK_FD_ISVALID(cl),
               "client socket failed to open (%d)",
               cl);
    ev = fio_sock_wait_io(cl, POLLIN /* | POLLOUT <= OS dependent */, 0);
    FIO_ASSERT(!ev,
               "no events should have been returned for connecting client(%d)",
               ev);
    ev = fio_sock_wait_io(srv, POLLIN, 100);
    FIO_ASSERT(ev == POLLIN,
               "incoming connection should have been detected (%d)",
               ev);
    intptr_t accepted = accept(srv, NULL, NULL);
    FIO_ASSERT(FIO_SOCK_FD_ISVALID(accepted),
               "accepted socket failed to open (%zd)",
               (ssize_t)accepted);
    ev = fio_sock_wait_io(cl, POLLIN | POLLOUT, 0);
    FIO_ASSERT(ev == POLLOUT,
               "POLLOUT should have been returned for connected client(%d)",
               ev);
    ev = fio_sock_wait_io(accepted, POLLIN | POLLOUT, 0);
    FIO_ASSERT(ev == POLLOUT,
               "POLLOUT should have been returned for connected client 2(%d)",
               ev);
    if (fio_sock_write(accepted, "hello", 5) > 0) {
      // wait for read
      FIO_ASSERT(
          fio_sock_wait_io(cl, POLLIN, 10) != -1 &&
              ((fio_sock_wait_io(cl, POLLIN | POLLOUT, 0) & POLLIN) == POLLIN),
          "fio_sock_wait_io should have returned a POLLIN event for client.");
      {
        char buf[64];
        errno = 0;
        FIO_ASSERT(fio_sock_read(cl, buf, 64) > 0,
                   "Read should have read some data...\n\t"
                   "error: %s",
                   strerror(errno));
      }
      FIO_ASSERT(!fio_sock_wait_io(cl, POLLIN, 0),
                 "No events should have occurred here! (%zu)",
                 ev);
    } else {
      FIO_ASSERT(0,
                 "send(fd:%ld) failed! error: %s",
                 accepted,
                 strerror(errno));
    }
    fio_sock_close(accepted);
    fio_sock_close(cl);
    fio_sock_close(srv);
    FIO_ASSERT((fio_sock_wait_io(cl, POLLIN | POLLOUT, 0) & POLLNVAL),
               "POLLNVAL should have been returned for closed socket (%d & %d) "
               "(POLLERR == %d)",
               fio_sock_wait_io(cl, POLLIN | POLLOUT, 0),
               (int)POLLNVAL,
               (int)POLLERR);
#ifdef AF_UNIX
    if (FIO_SOCK_UNIX == server_tests[i].flag)
      unlink(server_tests[i].address);
#endif
  }
  {
    /* UDP semi test */
    fprintf(stderr, "* Testing UDP socket (abbreviated test)\n");
    int srv =
        fio_sock_open("127.0.0.1", "9437", FIO_SOCK_UDP | FIO_SOCK_SERVER);
    int n = 0; /* try for 32Mb */
    socklen_t sn = sizeof(n);
    if (-1 != getsockopt(srv, SOL_SOCKET, SO_RCVBUF, (void *)&n, &sn) &&
        sizeof(n) == sn)
      fprintf(stderr, "\t- UDP default receive buffer is %d bytes\n", n);
    n = 32 * 1024 * 1024; /* try for 32Mb */
    sn = sizeof(n);
    while (setsockopt(srv, SOL_SOCKET, SO_RCVBUF, (void *)&n, sn) == -1) {
      /* failed - repeat attempt at 0.5Mb interval */
      if (n >= (1024 * 1024)) // OS may have returned max value
        n -= 512 * 1024;
      else
        break;
    }
    if (-1 != getsockopt(srv, SOL_SOCKET, SO_RCVBUF, (void *)&n, &sn) &&
        sizeof(n) == sn)
      fprintf(stderr, "\t- UDP receive buffer could be set to %d bytes\n", n);
    FIO_ASSERT(srv != -1,
               "Couldn't open UDP server socket: %s",
               strerror(errno));
    FIO_LOG_INFO("Opening client UDP socket.");
    int cl = fio_sock_open("127.0.0.1", "9437", FIO_SOCK_UDP | FIO_SOCK_CLIENT);
    FIO_ASSERT(cl != -1,
               "Couldn't open UDP client socket: %s",
               strerror(errno));
    FIO_LOG_INFO("Starting UDP roundtrip.");
    FIO_ASSERT(fio_sock_write(cl, "hello", 5) != -1,
               "couldn't send datagram from client");
    char buf[64];
    FIO_LOG_INFO("Receiving UDP msg.");
    FIO_ASSERT(recvfrom(srv, buf, 64, 0, NULL, NULL) != -1,
               "couldn't read datagram");
    FIO_ASSERT(!memcmp(buf, "hello", 5), "transmission error");
    FIO_LOG_INFO("cleaning up UDP sockets.");
    fio_sock_close(srv);
    fio_sock_close(cl);
  }
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
FIO_SOCK - cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_SOCK
#endif
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_STREAM     /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




      A packet based data stream for storing / buffering endless data.



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_STREAM) && !defined(H___FIO_STREAM___H)
#define H___FIO_STREAM___H

#if !FIO_HAVE_UNIX_TOOLS
#if _MSC_VER
#pragma message("POSIX behavior is expected by the fio_stream API.")
#else
#warning "POSIX behavior is expected by the fio_stream API."
#endif
#endif /* FIO_HAVE_UNIX_TOOLS */
#include <sys/stat.h>

#ifndef FIO_STREAM_COPY_PER_PACKET
/** Break apart large memory blocks into smaller pieces. by default 96Kb */
#define FIO_STREAM_COPY_PER_PACKET 98304
#endif

/* *****************************************************************************
Stream API - types, constructor / destructor
***************************************************************************** */

typedef struct fio_stream_packet_s fio_stream_packet_s;

typedef struct {
  /* do not directly acecss! */
  fio_stream_packet_s *next;
  fio_stream_packet_s **pos;
  size_t consumed;
  size_t length;
} fio_stream_s;

/* at this point publish (declare only) the public API */

#ifndef FIO_STREAM_INIT
/* Initialization macro. */
#define FIO_STREAM_INIT(s)                                                     \
  { .next = NULL, .pos = &(s).next }
#endif

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY

/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC fio_stream_s *fio_stream_new(void);

/* Frees any internal data AND the object's container! */
FIO_IFUNC int fio_stream_free(fio_stream_s *stream);

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/** Destroys the object, re-initializing its container. */
SFUNC void fio_stream_destroy(fio_stream_s *stream);

/* *****************************************************************************
Stream API - packing data into packets and adding it to the stream
***************************************************************************** */

/** Packs data into a fio_stream_packet_s container. */
SFUNC fio_stream_packet_s *fio_stream_pack_data(void *buf,
                                                size_t len,
                                                size_t offset,
                                                uint8_t copy_buffer,
                                                void (*dealloc_func)(void *));

/** Packs a file descriptor into a fio_stream_packet_s container. */
SFUNC fio_stream_packet_s *fio_stream_pack_fd(int fd,
                                              size_t len,
                                              size_t offset,
                                              uint8_t keep_open);

/** Adds a packet to the stream. This isn't thread safe.*/
SFUNC void fio_stream_add(fio_stream_s *stream, fio_stream_packet_s *packet);

/** Destroys the fio_stream_packet_s - call this ONLY if unused. */
SFUNC void fio_stream_pack_free(fio_stream_packet_s *packet);

/* *****************************************************************************
Stream API - Consuming the stream
***************************************************************************** */

/**
 * Reads data from the stream (if any), leaving it in the stream.
 *
 * `buf` MUST point to a buffer with - at least - `len` bytes. This is required
 * in case the packed data is fragmented or references a file and needs to be
 * copied to an available buffer.
 *
 * On error, or if the stream is empty, `buf` will be set to NULL and `len` will
 * be set to zero.
 *
 * Otherwise, `buf` may retain the same value or it may point directly to a
 * memory address within the stream's buffer (the original value may be lost)
 * and `len` will be updated to the largest possible value for valid data that
 * can be read from `buf`.
 *
 * Note: this isn't thread safe.
 */
SFUNC void fio_stream_read(fio_stream_s *stream, char **buf, size_t *len);

/**
 * Advances the Stream, so the first `len` bytes are marked as consumed.
 *
 * Note: this isn't thread safe.
 */
SFUNC void fio_stream_advance(fio_stream_s *stream, size_t len);

/**
 * Returns true if there's any data in the stream.
 *
 * Note: this isn't truly thread safe.
 */
FIO_IFUNC uint8_t fio_stream_any(fio_stream_s *stream);

/**
 * Returns the number of bytes waiting in the stream.
 *
 * Note: this isn't truly thread safe.
 */
FIO_IFUNC uint32_t fio_stream_length(fio_stream_s *stream);

/* *****************************************************************************








                          Stream Implementation








***************************************************************************** */

/* *****************************************************************************
Stream Implementation - inlined static functions
***************************************************************************** */

#if FIO_OS_WIN && _MSC_VER && !defined(fstat)
#define fstat           _fstat64
#define FIO_FSTAT_UNDEF 1
#endif /* FIO_OS_WIN && _MSC_VER */

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY
/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC fio_stream_s *fio_stream_new(void) {
  fio_stream_s *s = (fio_stream_s *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*s), 0);
  if (s) {
    *s = (fio_stream_s)FIO_STREAM_INIT(s[0]);
  }
  return s;
}
/* Frees any internal data AND the object's container! */
FIO_IFUNC int fio_stream_free(fio_stream_s *s) {
  fio_stream_destroy(s);
  FIO_MEM_FREE_(s, sizeof(*s));
  return 0;
}
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/* Returns true if there's any data in the stream */
FIO_IFUNC uint8_t fio_stream_any(fio_stream_s *s) { return s && !!s->next; }

/* Returns the number of bytes waiting in the stream */
FIO_IFUNC uint32_t fio_stream_length(fio_stream_s *s) { return s->length; }

/* *****************************************************************************
Stream Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_IFUNC void fio_stream_packet_free_all(fio_stream_packet_s *p);
/* Frees any internal data AND the object's container! */
SFUNC void fio_stream_destroy(fio_stream_s *s) {
  if (!s)
    return;
  fio_stream_packet_free_all(s->next);
  *s = (fio_stream_s)FIO_STREAM_INIT(s[0]);
  return;
}

/* *****************************************************************************
Stream API - packing data into packets and adding it to the stream
***************************************************************************** */

struct fio_stream_packet_s {
  fio_stream_packet_s *next;
};

typedef enum {
  FIO_PACKET_TYPE_EMBEDDED = 0,
  FIO_PACKET_TYPE_EXTERNAL = 1,
  FIO_PACKET_TYPE_FILE = 2,
  FIO_PACKET_TYPE_FILE_NO_CLOSE = 3,
} fio_stream_packet_type_e;
#define FIO_STREAM___TYPE_BITS 2

typedef struct fio_stream_packet_embd_s {
  uint32_t type;
  char buf[];
} fio_stream_packet_embd_s;

typedef struct fio_stream_packet_extrn_s {
  uint32_t type;
  uint32_t length;
  char *buf;
  uintptr_t offset;
  void (*dealloc)(void *buf);
} fio_stream_packet_extrn_s;

/** User-space socket buffer data */
typedef struct {
  uint32_t type;
  uint32_t length;
  int32_t offset;
  int fd;
} fio_stream_packet_fd_s;

FIO_SFUNC void fio_stream_packet_free(fio_stream_packet_s *p) {
  if (!p)
    return;
  union {
    fio_stream_packet_embd_s *em;
    fio_stream_packet_extrn_s *ext;
    fio_stream_packet_fd_s *f;
  } const u = {.em = (fio_stream_packet_embd_s *)(p + 1)};
  switch ((fio_stream_packet_type_e)(u.em->type &
                                     ((1UL << FIO_STREAM___TYPE_BITS) - 1))) {
  case FIO_PACKET_TYPE_EMBEDDED:
    FIO_MEM_FREE_(p,
                  sizeof(*p) + sizeof(*u.em) +
                      (sizeof(char) * (u.em->type >> FIO_STREAM___TYPE_BITS)));
    break;
  case FIO_PACKET_TYPE_EXTERNAL:
    if (u.ext->dealloc)
      u.ext->dealloc(u.ext->buf);
    FIO_MEM_FREE_(p, sizeof(*p) + sizeof(*u.ext));
    break;
  case FIO_PACKET_TYPE_FILE:
    close(u.f->fd);
    /* fall through */
  case FIO_PACKET_TYPE_FILE_NO_CLOSE:
    FIO_MEM_FREE_(p, sizeof(*p) + sizeof(*u.f));
    break;
  }
}

FIO_IFUNC void fio_stream_packet_free_all(fio_stream_packet_s *p) {
  while (p) {
    register fio_stream_packet_s *t = p;
    p = p->next;
    fio_stream_packet_free(t);
  }
}

FIO_IFUNC size_t fio___stream_p2len(fio_stream_packet_s *p) {
  size_t len = 0;
  if (!p)
    return len;
  union {
    fio_stream_packet_embd_s *em;
    fio_stream_packet_extrn_s *ext;
    fio_stream_packet_fd_s *f;
  } const u = {.em = (fio_stream_packet_embd_s *)(p + 1)};

  switch ((fio_stream_packet_type_e)(u.em->type &
                                     ((1UL << FIO_STREAM___TYPE_BITS) - 1))) {
  case FIO_PACKET_TYPE_EMBEDDED:
    len = u.em->type >> FIO_STREAM___TYPE_BITS;
    return len;
  case FIO_PACKET_TYPE_EXTERNAL: len = u.ext->length; return len;
  case FIO_PACKET_TYPE_FILE: /* fall through */
  case FIO_PACKET_TYPE_FILE_NO_CLOSE: len = u.f->length; return len;
  }
  return len;
}
/** Packs data into a fio_stream_packet_s container. */
SFUNC fio_stream_packet_s *fio_stream_pack_data(void *buf,
                                                size_t len,
                                                size_t offset,
                                                uint8_t copy_buffer,
                                                void (*dealloc_func)(void *)) {
  fio_stream_packet_s *p = NULL;
  if (!len || !buf || (len & ((~(0UL)) << (32 - FIO_STREAM___TYPE_BITS))))
    goto error;
  if (copy_buffer || len <= 14) {
    while (len) {
      /* break apart large memory blocks into smaller pieces */
      const size_t slice =
          (len > FIO_STREAM_COPY_PER_PACKET) ? FIO_STREAM_COPY_PER_PACKET : len;
      fio_stream_packet_embd_s *em;
      fio_stream_packet_s *tmp = (fio_stream_packet_s *)FIO_MEM_REALLOC_(
          NULL,
          0,
          sizeof(*p) + sizeof(*em) + (sizeof(char) * slice),
          0);
      if (!tmp)
        goto error;
      tmp->next = p;
      em = (fio_stream_packet_embd_s *)(tmp + 1);
      em->type = (uint32_t)FIO_PACKET_TYPE_EMBEDDED |
                 (uint32_t)(slice << FIO_STREAM___TYPE_BITS);
      FIO_MEMCPY(em->buf, (char *)buf + offset + (len - slice), slice);
      p = tmp;
      len -= slice;
    }
    if (dealloc_func)
      dealloc_func(buf);
  } else {
    fio_stream_packet_extrn_s *ext;
    p = (fio_stream_packet_s *)
        FIO_MEM_REALLOC_(NULL, 0, sizeof(*p) + sizeof(*ext), 0);
    if (!p)
      goto error;
    p->next = NULL;
    ext = (fio_stream_packet_extrn_s *)(p + 1);
    *ext = (fio_stream_packet_extrn_s){
        .type = FIO_PACKET_TYPE_EXTERNAL,
        .length = (uint32_t)len,
        .buf = (char *)buf,
        .offset = offset,
        .dealloc = dealloc_func,
    };
  }
  return p;

error:
  if (dealloc_func)
    dealloc_func(buf);
  fio_stream_packet_free_all(p);
  return p;
}

/** Packs a file descriptor into a fio_stream_packet_s container. */
SFUNC fio_stream_packet_s *fio_stream_pack_fd(int fd,
                                              size_t len,
                                              size_t offset,
                                              uint8_t keep_open) {
  fio_stream_packet_s *p = NULL;
  fio_stream_packet_fd_s *f;
  if (fd < 0)
    goto no_file;

  if (!len) {
    /* review file total length and auto-calculate */
    struct stat st;
    if (fstat(fd, &st))
      goto error;
    if (st.st_size <= 0 || offset >= (size_t)st.st_size ||
        (uint64_t)st.st_size >= ((uint64_t)1UL << 32))
      goto error;
    len = (size_t)st.st_size - offset;
  }

  p = (fio_stream_packet_s *)
      FIO_MEM_REALLOC_(NULL, 0, sizeof(*p) + sizeof(*f), 0);
  if (!p)
    goto error;
  p->next = NULL;
  f = (fio_stream_packet_fd_s *)(p + 1);
  *f = (fio_stream_packet_fd_s){
      .type =
          (keep_open ? FIO_PACKET_TYPE_FILE : FIO_PACKET_TYPE_FILE_NO_CLOSE),
      .length = (uint32_t)len,
      .offset = (int32_t)offset,
      .fd = fd,
  };
  return p;
error:
  if (!keep_open)
    close(fd);
no_file:
  return p;
}

/** Adds a packet to the stream. This isn't thread safe.*/
SFUNC void fio_stream_add(fio_stream_s *s, fio_stream_packet_s *p) {
  fio_stream_packet_s *last = p;
  size_t len = 0;

  if (!s || !p)
    goto error;
  len = fio___stream_p2len(p);

  while (last->next) {
    last = last->next;
    len += fio___stream_p2len(last);
  }
  if (!s->pos)
    s->pos = &s->next;
  *s->pos = p;
  s->pos = &last->next;
  s->length += len;
  return;
error:
  fio_stream_pack_free(p);
}

/** Destroys the fio_stream_packet_s - call this ONLY if unused. */
SFUNC void fio_stream_pack_free(fio_stream_packet_s *p) {
  fio_stream_packet_free_all(p);
}

/* *****************************************************************************
Stream API - Consuming the stream
***************************************************************************** */

FIO_SFUNC void fio___stream_read_internal(fio_stream_packet_s *p,
                                          char **buf,
                                          size_t *len,
                                          size_t buf_offset,
                                          size_t offset,
                                          size_t must_copy) {
  if (!p || !len[0]) {
    len[0] = 0;
    return;
  }
  union {
    fio_stream_packet_embd_s *em;
    fio_stream_packet_extrn_s *ext;
    fio_stream_packet_fd_s *f;
  } const u = {.em = (fio_stream_packet_embd_s *)(p + 1)};
  size_t written = 0;

  switch ((fio_stream_packet_type_e)(u.em->type &
                                     ((1UL << FIO_STREAM___TYPE_BITS) - 1))) {
  case FIO_PACKET_TYPE_EMBEDDED:
    if (!buf[0] || !len[0] ||
        (!must_copy && (!p->next || (u.em->type >> FIO_STREAM___TYPE_BITS) >=
                                        len[0] + offset))) {
      buf[0] = u.em->buf + offset;
      len[0] = (size_t)(u.em->type >> FIO_STREAM___TYPE_BITS) - offset;
      return;
    }
    written = (u.em->type >> FIO_STREAM___TYPE_BITS) - offset;
    if (written > len[0])
      written = len[0];
    if (written) {
      FIO_MEMCPY(buf[0] + buf_offset, u.em->buf + offset, written);
      len[0] -= written;
    }
    if (len[0]) {
      fio___stream_read_internal(p->next, buf, len, written + buf_offset, 0, 1);
    }
    len[0] += written;
    return;
  case FIO_PACKET_TYPE_EXTERNAL:
    if (!buf[0] || !len[0] ||
        (!must_copy && (!p->next || u.ext->length >= len[0] + offset))) {
      buf[0] = u.ext->buf + u.ext->offset + offset;
      len[0] = (size_t)(u.ext->length) - offset;
      return;
    }
    written = u.ext->length - offset;
    if (written > len[0])
      written = len[0];
    if (written) {
      FIO_MEMCPY(buf[0] + buf_offset,
                 u.ext->buf + u.ext->offset + offset,
                 written);
      len[0] -= written;
    }
    if (len[0]) {
      fio___stream_read_internal(p->next, buf, len, written + buf_offset, 0, 1);
    }
    len[0] += written;
    return;
    break;
  case FIO_PACKET_TYPE_FILE: /* fall through */
  case FIO_PACKET_TYPE_FILE_NO_CLOSE:
    if (!buf[0] || !len[0]) {
      buf[0] = NULL;
      len[0] = 0;
      return;
    }
    {
      uint8_t possible_eol_surprise = 0;
      written = u.f->length - offset;
      if (written > len[0])
        written = len[0];
      if (written) {
        ssize_t act;
      retry_on_signal:
        act =
            pread(u.f->fd, buf[0] + buf_offset, written, u.f->offset + offset);
        if (act <= 0) {
          /* no more data in the file? */
          FIO_LOG_DEBUG("file read error for %d: %s", u.f->fd, strerror(errno));
          if (errno == EINTR)
            goto retry_on_signal;
          u.f->length = offset;
        } else if ((size_t)act != written) {
          /* a surprising EOF? */
          written = act;
          possible_eol_surprise = 1;
        }
        len[0] -= written;
      }
      if (!possible_eol_surprise && len[0]) {
        fio___stream_read_internal(p->next,
                                   buf,
                                   len,
                                   written + buf_offset,
                                   0,
                                   1);
      }
      len[0] += written;
    }
    return;
  }
}

/**
 * Reads data from the stream (if any), leaving it in the stream.
 *
 * `buf` MUST point to a buffer with - at least - `len` bytes. This is required
 * in case the packed data is fragmented or references a file and needs to be
 * copied to an available buffer.
 *
 * On error, or if the stream is empty, `buf` will be set to NULL and `len` will
 * be set to zero.
 *
 * Otherwise, `buf` may retain the same value or it may point directly to a
 * memory address wiithin the stream's buffer (the original value may be lost)
 * and `len` will be updated to the largest possible value for valid data that
 * can be read from `buf`.
 *
 * Note: this isn't thread safe.
 */
SFUNC void fio_stream_read(fio_stream_s *s, char **buf, size_t *len) {
  if (!s || !s->next)
    goto none;
  fio___stream_read_internal(s->next, buf, len, 0, s->consumed, 0);
  return;
none:
  *buf = NULL;
  *len = 0;
}

/**
 * Advances the Stream, so the first `len` bytes are marked as consumed.
 *
 * Note: this isn't thread safe.
 */
SFUNC void fio_stream_advance(fio_stream_s *s, size_t len) {
  if (!s || !s->next)
    return;
  s->length -= len;
  len += s->consumed;
  while (len) {
    size_t p_len = fio___stream_p2len(s->next);
    if (len >= p_len) {
      fio_stream_packet_s *p = s->next;
      s->next = p->next;
      fio_stream_packet_free(p);
      len -= p_len;
      if (!s->next) {
        s->pos = &s->next;
        s->consumed = 0;
        s->length = 0;
        return;
      }
    } else {
      s->consumed = len;
      return;
    }
  }
  s->consumed = len;
}

/* *****************************************************************************
Stream Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

FIO_SFUNC size_t FIO_NAME_TEST(stl, stream___noop_dealloc_count) = 0;
FIO_SFUNC void FIO_NAME_TEST(stl, stream___noop_dealloc)(void *ignr_) {
  fio_atomic_add(&FIO_NAME_TEST(stl, stream___noop_dealloc_count), 1);
  (void)ignr_;
}

FIO_SFUNC void FIO_NAME_TEST(stl, stream)(void) {
  char *const str =
      (char *)"My Hello World string should be long enough so it can be used "
              "for testing the stream functionality in the facil.io stream "
              "module. The stream moduule takes strings and failes and places "
              "them (by reference / copy) into a linked list of objects. When "
              "data is requested from the stream, the stream will either copy "
              "the data to a pre-allocated buffer or it may update the link to "
              "it points to its own internal buffer (avoiding a copy when "
              "possible).";
  fio_stream_s s = FIO_STREAM_INIT(s);
  char mem[4000];
  char *buf = mem;
  size_t len = 4000;
  size_t expect_dealloc = FIO_NAME_TEST(stl, stream___noop_dealloc_count);

  fprintf(stderr, "* Testing fio_stream for streaming buffer storage.\n");
  fio_stream_add(
      &s,
      fio_stream_pack_data(str,
                           11,
                           3,
                           1,
                           FIO_NAME_TEST(stl, stream___noop_dealloc)));
  ++expect_dealloc;
  FIO_ASSERT(fio_stream_any(&s),
             "stream is empty after `fio_stream_add` (data, copy)");
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "copying a packet should deallocate the original");
  for (int i = 0; i < 3; ++i) {
    /* test that read operrations are immutable */
    buf = mem;
    len = 4000;

    fio_stream_read(&s, &buf, &len);
    FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) ==
                   expect_dealloc,
               "reading a packet shouldn't deallocate anything");
    FIO_ASSERT(len == 11,
               "fio_stream_read didn't read all data from stream? (%zu)",
               len);
    FIO_ASSERT(!memcmp(str + 3, buf, len),
               "fio_stream_read data error? (%.*s)",
               (int)len,
               buf);
    FIO_ASSERT_DEBUG(
        buf != mem,
        "fio_stream_read should have been performed with zero-copy");
  }
  fio_stream_advance(&s, len);
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "advancing an embedded packet shouldn't deallocate anything");
  FIO_ASSERT(
      !fio_stream_any(&s),
      "after advance, at this point, the stream should have been consumed.");
  buf = mem;
  len = 4000;
  fio_stream_read(&s, &buf, &len);
  FIO_ASSERT(
      !buf && !len,
      "reading from an empty stream should set buf and len to NULL and zero.");
  fio_stream_destroy(&s);
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "destroying an empty stream shouldn't deallocate anything");
  FIO_ASSERT(!fio_stream_any(&s), "destroyed stream should be empty.");

  fio_stream_add(&s, fio_stream_pack_data(str, 11, 0, 1, NULL));
  fio_stream_add(
      &s,
      fio_stream_pack_data(str,
                           49,
                           11,
                           0,
                           FIO_NAME_TEST(stl, stream___noop_dealloc)));
  fio_stream_add(&s, fio_stream_pack_data(str, 20, 60, 0, NULL));

  FIO_ASSERT(fio_stream_any(&s), "stream with data shouldn't be empty.");
  FIO_ASSERT(fio_stream_length(&s) == 80, "stream length error.");
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "adding a stream shouldn't deallocate it.");

  buf = mem;
  len = 4000;
  fio_stream_read(&s, &buf, &len);

  FIO_ASSERT(len == 80,
             "fio_stream_read didn't read all data from stream(2)? (%zu)",
             len);
  FIO_ASSERT(!memcmp(str, buf, len),
             "fio_stream_read data error? (%.*s)",
             (int)len,
             buf);
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "reading a stream shouldn't deallocate any packets.");

  buf = mem;
  len = 8;
  fio_stream_read(&s, &buf, &len);

  FIO_ASSERT(len < 80,
             "fio_stream_read didn't perform a partial read? (%zu)",
             len);
  FIO_ASSERT(!memcmp(str, buf, len),
             "fio_stream_read partial read data error? (%.*s)",
             (int)len,
             buf);
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "failing to read a stream shouldn't deallocate any packets.");

  fio_stream_advance(&s, 20);
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "partial advancing shouldn't deallocate any packets.");
  FIO_ASSERT(fio_stream_length(&s) == 60, "stream length error (2).");
  buf = mem;
  len = 4000;
  fio_stream_read(&s, &buf, &len);
  FIO_ASSERT(len == 60,
             "fio_stream_read didn't read all data from stream(3)? (%zu)",
             len);
  FIO_ASSERT(!memcmp(str + 20, buf, len),
             "fio_stream_read data error? (%.*s)",
             (int)len,
             buf);
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "reading shouldn't deallocate packets the head packet.");

  fio_stream_add(&s, fio_stream_pack_fd(open(__FILE__, O_RDONLY), 20, 0, 0));
  FIO_ASSERT(fio_stream_length(&s) == 80, "stream length error (3).");
  buf = mem;
  len = 4000;
  fio_stream_read(&s, &buf, &len);
  FIO_ASSERT(len == 80,
             "fio_stream_read didn't read all data from stream(4)? (%zu)",
             len);
  FIO_ASSERT(!memcmp("/* *****************", buf + 60, 20),
             "fio_stream_read file read data error?\n%.*s",
             (int)len,
             buf);
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "reading more than one packet shouldn't deallocate anything.");
  buf = mem;
  len = 4000;
  fio_stream_read(&s, &buf, &len);
  FIO_ASSERT(len == 80,
             "fio_stream_read didn't (re)read all data from stream(5)? (%zu)",
             len);
  FIO_ASSERT(!memcmp("/* *****************", buf + 60, 20),
             "fio_stream_read file (re)read data error? (%.*s)",
             (int)len,
             buf);

  fio_stream_destroy(&s);
  ++expect_dealloc;

  FIO_ASSERT(!fio_stream_any(&s), "destroyed stream should be empty.");
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "destroying a stream should deallocate it's packets.");
  fio_stream_add(
      &s,
      fio_stream_pack_data(str,
                           49,
                           11,
                           0,
                           FIO_NAME_TEST(stl, stream___noop_dealloc)));
  buf = mem;
  len = 4000;
  fio_stream_read(&s, &buf, &len);
  FIO_ASSERT(len == 49,
             "fio_stream_read didn't read all data from stream? (%zu)",
             len);
  FIO_ASSERT(!memcmp(str + 11, buf, len),
             "fio_stream_read data error? (%.*s)",
             (int)len,
             buf);
  fio_stream_advance(&s, 80);
  ++expect_dealloc;
  FIO_ASSERT(FIO_NAME_TEST(stl, stream___noop_dealloc_count) == expect_dealloc,
             "partial advancing shouldn't deallocate any packets.");
  FIO_ASSERT(!fio_stream_any(&s), "stream should be empty at this point.");
  FIO_ASSERT(!fio_stream_length(&s),
             "stream length should be zero at this point.");
  fio_stream_destroy(&s);
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */
#ifdef FIO_FSTAT_UNDEF
#undef FIO_FSTAT_UNDEF
#undef fstat
#endif

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_STREAM___TYPE_BITS
#endif /* FIO_STREAM */
#undef FIO_STREAM
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_SIGNAL     /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                              Signal Monitoring



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_SIGNAL) && !defined(H___FIO_SIGNAL___H)
#define H___FIO_SIGNAL___H

#ifndef FIO_SIGNAL_MONITOR_MAX
/* The maximum number of signals the implementation will be able to monitor */
#define FIO_SIGNAL_MONITOR_MAX 24
#endif

#if !(FIO_OS_POSIX) && !(FIO_OS_WIN) /* use FIO_HAVE_UNIX_TOOLS instead? */
#error Either POSIX or Windows are required for the fio_signal API.
#endif

#include <signal.h>
/* *****************************************************************************
Signal Monitoring API
***************************************************************************** */

/**
 * Starts to monitor for the specified signal, setting an optional callback.
 */
SFUNC int fio_signal_monitor(int sig,
                             void (*callback)(int sig, void *),
                             void *udata);

/** Reviews all signals, calling any relevant callbacks. */
SFUNC int fio_signal_review(void);

/** Stops monitoring the specified signal. */
SFUNC int fio_signal_forget(int sig);

/* *****************************************************************************




                          Signal Monitoring Implementation




***************************************************************************** */

/* *****************************************************************************
Signal Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
POSIX implementation
***************************************************************************** */
#ifdef FIO_OS_POSIX

static struct {
  int32_t sig;
  volatile int32_t flag;
  void (*callback)(int sig, void *);
  void *udata;
  struct sigaction old;
} fio___signal_watchers[FIO_SIGNAL_MONITOR_MAX];

FIO_SFUNC void fio___signal_catcher(int sig) {
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].sig && !fio___signal_watchers[i].udata)
      return; /* initialized list is finishe */
    if (fio___signal_watchers[i].sig != sig)
      continue;
    /* mark flag */
    fio_atomic_exchange(&fio___signal_watchers[i].flag, 1);
    /* pass-through if exists */
    if (fio___signal_watchers[i].old.sa_handler != SIG_IGN &&
        fio___signal_watchers[i].old.sa_handler != SIG_DFL)
      fio___signal_watchers[i].old.sa_handler(sig);
    return;
  }
}

/**
 * Starts to monitor for the specified signal, setting an optional callback.
 */
SFUNC int fio_signal_monitor(int sig,
                             void (*callback)(int sig, void *),
                             void *udata) {
  if (!sig)
    return -1;
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    /* updating an existing monitor */
    if (fio___signal_watchers[i].sig == sig) {
      fio___signal_watchers[i].callback = callback;
      fio___signal_watchers[i].udata = udata;
      return 0;
    }
    /* slot busy */
    if (fio___signal_watchers[i].sig || fio___signal_watchers[i].callback)
      continue;
    /* place monitor in this slot */
    struct sigaction act;
    memset(&act, 0, sizeof(act));
    memset(fio___signal_watchers + i, 0, sizeof(fio___signal_watchers[i]));
    fio___signal_watchers[i].sig = sig;
    fio___signal_watchers[i].callback = callback;
    fio___signal_watchers[i].udata = udata;
    act.sa_handler = fio___signal_catcher;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_RESTART | SA_NOCLDSTOP;
    if (sigaction(sig, &act, &fio___signal_watchers[i].old)) {
      FIO_LOG_ERROR("couldn't set signal handler: %s", strerror(errno));
      fio___signal_watchers[i].callback = NULL;
      fio___signal_watchers[i].udata = (void *)1;
      fio___signal_watchers[i].sig = 0;
      return -1;
    }
    return 0;
  }
  return -1;
}

/** Stops monitoring the specified signal. */
SFUNC int fio_signal_forget(int sig) {
  if (!sig)
    return -1;
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].sig && !fio___signal_watchers[i].udata)
      return -1; /* initialized list is finishe */
    if (fio___signal_watchers[i].sig != sig)
      continue;
    fio___signal_watchers[i].callback = NULL;
    fio___signal_watchers[i].udata = (void *)1;
    fio___signal_watchers[i].sig = 0;
    struct sigaction act;
    memset(&act, 0, sizeof(act));
    if (sigaction(sig, &fio___signal_watchers[i].old, &act)) {
      FIO_LOG_ERROR("couldn't unset signal handler: %s", strerror(errno));
      return -1;
    }
    return 0;
  }
  return -1;
}

/* *****************************************************************************
Windows Implementation
***************************************************************************** */
#elif FIO_OS_WIN

static struct {
  int32_t sig;
  volatile int32_t flag;
  void (*callback)(int sig, void *);
  void *udata;
  void (*old)(int sig);
} fio___signal_watchers[FIO_SIGNAL_MONITOR_MAX];

FIO_SFUNC void fio___signal_catcher(int sig) {
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].sig && !fio___signal_watchers[i].udata)
      return; /* initialized list is finished */
    if (fio___signal_watchers[i].sig != sig)
      continue;
    /* mark flag */
    fio___signal_watchers[i].flag = 1;
    /* pass-through if exists */
    if (fio___signal_watchers[i].old &&
        (intptr_t)fio___signal_watchers[i].old != (intptr_t)SIG_IGN &&
        (intptr_t)fio___signal_watchers[i].old != (intptr_t)SIG_DFL) {
      fio___signal_watchers[i].old(sig);
      fio___signal_watchers[i].old = signal(sig, fio___signal_catcher);
    } else {
      fio___signal_watchers[i].old = signal(sig, fio___signal_catcher);
    }
    break;
  }
}

/**
 * Starts to monitor for the specified signal, setting an optional callback.
 */
SFUNC int fio_signal_monitor(int sig,
                             void (*callback)(int sig, void *),
                             void *udata) {
  if (!sig)
    return -1;
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    /* updating an existing monitor */
    if (fio___signal_watchers[i].sig == sig) {
      fio___signal_watchers[i].callback = callback;
      fio___signal_watchers[i].udata = udata;
      return 0;
    }
    /* slot busy */
    if (fio___signal_watchers[i].sig || fio___signal_watchers[i].callback)
      continue;
    /* place monitor in this slot */
    fio___signal_watchers[i].sig = sig;
    fio___signal_watchers[i].callback = callback;
    fio___signal_watchers[i].udata = udata;
    fio___signal_watchers[i].old = signal(sig, fio___signal_catcher);
    if ((intptr_t)SIG_ERR == (intptr_t)fio___signal_watchers[i].old) {
      fio___signal_watchers[i].sig = 0;
      fio___signal_watchers[i].callback = NULL;
      fio___signal_watchers[i].udata = (void *)1;
      fio___signal_watchers[i].old = NULL;
      FIO_LOG_ERROR("couldn't set signal handler: %s", strerror(errno));
      return -1;
    }
    return 0;
  }
  return -1;
}

/** Stops monitoring the specified signal. */
SFUNC int fio_signal_forget(int sig) {
  if (!sig)
    return -1;
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].sig && !fio___signal_watchers[i].udata)
      return -1; /* initialized list is finished */
    if (fio___signal_watchers[i].sig != sig)
      continue;
    fio___signal_watchers[i].callback = NULL;
    fio___signal_watchers[i].udata = (void *)1;
    fio___signal_watchers[i].sig = 0;
    if (fio___signal_watchers[i].old) {
      if ((intptr_t)signal(sig, fio___signal_watchers[i].old) ==
          (intptr_t)SIG_ERR)
        goto sig_error;
    } else {
      if ((intptr_t)signal(sig, SIG_DFL) == (intptr_t)SIG_ERR)
        goto sig_error;
    }
    return 0;
  }
  return -1;
sig_error:
  FIO_LOG_ERROR("couldn't unset signal handler: %s", strerror(errno));
  return -1;
}
#endif /* POSIX vs WINDOWS */

/* *****************************************************************************
Common OS implementation
***************************************************************************** */

/** Reviews all signals, calling any relevant callbacks. */
SFUNC int fio_signal_review(void) {
  int c = 0;
  for (size_t i = 0; i < FIO_SIGNAL_MONITOR_MAX; ++i) {
    if (!fio___signal_watchers[i].sig && !fio___signal_watchers[i].udata)
      return c;
    if (fio___signal_watchers[i].flag) {
      fio___signal_watchers[i].flag = 0;
      ++c;
      if (fio___signal_watchers[i].callback)
        fio___signal_watchers[i].callback(fio___signal_watchers[i].sig,
                                          fio___signal_watchers[i].udata);
    }
  }
  return c;
}

/* *****************************************************************************
Signal Monitoring Testing?
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, signal)(void) {

#define FIO___SIGNAL_MEMBER(a)                                                 \
  { (int)a, #a }
  struct {
    int sig;
    const char *name;
  } t[] = {
    FIO___SIGNAL_MEMBER(SIGINT),
    FIO___SIGNAL_MEMBER(SIGILL),
    FIO___SIGNAL_MEMBER(SIGABRT),
    FIO___SIGNAL_MEMBER(SIGSEGV),
    FIO___SIGNAL_MEMBER(SIGTERM),
#if FIO_OS_POSIX
    FIO___SIGNAL_MEMBER(SIGQUIT),
    FIO___SIGNAL_MEMBER(SIGHUP),
    FIO___SIGNAL_MEMBER(SIGTRAP),
    FIO___SIGNAL_MEMBER(SIGBUS),
    FIO___SIGNAL_MEMBER(SIGFPE),
    FIO___SIGNAL_MEMBER(SIGUSR1),
    FIO___SIGNAL_MEMBER(SIGUSR2),
    FIO___SIGNAL_MEMBER(SIGPIPE),
    FIO___SIGNAL_MEMBER(SIGALRM),
    FIO___SIGNAL_MEMBER(SIGCHLD),
    FIO___SIGNAL_MEMBER(SIGCONT),
#endif
  };
#undef FIO___SIGNAL_MEMBER
  size_t e = 0;
  fprintf(stderr, "* testing signal monitoring (setup / cleanup only).\n");
  for (size_t i = 0; i < sizeof(t) / sizeof(t[0]); ++i) {
    if (fio_signal_monitor(t[i].sig, NULL, NULL)) {
      FIO_LOG_ERROR("couldn't set signal monitoring for %s (%d)",
                    t[i].name,
                    t[i].sig);
      e = 1;
    }
  }
  for (size_t i = 0; i < sizeof(t) / sizeof(t[0]); ++i) {
    if (fio_signal_forget(t[i].sig)) {
      FIO_LOG_ERROR("couldn't stop signal monitoring for %s (%d)",
                    t[i].name,
                    t[i].sig);
      e = 1;
    }
  }
  FIO_ASSERT(!e, "signal monitoring error");
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_SIGNAL_MONITOR_MAX
#endif /* FIO_SIGNAL */
#undef FIO_SIGNAL
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_GLOB_MATCH /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                            Globe Matching



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_GLOB_MATCH) && !defined(H___FIO_GLOB_MATCH___H)
#define H___FIO_GLOB_MATCH___H

/* *****************************************************************************
Globe Matching API
***************************************************************************** */

/** A binary glob matching helper. Returns 1 on match, otherwise returns 0. */
SFUNC uint8_t fio_glob_match(fio_str_info_s pattern, fio_str_info_s string);

/* *****************************************************************************




                          Globe Matching Implementation




***************************************************************************** */

/* *****************************************************************************
Globe Matching Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
 * Glob Matching
 **************************************************************************** */

/** A binary glob matching helper. Returns 1 on match, otherwise returns 0. */
SFUNC uint8_t fio_glob_match(fio_str_info_s pat, fio_str_info_s str) {
  /* adapted and rewritten, with thankfulness, from the code at:
   * https://github.com/opnfv/kvmfornfv/blob/master/kernel/lib/glob.c
   *
   * Original version's copyright:
   * Copyright 2015 Open Platform for NFV Project, Inc. and its contributors
   * Under the MIT license.
   */

  /*
   * Backtrack to previous * on mismatch and retry starting one
   * character later in the string.  Because * matches all characters,
   * there's never a need to backtrack multiple levels.
   */
  uint8_t *back_pat = NULL, *back_str = (uint8_t *)str.buf;
  size_t back_pat_len = 0, back_str_len = str.len;

  /*
   * Loop over each token (character or class) in pat, matching
   * it against the remaining unmatched tail of str.  Return false
   * on mismatch, or true after matching the trailing nul bytes.
   */
  while (str.len && pat.len) {
    uint8_t c = *(uint8_t *)str.buf++;
    uint8_t d = *(uint8_t *)pat.buf++;
    str.len--;
    pat.len--;

    switch (d) {
    case '?': /* Wildcard: anything goes */ break;

    case '*':       /* Any-length wildcard */
      if (!pat.len) /* Optimize trailing * case */
        return 1;
      back_pat = (uint8_t *)pat.buf;
      back_pat_len = pat.len;
      back_str = (uint8_t *)--str.buf; /* Allow zero-length match */
      back_str_len = ++str.len;
      break;

    case '[': { /* Character class */
      uint8_t match = 0, inverted = (*(uint8_t *)pat.buf == '^' ||
                                     *(uint8_t *)pat.buf == '!');
      uint8_t *cls = (uint8_t *)pat.buf + inverted;
      uint8_t a = *cls++;

      /*
       * Iterate over each span in the character class.
       * A span is either a single character a, or a
       * range a-b.  The first span may begin with ']'.
       */
      do {
        uint8_t b = a;
        if (a == '\\') { /* when escaped, next character is regular */
          b = a = *(cls++);
        } else if (cls[0] == '-' && cls[1] != ']') {
          b = cls[1];

          cls += 2;
          if (a > b) {
            uint8_t tmp = a;
            a = b;
            b = tmp;
          }
        }
        match |= (a <= c && c <= b);
      } while ((a = *cls++) != ']');

      if (match == inverted)
        goto backtrack;
      pat.len -= cls - (uint8_t *)pat.buf;
      pat.buf = (char *)cls;

    } break;
    case '\\': d = *(uint8_t *)pat.buf++; pat.len--;
    /* fall through */
    default: /* Literal character */
      if (c == d)
        break;
    backtrack:
      if (!back_pat)
        return 0; /* No point continuing */
      /* Try again from last *, one character later in str. */
      pat.buf = (char *)back_pat;
      str.buf = (char *)++back_str;
      str.len = --back_str_len;
      pat.len = back_pat_len;
    }
  }
  /* if the trailing pattern allows for empty data, skip it */
  while (pat.len && pat.buf[0] == '*') {
    ++pat.buf;
    --pat.len;
  }
  return !str.len && !pat.len;
}

/* *****************************************************************************
Globe Matching Monitoring Testing?
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, glob_matching)(void) {
  struct {
    char *pat;
    char *str;
    uint8_t expect;
  } t[] = {
      // clang-format off
      /* test empty string */
      {.pat = (char *)"", .str = (char *)"", .expect = 1},
      /* test exact match */
      {.pat = (char *)"a", .str = (char *)"a", .expect = 1},
      /* test empty pattern */
      {.pat = (char *)"", .str = (char *)"a", .expect = 0},
      /* test longer pattern */
      {.pat = (char *)"a", .str = (char *)"", .expect = 0},
      /* test empty string with glob pattern */
      {.pat = (char *)"*", .str = (char *)"", .expect = 1},
      /* test glob pattern */
      {.pat = (char *)"*", .str = (char *)"Whatever", .expect = 1},
      /* test glob pattern at end */
      {.pat = (char *)"W*", .str = (char *)"Whatever", .expect = 1},
      /* test glob pattern as bookends */
      {.pat = (char *)"*Whatever*", .str = (char *)"Whatever", .expect = 1},
      /* test glob pattern in the middle */
      {.pat = (char *)"W*er", .str = (char *)"Whatever", .expect = 1},
      /* test glob pattern in the middle - empty match*/
      {.pat = (char *)"W*hatever", .str = (char *)"Whatever", .expect = 1},
      /* test glob pattern in the middle  - no match */
      {.pat = (char *)"W*htever", .str = (char *)"Whatever", .expect = 0},
      /* test partial match with glob at end */
      {.pat = (char *)"h*", .str = (char *)"Whatever", .expect = 0},
      /* test partial match with glob in the middle */
      {.pat = (char *)"h*er", .str = (char *)"Whatever", .expect = 0},
      /* test glob match with "?"  */
      {.pat = (char *)"?h*er", .str = (char *)"Whatever", .expect = 1},
      /* test "?" for length restrictions */
      {.pat = (char *)"?", .str = (char *)"Whatever", .expect = 0},
      /* test ? in the middle */
      {.pat = (char *)"What?ver", .str = (char *)"Whatever", .expect = 1},
      /* test letter list */
      {.pat = (char *)"[ASW]hat?ver", .str = (char *)"Whatever", .expect = 1},
      /* test letter range */
      {.pat = (char *)"[A-Z]hat?ver", .str = (char *)"Whatever", .expect = 1},
      /* test letter range (fail) */
      {.pat = (char *)"[a-z]hat?ver", .str = (char *)"Whatever", .expect = 0},
      /* test inverted letter range */
      {.pat = (char *)"[!a-z]hat?ver", .str = (char *)"Whatever", .expect = 1},
      /* test inverted list */
      {.pat = (char *)"[!F]hat?ver", .str = (char *)"Whatever", .expect = 1},
      /* test escaped range */
      {.pat = (char *)"[!a-z\\]]hat?ver", .str = (char *)"Whatever", .expect = 1},
      /* test "?" after range (no skip) */
      {.pat = (char *)"[A-Z]?at?ver", .str = (char *)"Whatever", .expect = 1},
      /* test error after range (no skip) */
      {.pat = (char *)"[A-Z]Fat?ver", .str = (char *)"Whatever", .expect = 0},
      /* end of test marker */
      {.pat = (char *)NULL, .str = (char *)NULL, .expect = 0},
      // clang-format on
  };
  fprintf(stderr, "* Testing glob matching.\n");
  for (size_t i = 0; t[i].pat; ++i) {
    fio_str_info_s p = FIO_STR_INFO1(t[i].pat);
    fio_str_info_s s = FIO_STR_INFO1(t[i].str);
    FIO_ASSERT(t[i].expect == fio_glob_match(p, s),
               "glob matching error for:\n\t String: %s\n\t Pattern: %s",
               s.buf,
               p.buf);
  }
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_GLOB_MATCH_MONITOR_MAX
#endif /* FIO_GLOB_MATCH */
#undef FIO_GLOB_MATCH
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_FILES      /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                   Common File Operations (POSIX style)



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_FILES) && !defined(H___FIO_FILES___H)
#define H___FIO_FILES___H

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

/* *****************************************************************************
File Helper API
***************************************************************************** */

/**
 * Opens `filename`, returning the same as values as `open` on POSIX systems.
 *
 * If `path` starts with a `"~/"` than it will be relative to the user's home
 * folder (on Windows, testing for `"~\"`).
 */
SFUNC int fio_filename_open(const char *filename, int flags);

/** Returns 1 if `path` does folds backwards (has "/../" or "//"). */
SFUNC int fio_filename_is_unsafe(const char *path);

/** Creates a temporary file, returning its file descriptor. */
SFUNC int fio_filename_tmp(void);

/**
 * Overwrites `filename` with the data in the buffer.
 *
 * If `path` starts with a `"~/"` than it will be relative to the user's home
 * folder (on Windows, testing for `"~\"`).
 *
 * Returns -1 on error or 0 on success. On error, the state of the file is
 * undefined (may be doesn't exit / nothing written / partially written).
 */
FIO_IFUNC int fio_filename_overwrite(const char *filename,
                                     const void *buf,
                                     size_t len);

/** Returns the file size (or 0 on both error / empty file). */
FIO_IFUNC size_t fio_filename_size(const char *filename);

/** Returns the file size (or 0 on both error / empty file). */
FIO_IFUNC size_t fio_fd_size(int fd);

/**
 * Returns the file type (or 0 on both error).
 *
 * See: https://www.man7.org/linux/man-pages/man7/inode.7.html
 */
FIO_IFUNC size_t fio_filename_type(const char *filename);

/**
 * Returns the file type (or 0 on both error).
 *
 * See: https://www.man7.org/linux/man-pages/man7/inode.7.html
 */
FIO_IFUNC size_t fio_fd_type(int fd);

/** Tests if `filename` references a folder. Returns -1 on error. */
#define fio_filename_is_folder(filename)                                       \
  (fio_filename_type((filename)) == S_IFDIR)

/**
 * Writes data to a file handle, returning the number of bytes written.
 *
 * Returns -1 on error.
 *
 * Since some systems have a limit on the number of bytes that can be written at
 * a time, this function fragments the system calls into smaller `write` blocks,
 * allowing large data to be written.
 *
 * If the file descriptor is non-blocking, test errno for EAGAIN / EWOULDBLOCK.
 */
FIO_IFUNC ssize_t fio_fd_write(int fd, const void *buf, size_t len);

/**
 * Reads up to `len` bytes from `fd`, returning the number of bytes read.
 *
 * Returns 0 if no bytes were read or on error.
 *
 * Since some systems have a limit on the number of bytes that can be read at
 * a time, this function fragments the system calls into smaller `read` blocks,
 * allowing large data to be read.
 *
 * If the file descriptor is non-blocking, test errno for EAGAIN / EWOULDBLOCK.
 */
FIO_IFUNC size_t fio_fd_read(int fd, void *buf, size_t len, off_t start_at);

/** A result type for the filename parsing helper. */
typedef struct {
  fio_buf_info_s folder;
  fio_buf_info_s basename;
  fio_buf_info_s ext;
} fio_filename_s;

/** Parses a file name to folder, base name and extension (zero-copy). */
SFUNC fio_filename_s fio_filename_parse(const char *filename);

/**
 * Returns offset for the next `token` in `fd`, or -1 if reached  EOF.
 *
 * This will use `FIO_FD_FIND_BLOCK` bytes on the stack to read the file in a
 * loop.
 *
 * Pros: limits memory use and (re)allocations, easier overflow protection.
 *
 * Cons: may be slower, as data will most likely be copied again from the file.
 */
SFUNC size_t fio_fd_find_next(int fd, char token, size_t start_at);
/** End of file value for `fio_fd_find_next` */
#define FIO_FD_FIND_EOF ((size_t)-1)
#ifndef FIO_FD_FIND_BLOCK
/** Size on the stack used by `fio_fd_find_next` for each read cycle. */
#define FIO_FD_FIND_BLOCK 4096
#endif

#if FIO_OS_WIN
#define FIO_FOLDER_SEPARATOR '\\'
#else
#define FIO_FOLDER_SEPARATOR '/'
#endif

/* *****************************************************************************
File Helper Inline Implementation
***************************************************************************** */

/**
 * Writes data to a file, returning the number of bytes written.
 *
 * Returns -1 on error.
 *
 * Since some systems have a limit on the number of bytes that can be written at
 * a single time, this function fragments the system calls into smaller `write`
 * blocks, allowing large data to be written.
 *
 * If the file descriptor is non-blocking, test errno for EAGAIN / EWOULDBLOCK.
 */
FIO_IFUNC ssize_t fio_fd_write(int fd, const void *buf_, size_t len) {
  ssize_t total = 0;
  const char *buf = (const char *)buf_;
  const size_t write_limit = (1ULL << 17);
  while (len > write_limit) {
    ssize_t w = write(fd, buf, write_limit);
    if (w > 0) {
      len -= w;
      buf += w;
      total += w;
      continue;
    }
    /* if (w == -1 && errno == EINTR) continue; */
    if (total == 0)
      return -1;
    return total;
  }
  while (len) {
    ssize_t w = write(fd, buf, len);
    if (w > 0) {
      len -= w;
      buf += w;
      continue;
    }
    if (total == 0)
      return -1;
    return total;
  }
  return total;
}

/**
 * Overwrites `filename` with the data in the buffer.
 *
 * If `path` starts with a `"~/"` than it will be relative to the user's home
 * folder (on Windows, testing for `"~\"`).
 */
FIO_IFUNC int fio_filename_overwrite(const char *filename,
                                     const void *buf,
                                     size_t len) {
  int fd = fio_filename_open(filename, O_RDWR | O_CREAT | O_TRUNC);
  if (fd == -1)
    return -1;
  ssize_t w = fio_fd_write(fd, buf, len);
  close(fd);
  if ((size_t)w != len)
    return -1;
  return 0;
}

/**
 * Reads up to `len` bytes from `fd`, returning the number of bytes read.
 *
 * Since some systems have a limit on the number of bytes that can be read at
 * a time, this function fragments the system calls into smaller `read` blocks,
 * allowing large data to be read.
 *
 * If the file descriptor is non-blocking, test errno for EAGAIN / EWOULDBLOCK.
 */
FIO_IFUNC size_t fio_fd_read(int fd, void *buf, size_t len, off_t start_at) {
  char *d = (char *)buf;
  size_t r = 0;
  for (;;) {
    /* use read sizes of up to 27 bits */
    const size_t to_read =
        (len & (((size_t)1 << 27) - 1)) | ((!!(len >> 27)) << 27);
    ssize_t act;
    if ((act = pread(fd, d + r, to_read, start_at)) > 0) {
      r += act;
      len -= act;
      start_at += act;
      if (!len)
        return r;
      continue;
    }
    if (act == -1 && errno == EINTR)
      continue;
    return r;
  }
}

/* *****************************************************************************
File Stat In-lined Helpers
***************************************************************************** */

FIO_IFUNC size_t fio_filename_size(const char *filename) {
  size_t r = 0;
  struct stat stt;
  if (stat(filename, &stt))
    return r;
  return (r = stt.st_size);
}

FIO_IFUNC size_t fio_fd_size(int fd) {
  size_t r = 0;
  struct stat stt;
  if (fd == -1)
    return r;
  if (fstat(fd, &stt))
    return r;
  return (r = stt.st_size);
  // S_ISDIR(stat.st_mode)
}

FIO_IFUNC size_t fio_filename_type(const char *filename) {
  size_t r = 0;
  struct stat stt;
  if (stat(filename, &stt))
    return r;
  return (r = (size_t)((stt.st_mode & S_IFMT)));
}

FIO_IFUNC size_t fio_fd_type(int fd) {
  size_t r = 0;
  struct stat stt;
  if (fd == -1)
    return r;
  if (fstat(fd, &stt))
    return r;
  return (r = (size_t)((stt.st_mode & S_IFMT)));
}

/* *****************************************************************************
File Helper Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/**
 * Opens `filename`, returning the same as values as `open` on POSIX systems.
 *
 * If `path` starts with a `"~/"` than it will be relative to the user's home
 * folder (on Windows, testing for `"~\"`).
 */
SFUNC int fio_filename_open(const char *filename, int flags) {
  int fd = -1;
  /* POSIX implementations. */
  if (filename == NULL)
    return fd;
  char *path = NULL;
  size_t path_len = 0;
  const char sep = FIO_FOLDER_SEPARATOR;

  if (filename[0] == '~' && filename[1] == sep) {
    char *home = getenv("HOME");
    if (home) {
      size_t filename_len = strlen(filename);
      size_t home_len = strlen(home);
      if ((home_len + filename_len) >= (1 << 16)) {
        /* too long */
        FIO_LOG_ERROR("couldn't open file, as filename is too long %.*s...",
                      (int)16,
                      (filename_len >= 16 ? filename : home));
        return fd;
      }
      if (home[home_len - 1] == sep)
        --home_len;
      path_len = home_len + filename_len - 1;
      path =
          (char *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*path) * (path_len + 1), 0);
      if (!path)
        return fd;
      FIO_MEMCPY(path, home, home_len);
      FIO_MEMCPY(path + home_len, filename + 1, filename_len);
      path[path_len] = 0;
      filename = path;
    }
  }
  fd = open(filename, flags, (S_IWUSR | S_IRUSR));
  if (path) {
    FIO_MEM_FREE_(path, path_len + 1);
  }
  return fd;
}

/** Returns 1 if `path` does folds backwards (has "/../" or "//"). */
SFUNC int fio_filename_is_unsafe(const char *path) {
#if FIO_OS_WIN
  const char sep = '\\';
#else
  const char sep = '/';
#endif
  for (;;) {
    if (!path)
      return 0;
    if (path[0] == sep && path[1] == sep)
      return 1;
    if (path[0] == sep && path[1] == '.' && path[2] == '.' && path[3] == sep)
      return 1;
    ++path;
    path = strchr(path, sep);
  }
}

/** Creates a temporary file, returning its file descriptor. */
SFUNC int fio_filename_tmp(void) {
  // create a temporary file to contain the data.
  int fd;
  char name_template[512];
  size_t len = 0;
  const char sep = FIO_FOLDER_SEPARATOR;
  const char *tmp = NULL;

  if (!tmp)
    tmp = getenv("TMPDIR");
  if (!tmp)
    tmp = getenv("TMP");
  if (!tmp)
    tmp = getenv("TEMP");
#if defined(P_tmpdir)
  if (!tmp && sizeof(P_tmpdir) <= 464 && sizeof(P_tmpdir) > 0) {
    tmp = P_tmpdir;
  }
#endif
  if (tmp && (len = strlen(tmp))) {
    FIO_MEMCPY(name_template, tmp, len);
    if (tmp[len - 1] != sep) {
      name_template[len++] = sep;
    }
  } else {
    /* use current folder */
    name_template[len++] = '.';
    name_template[len++] = sep;
  }

  FIO_MEMCPY(name_template + len, "facil_io_tmp_", 13);
  len += 13;
  do {
#ifdef O_TMPFILE
    uint64_t r = fio_rand64();
    size_t delta = fio_ltoa(name_template + len, r, 32);
    name_template[delta + len] = 0;
    fd = open(name_template,
              O_CREAT | O_TMPFILE | O_EXCL | O_RDWR,
              (S_IWUSR | S_IRUSR));
#else
    FIO_MEMCPY(name_template + len, "XXXXXXXXXXXX", 12);
    name_template[12 + len] = 0;
    fd = mkstemp(name_template);
#endif
  } while (fd == -1 && errno == EEXIST);
  return fd;
  (void)tmp;
}

/** Parses a file name to folder, base name and extension (zero-copy). */
SFUNC fio_filename_s fio_filename_parse(const char *filename) {
  fio_filename_s r = {{0}};
  if (!filename || !filename[0])
    return r;
  const char *pos = filename;
  r.basename.buf = (char *)filename;
  for (;;) {
    switch (*pos) {
    case 0:
      if (r.ext.buf) {
        r.ext.len = pos - r.ext.buf;
        if (!r.basename.len) {
          r.basename = FIO_BUF_INFO2(--r.ext.buf, ++r.ext.len);
          r.ext.buf = NULL;
          r.ext.len = 0;
        }
      } else {
        r.basename.len = (size_t)(pos - r.basename.buf);
      }
      if (!r.folder.len)
        r.folder.buf = NULL;
      if (!r.basename.len)
        r.basename.buf = NULL;
      if (!r.ext.len)
        r.ext.buf = NULL;
      return r;
    case FIO_FOLDER_SEPARATOR:
      r.folder.buf = (char *)filename;
      r.folder.len = (size_t)(pos - filename) + 1;
      r.basename.buf = (char *)pos + 1;
      r.ext.buf = NULL;
      r.basename.len = 0;
      break;
    case '.':
      if (!r.ext.buf) {
        r.ext.buf = (char *)pos + 1;
        r.basename.len = (char *)pos - r.basename.buf;
      }
      break;
    }
    ++pos;
  }
}

/** Returns index for next `token` in `fd`, or -1 at EOF. */
SFUNC size_t fio_fd_find_next(int fd, char token, size_t start_at) {
  size_t r = FIO_FD_FIND_EOF;
  if (fd == -1 || start_at == FIO_FD_FIND_EOF)
    return r;
  char buf[FIO_FD_FIND_BLOCK];
  for (;;) {
    size_t l =
        (size_t)pread(fd, buf, (size_t)FIO_FD_FIND_BLOCK, (off_t)start_at);
    if (l == FIO_FD_FIND_EOF && errno == EINTR)
      continue; /* try again */
    if (l + 1ULL < 2ULL)
      return r; /* single modular math test for -1 and 0 */
    char *pos = (char *)FIO_MEMCHR(buf, token, l);
    if (!pos) {
      start_at += l;
      continue;
    }
    r = start_at + (size_t)(pos - buf);
    return r;
  }
}

/* *****************************************************************************
Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, filename)(void) {
  fprintf(stderr, "* Testing file utilities (partial).\n");
  struct {
    const char *str;
    fio_filename_s result;
  } filename_test[] = {
      // clang-format off
      {.str = "/", .result = {.folder = FIO_BUF_INFO2((char*)0, 1), .basename = FIO_BUF_INFO2(NULL, 0), .ext = FIO_BUF_INFO2(NULL, 0)}},
      {.str = "/.", .result = {.folder = FIO_BUF_INFO2((char*)0, 1), .basename = FIO_BUF_INFO2((char*)1, 1), .ext = FIO_BUF_INFO2(NULL, 0)}},
      {.str = "/..", .result = {.folder = FIO_BUF_INFO2((char*)0, 1), .basename = FIO_BUF_INFO2((char*)1, 2), .ext = FIO_BUF_INFO2(NULL, 0)}},
      {.str = "name", .result = {.folder = FIO_BUF_INFO2(NULL, 0), .basename = FIO_BUF_INFO2(0, 4), .ext = FIO_BUF_INFO2(NULL, 0)}},
      {.str = "name.ext", .result = {.folder = FIO_BUF_INFO2(NULL, 0), .basename = FIO_BUF_INFO2((char*)0, 4), .ext = FIO_BUF_INFO2((char*)5, 3)}},
      {.str = ".name", .result = {.folder = FIO_BUF_INFO2(NULL, 0), .basename = FIO_BUF_INFO2((char*)0, 5), .ext = FIO_BUF_INFO2(NULL, 0)}},
      {.str = "/.name", .result = {.folder = FIO_BUF_INFO2((char*)0, 1), .basename = FIO_BUF_INFO2((char*)1, 5), .ext = FIO_BUF_INFO2(NULL, 0)}},
      {.str = "/my_folder/.name", .result = {.folder = FIO_BUF_INFO2((char*)0, 11), .basename = FIO_BUF_INFO2((char*)11, 5), .ext = FIO_BUF_INFO2(NULL, 0)}},
      {.str = "/my_folder/name.ext", .result = {.folder = FIO_BUF_INFO2((char*)0, 11), .basename = FIO_BUF_INFO2((char*)11, 4), .ext = FIO_BUF_INFO2((char*)16, 3)}},
      {.str = NULL}, // clang-format on
  };
  for (size_t i = 0; filename_test[i].str; ++i) {
    fio_filename_s r = fio_filename_parse(filename_test[i].str);
    FIO_ASSERT(
        r.folder.len == filename_test[i].result.folder.len &&
            r.basename.len == filename_test[i].result.basename.len &&
            r.ext.len == filename_test[i].result.ext.len &&
            ((!r.folder.buf && !filename_test[i].result.folder.len) ||
             r.folder.buf == (filename_test[i].str +
                              (size_t)filename_test[i].result.folder.buf)) &&
            ((!r.basename.buf && !filename_test[i].result.basename.len) ||
             r.basename.buf ==
                 (filename_test[i].str +
                  (size_t)filename_test[i].result.basename.buf)) &&
            ((!r.ext.buf && !filename_test[i].result.ext.len) ||
             r.ext.buf == (filename_test[i].str +
                           (size_t)filename_test[i].result.ext.buf)),
        "fio_filename_parse error for %s"
        "\n\t folder:    (%zu) %.*s (%p)"
        "\n\t basename:  (%zu) %.*s (%p)"
        "\n\t extension: (%zu) %.*s (%p)",
        filename_test[i].str,
        r.folder.len,
        (int)r.folder.len,
        (r.folder.buf ? r.folder.buf : "null"),
        r.folder.buf,
        r.basename.len,
        (int)r.basename.len,
        (r.basename.buf ? r.basename.buf : "null"),
        r.basename.buf,
        r.ext.len,
        (int)r.ext.len,
        (r.ext.buf ? r.ext.buf : "null"),
        r.ext.buf);
  }
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_FILES */
#undef FIO_FILES
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_STR        /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                      Binary Safe String Core Helpers



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_STR) && !defined(H__FIO_STR__H)
#define H__FIO_STR__H

/** Creates a stack fio_str_info_s variable `name` with `capacity` bytes. */
#define FIO_STR_INFO_TMP_VAR(name, capacity)                                   \
  char fio_stack_mem___##name[(capacity)];                                     \
  fio_str_info_s name = (fio_str_info_s) {                                     \
    .buf = fio_stack_mem___##name, .capa = (capacity)                          \
  }

/* *****************************************************************************
String Authorship Helpers (`fio_string_write` functions)
***************************************************************************** */

/**
 * A reallocation callback type for buffers in a `fio_str_info_s`.
 *
 * The callback MUST allocate at least `len + 1` bytes, setting the new capacity
 * in `dest->capa`.
 * */
typedef int (*fio_string_realloc_fn)(fio_str_info_s *dest, size_t len);
/**
 * Writes data to the end of the string in the `fio_string_s` struct,
 * returning an updated `fio_string_s` struct.
 *
 * The returned string is NUL terminated if edited.
 *
 * * `dest` an `fio_string_s` struct containing the destination string.
 *
 * * `reallocate` is a callback that attempts to reallocate more memory (i.e.,
 * using `realloc`) and returns an updated `fio_string_s` struct containing the
 *   updated capacity and buffer pointer (as well as the original length).
 *
 *   On failure the original `fio_string_s` should be returned. if
 * `reallocate` is NULL or fails, the data copied will be truncated.
 *
 * * `src` is the data to be written to the end of `dest`.
 *
 * * `len` is the length of the data to be written to the end of `dest`.
 *
 * Note: this function performs only minimal checks and assumes that `dest` is
 *       fully valid - i.e., that `dest.capa >= dest.len`, that `dest.buf` is
 *       valid, etc'.
 *
 * An example for a `reallocate` callback using the system's `realloc` function:
 *
 *      int fio_string_realloc_system(fio_str_info_s *dest, size_t len_no_nul) {
 *       const size_t new_capa = fio_string_capa4len(len_pre_nul);
 *       void *tmp = realloc(dest.buf, new_capa);
 *       if (!tmp)
 *         return -1;
 *       dest.capa = new_capa;
 *       dest.buf = (char *)tmp;
 *       return 0;
 *     }
 *
 * An example for using the function:
 *
 *     void example(void) {
 *       char buf[32];
 *       fio_str_info_s str = FIO_STR_INFO3(buf, 0, 32);
 *       fio_string_write(&str, NULL, "The answer is: 0x", 17);
 *       str.len += fio_ltoa(str.buf + str.len, 42, 16);
 *       fio_string_write(&str, NULL, "!\n", 2);
 *       printf("%s", str.buf);
 *     }
 */
FIO_SFUNC int fio_string_write(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               const void *restrict src,
                               size_t len);

/**
 * Similar to `fio_string_write`, only replacing/inserting a sub-string in a
 * specific location.
 *
 * Negative `start_pos` values are calculated backwards, `-1` == end of String.
 *
 * When `overwrite_len` is zero, the function will insert the data at
 * `start_pos`, pushing existing data until after the inserted data.
 *
 * If `overwrite_len` is non-zero, than `overwrite_len` bytes will be
 * overwritten (or deleted).
 *
 * If `len == 0` than `src` will be ignored and the data marked for replacement
 * will be erased.
 */
SFUNC int fio_string_replace(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             intptr_t start_pos,
                             size_t overwrite_len,
                             const void *src,
                             size_t len);

/** Argument type used by fio_string_write2. */
typedef struct {
  size_t klass;
  union {
    struct {
      size_t len;
      const char *buf;
    } str;
    double f;
    int64_t i;
    uint64_t u;
  } info;
} fio_string_write_s;

/**
 * Writes a group of objects (strings, numbers, etc') to `dest`.
 *
 * `dest` and `reallocate` are similar to `fio_string_write`.
 *
 * `src` is an array of `fio_string_write_s` structs, ending with a struct
 * that's all set to 0.
 *
 * Use the `fio_string_write2` macro for ease, i.e.:
 *
 *    fio_str_info_s str = {0};
 *    fio_string_write2(&str, my_reallocate,
 *                        FIO_STRING_WRITE_STR1("The answer is: "),
 *                        FIO_STRING_WRITE_NUM(42),
 *                        FIO_STRING_WRITE_STR2("(0x", 3),
 *                        FIO_STRING_WRITE_HEX(42),
 *                        FIO_STRING_WRITE_STR2(")", 1));
 *
 * Note: this function might end up allocating more memory than absolutely
 * required as it favors fast performance over memory savings. It performs only
 * a single allocation (if any) and computes numeral string length only when
 * writing the numbers to the string.
 */
SFUNC int fio_string_write2(fio_str_info_s *restrict dest,
                            fio_string_realloc_fn reallocate,
                            const fio_string_write_s srcs[]);

/* Helper macro for fio_string_write2 */
#define fio_string_write2(dest, reallocate, ...)                               \
  fio_string_write2((dest),                                                    \
                    (reallocate),                                              \
                    (fio_string_write_s[]){__VA_ARGS__, {0}})

/** A macro to add a String to `fio_string_write2`. */
#define FIO_STRING_WRITE_STR1(str_)                                            \
  ((fio_string_write_s){.klass = 1,                                            \
                        .info.str = {.len = strlen((str_)), .buf = (str_)}})

/** A macro to add a String with known length to `fio_string_write2`. */
#define FIO_STRING_WRITE_STR2(str_, len_)                                      \
  ((fio_string_write_s){.klass = 1, .info.str = {.len = (len_), .buf = (str_)}})

/** A macro to add a String with known length to `fio_string_write2`. */
#define FIO_STRING_WRITE_STR_INFO(str_)                                        \
  ((fio_string_write_s){.klass = 1,                                            \
                        .info.str = {.len = (str_).len, .buf = (str_).buf}})

/** A macro to add a signed number to `fio_string_write2`. */
#define FIO_STRING_WRITE_NUM(num)                                              \
  ((fio_string_write_s){.klass = 2, .info.i = (int64_t)(num)})

/** A macro to add an unsigned number to `fio_string_write2`. */
#define FIO_STRING_WRITE_UNUM(num)                                             \
  ((fio_string_write_s){.klass = 3, .info.u = (uint64_t)(num)})

/** A macro to add a hex representation to `fio_string_write2`. */
#define FIO_STRING_WRITE_HEX(num)                                              \
  ((fio_string_write_s){.klass = 4, .info.u = (uint64_t)(num)})

/** A macro to add a binary representation to `fio_string_write2`. */
#define FIO_STRING_WRITE_BIN(num)                                              \
  ((fio_string_write_s){.klass = 5, .info.u = (uint64_t)(num)})

/** A macro to add a float (double) to `fio_string_write2`. */
#define FIO_STRING_WRITE_FLOAT(num)                                            \
  ((fio_string_write_s){.klass = 6, .info.f = (double)(num)})

/* *****************************************************************************
String Numerals support
***************************************************************************** */

/* Writes a signed number `i` to the String */
SFUNC int fio_string_write_i(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             int64_t i);
/* Writes an unsigned number `i` to the String */
SFUNC int fio_string_write_u(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             uint64_t i);
/* Writes a hex representation of `i` to the String */
SFUNC int fio_string_write_hex(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               uint64_t i);
/* Writes a binary representation of `i` to the String */
SFUNC int fio_string_write_bin(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               uint64_t i);

/* *****************************************************************************
String printf style support
***************************************************************************** */

/** Similar to fio_string_write, only using printf semantics. */
SFUNC __attribute__((format(FIO___PRINTF_STYLE, 3, 0))) int fio_string_printf(
    fio_str_info_s *dest,
    fio_string_realloc_fn reallocate,
    const char *format,
    ...);

/** Similar to fio_string_write, only using vprintf semantics. */
SFUNC __attribute__((format(FIO___PRINTF_STYLE, 3, 0))) int fio_string_vprintf(
    fio_str_info_s *dest,
    fio_string_realloc_fn reallocate,
    const char *format,
    va_list argv);

/* *****************************************************************************
String C / JSON escaping
***************************************************************************** */

/**
 * Writes data at the end of the String, escaping the data using JSON semantics.
 *
 * The JSON semantic are common to many programming languages, promising a UTF-8
 * String while making it easy to read and copy the string during debugging.
 */
SFUNC int fio_string_write_escape(fio_str_info_s *restrict dest,
                                  fio_string_realloc_fn reallocate,
                                  const void *src,
                                  size_t len);

/** Writes an escaped data into the string after un-escaping the data. */
SFUNC int fio_string_write_unescape(fio_str_info_s *dest,
                                    fio_string_realloc_fn reallocate,
                                    const void *src,
                                    size_t len);

/* *****************************************************************************
String Base64 support
***************************************************************************** */

/** Writes data to String using base64 encoding. */
SFUNC int fio_string_write_base64enc(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *data,
                                     size_t data_len,
                                     uint8_t url_encoded);

/** Writes decoded base64 data to String. */
SFUNC int fio_string_write_base64dec(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *encoded,
                                     size_t encoded_len);

/* *****************************************************************************
String File Reading support
***************************************************************************** */

/**
 * Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at`.
 *
 * If `limit` is 0 (or less than 0) data will be written until EOF.
 *
 * If `start_at` is negative, position will be calculated from the end of the
 * file where `-1 == EOF`.
 *
 * Note: this will fail unless used on actual files (not sockets, not pipes).
 * */
SFUNC int fio_string_readfd(fio_str_info_s *dest,
                            fio_string_realloc_fn reallocate,
                            int fd,
                            intptr_t start_at,
                            size_t limit);

/**
 * Opens the file `filename` and pastes it's contents (or a slice ot it) at
 * the end of the String. If `limit == 0`, than the data will be read until
 * EOF.
 *
 * If the file can't be located, opened or read, or if `start_at` is beyond
 * the EOF position, NULL is returned in the state's `data` field.
 */
SFUNC int fio_string_readfile(fio_str_info_s *dest,
                              fio_string_realloc_fn reallocate,
                              const char *filename,
                              intptr_t start_at,
                              size_t limit);

/**
 * Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at` and
 * ending either at the first occurrence of `delim` or at EOF.
 *
 * If `limit` is 0 (or less than 0) as much data as may be required will be
 * written.
 *
 * If `start_at` is negative, position will be calculated from the end of the
 * file where `-1 == EOF`.
 *
 * Note: this will fail unless used on actual seekable files (not sockets, not
 * pipes).
 * */
SFUNC int fio_string_getdelim_fd(fio_str_info_s *dest,
                                 fio_string_realloc_fn reallocate,
                                 int fd,
                                 intptr_t start_at,
                                 char delim,
                                 size_t limit);

/**
 * Opens the file `filename`, calls `fio_string_getdelim_fd` and closes the
 * file.
 */
SFUNC int fio_string_getdelim_file(fio_str_info_s *dest,
                                   fio_string_realloc_fn reallocate,
                                   const char *filename,
                                   intptr_t start_at,
                                   char delim,
                                   size_t limit);

/* *****************************************************************************
Memory Helpers (for Authorship)
***************************************************************************** */

/* calculates a 16 bytes boundary aligned capacity for `new_len`. */
FIO_IFUNC size_t fio_string_capa4len(size_t new_len);

/** Default reallocation callback implementation */
#define FIO_STRING_REALLOC fio_string_default_reallocate
/** Default reallocation callback for memory that mustn't be freed. */
#define FIO_STRING_ALLOC_COPY fio_string_default_copy_and_reallocate
/** default allocator for the fio_keystr_s string data.. */
#define FIO_STRING_ALLOC_KEY fio_string_default_key_alloc
/** Frees memory that was allocated with the default callbacks. */
#define FIO_STRING_FREE fio_string_default_free
/** Frees memory that was allocated with the default callbacks. */
#define FIO_STRING_FREE2 fio_string_default_free2
/** Frees memory that was allocated for a key string. */
#define FIO_STRING_FREE_KEY fio_string_default_free_key
/** Does nothing. */
#define FIO_STRING_FREE_NOOP fio_string_default_free_noop
/** Does nothing. */
#define FIO_STRING_FREE_NOOP2 fio_string_default_free_noop2

/** default reallocation callback implementation. */
SFUNC int fio_string_default_reallocate(fio_str_info_s *dst, size_t len);
/** default reallocation callback for memory that mustn't be freed. */
SFUNC int fio_string_default_copy_and_reallocate(fio_str_info_s *dest,
                                                 size_t new_capa);
/** frees memory that was allocated with the default callbacks. */
SFUNC void fio_string_default_free(void *);
/** frees memory that was allocated with the default callbacks. */
SFUNC void fio_string_default_free2(fio_str_info_s str);
/** does nothing. */
SFUNC void fio_string_default_free_noop(void *);
/** does nothing. */
SFUNC void fio_string_default_free_noop2(fio_str_info_s str);

/** default allocator for the fio_keystr_s string data.. */
SFUNC void *fio_string_default_key_alloc(size_t len);
/** frees a fio_keystr_s memory that was allocated with the default callback. */
SFUNC void fio_string_default_free_key(void *, size_t);
/* *****************************************************************************
UTF-8 Support
***************************************************************************** */

/** Returns 1 if the String is UTF-8 valid and 0 if not. */
SFUNC size_t fio_string_utf8_valid(fio_str_info_s str);

/** Returns the String's length in UTF-8 characters or 0 if invalid. */
SFUNC size_t fio_string_utf8_len(fio_str_info_s str);

/**
 * Takes a UTF-8 character selection information (UTF-8 position and length)
 * and updates the same variables so they reference the raw byte slice
 * information.
 *
 * If the String isn't UTF-8 valid up to the requested selection, than `pos`
 * will be updated to `-1` otherwise values are always positive.
 *
 * The returned `len` value may be shorter than the original if there wasn't
 * enough data left to accommodate the requested length. When a `len` value of
 * `0` is returned, this means that `pos` marks the end of the String.
 *
 * Returns -1 on error and 0 on success.
 */
SFUNC int fio_string_utf8_select(fio_str_info_s str,
                                 intptr_t *pos,
                                 size_t *len);

/* *****************************************************************************
Sorting / Comparison Helpers
***************************************************************************** */

/**
 * Compares two `fio_buf_info_s`, returning 1 if data in a is bigger than b.
 *
 * Note: returns 0 if data in b is bigger than or equal(!).
 */
SFUNC int fio_string_is_greater_buf(fio_buf_info_s a, fio_buf_info_s b);

/**
 * Compares two strings, returning 1 if string a is bigger than string b.
 *
 * Note: returns 0 if string b is bigger than string a or if strings are equal.
 */
FIO_IFUNC int fio_string_is_greater(fio_str_info_s a, fio_str_info_s b);

/* *****************************************************************************
Binary String Type - Embedded Strings optimized for mutability and locality
***************************************************************************** */

/* for internal use only */
typedef struct {
  uint32_t len;
  uint32_t capa;
  uint32_t ref;
} fio___bstr_meta_s;

/* for internal use only */
typedef struct {
  fio___bstr_meta_s meta;
  char *ptr;
} fio___bstr_const_s;

/** Reserves `len` for future `write` operations (used to minimize realloc). */
FIO_IFUNC char *fio_bstr_reserve(char *bstr, size_t len);

/** Copies a `fio_bstr` using "copy on write". */
FIO_IFUNC char *fio_bstr_copy(char *bstr);
/** Frees a binary string allocated by a `fio_bstr` function. */
FIO_IFUNC void fio_bstr_free(char *bstr);

/** Returns information about the fio_bstr. */
FIO_IFUNC fio_str_info_s fio_bstr_info(char *bstr);
/** Returns information about the fio_bstr. */
FIO_IFUNC fio_buf_info_s fio_bstr_buf(char *bstr);
/** Gets the length of the fio_bstr. `bstr` MUST NOT be NULL. */
FIO_IFUNC size_t fio_bstr_len(char *bstr);
/** Sets the length of the fio_bstr. `bstr` MUST NOT be NULL. */
FIO_IFUNC char *fio_bstr_len_set(char *bstr, size_t len);

/** Compares to see if fio_bstr a is greater than fio_bstr b (for FIO_SORT). */
FIO_SFUNC int fio_bstr_is_greater(char *a, char *b);
/** Compares to see if fio_bstr a is equal to another String. */
FIO_SFUNC int fio_bstr_is_eq2info(char *a_, fio_str_info_s b);
/** Compares to see if fio_bstr a is equal to another String. */
FIO_SFUNC int fio_bstr_is_eq2buf(char *a_, fio_buf_info_s b);

/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write(char *bstr,
                               const void *restrict src,
                               size_t len);
/** Replaces data in a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_replace(char *bstr,
                                 intptr_t start_pos,
                                 size_t overwrite_len,
                                 const void *src,
                                 size_t len);
/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write2(char *bstr, const fio_string_write_s srcs[]);
/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
#define fio_bstr_write2(bstr, ...)                                             \
  fio_bstr_write2(bstr, (fio_string_write_s[]){__VA_ARGS__, {0}})

/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_i(char *bstr, int64_t num);
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_u(char *bstr, uint64_t num);
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_hex(char *bstr, uint64_t num);
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_bin(char *bstr, uint64_t num);

/** Writes escaped data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_escape(char *bstr, const void *src, size_t len);
/** Un-escapes and writes data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_unescape(char *bstr,
                                        const void *src,
                                        size_t len);

/** Writes base64 encoded data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_base64enc(char *bstr,
                                         const void *src,
                                         size_t len,
                                         uint8_t url_encoded);
/** Decodes base64 data and writes to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_base64dec(char *bstr,
                                         const void *src,
                                         size_t len);

/** Writes to the String from a regular file `fd`. */
FIO_IFUNC char *fio_bstr_readfd(char *bstr,
                                int fd,
                                intptr_t start_at,
                                intptr_t limit);
/** Writes to the String from a regular file named `filename`. */
FIO_IFUNC char *fio_bstr_readfile(char *bstr,
                                  const char *filename,
                                  intptr_t start_at,
                                  intptr_t limit);
/** Writes to the String from a regular file named `filename`. */
FIO_IFUNC char *fio_bstr_getdelim_file(char *bstr,
                                       const char *filename,
                                       intptr_t start_at,
                                       char delim,
                                       size_t limit);
/** Writes to the String from a regular file `fd`. */
FIO_IFUNC char *fio_bstr_getdelim_fd(char *bstr,
                                     int fd,
                                     intptr_t start_at,
                                     char delim,
                                     size_t limit);

/** Writes a `fio_bstr` in `printf` style. */
FIO_IFUNC __attribute__((format(FIO___PRINTF_STYLE, 2, 0))) char *
fio_bstr_printf(char *bstr, const char *format, ...);

/** default reallocation callback implementation - mostly for internal use. */
SFUNC int fio_bstr_reallocate(fio_str_info_s *dest, size_t len);

/* *****************************************************************************
Key String Type - binary String container for Hash Maps and Arrays
***************************************************************************** */

/** a semi-opaque type used for the `fio_keystr` functions */
typedef struct fio_keystr_s fio_keystr_s;

/** returns the Key String. NOTE: Key Strings are NOT NUL TERMINATED! */
FIO_IFUNC fio_buf_info_s fio_keystr_buf(fio_keystr_s *str);
/** returns the Key String. NOTE: Key Strings are NOT NUL TERMINATED! */
FIO_IFUNC fio_str_info_s fio_keystr_info(fio_keystr_s *str);

/** Returns a TEMPORARY `fio_keystr_s` to be used as a key for a hash map. */
FIO_IFUNC fio_keystr_s fio_keystr(const char *buf, uint32_t len);
/** Returns a copy of `fio_keystr_s` - used internally by the hash map. */
FIO_SFUNC fio_keystr_s fio_keystr_copy(fio_str_info_s str,
                                       void *(*alloc_func)(size_t len));
/** Destroys a copy of `fio_keystr_s` - used internally by the hash map. */
FIO_SFUNC void fio_keystr_destroy(fio_keystr_s *key,
                                  void (*free_func)(void *, size_t));
/** Compares two Key Strings. */
FIO_IFUNC int fio_keystr_is_eq(fio_keystr_s a, fio_keystr_s b);
/** Compares a Key String to any String - used internally by the hash map. */
FIO_IFUNC int fio_keystr_is_eq2(fio_keystr_s a_, fio_str_info_s b);

#define FIO_KEYSTR_CONST ((size_t)-1LL)

/* *****************************************************************************


                             String Implementation

                           IMPLEMENTATION - INLINED


***************************************************************************** */

/* *****************************************************************************
String Authorship Helpers - (inlined) implementation
***************************************************************************** */

/* calculates a 16 bytes boundary aligned capacity for `new_len`. */
FIO_IFUNC size_t fio_string_capa4len(size_t new_len) {
  return sizeof(char) *
         ((new_len + 15LL + (!(new_len & 15ULL))) & (~((size_t)15ULL)));
}

/*
 * performs `reallocate` if necessary, `capa` rounded up to 16 byte units.
 * updates `len` if reallocation fails (or is unavailable).
 */
FIO_IFUNC int fio_string___write_validate_len(fio_str_info_s *restrict dest,
                                              fio_string_realloc_fn reallocate,
                                              size_t *restrict len) {
  if ((dest->capa > dest->len + len[0]))
    return 0;
  if (reallocate && !reallocate(dest, dest->len + len[0]))
    return 0;
  if (dest->capa > dest->len + 1)
    len[0] = dest->capa - (dest->len + 1);
  else
    len[0] = 0;
  return -1;
}

/* fio_string_write */
FIO_SFUNC int fio_string_write(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               const void *restrict src,
                               size_t len) {
  int r = fio_string___write_validate_len(dest, reallocate, &len);
  if (FIO_LIKELY(len && src))
    FIO_MEMCPY(dest->buf + dest->len, src, len);
  dest->len += len;
  dest->buf[dest->len] = 0;
  return r;
}

/**
 * Compares two strings, returning 1 if string a is bigger than string b.
 *
 * Note: returns 0 if string b is bigger than string a or if strings are equal.
 */
FIO_IFUNC int fio_string_is_greater(fio_str_info_s a, fio_str_info_s b) {
  return fio_string_is_greater_buf(FIO_STR2BUF_INFO(a), FIO_STR2BUF_INFO(b));
}

/* *****************************************************************************
Binary String Type - Embedded Strings
***************************************************************************** */

#if defined(DEBUG) || defined(FIO_LEAK_COUNTER)
SFUNC void FIO_BSTR___LEAK_TESTER(int add);
FIO_DESTRUCTOR(fio_bstr___leak_test) { FIO_BSTR___LEAK_TESTER(0); }
#else
#define FIO_BSTR___LEAK_TESTER(i)
#endif /* defined(DEBUG) || defined(FIO_LEAK_COUNTER) */
#ifndef FIO___BSTR_META
#define FIO___BSTR_META(bstr)                                                  \
  FIO_PTR_MATH_SUB(fio___bstr_meta_s, bstr, sizeof(fio___bstr_meta_s))
#endif

/** Duplicates a `fio_bstr` using copy on write. */
FIO_IFUNC char *fio_bstr_copy(char *bstr) {
  if (!bstr)
    return bstr;
  fio___bstr_meta_s *meta = FIO___BSTR_META(bstr);
  if (fio_atomic_add(&meta->ref, 1) > ((uint32_t)1UL << 31))
    goto copy_anyway;
  return bstr;
copy_anyway:
  bstr = fio_bstr_write(NULL, bstr, meta->len);
  fio_bstr_free((char *)(meta + 1));
  return bstr;
}

/** Frees a binary string allocated by a `fio_bstr` function. */
FIO_IFUNC void fio_bstr_free(char *bstr) {
  if (!bstr)
    return;
  fio___bstr_meta_s *meta = FIO___BSTR_META(bstr);
  if (fio_atomic_sub(&meta->ref, 1))
    return;
  FIO_MEM_FREE_(meta, (meta->capa + sizeof(*meta)));
  FIO_BSTR___LEAK_TESTER(-1);
}

/** internal helper - sets the length of the fio_bstr. */
FIO_IFUNC char *fio_bstr___len_set(char *bstr, size_t len) {
  if (!bstr)
    return bstr;
  bstr[(FIO___BSTR_META(bstr)->len = len)] = 0;
  return bstr;
}

/** internal helper to make unique before mutation */
FIO_SFUNC char *fio_bstr___make_unique(char *bstr) {
  if (!bstr)
    return bstr;
  fio___bstr_meta_s *meta = FIO___BSTR_META(bstr);
  // if (!fio_atomic_add(&meta->ref, 1)) {
  //   fio_atomic_sub(&meta->ref, 1);
  //   return bstr;
  // }
  if (!meta->ref)
    return bstr;
  fio_str_info_s i = fio_bstr_info(bstr);
  i.capa = 0;
  if (i.len)
    fio_bstr_reallocate(&i, i.len);
  else
    i.buf = NULL;
  fio_bstr_free(bstr);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Reserves `len` for future `write` operations (used to minimize realloc). */
FIO_IFUNC char *fio_bstr_reserve(char *bstr, size_t len) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  if (i.len + len < i.capa)
    return bstr;
  fio_bstr_reallocate(&i, (i.len + len));
  return fio_bstr___len_set(i.buf, i.len);
}

/** Returns information about the fio_bstr. */
FIO_IFUNC fio_str_info_s fio_bstr_info(char *bstr) {
  fio___bstr_meta_s mem[1] = {{0}};
  fio___bstr_meta_s *meta_map[2] = {FIO___BSTR_META(bstr), mem};
  fio___bstr_meta_s *meta = meta_map[!bstr];
  return FIO_STR_INFO3(bstr, meta->len, meta->capa);
}

/** Returns information about the fio_bstr. */
FIO_IFUNC fio_buf_info_s fio_bstr_buf(char *bstr) {
  fio___bstr_meta_s mem[1] = {{0}};
  fio___bstr_meta_s *meta_map[2] = {FIO___BSTR_META(bstr), mem};
  fio___bstr_meta_s *meta = meta_map[!bstr];
  return FIO_BUF_INFO2(bstr, meta->len);
}

/** Gets the length of the fio_bstr. `bstr` MUST NOT be NULL. */
FIO_IFUNC size_t fio_bstr_len(char *bstr) {
  if (!bstr)
    return 0;
  fio___bstr_meta_s *meta = FIO___BSTR_META(bstr);
  return meta->len;
}

/** Sets the length of the fio_bstr. `bstr` MUST NOT be NULL. */
FIO_IFUNC char *fio_bstr_len_set(char *bstr, size_t len) {
  bstr = fio_bstr___make_unique(bstr);
  if (!bstr)
    return bstr;
  fio___bstr_meta_s *meta = FIO___BSTR_META(bstr);
  meta->len = len < meta->capa ? len : meta->len;
  return fio_bstr___len_set(bstr, len);
}

/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write(char *bstr,
                               const void *restrict src,
                               size_t len) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Replaces data in a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_replace(char *bstr,
                                 intptr_t start_pos,
                                 size_t overwrite_len,
                                 const void *src,
                                 size_t len) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_replace(&i,
                     fio_bstr_reallocate,
                     start_pos,
                     overwrite_len,
                     src,
                     len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes data to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write2 FIO_NOOP(char *bstr,
                                         const fio_string_write_s srcs[]) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write2 FIO_NOOP(&i, fio_bstr_reallocate, srcs);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_i(char *bstr, int64_t num) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_i(&i, fio_bstr_reallocate, num);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_u(char *bstr, uint64_t num) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_u(&i, fio_bstr_reallocate, num);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_hex(char *bstr, uint64_t num) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_hex(&i, fio_bstr_reallocate, num);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes number to a fio_bstr, returning the address of the new fio_bstr. */
FIO_IFUNC char *fio_bstr_write_bin(char *bstr, uint64_t num) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_bin(&i, fio_bstr_reallocate, num);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes escaped data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_escape(char *bstr, const void *src, size_t len) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_escape(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Un-escapes and writes data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_unescape(char *bstr,
                                        const void *src,
                                        size_t len) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_unescape(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes base64 encoded data to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_base64enc(char *bstr,
                                         const void *src,
                                         size_t len,
                                         uint8_t url_encoded) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_base64enc(&i, fio_bstr_reallocate, src, len, url_encoded);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Decodes base64 data and writes to a fio_bstr, returning its new address. */
FIO_IFUNC char *fio_bstr_write_base64dec(char *bstr,
                                         const void *src,
                                         size_t len) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_write_base64dec(&i, fio_bstr_reallocate, src, len);
  return fio_bstr___len_set(i.buf, i.len);
}

FIO_IFUNC __attribute__((format(FIO___PRINTF_STYLE, 2, 0))) char *
fio_bstr_printf(char *bstr, const char *format, ...) {
  bstr = fio_bstr___make_unique(bstr);
  va_list argv;
  va_start(argv, format);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_vprintf(&i, fio_bstr_reallocate, format, argv);
  va_end(argv);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes to the String from a regular file `fd`. */
FIO_IFUNC char *fio_bstr_readfd(char *bstr,
                                int fd,
                                intptr_t start_at,
                                intptr_t limit) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_readfd(&i, fio_bstr_reallocate, fd, start_at, limit);
  return fio_bstr___len_set(i.buf, i.len);
}
/** Writes to the String from a regular file named `filename`. */
FIO_IFUNC char *fio_bstr_readfile(char *bstr,
                                  const char *filename,
                                  intptr_t start_at,
                                  intptr_t limit) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_readfile(&i, fio_bstr_reallocate, filename, start_at, limit);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes to the String from a regular file named `filename`. */
FIO_IFUNC char *fio_bstr_getdelim_file(char *bstr,
                                       const char *filename,
                                       intptr_t start_at,
                                       char delim,
                                       size_t limit) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_getdelim_file(&i,
                           fio_bstr_reallocate,
                           filename,
                           start_at,
                           delim,
                           limit);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Writes to the String from a regular file `fd`. */
FIO_IFUNC char *fio_bstr_getdelim_fd(char *bstr,
                                     int fd,
                                     intptr_t start_at,
                                     char delim,
                                     size_t limit) {
  bstr = fio_bstr___make_unique(bstr);
  fio_str_info_s i = fio_bstr_info(bstr);
  fio_string_getdelim_fd(&i, fio_bstr_reallocate, fd, start_at, delim, limit);
  return fio_bstr___len_set(i.buf, i.len);
}

/** Compares to see if fio_bstr a is greater than fio_bstr b (for FIO_SORT). */
FIO_SFUNC int fio_bstr_is_greater(char *a, char *b) {
  return fio_string_is_greater_buf(fio_bstr_buf(a), fio_bstr_buf(b));
}

/** Compares to see if fio_bstr a is equal to another String. */
FIO_SFUNC int fio_bstr_is_eq2info(char *a_, fio_str_info_s b) {
  fio_str_info_s a = fio_bstr_info(a_);
  return FIO_STR_INFO_IS_EQ(a, b);
}
/** Compares to see if fio_bstr a is equal to another String. */
FIO_SFUNC int fio_bstr_is_eq2buf(char *a_, fio_buf_info_s b) {
  fio_buf_info_s a = fio_bstr_buf(a_);
  return FIO_BUF_INFO_IS_EQ(a, b);
}

/* *****************************************************************************
Key String Type - binary String container for Hash Maps and Arrays
***************************************************************************** */

/* key string type implementation */
struct fio_keystr_s {
  uint8_t info;
  uint8_t embd[3];
  uint32_t len;
  const char *buf;
};

/** returns the Key String. NOTE: Key Strings are NOT NUL TERMINATED! */
FIO_IFUNC fio_buf_info_s fio_keystr_buf(fio_keystr_s *str) {
  fio_buf_info_s r;
  if ((str->info + 1) > 1) {
    r = (fio_buf_info_s){.len = str->info, .buf = (char *)str->embd};
    return r;
  }
  r = (fio_buf_info_s){.len = str->len, .buf = (char *)str->buf};
  return r;
}
/** returns the Key String. NOTE: Key Strings are NOT NUL TERMINATED! */
FIO_IFUNC fio_str_info_s fio_keystr_info(fio_keystr_s *str) {
  fio_str_info_s r;
  if ((str->info + 1) > 1) {
    r = (fio_str_info_s){.len = str->info, .buf = (char *)str->embd};
    return r;
  }
  r = (fio_str_info_s){.len = str->len, .buf = (char *)str->buf};
  return r;
}

/** Returns a TEMPORARY `fio_keystr_s` to be used as a key for a hash map. */
FIO_IFUNC fio_keystr_s fio_keystr(const char *buf, uint32_t len) {
  fio_keystr_s r = {0};
  if (len + 1 < sizeof(r)) { /* always embed small strings in container! */
    r.info = (uint8_t)len;
    FIO_MEMCPY(r.embd, buf, len);
    return r;
  }
  r.info = 0xFF;
  r.len = len;
  r.buf = buf;
  return r;
}

/** Returns a copy of `fio_keystr_s` - used internally by the hash map. */
FIO_SFUNC fio_keystr_s fio_keystr_copy(fio_str_info_s str,
                                       void *(*alloc_func)(size_t len)) {
  fio_keystr_s r = {0};
  if (str.len + 1 < sizeof(r)) {
    r.info = (uint8_t)str.len;
    FIO_MEMCPY(r.embd, str.buf, str.len);
    return r;
  }
  if (str.capa == FIO_KEYSTR_CONST) {
  no_mem2:
    r.info = 0xFF;
    r.len = str.len;
    r.buf = str.buf;
    return r;
  }
  char *buf;
  r.len = str.len;
  r.buf = buf = (char *)alloc_func(str.len + 1);
  if (!buf)
    goto no_mem;
  FIO_MEMCPY(buf, str.buf, str.len);
  buf[str.len] = 0;
  return r;
no_mem:
  FIO_LOG_FATAL("fio_keystr_copy allocation failed - results undefined!!!");
  goto no_mem2;
}
/** Destroys a copy of `fio_keystr_s` - used internally by the hash map. */
FIO_SFUNC void fio_keystr_destroy(fio_keystr_s *key,
                                  void (*free_func)(void *, size_t)) {
  if (key->info)
    return;
  free_func((void *)key->buf, key->len);
}

/** Compares two Key Strings. */
FIO_IFUNC int fio_keystr_is_eq(fio_keystr_s a_, fio_keystr_s b_) {
  fio_buf_info_s a = fio_keystr_buf(&a_);
  fio_buf_info_s b = fio_keystr_buf(&b_);
  return FIO_BUF_INFO_IS_EQ(a, b);
}

/** Compares a Key String to any String - used internally by the hash map. */
FIO_IFUNC int fio_keystr_is_eq2(fio_keystr_s a_, fio_str_info_s b) {
  fio_str_info_s a = fio_keystr_info(&a_);
  return FIO_STR_INFO_IS_EQ(a, b);
}

/* *****************************************************************************
Extern-ed functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Allocation Helpers
***************************************************************************** */
SFUNC int fio_string_default_reallocate(fio_str_info_s *dest, size_t len) {
  len = fio_string_capa4len(len);
  void *tmp = FIO_MEM_REALLOC_(dest->buf, dest->capa, len, dest->len);
  if (!tmp)
    return -1;
  dest->capa = len;
  dest->buf = (char *)tmp;
  return 0;
}

SFUNC int fio_string_default_copy_and_reallocate(fio_str_info_s *dest,
                                                 size_t len) {
  len = fio_string_capa4len(len);
  void *tmp = FIO_MEM_REALLOC_(NULL, 0, len, 0);
  if (!tmp)
    return -1;
  dest->capa = len;
  dest->buf = (char *)tmp;
  if (dest->len)
    FIO_MEMCPY(tmp, dest->buf, dest->len);
  return 0;
}

SFUNC void *fio_string_default_key_alloc(size_t len) {
  return FIO_MEM_REALLOC_(NULL, 0, len, 0);
}

SFUNC void fio_string_default_free(void *ptr) { FIO_MEM_FREE_(ptr, 0); }
SFUNC void fio_string_default_free2(fio_str_info_s str) {
  FIO_MEM_FREE_(str.buf, str.capa);
}

/** frees a fio_keystr_s memory that was allocated with the default callback. */
SFUNC void fio_string_default_free_key(void *buf, size_t capa) {
  FIO_MEM_FREE_(buf, capa);
  (void)capa; /* if unused */
}

SFUNC void fio_string_default_free_noop(void *str) { (void)str; }
SFUNC void fio_string_default_free_noop2(fio_str_info_s str) { (void)str; }

/* *****************************************************************************
Numeral Support
***************************************************************************** */

/* fio_string_write_i */
SFUNC int fio_string_write_i(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             int64_t i) {
  int r = -1;
  size_t len = 0;
  len = fio_digits10(i);
  if (fio_string___write_validate_len(dest, reallocate, &len))
    return r; /* no writing of partial numbers. */
  r = 0;
  fio_ltoa10(dest->buf + dest->len, i, len);
  dest->len += len;
  return r;
}

/* fio_string_write_u */
SFUNC int fio_string_write_u(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             uint64_t i) {
  int r = -1;
  size_t len = fio_digits10u(i);
  if (fio_string___write_validate_len(dest, reallocate, &len))
    return r; /* no writing of partial numbers. */
  r = 0;
  fio_ltoa10u(dest->buf + dest->len, i, len);
  dest->len += len;
  return r;
}

/* fio_string_write_hex */
SFUNC int fio_string_write_hex(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               uint64_t i) {
  int r = 0;
  size_t len = fio_digits16u(i);
  if (fio_string___write_validate_len(dest, reallocate, &len))
    return (r = -1); /* no writing of partial numbers. */
  fio_ltoa16u(dest->buf + dest->len, i, len);
  dest->len += len;
  return r;
}

/* fio_string_write_bin */
SFUNC int fio_string_write_bin(fio_str_info_s *dest,
                               fio_string_realloc_fn reallocate,
                               uint64_t i) {
  int r = 0;
  size_t len = fio_digits_bin(i);
  if (fio_string___write_validate_len(dest, reallocate, &len))
    return (r = -1); /* no writing of partial numbers. */
  fio_ltoa_bin(dest->buf + dest->len, i, len);
  dest->len += len;
  return r;
}

/* *****************************************************************************
`printf` Style Support
***************************************************************************** */

/* Similar to fio_string_write, only using vprintf semantics. */
SFUNC int __attribute__((format(FIO___PRINTF_STYLE, 3, 0)))
fio_string_vprintf(fio_str_info_s *dest,
                   fio_string_realloc_fn reallocate,
                   const char *format,
                   va_list argv) {
  int r = 0;
  va_list argv_cpy;
  va_copy(argv_cpy, argv);
  int len_i = vsnprintf(NULL, 0, format, argv_cpy);
  va_end(argv_cpy);
  if (len_i <= 0)
    return -1;
  size_t len = (size_t)len_i;
  r = fio_string___write_validate_len(dest, reallocate, &len);
  if (FIO_UNLIKELY(dest->capa < dest->len + 2))
    return -1;
  if (len)
    vsnprintf(dest->buf + dest->len, len + 1, format, argv);
  dest->len += len;
  dest->buf[dest->len] = 0;
  return r;
}

/** Similar to fio_string_write, only using printf semantics. */
SFUNC int __attribute__((format(FIO___PRINTF_STYLE, 3, 4)))
fio_string_printf(fio_str_info_s *dest,
                  fio_string_realloc_fn reallocate,
                  const char *format,
                  ...) {
  int r = 0;
  va_list argv;
  va_start(argv, format);
  r = fio_string_vprintf(dest, reallocate, format, argv);
  va_end(argv);
  return r;
}

/* *****************************************************************************
UTF-8 Support
***************************************************************************** */
/**
 * Maps the first 5 bits in a byte (0b11111xxx) to a UTF-8 codepoint length.
 *
 * Codepoint length 0 == error.
 *
 * The first valid length can be any value between 1 to 4.
 *
 * A continuation byte (second, third or forth) valid length marked as 5.
 *
 * To map was populated using the following Ruby script:
 *
 *      map = []; 32.times { map << 0 }; (0..0b1111).each {|i| map[i] = 1} ;
 *      (0b10000..0b10111).each {|i| map[i] = 5} ;
 *      (0b11000..0b11011).each {|i| map[i] = 2} ;
 *      (0b11100..0b11101).each {|i| map[i] = 3} ;
 *      map[0b11110] = 4; map;
 */
static __attribute__((unused)) uint8_t fio__string_utf8_map[] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    5, 5, 5, 5, 5, 5, 5, 5, 2, 2, 2, 2, 3, 3, 4, 0};

/**
 * Advances the `ptr` by one utf-8 character, placing the value of the UTF-8
 * character into the i32 variable (which must be a signed integer with 32bits
 * or more). On error, `i32` will be equal to `-1` and `ptr` will not step
 * forwards.
 *
 * The `end` value provides overflow protection.
 */
#define FIO_STR_UTF8_CODE_POINT(ptr, end, i32)                                 \
  do {                                                                         \
    switch (fio__string_utf8_map[((uint8_t *)(ptr))[0] >> 3]) {                \
    case 1:                                                                    \
      (i32) = ((uint8_t *)(ptr))[0];                                           \
      ++(ptr);                                                                 \
      break;                                                                   \
    case 2:                                                                    \
      if (((ptr) + 2 > (end)) ||                                               \
          fio__string_utf8_map[((uint8_t *)(ptr))[1] >> 3] != 5) {             \
        (i32) = -1;                                                            \
        break;                                                                 \
      }                                                                        \
      (i32) =                                                                  \
          ((((uint8_t *)(ptr))[0] & 31) << 6) | (((uint8_t *)(ptr))[1] & 63);  \
      (ptr) += 2;                                                              \
      break;                                                                   \
    case 3:                                                                    \
      if (((ptr) + 3 > (end)) ||                                               \
          fio__string_utf8_map[((uint8_t *)(ptr))[1] >> 3] != 5 ||             \
          fio__string_utf8_map[((uint8_t *)(ptr))[2] >> 3] != 5) {             \
        (i32) = -1;                                                            \
        break;                                                                 \
      }                                                                        \
      (i32) = ((((uint8_t *)(ptr))[0] & 15) << 12) |                           \
              ((((uint8_t *)(ptr))[1] & 63) << 6) |                            \
              (((uint8_t *)(ptr))[2] & 63);                                    \
      (ptr) += 3;                                                              \
      break;                                                                   \
    case 4:                                                                    \
      if (((ptr) + 4 > (end)) ||                                               \
          fio__string_utf8_map[((uint8_t *)(ptr))[1] >> 3] != 5 ||             \
          fio__string_utf8_map[((uint8_t *)(ptr))[2] >> 3] != 5 ||             \
          fio__string_utf8_map[((uint8_t *)(ptr))[3] >> 3] != 5) {             \
        (i32) = -1;                                                            \
        break;                                                                 \
      }                                                                        \
      (i32) = ((((uint8_t *)(ptr))[0] & 7) << 18) |                            \
              ((((uint8_t *)(ptr))[1] & 63) << 12) |                           \
              ((((uint8_t *)(ptr))[2] & 63) << 6) |                            \
              (((uint8_t *)(ptr))[3] & 63);                                    \
      (ptr) += 4;                                                              \
      break;                                                                   \
    default: (i32) = -1; break;                                                \
    }                                                                          \
  } while (0);

/** Returns 1 if the String is UTF-8 valid and 0 if not. */
SFUNC size_t fio_string_utf8_valid(fio_str_info_s str) {
  if (!str.len)
    return 1;
  char *const end = str.buf + str.len;
  int32_t c = 0;
  do {
    FIO_STR_UTF8_CODE_POINT(str.buf, end, c);
  } while (c > 0 && str.buf < end);
  return str.buf == end && c >= 0;
}

/** Returns the String's length in UTF-8 characters. */
SFUNC size_t fio_string_utf8_len(fio_str_info_s str) {
  if (!str.len)
    return 0;
  char *end = str.buf + str.len;
  size_t utf8len = 0;
  int32_t c = 0;
  do {
    ++utf8len;
    FIO_STR_UTF8_CODE_POINT(str.buf, end, c);
  } while (c > 0 && str.buf < end);
  if (str.buf != end || c == -1) {
    /* invalid */
    return 0;
  }
  return utf8len;
}

/**
 * Takes a UTF-8 character selection information (UTF-8 position and length)
 * and updates the same variables so they reference the raw byte slice
 * information.
 *
 * If the String isn't UTF-8 valid up to the requested selection, than `pos`
 * will be updated to `-1` otherwise values are always positive.
 *
 * The returned `len` value may be shorter than the original if there wasn't
 * enough data left to accommodate the requested length. When a `len` value of
 * `0` is returned, this means that `pos` marks the end of the String.
 *
 * Returns -1 on error and 0 on success.
 */
SFUNC int fio_string_utf8_select(fio_str_info_s str,
                                 intptr_t *pos,
                                 size_t *len) {
  int32_t c = 0;
  char *p = str.buf;
  char *const end = str.buf + str.len;
  size_t start;

  if (!str.buf)
    goto error;
  if (!str.len || *pos == -1)
    goto at_end;

  if (*pos) {
    if ((*pos) > 0) {
      start = *pos;
      while (start && p < end && c >= 0) {
        FIO_STR_UTF8_CODE_POINT(p, end, c);
        --start;
      }
      if (c == -1)
        goto error;
      if (start || p >= end)
        goto at_end;
      *pos = p - str.buf;
    } else {
      /* walk backwards */
      p = str.buf + str.len - 1;
      c = 0;
      ++*pos;
      do {
        switch (fio__string_utf8_map[((uint8_t *)p)[0] >> 3]) {
        case 5: ++c; break;
        case 4:
          if (c != 3)
            goto error;
          c = 0;
          ++(*pos);
          break;
        case 3:
          if (c != 2)
            goto error;
          c = 0;
          ++(*pos);
          break;
        case 2:
          if (c != 1)
            goto error;
          c = 0;
          ++(*pos);
          break;
        case 1:
          if (c)
            goto error;
          ++(*pos);
          break;
        default: goto error;
        }
        --p;
      } while (p > str.buf && *pos);
      if (c)
        goto error;
      ++p; /* There's always an extra back-step */
      *pos = (p - str.buf);
    }
  }

  /* find end */
  start = *len;
  while (start && p < end && c >= 0) {
    FIO_STR_UTF8_CODE_POINT(p, end, c);
    --start;
  }
  if (c == -1 || p > end)
    goto error;
  *len = p - (str.buf + (*pos));
  return 0;

at_end:
  *pos = str.len;
  *len = 0;
  return 0;
error:
  *pos = -1;
  *len = 0;
  return -1;
}

/* *****************************************************************************
fio_string_is_greater
***************************************************************************** */

/**
 * Compares two `fio_buf_info_s`, returning 1 if data in a is bigger than b.
 *
 * Note: returns 0 if data in b is bigger than or equal(!).
 */
SFUNC int fio_string_is_greater_buf(fio_buf_info_s a, fio_buf_info_s b) {
  const size_t a_len_is_bigger = a.len > b.len;
  size_t len = a_len_is_bigger ? b.len : a.len; /* shared length */
  if (a.buf == b.buf)
    return a_len_is_bigger;
  uint64_t ua[4] FIO_ALIGN(16) = {0};
  uint64_t ub[4] FIO_ALIGN(16) = {0};
  uint64_t flag = 0;
  if (len < 32)
    goto mini_cmp;

  len -= 32;
  for (;;) {
    for (size_t i = 0; i < 4; ++i) {
      fio_memcpy8(ua + i, a.buf);
      fio_memcpy8(ub + i, b.buf);
      flag |= (ua[i] ^ ub[i]);
      a.buf += 8;
      b.buf += 8;
    }
    if (flag)
      goto review_diff;
    if (len > 31) {
      len -= 32;
      continue;
    }
    if (!len)
      return a_len_is_bigger;
    a.buf -= 32;
    b.buf -= 32;
    a.buf += len & 31;
    b.buf += len & 31;
    len = 0;
  }

review_diff:
  if (ua[2] != ub[2]) {
    ua[3] = ua[2];
    ub[3] = ub[2];
  }
  if (ua[1] != ub[1]) {
    ua[3] = ua[1];
    ub[3] = ub[1];
  }
  if (ua[0] != ub[0]) {
    ua[3] = ua[0];
    ub[3] = ub[0];
  }
review_diff8:
  ua[3] = fio_lton64(ua[3]); /* comparison requires network byte order */
  ub[3] = fio_lton64(ub[3]);
  return ua[3] > ub[3];

mini_cmp:
  if (len > 7) {
    len -= 8;
    for (;;) {
      fio_memcpy8(ua + 3, a.buf);
      fio_memcpy8(ub + 3, b.buf);
      if (ua[3] != ub[3])
        goto review_diff8;
      if (len > 7) {
        a.buf += 8;
        b.buf += 8;
        len -= 8;
        continue;
      }
      if (!len)
        return a_len_is_bigger;
      a.buf += len & 7;
      b.buf += len & 7;
      len = 0;
    }
  }
  while (len--) {
    if (a.buf[0] != b.buf[0])
      return a.buf[0] > b.buf[0];
    ++a.buf;
    ++b.buf;
  }
  return a_len_is_bigger;
}

/* *****************************************************************************
Insert / Write2
***************************************************************************** */

/* fio_string_replace */
SFUNC int fio_string_replace(fio_str_info_s *dest,
                             fio_string_realloc_fn reallocate,
                             intptr_t start_pos,
                             size_t overwrite_len,
                             const void *src,
                             size_t len) {
  int r = 0;
  if (start_pos < 0) {
    start_pos = dest->len + start_pos + 1;
    if (start_pos < 0)
      start_pos = 0;
  }
  if (dest->len < (size_t)start_pos + overwrite_len + 1) {
    if ((size_t)start_pos < dest->len)
      dest->len = start_pos;
    return fio_string_write(dest, reallocate, src, len);
  }

  size_t move_start = start_pos + overwrite_len;
  size_t move_len = dest->len - (start_pos + overwrite_len);
  if (overwrite_len < len) {
    /* adjust for possible memory expansion */
    const size_t extra = len - overwrite_len;
    if (dest->capa < dest->len + extra + 1) {
      r = -1; /* in case reallocate is NULL */
      if (!reallocate ||
          FIO_UNLIKELY(
              (r = reallocate(dest, fio_string_capa4len(dest->len + extra))))) {
        move_len -= (dest->len + extra + 1) - dest->capa;
        if (dest->capa < start_pos + len + 1) {
          move_len = 0;
          len = dest->capa - start_pos - 1;
        }
      }
    }
  }
  if (move_len)
    FIO_MEMMOVE(dest->buf + start_pos + len, dest->buf + move_start, move_len);
  if (len)
    FIO_MEMCPY(dest->buf + start_pos, src, len);
  dest->len = start_pos + len + move_len;
  dest->buf[dest->len] = 0;
  return r;
}

/* IDE marker */
void fio_string_write2____(void);
/* the fio_string_write2 is a printf alternative. */
SFUNC int fio_string_write2 FIO_NOOP(fio_str_info_s *restrict dest,
                                     fio_string_realloc_fn reallocate,
                                     const fio_string_write_s srcs[]) {
  int r = 0;
  const fio_string_write_s *pos = srcs;
  size_t len = 0;

  while (pos->klass) {
    switch (pos->klass) { /* use more memory rather then calculate twice. */
    case 2: /* number */ len += fio_digits10(pos->info.i); break;
    case 3: /* unsigned */ len += fio_digits10u(pos->info.u); break;
    case 4: /* hex */ len += fio_digits16u(pos->info.u); break;
    case 5: /* binary */ len += fio_digits_bin(pos->info.u); break;
    case 6: /* float */ len += 18; break;
    default: len += pos->info.str.len;
    }
    ++pos;
  }
  pos = srcs;
  if (fio_string___write_validate_len(dest, reallocate, &len))
    goto truncate;
  while (pos->klass) {
    switch (pos->klass) {
    case 2: fio_string_write_i(dest, NULL, pos->info.i); break;   /* number */
    case 3: fio_string_write_u(dest, NULL, pos->info.u); break;   /* unsigned */
    case 4: fio_string_write_hex(dest, NULL, pos->info.u); break; /* hex */
    case 5: fio_string_write_bin(dest, NULL, pos->info.u); break; /* binary */
    case 6:                                                       /* float */
      dest->len += snprintf(dest->buf + dest->len, 19, "%.15g", pos->info.f);
      break;
    default:
      FIO_MEMCPY(&dest->buf[dest->len], pos->info.str.buf, pos->info.str.len);
      dest->len += pos->info.str.len;
    }
    ++pos;
  }
finish:
  dest->buf[dest->len] = 0;
  return r;
truncate:
  r = -1;
  while (pos->klass) {
    switch (pos->klass) {
    case 2:
      if (fio_string_write_i(dest, NULL, pos->info.i))
        goto finish;
      break; /* number */
    case 3:
      if (fio_string_write_u(dest, NULL, pos->info.u))
        goto finish;
      break; /* unsigned */
    case 4:
      if (fio_string_write_hex(dest, NULL, pos->info.u))
        goto finish;
      break; /* hex */
    case 5:
      if (fio_string_write_bin(dest, NULL, pos->info.u))
        goto finish;
      break; /* binary */
    case 6:  /* float */
      len = snprintf(dest->buf + dest->len, 19, "%.15g", pos->info.f);
      if (dest->capa < dest->len + len + 2)
        goto finish;
      dest->len += len;
      break;
    default:
      if (fio_string_write(dest, NULL, pos->info.str.buf, pos->info.str.len))
        goto finish;
    }
    ++pos;
  }
  goto finish;
}

/* *****************************************************************************
String C / JSON escaping
***************************************************************************** */

/**
 * Writes data at the end of the String, escaping the data using JSON semantics.
 *
 * The JSON semantic are common to many programming languages, promising a UTF-8
 * String while making it easy to read and copy the string during debugging.
 */
SFUNC int fio_string_write_escape(fio_str_info_s *restrict dest,
                                  fio_string_realloc_fn reallocate,
                                  const void *src_,
                                  size_t len) {
  int r = 0;
  if ((!len | !src_ | !dest))
    return r;
  if (dest->buf + dest->len == (char *)src_)
    return (r = -1);
  const uint8_t *src = (const uint8_t *)src_;
  size_t at = 0;
  uint8_t set_at = 1;
  size_t escaped_len = len;

  /* collect escaping requirements */
  for (size_t i = 0; i < len; ++i) {
    /* skip valid ascii */
    if ((src[i] > 34 && src[i] < 127 && src[i] != '\\') || src[i] == '!' ||
        src[i] == ' ')
      continue;
    /* skip valid UTF-8 */
    switch (fio__string_utf8_map[src[i] >> 3]) {
    case 4:
      if (fio__string_utf8_map[src[i + 3] >> 3] != 5) {
        break; /* from switch */
      }
    /* fall through */
    case 3:
      if (fio__string_utf8_map[src[i + 2] >> 3] != 5) {
        break; /* from switch */
      }
    /* fall through */
    case 2:
      if (fio__string_utf8_map[src[i + 1] >> 3] != 5) {
        break; /* from switch */
      }
      i += fio__string_utf8_map[src[i] >> 3] - 1;
      continue;
    }
    /* store first instance of character that needs escaping */
    /* constant time (non-branching) alternative to if(`set_at`) */
    at ^= ((set_at | (0 - set_at)) & (i ^ at));
    set_at = 0;
    /* count extra bytes */
    switch (src[i]) {
    case '\b': /* fall through */
    case '\f': /* fall through */
    case '\n': /* fall through */
    case '\r': /* fall through */
    case '\t': /* fall through */
    case '"':  /* fall through */
    case '\\': /* fall through */
    case '/': ++escaped_len; break;
    default:
      /* escaping all control characters and non-UTF-8 characters */
      escaped_len += 3 + ((src[i] < 127) << 1);
    }
  }
  /* reserve space and copy any valid "head" */
  /* the +4 adds room for the usual use case of a following "\", \"" */
  if ((dest->capa < dest->len + escaped_len + 1) &&
      (!reallocate ||
       reallocate(dest, fio_string_capa4len(dest->len + escaped_len + 4)))) {
    r = -1;
    len = (dest->capa + len) - (dest->len + escaped_len + 2);
    if (dest->capa < len + 2)
      return r;
  }

  uint8_t *writer = (uint8_t *)dest->buf + dest->len;
  /* is escaping required? - simple memcpy if we don't need to escape */
  if (set_at) {
    FIO_MEMCPY(writer, src, len);
    dest->len += len;
    return r;
  }
  /* simple memcpy until first char that needs escaping */
  if (at >= 8) {
    FIO_MEMCPY(writer, src, at);
  } else {
    at = 0;
  }
  /* start escaping */
  for (size_t i = at; i < len; ++i) {
    /* skip valid ascii */
    if ((src[i] > 34 && src[i] < 127 && src[i] != '\\') || src[i] == '!' ||
        src[i] == ' ') {
      writer[at++] = src[i];
      continue;
    }
    /* skip valid UTF-8 */
    switch (fio__string_utf8_map[src[i] >> 3]) {
    case 4:
      if (fio__string_utf8_map[src[i + 3] >> 3] != 5) {
        break; /* from switch */
      }
    /* fall through */
    case 3:
      if (fio__string_utf8_map[src[i + 2] >> 3] != 5) {
        break; /* from switch */
      }
    /* fall through */
    case 2:
      if (fio__string_utf8_map[src[i + 1] >> 3] != 5) {
        break; /* from switch */
      }
      switch (fio__string_utf8_map[src[i] >> 3]) {
      case 4: writer[at++] = src[i++]; /* fall through */
      case 3: writer[at++] = src[i++]; /* fall through */
      case 2: writer[at++] = src[i++]; writer[at++] = src[i];
      }
      continue;
    }

    /* write escape sequence */
    writer[at++] = '\\';
    switch (src[i]) {
    case '\b': writer[at++] = 'b'; break;
    case '\f': writer[at++] = 'f'; break;
    case '\n': writer[at++] = 'n'; break;
    case '\r': writer[at++] = 'r'; break;
    case '\t': writer[at++] = 't'; break;
    case '"': writer[at++] = '"'; break;
    case '\\': writer[at++] = '\\'; break;
    case '/': writer[at++] = '/'; break;
    default:
      /* escaping all control characters and non-UTF-8 characters */
      if (src[i] < 127) {
        writer[at++] = 'u';
        writer[at++] = '0';
        writer[at++] = '0';
        writer[at++] = fio_i2c(src[i] >> 4);
        writer[at++] = fio_i2c(src[i] & 15);
      } else {
        /* non UTF-8 data... encode as hex */
        writer[at++] = 'x';
        writer[at++] = fio_i2c(src[i] >> 4);
        writer[at++] = fio_i2c(src[i] & 15);
      }
    }
  }
  dest->len += at;
  dest->buf[dest->len] = 0;
  return r;
}

/**
 * Writes an escaped data into the string after unescaping the data.
 */
SFUNC int fio_string_write_unescape(fio_str_info_s *dest,
                                    fio_string_realloc_fn reallocate,
                                    const void *src_,
                                    size_t len) {
  int r = 0;
  size_t at = 0;
  size_t reduced = 0;
  if ((!len | !src_ | !dest))
    return r;
  { /* calculate assumed `len` reduction (minimal reduction) */
    const char *tmp = (const char *)src_;
    const char *stop = tmp + len - 1; /* avoid overflow for tmp[1] */
    for (;;) {
      tmp = (const char *)FIO_MEMCHR(tmp, '\\', (size_t)(stop - tmp));
      if (!tmp)
        break;
      size_t step = 1;
      step += ((tmp[1] == 'x') << 1); /* step == 3 */
      step += (tmp[1] == 'u');        /* UTF-8 output <= 3 */
      reduced += step;
      tmp += step;
      if (tmp + 1 > stop)
        break;
    }
    FIO_ASSERT_DEBUG(reduced < len, "string unescape reduced too long");
    reduced = len - reduced;
  }
  if (fio_string___write_validate_len(dest, reallocate, &reduced)) {
    r = -1;
    len = dest->capa - (dest->len + 1);
  }
  const uint8_t *src = (const uint8_t *)src_;
  const uint8_t *end = src + len;
  uint8_t *writer = (uint8_t *)dest->buf + dest->len;
  while (src < end) {
    if (*src != '\\') {
      const uint8_t *escape_pos =
          (const uint8_t *)FIO_MEMCHR(src, '\\', end - src);
      if (!escape_pos)
        escape_pos = end;
      const size_t valid_len = escape_pos - src;
      if (writer + at != src && valid_len)
        FIO_MEMMOVE(writer + at, src, valid_len);
      at += valid_len;
      src = escape_pos;
    }
    if (end - src == 1) {
      writer[at++] = *(src++);
    }
    if (src >= end)
      break;
    /* escaped data - src[0] == '\\' */
    ++src;
    switch (src[0]) {
    case 'b':
      writer[at++] = '\b';
      ++src;
      break; /* from switch */
    case 'f':
      writer[at++] = '\f';
      ++src;
      break; /* from switch */
    case 'n':
      writer[at++] = '\n';
      ++src;
      break; /* from switch */
    case 'r':
      writer[at++] = '\r';
      ++src;
      break; /* from switch */
    case 't':
      writer[at++] = '\t';
      ++src;
      break; /* from switch */
    case 'u': {
      /* test UTF-8 notation */
      if (fio_c2i(src[1]) < 16 && fio_c2i(src[2]) < 16 &&
          fio_c2i(src[3]) < 16 && fio_c2i(src[4]) < 16) {
        uint32_t u = (((fio_c2i(src[1]) << 4) | fio_c2i(src[2])) << 8) |
                     ((fio_c2i(src[3]) << 4) | fio_c2i(src[4]));
        if (((fio_c2i(src[1]) << 4) | fio_c2i(src[2])) == 0xD8U &&
            src[5] == '\\' && src[6] == 'u' && fio_c2i(src[7]) < 16 &&
            fio_c2i(src[8]) < 16 && fio_c2i(src[9]) < 16 &&
            fio_c2i(src[10]) < 16) {
          /* surrogate-pair */
          u = (u & 0x03FF) << 10;
          u |= (((((fio_c2i(src[7]) << 4) | fio_c2i(src[8])) << 8) |
                 ((fio_c2i(src[9]) << 4) | fio_c2i(src[10]))) &
                0x03FF);
          u += 0x10000;
          src += 6;
        }
        if (u < 128) {
          writer[at++] = u;
        } else if (u < 2048) {
          writer[at++] = 192 | (u >> 6);
          writer[at++] = 128 | (u & 63);
        } else if (u < 65536) {
          writer[at++] = 224 | (u >> 12);
          writer[at++] = 128 | ((u >> 6) & 63);
          writer[at++] = 128 | (u & 63);
        } else {
          writer[at++] = 240 | ((u >> 18) & 7);
          writer[at++] = 128 | ((u >> 12) & 63);
          writer[at++] = 128 | ((u >> 6) & 63);
          writer[at++] = 128 | (u & 63);
        }
        src += 5;
        break; /* from switch */
      } else
        goto invalid_escape;
    }
    case 'x': { /* test for hex notation */
      if (fio_c2i(src[1]) < 16 && fio_c2i(src[2]) < 16) {
        writer[at++] = (fio_c2i(src[1]) << 4) | fio_c2i(src[2]);
        src += 3;
        break; /* from switch */
      } else
        goto invalid_escape;
    }
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7': { /* test for octal notation */
      if (src[0] >= '0' && src[0] <= '7' && src[1] >= '0' && src[1] <= '7') {
        writer[at++] = ((src[0] - '0') << 3) | (src[1] - '0');
        src += 2;
        break; /* from switch */
      } else
        goto invalid_escape;
    }
    case '"':
    case '\\':
    case '/':
    /* fall through */
    default:
    invalid_escape:
      writer[at++] = *(src++);
    }
  }
  dest->len += at;
  dest->buf[dest->len] = 0;
  FIO_ASSERT_DEBUG(at < reduced + 1,
                   "string unescape reduced calculation error");
  return r;
}

/* *****************************************************************************
String Base64 support
***************************************************************************** */

/** Writes data to String using Base64 encoding. */
SFUNC int fio_string_write_base64enc(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *data,
                                     size_t len,
                                     uint8_t url_encoded) {
  int r = 0;
  if (!dest || !data || !len)
    return r;
  static const char *encmap[2] = {
      /* Regular, URL encoding*/
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  };

  /* the base64 encoding array */
  const char *encoding = encmap[!!url_encoded];

  /* base64 length and padding information */
  size_t groups = len / 3;
  const size_t mod = len - (groups * 3);
  size_t target_size = (groups + (mod != 0)) * 4;

  if (fio_string___write_validate_len(dest, reallocate, &target_size)) {
    return (r = -1); /* no partial encoding. */
  }
  char *writer = dest->buf + dest->len;
  const unsigned char *reader = (const unsigned char *)data;
  dest->len += target_size;
  /* write encoded data */
  while (groups) {
    --groups;
    const unsigned char tmp1 = *(reader++);
    const unsigned char tmp2 = *(reader++);
    const unsigned char tmp3 = *(reader++);

    *(writer++) = encoding[(tmp1 >> 2) & 63];
    *(writer++) = encoding[(((tmp1 & 3) << 4) | ((tmp2 >> 4) & 15))];
    *(writer++) = encoding[((tmp2 & 15) << 2) | ((tmp3 >> 6) & 3)];
    *(writer++) = encoding[tmp3 & 63];
  }

  /* write padding / ending */
  switch (mod) {
  case 2: {
    const unsigned char tmp1 = *(reader++);
    const unsigned char tmp2 = *(reader++);

    *(writer++) = encoding[(tmp1 >> 2) & 63];
    *(writer++) = encoding[((tmp1 & 3) << 4) | ((tmp2 >> 4) & 15)];
    *(writer++) = encoding[((tmp2 & 15) << 2)];
    *(writer++) = '=';
  } break;
  case 1: {
    const unsigned char tmp1 = *(reader++);

    *(writer++) = encoding[(tmp1 >> 2) & 63];
    *(writer++) = encoding[(tmp1 & 3) << 4];
    *(writer++) = '=';
    *(writer++) = '=';
  } break;
  }
  dest->buf[dest->len] = 0;
  return r;
}

/** Writes decoded base64 data to String. */
SFUNC int fio_string_write_base64dec(fio_str_info_s *dest,
                                     fio_string_realloc_fn reallocate,
                                     const void *encoded_,
                                     size_t len) {
  /* Base64 decoding array. Generation script (Ruby):
s = ["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
valid = []; (0..255).each {|i| valid[i] = 0 };
decoder = []; (0..127).each {|i| decoder[i] = 0 };
s.each {|d| d.bytes.each_with_index { |b, i| decoder[b] = i; valid[b] = 1 } };
p valid; p decoder; nil
  */
  static const uint8_t base64_valid[256] = {
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  };
  static const uint8_t base64_decodes[128] = {
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  62, 0,  62, 0,  63,
      52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0,  0,  0,  64, 0,  0,
      0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14,
      15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0,  0,  0,  0,  63,
      0,  26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
      41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 0,  0,  0,  0,  0,
  };
  int r = 0;
  if (!dest || !encoded_)
    return (r = -1);
  const uint8_t *encoded = (const uint8_t *)encoded_;
  /* skip unknown data at end */
  while (len && !base64_valid[encoded[len - 1]]) {
    len--;
  }
  if (!len)
    return (r = -1);

  /* reserve memory space */
  {
    size_t required_len = (((len >> 2) * 3) + 3);
    if (fio_string___write_validate_len(dest, reallocate, &required_len)) {
      return (r = -1); /* no partial decoding. */
    };
  }

  /* decoded and count actual length */
  size_t pos = 0;
  uint8_t b64wrd[4];
  const uint8_t *stop = encoded + len;
  uint8_t *writer = (uint8_t *)dest->buf + dest->len;
  for (;;) {
    if (base64_valid[encoded[0]])
      b64wrd[pos++] = base64_decodes[encoded[0]];
    else if (!isspace(encoded[0]))
      break;
    ++encoded;
    if (pos == 4) {
      writer[0] = (b64wrd[0] << 2) | (b64wrd[1] >> 4);
      writer[1] = (b64wrd[1] << 4) | (b64wrd[2] >> 2);
      writer[2] = (b64wrd[2] << 6) | b64wrd[3];
      pos = 0;
      writer += 3;
    }
    if (encoded == stop)
      break;
  }
  switch (pos) {
  case 1: b64wrd[1] = 0; /* fall through */
  case 2: b64wrd[2] = 0; /* fall through */
  case 3: b64wrd[3] = 0; /* fall through */
  case 4:
    writer[0] = (b64wrd[0] << 2) | (b64wrd[1] >> 4);
    writer[1] = (b64wrd[1] << 4) | (b64wrd[2] >> 2);
    writer[2] = (b64wrd[2] << 6) | b64wrd[3];
    writer += 3;
  }
  writer -= (encoded[-1] == '=') + (encoded[-2] == '=');
  if (writer < ((uint8_t *)dest->buf + dest->len))
    writer = ((uint8_t *)dest->buf + dest->len);
  dest->len = (size_t)(writer - (uint8_t *)dest->buf);
  dest->buf[dest->len] = 0;
  return r;
}

/* *****************************************************************************
String File Reading support
***************************************************************************** */

FIO_IFUNC intptr_t fio___string_fd_normalise_offset(intptr_t i,
                                                    size_t file_len) {
  if (i < 0) {
    i += (intptr_t)file_len + 1;
    if (i < 0)
      i = 0;
  }
  return i;
}

/**
 * Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at`.
 *
 * If `limit` is 0 (or less than 0) data will be written until EOF.
 *
 * If `start_at` is negative, position will be calculated from the end of the
 * file where `-1 == EOF`.
 *
 * Note: this will fail unless used on actual files (not sockets, not pipes).
 * */
SFUNC int fio_string_readfd(fio_str_info_s *dest,
                            fio_string_realloc_fn reallocate,
                            int fd,
                            intptr_t start_at,
                            size_t limit) {
  int r = 0;
  size_t file_len = fio_fd_size(fd);
  start_at = fio___string_fd_normalise_offset(start_at, file_len);
  if (limit < 1 || file_len < (size_t)(limit + start_at)) {
    limit = (intptr_t)file_len - start_at;
  }
  if (!dest || !file_len || !limit || (size_t)start_at >= file_len) {
    return (r = -1);
  }
  r = fio_string___write_validate_len(dest, reallocate, &limit);
  size_t added = fio_fd_read(fd, dest->buf + dest->len, limit, (off_t)start_at);
  dest->len += added;
  dest->buf[dest->len] = 0;
  return r;
}

/**
 * Opens the file `filename` and pastes it's contents (or a slice ot it) at
 * the end of the String. If `limit == 0`, than the data will be read until
 * EOF.
 *
 * If the file can't be located, opened or read, or if `start_at` is beyond
 * the EOF position, NULL is returned in the state's `data` field.
 */
SFUNC int fio_string_readfile(fio_str_info_s *dest,
                              fio_string_realloc_fn reallocate,
                              const char *filename,
                              intptr_t start_at,
                              size_t limit) {
  int r = -1;
  int fd = fio_filename_open(filename, O_RDONLY);
  if (fd == -1)
    return r;
  r = fio_string_readfd(dest, reallocate, fd, start_at, limit);
  close(fd);
  return r;
}

/**
 * Writes up to `limit` bytes from `fd` into `dest`, starting at `start_at` and
 * ending at the first occurrence of `token`.
 *
 * If `limit` is 0 (or less than 0) as much data as may be required will be
 * written.
 *
 * If `start_at` is negative, position will be calculated from the end of the
 * file where `-1 == EOF`.
 *
 * Note: this will fail unless used on actual seekable files (not sockets, not
 * pipes).
 * */
SFUNC int fio_string_getdelim_fd(fio_str_info_s *dest,
                                 fio_string_realloc_fn reallocate,
                                 int fd,
                                 intptr_t start_at,
                                 char delim,
                                 size_t limit) {
  int r = -1;
  if (!dest || fd == -1)
    return r;
  size_t file_len = fio_fd_size(fd);
  if (!file_len)
    return r;
  start_at = fio___string_fd_normalise_offset(start_at, file_len);
  if ((size_t)start_at >= file_len)
    return r;
  size_t index = fio_fd_find_next(fd, delim, (size_t)start_at);
  if (index == FIO_FD_FIND_EOF)
    return r;
  if (limit < 1 || limit > (index - start_at) + 1) {
    limit = (index - start_at) + 1;
  }

  r = fio_string___write_validate_len(dest, reallocate, &limit);
  size_t added = fio_fd_read(fd, dest->buf + dest->len, limit, (off_t)start_at);
  dest->len += added;
  dest->buf[dest->len] = 0;
  return r;
}

/**
 * Opens the file `filename`, calls `fio_string_getdelim_fd` and closes the
 * file.
 */
SFUNC int fio_string_getdelim_file(fio_str_info_s *dest,
                                   fio_string_realloc_fn reallocate,
                                   const char *filename,
                                   intptr_t start_at,
                                   char delim,
                                   size_t limit) {
  int r = -1;
  int fd = fio_filename_open(filename, O_RDONLY);
  if (fd == -1)
    return r;
  r = fio_string_getdelim_fd(dest, reallocate, fd, start_at, delim, limit);
  close(fd);
  return r;
}

/* *****************************************************************************
Binary String Type - Embedded Strings
***************************************************************************** */
/** default reallocation callback implementation */
SFUNC int fio_bstr_reallocate(fio_str_info_s *dest, size_t len) {
  fio___bstr_meta_s *bstr_m = NULL;
  const size_t new_capa = fio_string_capa4len(len + 1 + sizeof(bstr_m[0]));
  if (!dest->capa)
    goto copy_the_string;
  bstr_m = (fio___bstr_meta_s *)FIO_MEM_REALLOC_(
      ((fio___bstr_meta_s *)dest->buf - 1),
      sizeof(bstr_m[0]) + dest->capa,
      new_capa,
      ((fio___bstr_meta_s *)dest->buf)[-1].len + sizeof(bstr_m[0]));
  if (!bstr_m)
    return -1;
update_metadata:
  dest->buf = (char *)(bstr_m + 1);
  bstr_m->capa = dest->capa = new_capa - sizeof(bstr_m[0]);
  return 0;

copy_the_string:
  bstr_m = (fio___bstr_meta_s *)FIO_MEM_REALLOC_(NULL, 0, new_capa, 0);
  if (!bstr_m)
    return -1;
  if (!FIO_MEM_REALLOC_IS_SAFE_)
    *bstr_m = (fio___bstr_meta_s){0};
  FIO_BSTR___LEAK_TESTER(1);
  if (dest->len) {
    FIO_MEMCPY((bstr_m + 1), dest->buf, dest->len + 1);
    bstr_m->len = dest->len;
  }
  goto update_metadata;
}

#if defined(DEBUG) || defined(FIO_LEAK_COUNTER)
/* leak tester implementation */
SFUNC void FIO_BSTR___LEAK_TESTER(int add) {
  static size_t counter = 0;
  if (add > 0) {
    fio_atomic_add(&counter, 1);
    return;
  }
  if (add < 0) {
    fio_atomic_sub(&counter, 1);
    return;
  }
  if (counter) {
    FIO_LOG_ERROR("(fio_bstr_s):\n          "
                  "%zd memory leak(s) detected for "
                  "type: fio_bstr_s",
                  counter);
  }
}
#endif /* defined(DEBUG) || defined(FIO_LEAK_COUNTER) */

/* *****************************************************************************
Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

FIO_SFUNC size_t FIO_NAME_TEST(stl, string_core_ltoa)(char *buf,
                                                      int64_t i,
                                                      uint8_t base) {
  fio_str_info_s s = FIO_STR_INFO3(buf, 0, 1024);
  if (base == 16) {
    fio_string_write_hex(&s, NULL, i);
    return s.len;
  }
  if (base == 2) {
    fio_string_write_bin(&s, NULL, i);
    return s.len;
  }
  fio_string_write_i(&s, NULL, i);
  return s.len;
}

FIO_SFUNC void FIO_NAME_TEST(stl, string_core_helpers)(void) {
  fprintf(stderr, "* Testing Core String API.\n");
  { /* test basic fio_string_write functions. */
    fprintf(stderr, "* Testing Core String writing functions.\n");
    char mem[16];
    fio_str_info_s buf = FIO_STR_INFO3(mem, 0, 16);
    FIO_ASSERT(!fio_string_write(&buf, NULL, "World", 5),
               "non-truncated return should be zero for fio_string_write");
    FIO_ASSERT(mem == buf.buf && buf.len == 5 && !memcmp(buf.buf, "World", 6),
               "fio_string_write failed!");
    FIO_ASSERT(!fio_string_replace(&buf, NULL, 0, 0, "Hello ", 6),
               "non-truncated return should be zero for fio_string_replace");
    FIO_ASSERT(mem == buf.buf && buf.len == 11 &&
                   !memcmp(buf.buf, "Hello World", 12),
               "fio_string_replace failed to perform insert (index[0])!");
    fio_string_write(&buf, NULL, "Hello World", 11);
    FIO_ASSERT(mem == buf.buf && buf.len == 15 &&
                   !memcmp(buf.buf, "Hello WorldHell", 16),
               "fio_string_write failed to truncate!");
    fio_string_replace(&buf, NULL, 0, 5, "Hola", 4);
    FIO_ASSERT(mem == buf.buf && buf.len == 14 &&
                   !memcmp(buf.buf, "Hola WorldHell", 15),
               "fio_string_replace at index 0 failed!");
    FIO_ASSERT(!fio_string_replace(&buf, NULL, 5, 9, "World", 5),
               "non-truncated return should be zero for fio_string_replace");
    FIO_ASSERT(mem == buf.buf && buf.len == 10 &&
                   !memcmp(buf.buf, "Hola World", 11),
               "fio_string_replace end overwrite failed!");
    fio_string_replace(&buf, NULL, 5, 0, "my beautiful", 12);
    FIO_ASSERT(mem == buf.buf && buf.len == 15 &&
                   !memcmp(buf.buf, "Hola my beautif", 16),
               "fio_string_replace failed to truncate!");
    FIO_ASSERT(fio_string_replace(&buf, NULL, -11, 2, "big", 3),
               "truncation should return non-zero on fio_string_replace.");
    FIO_ASSERT(mem == buf.buf && buf.len == 15 &&
                   !memcmp(buf.buf, "Hola big beauti", 16),
               "fio_string_replace failed to truncate (negative index)!");
    buf = FIO_STR_INFO3(mem, 0, 16);
    fio_string_printf(&buf, NULL, "I think %d is the best answer", 42);
    FIO_ASSERT(mem == buf.buf && buf.len == 15 &&
                   !memcmp(buf.buf, "I think 42 is t", 16),
               "fio_string_printf failed to truncate!");

    FIO_MEMSET(mem, 0, 16);
    buf = FIO_STR_INFO3(mem, 0, 16);
    FIO_ASSERT(
        fio_string_write2(&buf,
                          NULL,
                          FIO_STRING_WRITE_STR2((char *)"I think ", 8),
                          FIO_STRING_WRITE_NUM(42),
                          FIO_STRING_WRITE_STR1((char *)" is the best answer")),
        "truncation return value should be non-zero for fio_string_write2.");
    FIO_ASSERT(mem == buf.buf && buf.len == 15 &&
                   !memcmp(buf.buf, "I think 42 is t", 16),
               "fio_string_write2 failed to truncate!");
    FIO_MEMSET(mem, 0, 16);
    buf = FIO_STR_INFO3(mem, 0, 16);
    FIO_ASSERT(
        fio_string_write2(&buf,
                          NULL,
                          FIO_STRING_WRITE_STR2((char *)"I think ", 8),
                          FIO_STRING_WRITE_HEX(42),
                          FIO_STRING_WRITE_STR1((char *)" is the best answer")),
        "truncation return value should be non-zero for fio_string_write2.");
    FIO_ASSERT(mem == buf.buf && buf.len == 15 &&
                   !memcmp(buf.buf, "I think 2A is t", 16),
               "fio_string_write2 failed to truncate (hex)!");
    FIO_MEMSET(mem, 0, 16);
    buf = FIO_STR_INFO3(mem, 0, 16);
    FIO_ASSERT(
        fio_string_write2(&buf,
                          NULL,
                          FIO_STRING_WRITE_STR2((char *)"I Think ", 8),
                          FIO_STRING_WRITE_FLOAT(42.42),
                          FIO_STRING_WRITE_STR1((char *)" is the best answer")),
        "truncation return value should be non-zero for fio_string_write2.");
    FIO_ASSERT(mem == buf.buf && buf.len == 15 &&
                   !memcmp(buf.buf, "I Think 42.42 i", 16),
               "fio_string_write2 failed to truncate (float)!");
    buf = FIO_STR_INFO3(mem, 0, 16);
    fio_string_write2(&buf,
                      NULL,
                      FIO_STRING_WRITE_STR2((char *)"I think ", 8),
                      FIO_STRING_WRITE_BIN(-1LL),
                      FIO_STRING_WRITE_STR1((char *)" is the best answer"));
    FIO_ASSERT(mem == buf.buf && buf.len == 8 &&
                   !memcmp(buf.buf, "I think ", 8),
               "fio_string_write2 failed to truncate (bin)!");
  }
  { /* test numeral fio_string_write functions. */
    char mem[32];
    fio_str_info_s buf = FIO_STR_INFO3(mem, 0, 32);
    FIO_ASSERT(!fio_string_write_i(&buf, NULL, 0),
               "fio_string_write_i returned error!");
    FIO_ASSERT(mem == buf.buf && buf.len == 1 && !memcmp(buf.buf, "0", 2),
               "fio_string_write_i didn't print 0!");
    FIO_ASSERT(!fio_string_write_i(&buf, NULL, -42),
               "fio_string_write_i returned error!");
    FIO_ASSERT(mem == buf.buf && buf.len == 4 && !memcmp(buf.buf, "0-42", 5),
               "fio_string_write_i didn't print -24!");
    buf = FIO_STR_INFO3(mem, 0, 32);
    FIO_ASSERT(!fio_string_write_u(&buf, NULL, 0),
               "fio_string_write_u returned error!");
    FIO_ASSERT(mem == buf.buf && buf.len == 1 && !memcmp(buf.buf, "0", 2),
               "fio_string_write_u didn't print 0!");
    FIO_ASSERT(!fio_string_write_u(&buf, NULL, -42LL),
               "fio_string_write_u returned error!");
    FIO_ASSERT(mem == buf.buf && buf.len == 21 &&
                   !memcmp(buf.buf, "018446744073709551574", 21),
               "fio_string_write_u didn't print -24!");
    buf = FIO_STR_INFO3(mem, 0, 32);
    FIO_ASSERT(!fio_string_write_hex(&buf, NULL, 0),
               "fio_string_write_hex returned error!");
    FIO_ASSERT(mem == buf.buf && buf.len == 2 && !memcmp(buf.buf, "00", 3),
               "fio_string_write_hex didn't print 0!");
    FIO_ASSERT(!fio_string_write_hex(&buf, NULL, 42),
               "fio_string_write_hex returned error!");
    FIO_ASSERT(mem == buf.buf && buf.len == 4 && !memcmp(buf.buf, "002A", 5),
               "fio_string_write_hex didn't print 2A!");
    buf = FIO_STR_INFO3(mem, 0, 32);
    FIO_ASSERT(!fio_string_write_bin(&buf, NULL, 0),
               "fio_string_write_bin returned error!");
    FIO_ASSERT(mem == buf.buf && buf.len == 1 && !memcmp(buf.buf, "0", 2),
               "fio_string_write_bin didn't print 0!");
    FIO_ASSERT(!fio_string_write_bin(&buf, NULL, 16),
               "fio_string_write_bin returned error!");
    FIO_ASSERT(mem == buf.buf && buf.len == 7 && !memcmp(buf.buf, "0010000", 8),
               "fio_string_write_bin didn't print 16!");
  }
  { /* Testing UTF-8 */
    fprintf(stderr, "* Testing UTF-8 support.\n");
    const char *utf8_sample = /* three hearts, small-big-small*/
        "\xf0\x9f\x92\x95\xe2\x9d\xa4\xef\xb8\x8f\xf0\x9f\x92\x95";
    fio_str_info_s utf8 = FIO_STR_INFO1((char *)utf8_sample);
    intptr_t pos = -2;
    size_t len = 2;
    FIO_ASSERT(fio_string_utf8_select(utf8, &pos, &len) == 0,
               "`fio_string_utf8_select` returned error for negative pos on "
               "UTF-8 data! (%zd, %zu)",
               (ssize_t)pos,
               len);
    FIO_ASSERT(pos == (intptr_t)utf8.len - 4, /* 4 byte emoji */
               "`fio_string_utf8_select` error, negative position invalid on "
               "UTF-8 data! (%zd)",
               (ssize_t)pos);
    FIO_ASSERT(len == 4, /* last utf-8 char is 4 byte long */
               "`fio_string_utf8_select` error, truncated length invalid on "
               "UTF-8 data! (%zd)",
               (ssize_t)len);
    pos = 1;
    len = 20;
    FIO_ASSERT(fio_string_utf8_select(utf8, &pos, &len) == 0,
               "`fio_string_utf8_select` returned error on UTF-8 data! "
               "(%zd, %zu)",
               (ssize_t)pos,
               len);
    FIO_ASSERT(pos == 4,
               "`fio_string_utf8_select` error, position invalid on "
               "UTF-8 data! (%zd)",
               (ssize_t)pos);
    FIO_ASSERT(len == 10,
               "`fio_string_utf8_select` error, length invalid on "
               "UTF-8 data! (%zd)",
               (ssize_t)len);
    pos = 1;
    len = 3;
    FIO_ASSERT(fio_string_utf8_select(utf8, &pos, &len) == 0,
               "`fio_string_utf8_select` returned error on UTF-8 data "
               "(2)! (%zd, %zu)",
               (ssize_t)pos,
               len);
    FIO_ASSERT(len ==
                   10, /* 3 UTF-8 chars: 4 byte + 4 byte + 2 byte codes == 10 */
               "`fio_string_utf8_select` error, length invalid on UTF-8 data! "
               "(%zd)",
               (ssize_t)len);
  }
  { /* testing C / JSON style escaping */
    fprintf(stderr, "* Testing C / JSON style character (un)escaping.\n");
    char mem[2048];
    fio_str_info_s unescaped = FIO_STR_INFO3(mem, 0, 512);
    fio_str_info_s decoded = FIO_STR_INFO3(mem + 512, 0, 512);
    fio_str_info_s encoded = FIO_STR_INFO3(mem + 1024, 0, 1024);
    const char *utf8_sample = /* three hearts, small-big-small*/
        "\xf0\x9f\x92\x95\xe2\x9d\xa4\xef\xb8\x8f\xf0\x9f\x92\x95";
    FIO_ASSERT(
        !fio_string_write(&unescaped, NULL, utf8_sample, strlen(utf8_sample)),
        "Couldn't write UTF-8 example.");
    for (int i = 0; i < 256; ++i) {
      uint8_t c = i;
      FIO_ASSERT(!fio_string_write(&unescaped, NULL, &c, 1),
                 "write returned an error");
    }
    FIO_ASSERT(
        !fio_string_write_escape(&encoded, NULL, unescaped.buf, unescaped.len),
        "write escape returned an error");
    FIO_ASSERT(
        !fio_string_write_unescape(&decoded, NULL, encoded.buf, encoded.len),
        "write unescape returned an error");
    FIO_ASSERT(encoded.len, "JSON encoding failed");
    FIO_ASSERT(!memcmp(encoded.buf, utf8_sample, strlen(utf8_sample)),
               "valid UTF-8 data shouldn't be escaped:\n%.*s\n%s",
               (int)encoded.len,
               encoded.buf,
               decoded.buf);
    FIO_ASSERT(
        unescaped.len == decoded.len,
        "C escaping roundtrip length error, %zu != %zu (%zu - %zu):\n %s",
        unescaped.len,
        decoded.len,
        decoded.len,
        encoded.len,
        decoded.buf);
    FIO_ASSERT(!memcmp(unescaped.buf, decoded.buf, unescaped.len),
               "C escaping round-trip failed:\n %s",
               decoded.buf);
  }
  { /* testing Base64 Support */
    fprintf(stderr, "* Testing Base64 encoding / decoding.\n");
    char mem[2048];
    fio_str_info_s original = FIO_STR_INFO3(mem, 0, 512);
    fio_str_info_s decoded = FIO_STR_INFO3(mem + 512, 0, 512);
    fio_str_info_s encoded = FIO_STR_INFO3(mem + 1024, 0, 512);
    fio_string_write(&original,
                     NULL,
                     "Hello World, this is the voice of peace:)",
                     41);
    for (int i = 0; i < 256; ++i) {
      uint8_t c = i;
      FIO_ASSERT(!fio_string_write(&original, NULL, &c, 1),
                 "write returned an error");
    }
    FIO_ASSERT(!fio_string_write_base64enc(&encoded,
                                           NULL,
                                           original.buf,
                                           original.len,
                                           1),
               "base64 write escape returned an error");
    FIO_ASSERT(
        !fio_string_write_base64dec(&decoded, NULL, encoded.buf, encoded.len),
        "base64 write unescape returned an error");

    FIO_ASSERT(encoded.len, "Base64 encoding failed");
    FIO_ASSERT(decoded.len < encoded.len,
               "Base64 decoding failed:\n%s",
               encoded.buf);
    FIO_ASSERT(original.len == decoded.len,
               "Base64 roundtrip length error, %zu != %zu (%zu - %zu):\n %s",
               original.len,
               decoded.len,
               decoded.len,
               encoded.len,
               decoded.buf);
    FIO_ASSERT(!memcmp(original.buf, decoded.buf, original.len),
               "Base64 round-trip failed:\n %s",
               decoded.buf);
  }
  { /* Comparison testing */
    fprintf(stderr, "* Testing comparison\n");
    FIO_ASSERT(fio_string_is_greater(FIO_STR_INFO1((char *)"A"),
                                     FIO_STR_INFO1((char *)"")),
               "fio_string_is_greater failed for A vs __");
    FIO_ASSERT(fio_string_is_greater(FIO_STR_INFO1((char *)"hello world"),
                                     FIO_STR_INFO1((char *)"hello worl")),
               "fio_string_is_greater failed for hello worl(d)");
    FIO_ASSERT(fio_string_is_greater(FIO_STR_INFO1((char *)"01234567"),
                                     FIO_STR_INFO1((char *)"012345664")),
               "fio_string_is_greater failed for 01234567");
    FIO_ASSERT(!fio_string_is_greater(FIO_STR_INFO1((char *)""),
                                      FIO_STR_INFO1((char *)"A")),
               "fio_string_is_greater failed for A inv");
    FIO_ASSERT(!fio_string_is_greater(FIO_STR_INFO1((char *)"hello worl"),
                                      FIO_STR_INFO1((char *)"hello world")),
               "fio_string_is_greater failed for hello worl(d) inv");
    FIO_ASSERT(!fio_string_is_greater(FIO_STR_INFO1((char *)"012345664"),
                                      FIO_STR_INFO1((char *)"01234567")),
               "fio_string_is_greater failed for 01234567 inv");
    FIO_ASSERT(!fio_string_is_greater(FIO_STR_INFO1((char *)"Hzzzzzzzzzz"),
                                      FIO_STR_INFO1((char *)"hello world")),
               "fio_string_is_greater failed for Hello world");
  }
  { /* testing fio_bstr helpers */
    fprintf(stderr, "* Testing fio_bstr helpers (micro test).\n");
    char *str = fio_bstr_write(NULL, "Hello", 5);
    FIO_ASSERT(fio_bstr_info(str).len == 5 &&
                   !memcmp(str, "Hello", fio_bstr_info(str).len + 1),
               "fio_bstr_write failed!");
    FIO_ASSERT(fio_bstr_is_greater(str, NULL),
               "fio_bstr_is_greater failed vs a NULL String");
    str = fio_bstr_write2(str,
                          FIO_STRING_WRITE_STR1((char *)" "),
                          FIO_STRING_WRITE_STR1((char *)"World!"));
    FIO_ASSERT(fio_bstr_info(str).len == 12 &&
                   !memcmp(str, "Hello World!", fio_bstr_info(str).len + 1),
               "fio_bstr_write2 failed!");
    /* test copy-on-write for fio_bstr_copy */
    char *s_copy = fio_bstr_copy(str);
    FIO_ASSERT(s_copy == str, "fio_bstr_copy should only copy on write");
    str = fio_bstr_write(str, "!", 1);
    FIO_ASSERT(s_copy != str, "fio_bstr_s write after copy error!");
    FIO_ASSERT(fio_bstr_len(str) > fio_bstr_len(s_copy),
               "fio_bstr copy after write length error!");
    FIO_ASSERT(!memcmp(str, s_copy, fio_bstr_len(s_copy)),
               "fio_bstr copy after write copied data error!");
    FIO_ASSERT(FIO_BUF_INFO_IS_EQ(fio_bstr_buf(s_copy),
                                  FIO_BUF_INFO2((char *)"Hello World!", 12)),
               "fio_bstr old copy corrupted?");
    fio_bstr_free(s_copy);
    fio_bstr_free(str);
  }
  {
    char *s = fio_bstr_readfile(NULL, __FILE__, 0, 0);
    FIO_ASSERT(s && fio_bstr_len(s), "fio_bstr_readfile failed");
    FIO_LOG_DEBUG("readfile returned %zu bytes, starting with:\n%s",
                  fio_bstr_len(s),
                  s);
    char *find_z = (char *)FIO_MEMCHR(s, 'Z', fio_bstr_len(s));
    if (find_z) {
      int fd = open(__FILE__, 0, "r"); // fio_filename_open(__FILE__, 0);
      FIO_ASSERT(fd != -1, "couldn't open file for testing: " __FILE__);
      size_t z_index = fio_fd_find_next(fd, 'Z', 0);
      FIO_ASSERT(z_index != FIO_FD_FIND_EOF, "fio_fd_find_next returned EOF");
      FIO_ASSERT(z_index == (size_t)(find_z - s),
                 "fio_fd_find_next index error (%zu != %zu)",
                 z_index,
                 (size_t)(find_z - s));
      close(fd);
      char *s2 = fio_bstr_getdelim_file(NULL, __FILE__, 0, 'Z', 0);
      FIO_ASSERT(fio_bstr_len(s2) == z_index + 1,
                 "fio_bstr_getdelim_file length error (%zu != %zu)?",
                 fio_bstr_len(s2),
                 z_index + 1);
      FIO_ASSERT(s2[z_index] == 'Z',
                 "fio_bstr_getdelim_file copy error?\n%s",
                 s2);
      fio_bstr_free(s2);
    } else {
      FIO_LOG_WARNING("couldn't find 'Z' after reading file (bstr)");
    }
    fio_bstr_free(s);
  }

#if !defined(DEBUG) || defined(NODEBUG)
  { /* speed testing comparison */
    char mem[4096];
    fio_str_info_s sa = FIO_STR_INFO3(mem, 0, 2047);
    fio_str_info_s sb = FIO_STR_INFO3(mem + 2048, 0, 2047);
    fio_string_readfile(&sa, NULL, __FILE__, 0, 0);
    fio_string_write(&sb, NULL, sa.buf, sa.len);
    sa.buf[sa.len - 1] += 1;
    fio_buf_info_s sa_buf = FIO_STR2BUF_INFO(sa);
    fio_buf_info_s sb_buf = FIO_STR2BUF_INFO(sb);

    const size_t test_repetitions = (1ULL << 19);
    const size_t positions[] = {(sa.len - 1), ((sa.len >> 1) - 1), 30, 0};
    for (const size_t *ppos = positions; *ppos; ++ppos) {
      sa.buf[*ppos] += 1;
      sa.len = *ppos + 1;
      sb.len = *ppos + 1;
      fprintf(stderr,
              "* Testing comparison speeds (%zu tests of %zu bytes):\n",
              test_repetitions,
              *ppos);
      clock_t start = clock();
      for (size_t i = 0; i < test_repetitions; ++i) {
        FIO_COMPILER_GUARD;
        int r = fio_string_is_greater_buf(sa_buf, sb_buf);
        FIO_ASSERT(r > 0, "fio_string_is_greater error?!");
      }
      clock_t end = clock();
      fprintf(stderr,
              "\t* fio_string_is_greater test cycles:   %zu\n",
              (size_t)(end - start));
      start = clock();
      for (size_t i = 0; i < test_repetitions; ++i) {
        FIO_COMPILER_GUARD;
        int r = memcmp(sa.buf, sb.buf, sa.len > sb.len ? sb.len : sa.len);
        if (!r)
          r = sa.len > sb.len;
        FIO_ASSERT(r > 0, "memcmp error?!");
      }
      end = clock();
      fprintf(stderr,
              "\t* memcmp libc test cycles:            %zu\n",
              (size_t)(end - start));
      start = clock();
      for (size_t i = 0; i < test_repetitions; ++i) {
        FIO_COMPILER_GUARD;
        int r = strcmp(sa.buf, sb.buf);
        FIO_ASSERT(r > 0, "strcmp error?!");
      }
      end = clock();
      fprintf(stderr,
              "\t* strcmp libc test cycles:            %zu\n",
              (size_t)(end - start));
    }

    fprintf(stderr, "* Testing fio_string_write_(i|u|hex|bin) speeds:\n");
    FIO_NAME_TEST(stl, atol_speed)
    ("fio_string_write/fio_atol",
     fio_atol,
     FIO_NAME_TEST(stl, string_core_ltoa));
  }
#endif /* DEBUG */
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
String Core Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_STR
#endif /* H__FIO_STR__H */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___     /* Development inclusion - ignore line */
#define FIO_STR_NAME fio /* Development inclusion - ignore line */
#include "./include.h"   /* Development inclusion - ignore line */
#endif                   /* Development inclusion - ignore line */
/* *****************************************************************************




                        Dynamic Strings (binary safe)



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#ifdef FIO_STR_SMALL
#ifndef FIO_STR_NAME
#define FIO_STR_NAME FIO_STR_SMALL
#endif
#ifndef FIO_STR_OPTIMIZE4IMMUTABILITY
#define FIO_STR_OPTIMIZE4IMMUTABILITY 1
#endif
#endif /* FIO_STR_SMALL */

#if defined(FIO_STR_NAME)

#ifndef FIO_STR_OPTIMIZE_EMBEDDED
/**
 * For each unit (0 by default), adds `sizeof(char *)` bytes to the type size,
 * increasing the amount of strings that could be embedded within the type
 * without additional memory allocation.
 *
 * For example, when using a reference counter wrapper on a 64bit system, it
 * would make sense to set this value to 1 - allowing the type size to fully
 * utilize a 16 byte memory allocation alignment.
 */
#define FIO_STR_OPTIMIZE_EMBEDDED 0
#endif

#ifndef FIO_STR_OPTIMIZE4IMMUTABILITY
/**
 * Minimizes the struct size, storing only string length and pointer.
 *
 * By avoiding extra (mutable related) data, such as the allocated memory's
 * capacity, strings require less memory. However, this does introduce a
 * performance penalty when editing the string data.
 */
#define FIO_STR_OPTIMIZE4IMMUTABILITY 0
#endif

#if FIO_STR_OPTIMIZE4IMMUTABILITY
/* enforce limit after which FIO_STR_OPTIMIZE4IMMUTABILITY makes no sense */
#if FIO_STR_OPTIMIZE_EMBEDDED > 1
#undef FIO_STR_OPTIMIZE_EMBEDDED
#define FIO_STR_OPTIMIZE_EMBEDDED 1
#endif
#else
/* enforce limit due to 6 bit embedded string length limit (assumes 64 bit) */
#if FIO_STR_OPTIMIZE_EMBEDDED > 4
#undef FIO_STR_OPTIMIZE_EMBEDDED
#define FIO_STR_OPTIMIZE_EMBEDDED 4
#endif
#endif /* FIO_STR_OPTIMIZE4IMMUTABILITY*/

/* *****************************************************************************
String API - Initialization and Destruction
***************************************************************************** */

/**
 * The `fio_str_s` type should be considered opaque.
 *
 * The type's attributes should be accessed ONLY through the accessor
 * functions: `fio_str2cstr`, `fio_str_len`, `fio_str2ptr`, `fio_str_capa`,
 * etc'.
 *
 * Note: when the `small` flag is present, the structure is ignored and used
 * as raw memory for a small String (no additional allocation). This changes
 * the String's behavior drastically and requires that the accessor functions
 * be used.
 */
typedef struct {
  /* String flags:
   *
   * bit 1: small string.
   * bit 2: frozen string.
   * bit 3: static (non allocated) string (big strings only).
   * bit 3-8: small string length (up to 64 bytes).
   */
  uint8_t special;
  uint8_t reserved[(sizeof(void *) * (1 + FIO_STR_OPTIMIZE_EMBEDDED)) -
                   (sizeof(uint8_t))]; /* padding length */
#if !FIO_STR_OPTIMIZE4IMMUTABILITY
  size_t capa; /* known capacity for longer Strings */
  size_t len;  /* String length for longer Strings */
#endif         /* FIO_STR_OPTIMIZE4IMMUTABILITY */
  char *buf;   /* pointer for longer Strings */
} FIO_NAME(FIO_STR_NAME, s);

#ifdef FIO_PTR_TAG_TYPE
#define FIO_STR_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_STR_PTR FIO_NAME(FIO_STR_NAME, s) *
#endif

#ifndef FIO_STR_INIT
/**
 * This value should be used for initialization. For example:
 *
 *      // on the stack
 *      fio_str_s str = FIO_STR_INIT;
 *
 *      // or on the heap
 *      fio_str_s *str = malloc(sizeof(*str));
 *      *str = FIO_STR_INIT;
 *
 * Remember to cleanup:
 *
 *      // on the stack
 *      fio_str_destroy(&str);
 *
 *      // or on the heap
 *      fio_str_free(str);
 *      free(str);
 */
#define FIO_STR_INIT                                                           \
  { .special = 0 }

/**
 * This macro allows the container to be initialized with existing data, as long
 * as it's memory was allocated with the same allocator (`malloc` /
 * `fio_malloc`).
 *
 * The `capacity` value should exclude the NUL character (if exists).
 *
 * NOTE: This macro isn't valid for FIO_STR_SMALL (or strings with the
 * FIO_STR_OPTIMIZE4IMMUTABILITY optimization)
 */
#define FIO_STR_INIT_EXISTING(buffer, length, capacity)                        \
  { .capa = (capacity), .len = (length), .buf = (buffer) }

/**
 * This macro allows the container to be initialized with existing static data,
 * that shouldn't be freed.
 *
 * NOTE: This macro isn't valid for FIO_STR_SMALL (or strings with the
 * FIO_STR_OPTIMIZE4IMMUTABILITY optimization)
 */
#define FIO_STR_INIT_STATIC(buffer)                                            \
  {                                                                            \
    .special = 4, .capa = strlen((buffer)), .len = strlen((buffer)),           \
    .buf = (char *)(buffer)                                                    \
  }

/**
 * This macro allows the container to be initialized with existing static data,
 * that shouldn't be freed.
 *
 * NOTE: This macro isn't valid for FIO_STR_SMALL (or strings with the
 * FIO_STR_OPTIMIZE4IMMUTABILITY optimization)
 */
#define FIO_STR_INIT_STATIC2(buffer, length)                                   \
  { .special = 4, .capa = (length), .len = (length), .buf = (char *)(buffer) }

#endif /* FIO_STR_INIT */

#ifndef FIO_REF_CONSTRUCTOR_ONLY
/** Allocates a new String object on the heap. */
FIO_IFUNC FIO_STR_PTR FIO_NAME(FIO_STR_NAME, new)(void);

/**
 * Destroys the string and frees the container (if allocated with `new`).
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, free)(FIO_STR_PTR s);
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/**
 * Initializes the container with the provided static / constant string.
 *
 * The string will be copied to the container **only** if it will fit in the
 * container itself. Otherwise, the supplied pointer will be used as is and it
 * should remain valid until the string is destroyed.
 *
 * The final string can be safely be destroyed (using the `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_const)(FIO_STR_PTR s,
                                                            const char *str,
                                                            size_t len);

/**
 * Initializes the container with a copy of the provided dynamic string.
 *
 * The string is always copied and the final string must be destroyed (using the
 * `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_copy)(FIO_STR_PTR s,
                                                           const char *str,
                                                           size_t len);

/**
 * Initializes the container with a copy of an existing String object.
 *
 * The string is always copied and the final string must be destroyed (using the
 * `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_copy2)(FIO_STR_PTR dest,
                                                            FIO_STR_PTR src);

/**
 * Frees the String's resources and re-initializes the container.
 *
 * Note: if the container isn't allocated on the stack, it should be freed
 * separately using the appropriate `free` function.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, destroy)(FIO_STR_PTR s);

/**
 * Returns a C string with the existing data, re-initializing the String.
 *
 * Note: the String data is removed from the container, but the container
 * isn't freed.
 *
 * Returns NULL if there's no String data.
 *
 * NOTE: Returned string is ALWAYS dynamically allocated. Remember to free.
 */
FIO_IFUNC char *FIO_NAME(FIO_STR_NAME, detach)(FIO_STR_PTR s);

/** Frees the pointer returned by `detach`. */
SFUNC void FIO_NAME(FIO_STR_NAME, dealloc)(void *ptr);

/* *****************************************************************************
String API - String state (data pointers, length, capacity, etc')
***************************************************************************** */

/** Returns the String's complete state (capacity, length and pointer).  */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, info)(const FIO_STR_PTR s);

/** Returns the String's partial state (length and pointer).  */
FIO_IFUNC fio_buf_info_s FIO_NAME(FIO_STR_NAME, buf)(const FIO_STR_PTR s);

/** Returns a pointer (`char *`) to the String's content. */
FIO_IFUNC char *FIO_NAME(FIO_STR_NAME, ptr)(FIO_STR_PTR s);

/** Returns the String's length in bytes. */
FIO_IFUNC size_t FIO_NAME(FIO_STR_NAME, len)(FIO_STR_PTR s);

/** Returns the String's existing capacity (total used & available memory). */
FIO_IFUNC size_t FIO_NAME(FIO_STR_NAME, capa)(FIO_STR_PTR s);

/** Prevents further manipulations to the String's content. */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, freeze)(FIO_STR_PTR s);

/** Returns true if the string is frozen. */
FIO_IFUNC uint8_t FIO_NAME_BL(FIO_STR_NAME, frozen)(FIO_STR_PTR s);

/** Returns 1 if memory was allocated (and the String must be destroyed). */
FIO_IFUNC int FIO_NAME_BL(FIO_STR_NAME, allocated)(const FIO_STR_PTR s);

/** Binary comparison returns `1` if both strings are equal and `0` if not. */
FIO_IFUNC int FIO_NAME_BL(FIO_STR_NAME, eq)(const FIO_STR_PTR str1,
                                            const FIO_STR_PTR str2);

/**
 * Returns the string's Risky Hash value.
 *
 * Note: Hash algorithm might change without notice.
 */
FIO_IFUNC uint64_t FIO_NAME(FIO_STR_NAME, hash)(const FIO_STR_PTR s,
                                                uint64_t seed);

/* *****************************************************************************
String API - Memory management
***************************************************************************** */

/**
 * Sets the new String size without reallocating any memory (limited by
 * existing capacity).
 *
 * Returns the updated state of the String.
 *
 * Note: When shrinking, any existing data beyond the new size may be
 * corrupted.
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, resize)(FIO_STR_PTR s,
                                                        size_t size);

/**
 * Performs a best attempt at minimizing memory consumption.
 *
 * Actual effects depend on the underlying memory allocator and it's
 * implementation. Not all allocators will free any memory.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, compact)(FIO_STR_PTR s);

#if !FIO_STR_OPTIMIZE4IMMUTABILITY
/**
 * Reserves (at least) `amount` of bytes for the string's data.
 *
 * The reserved count includes used data. If `amount` is less than the current
 * string length, the string will be truncated(!).
 *
 * Note: When optimized for immutability (`FIO_STR_SMALL`), this may corrupt the
 * string length data.
 *
 * Make sure to call `resize` with the updated information once the editing is
 * done.
 *
 * Returns the updated state of the String.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, reserve)(FIO_STR_PTR s,
                                                     size_t amount);
#define FIO_STR_RESERVE_NAME reserve
#else
/** INTERNAL - DO NOT USE! */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, __reserve)(FIO_STR_PTR s,
                                                       size_t amount);
#define FIO_STR_RESERVE_NAME __reserve
#endif
/* *****************************************************************************
String API - UTF-8 State
***************************************************************************** */

/** Returns 1 if the String is UTF-8 valid and 0 if not. */
SFUNC size_t FIO_NAME(FIO_STR_NAME, utf8_valid)(FIO_STR_PTR s);

/** Returns the String's length in UTF-8 characters. */
SFUNC size_t FIO_NAME(FIO_STR_NAME, utf8_len)(FIO_STR_PTR s);

/**
 * Takes a UTF-8 character selection information (UTF-8 position and length)
 * and updates the same variables so they reference the raw byte slice
 * information.
 *
 * If the String isn't UTF-8 valid up to the requested selection, than `pos`
 * will be updated to `-1` otherwise values are always positive.
 *
 * The returned `len` value may be shorter than the original if there wasn't
 * enough data left to accommodate the requested length. When a `len` value of
 * `0` is returned, this means that `pos` marks the end of the String.
 *
 * Returns -1 on error and 0 on success.
 */
SFUNC int FIO_NAME(FIO_STR_NAME,
                   utf8_select)(FIO_STR_PTR s, intptr_t *pos, size_t *len);

/* *****************************************************************************
String API - Content Manipulation and Review
***************************************************************************** */

/** Writes data at the end of the String. */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write)(FIO_STR_PTR s,
                                                       const void *src,
                                                       size_t src_len);

/**
 * Appends the `src` String to the end of the `dest` String.
 *
 * If `dest` is empty, the resulting Strings will be equal.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, concat)(FIO_STR_PTR dest,
                                                    FIO_STR_PTR const src);

/** Alias for fio_str_concat */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, join)(FIO_STR_PTR dest,
                                                      FIO_STR_PTR const src) {
  return FIO_NAME(FIO_STR_NAME, concat)(dest, src);
}

/**
 * Replaces the data in the String - replacing `old_len` bytes starting at
 * `start_pos`, with the data at `src` (`src_len` bytes long).
 *
 * Negative `start_pos` values are calculated backwards, `-1` == end of
 * String.
 *
 * When `old_len` is zero, the function will insert the data at `start_pos`.
 *
 * If `src_len == 0` than `src` will be ignored and the data marked for
 * replacement will be erased.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, replace)(FIO_STR_PTR s,
                                                     intptr_t start_pos,
                                                     size_t old_len,
                                                     const void *src,
                                                     size_t src_len);

/** Writes data at the end of the String. See `fio_string_write2`. */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              __write2)(FIO_STR_PTR s,
                                        const fio_string_write_s srcs[]);

#ifndef FIO_STR_WRITE2
#define FIO_STR_WRITE2(str_name, dest, ...)                                    \
  FIO_NAME(str_name, __write2)(dest, (fio_string_write_s[]){__VA_ARGS__, {0}})
#endif
/* *****************************************************************************
String API - Numerals
***************************************************************************** */

/** Writes a number at the end of the String using normal base 10 notation. */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_i)(FIO_STR_PTR s,
                                                     int64_t num);

/** Writes a number at the end of the String using Hex (base 16) notation. */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_hex)(FIO_STR_PTR s,
                                                       int64_t num);

/* Writes a binary representation of `i` to the String */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_bin)(FIO_STR_PTR s,
                                                       int64_t num);

/* *****************************************************************************
String API - printf style support
***************************************************************************** */

/**
 * Writes to the String using a vprintf like interface.
 *
 * Data is written to the end of the String.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, vprintf)(FIO_STR_PTR s,
                                                     const char *format,
                                                     va_list argv);

/**
 * Writes to the String using a printf like interface.
 *
 * Data is written to the end of the String.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              printf)(FIO_STR_PTR s, const char *format, ...);

/* *****************************************************************************
String API - C / JSON escaping
***************************************************************************** */

/**
 * Writes data at the end of the String, escaping the data using JSON semantics.
 *
 * The JSON semantic are common to many programming languages, promising a UTF-8
 * String while making it easy to read and copy the string during debugging.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_escape)(FIO_STR_PTR s,
                                                          const void *data,
                                                          size_t data_len);

/**
 * Writes an escaped data into the string after unescaping the data.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_unescape)(FIO_STR_PTR s,
                                                            const void *escaped,
                                                            size_t len);

/* *****************************************************************************
String API - Base64 support
***************************************************************************** */

/**
 * Writes data at the end of the String, encoding the data as Base64 encoded
 * data.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_base64enc)(FIO_STR_PTR s,
                                               const void *data,
                                               size_t data_len,
                                               uint8_t url_encoded);

/**
 * Writes decoded base64 data to the end of the String.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_base64dec)(FIO_STR_PTR s,
                                               const void *encoded,
                                               size_t encoded_len);

/* *****************************************************************************
String API - writing data from files to the String
***************************************************************************** */

/**
 * Reads data from a file descriptor `fd` at offset `start_at` and pastes it's
 * contents (or a slice of it) at the end of the String. If `limit == 0`, than
 * the data will be read until EOF.
 *
 * The file should be a regular file or the operation might fail (can't be used
 * for sockets).
 *
 * The file descriptor will remain open and should be closed manually.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, readfd)(FIO_STR_PTR s,
                                                    int fd,
                                                    intptr_t start_at,
                                                    intptr_t limit);
/**
 * Opens the file `filename` and pastes it's contents (or a slice ot it) at
 * the end of the String. If `limit == 0`, than the data will be read until
 * EOF.
 *
 * If the file can't be located, opened or read, or if `start_at` is beyond
 * the EOF position, NULL is returned in the state's `data` field.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, readfile)(FIO_STR_PTR s,
                                                      const char *filename,
                                                      intptr_t start_at,
                                                      intptr_t limit);
/* *****************************************************************************
String API - Testing
***************************************************************************** */
#ifdef FIO_STR_WRITE_TEST_FUNC
/**
 * Tests the fio_str functionality.
 */
SFUNC void FIO_NAME_TEST(stl, FIO_STR_NAME)(void);
#endif
/* *****************************************************************************


                             String Implementation

                           IMPLEMENTATION - INLINED


***************************************************************************** */

/* *****************************************************************************
String Macro Helpers
***************************************************************************** */

#define FIO_STR_IS_SMALL(s)  ((((s)->special & 1) | !(s)->buf))
#define FIO_STR_SMALL_LEN(s) ((size_t)((s)->special >> 2))
#define FIO_STR_SMALL_LEN_SET(s, l)                                            \
  ((s)->special = (((s)->special & 2) | ((uint8_t)(l) << 2) | 1))
#define FIO_STR_SMALL_CAPA(s) ((sizeof(*(s)) - 2) & 63)
#define FIO_STR_SMALL_DATA(s) ((char *)((s)->reserved))

#define FIO_STR_BIG_DATA(s)       ((s)->buf)
#define FIO_STR_BIG_IS_DYNAMIC(s) (!((s)->special & 4))
#define FIO_STR_BIG_SET_STATIC(s) ((s)->special |= 4)
#define FIO_STR_BIG_FREE_BUF(s)   (FIO_MEM_FREE_((s)->buf, FIO_STR_BIG_CAPA((s))))

#define FIO_STR_IS_FROZEN(s) ((s)->special & 2)
#define FIO_STR_FREEZE_(s)   ((s)->special |= 2)
#define FIO_STR_THAW_(s)     ((s)->special ^= (uint8_t)2)

#if FIO_STR_OPTIMIZE4IMMUTABILITY

#define FIO_STR_BIG_LEN(s)                                                     \
  ((sizeof(void *) == 4)                                                       \
       ? (((uint32_t)(s)->reserved[0]) | ((uint32_t)(s)->reserved[1] << 8) |   \
          ((uint32_t)(s)->reserved[2] << 16))                                  \
       : (((uint64_t)(s)->reserved[0]) | ((uint64_t)(s)->reserved[1] << 8) |   \
          ((uint64_t)(s)->reserved[2] << 16) |                                 \
          ((uint64_t)(s)->reserved[3] << 24) |                                 \
          ((uint64_t)(s)->reserved[4] << 32) |                                 \
          ((uint64_t)(s)->reserved[5] << 40) |                                 \
          ((uint64_t)(s)->reserved[6] << 48)))
#define FIO_STR_BIG_LEN_SET(s, l)                                              \
  do {                                                                         \
    if (sizeof(void *) == 4) {                                                 \
      if (!((l) & ((~(uint32_t)0) << 24))) {                                   \
        (s)->reserved[0] = (l)&0xFF;                                           \
        (s)->reserved[1] = ((uint32_t)(l) >> 8) & 0xFF;                        \
        (s)->reserved[2] = ((uint32_t)(l) >> 16) & 0xFF;                       \
      } else {                                                                 \
        FIO_LOG_ERROR("facil.io small string length error - too long");        \
        (s)->reserved[0] = 0xFF;                                               \
        (s)->reserved[1] = 0xFF;                                               \
        (s)->reserved[2] = 0xFF;                                               \
      }                                                                        \
    } else {                                                                   \
      if (!((l) & ((~(uint64_t)0) << 56))) {                                   \
        (s)->reserved[0] = (l)&0xFF;                                           \
        (s)->reserved[1] = ((uint64_t)(l) >> 8) & 0xFF;                        \
        (s)->reserved[2] = ((uint64_t)(l) >> 16) & 0xFF;                       \
        (s)->reserved[3] = ((uint64_t)(l) >> 24) & 0xFF;                       \
        (s)->reserved[4] = ((uint64_t)(l) >> 32) & 0xFF;                       \
        (s)->reserved[5] = ((uint64_t)(l) >> 40) & 0xFF;                       \
        (s)->reserved[6] = ((uint64_t)(l) >> 48) & 0xFF;                       \
      } else {                                                                 \
        FIO_LOG_ERROR("facil.io small string length error - too long");        \
        (s)->reserved[0] = 0xFF;                                               \
        (s)->reserved[1] = 0xFF;                                               \
        (s)->reserved[2] = 0xFF;                                               \
        (s)->reserved[3] = 0xFF;                                               \
        (s)->reserved[4] = 0xFF;                                               \
        (s)->reserved[5] = 0xFF;                                               \
        (s)->reserved[6] = 0xFF;                                               \
      }                                                                        \
    }                                                                          \
  } while (0)
#define FIO_STR_BIG_CAPA(s) fio_string_capa4len(FIO_STR_BIG_LEN((s)))
#define FIO_STR_BIG_CAPA_SET(s, capa)
#else
#define FIO_STR_BIG_LEN(s)            ((s)->len)
#define FIO_STR_BIG_LEN_SET(s, l)     ((s)->len = (l))
#define FIO_STR_BIG_CAPA(s)           ((s)->capa)
#define FIO_STR_BIG_CAPA_SET(s, capa) (FIO_STR_BIG_CAPA(s) = (capa))
#endif

/* *****************************************************************************
String Information Round-tripping
***************************************************************************** */

/** Returns the String's complete state (capacity, length and pointer).  */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, info)(const FIO_STR_PTR s_) {
  fio_str_info_s r = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, r);
  FIO_NAME(FIO_STR_NAME, s) *s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (FIO_STR_IS_SMALL(s))
    r = (fio_str_info_s){
        .buf = FIO_STR_SMALL_DATA(s),
        .len = FIO_STR_SMALL_LEN(s),
        .capa = FIO_STR_SMALL_CAPA(s),
    };
  else
    r = (fio_str_info_s){
        .buf = FIO_STR_BIG_DATA(s),
        .len = FIO_STR_BIG_LEN(s),
        .capa = FIO_STR_BIG_CAPA(s),
    };
  r.capa &= ((size_t)0ULL - (!FIO_STR_IS_FROZEN(s)));
  return r;
}

/** Returns the String's partial state (length and pointer).  */
FIO_IFUNC fio_buf_info_s FIO_NAME(FIO_STR_NAME, buf)(const FIO_STR_PTR s_) {
  fio_buf_info_s r = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, r);
  FIO_NAME(FIO_STR_NAME, s) *s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (FIO_STR_IS_SMALL(s))
    r = (fio_buf_info_s){
        .buf = FIO_STR_SMALL_DATA(s),
        .len = FIO_STR_SMALL_LEN(s),
    };
  else
    r = (fio_buf_info_s){
        .buf = FIO_STR_BIG_DATA(s),
        .len = FIO_STR_BIG_LEN(s),
    };
  return r;
}

/* Internal(!): updated String data according to `info`.  */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, __info_update)(const FIO_STR_PTR s_,
                                                     fio_str_info_s info) {
  /* internally used function, tagging already validated. */
  FIO_NAME(FIO_STR_NAME, s) *s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (info.buf == FIO_STR_SMALL_DATA(s)) {
    s->special |= 1;
    FIO_STR_SMALL_LEN_SET(s, info.len);
    return;
  }
  s->special = 0;
  FIO_STR_BIG_LEN_SET(s, info.len);
  FIO_STR_BIG_CAPA_SET(s, info.capa);
  s->buf = info.buf;
}

/* using now, declared later. */

FIO_SFUNC int FIO_NAME(FIO_STR_NAME, __default_reallocate)(fio_str_info_s *dest,
                                                           size_t new_capa);
FIO_SFUNC int FIO_NAME(FIO_STR_NAME,
                       __default_copy_and_reallocate)(fio_str_info_s *dest,
                                                      size_t new_capa);

/* Internal(!): updated String data according to `info`.  */
FIO_IFUNC fio_string_realloc_fn FIO_NAME(FIO_STR_NAME,
                                         __realloc_func)(const FIO_STR_PTR s_) {
  fio_string_realloc_fn options[] = {
      FIO_NAME(FIO_STR_NAME, __default_reallocate),
      FIO_NAME(FIO_STR_NAME, __default_copy_and_reallocate),
  };
  /* internally used function, tagging already validated. */
  FIO_NAME(FIO_STR_NAME, s) *s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  return options[FIO_STR_IS_SMALL(s) | !FIO_STR_BIG_IS_DYNAMIC(s)];
}

/* *****************************************************************************
String Constructors (inline)
***************************************************************************** */
#ifndef FIO_REF_CONSTRUCTOR_ONLY

/** Allocates a new String object on the heap. */
FIO_IFUNC FIO_STR_PTR FIO_NAME(FIO_STR_NAME, new)(void) {
  FIO_NAME(FIO_STR_NAME, s) *const s =
      (FIO_NAME(FIO_STR_NAME, s) *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*s), 0);
  if (!FIO_MEM_REALLOC_IS_SAFE_ && s) {
    *s = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT;
  }
#ifdef DEBUG
  {
    FIO_NAME(FIO_STR_NAME, s) tmp = {0};
    FIO_ASSERT(!FIO_MEMCMP(&tmp, s, sizeof(tmp)),
               "new " FIO_MACRO2STR(
                   FIO_NAME(FIO_STR_NAME, s)) " object not initialized!");
  }
#endif
  return (FIO_STR_PTR)FIO_PTR_TAG(s);
}

/** Destroys the string and frees the container (if allocated with `new`). */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, free)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(s_);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (!FIO_STR_IS_SMALL(s) && FIO_STR_BIG_IS_DYNAMIC(s)) {
    FIO_STR_BIG_FREE_BUF(s);
  }
  FIO_MEM_FREE_(s, sizeof(*s));
}

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/**
 * Frees the String's resources and reinitializes the container.
 *
 * Note: if the container isn't allocated on the stack, it should be freed
 * separately using the appropriate `free` function.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, destroy)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(s_);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (!FIO_STR_IS_SMALL(s) && FIO_STR_BIG_IS_DYNAMIC(s)) {
    FIO_STR_BIG_FREE_BUF(s);
  }
  *s = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT;
}

/**
 * Returns a C string with the existing data, re-initializing the String.
 *
 * Note: the String data is removed from the container, but the container
 * isn't freed.
 *
 * Returns NULL if there's no String data.
 */
FIO_IFUNC char *FIO_NAME(FIO_STR_NAME, detach)(FIO_STR_PTR s_) {
  char *data = NULL;
  FIO_PTR_TAG_VALID_OR_RETURN(s_, data);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (FIO_STR_IS_SMALL(s)) {
    if (FIO_STR_SMALL_LEN(s)) { /* keep these ifs apart */
      data =
          (char *)FIO_MEM_REALLOC_(NULL,
                                   0,
                                   sizeof(*data) * (FIO_STR_SMALL_LEN(s) + 1),
                                   0);
      if (data)
        FIO_MEMCPY(data, FIO_STR_SMALL_DATA(s), (FIO_STR_SMALL_LEN(s) + 1));
    }
  } else {
    if (FIO_STR_BIG_IS_DYNAMIC(s)) {
      data = FIO_STR_BIG_DATA(s);
    } else if (FIO_STR_BIG_LEN(s)) {
      data = (char *)FIO_MEM_REALLOC_(NULL,
                                      0,
                                      sizeof(*data) * (FIO_STR_BIG_LEN(s) + 1),
                                      0);
      if (data)
        FIO_MEMCPY(data, FIO_STR_BIG_DATA(s), FIO_STR_BIG_LEN(s) + 1);
    }
  }
  *s = (FIO_NAME(FIO_STR_NAME, s)){0};
  return data;
}

/**
 * Performs a best attempt at minimizing memory consumption.
 *
 * Actual effects depend on the underlying memory allocator and it's
 * implementation. Not all allocators will free any memory.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, compact)(FIO_STR_PTR s_) {
#if FIO_STR_OPTIMIZE4IMMUTABILITY
  (void)s_;
#else
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(s_);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (FIO_STR_IS_SMALL(s) || !FIO_STR_BIG_IS_DYNAMIC(s) ||
      fio_string_capa4len(FIO_NAME(FIO_STR_NAME, len)(s_)) >=
          FIO_NAME(FIO_STR_NAME, capa)(s_))
    return;
  FIO_NAME(FIO_STR_NAME, s) tmp = FIO_STR_INIT;
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  FIO_NAME(FIO_STR_NAME, init_copy)
  ((FIO_STR_PTR)FIO_PTR_TAG(&tmp), i.buf, i.len);
  FIO_NAME(FIO_STR_NAME, destroy)(s_);
  *s = tmp;
#endif
}

/* *****************************************************************************
String Initialization (inline)
***************************************************************************** */

/**
 * Initializes the container with the provided static / constant string.
 *
 * The string will be copied to the container **only** if it will fit in the
 * container itself. Otherwise, the supplied pointer will be used as is and it
 * should remain valid until the string is destroyed.
 *
 * The final string can be safely be destroyed (using the `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_const)(FIO_STR_PTR s_,
                                                            const char *str,
                                                            size_t len) {
  fio_str_info_s i = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, i);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  *s = (FIO_NAME(FIO_STR_NAME, s)){0};
  if (len < FIO_STR_SMALL_CAPA(s)) {
    FIO_STR_SMALL_LEN_SET(s, len);
    if (len && str)
      FIO_MEMCPY(FIO_STR_SMALL_DATA(s), str, len);
    FIO_STR_SMALL_DATA(s)[len] = 0;

    i = (fio_str_info_s){.buf = FIO_STR_SMALL_DATA(s),
                         .len = len,
                         .capa = FIO_STR_SMALL_CAPA(s)};
    return i;
  }
  FIO_STR_BIG_DATA(s) = (char *)str;
  FIO_STR_BIG_LEN_SET(s, len);
  FIO_STR_BIG_CAPA_SET(s, len);
  FIO_STR_BIG_SET_STATIC(s);
  i = (fio_str_info_s){.buf = FIO_STR_BIG_DATA(s), .len = len, .capa = 0};
  return i;
}

/**
 * Initializes the container with the provided dynamic string.
 *
 * The string is always copied and the final string must be destroyed (using the
 * `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_copy)(FIO_STR_PTR s_,
                                                           const char *str,
                                                           size_t len) {
  fio_str_info_s i = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, i);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  *s = (FIO_NAME(FIO_STR_NAME, s)){0};
  if (len < FIO_STR_SMALL_CAPA(s)) {
    FIO_STR_SMALL_LEN_SET(s, len);
    if (len && str)
      FIO_MEMCPY(FIO_STR_SMALL_DATA(s), str, len);
    FIO_STR_SMALL_DATA(s)[len] = 0;

    i = (fio_str_info_s){.buf = FIO_STR_SMALL_DATA(s),
                         .len = len,
                         .capa = FIO_STR_SMALL_CAPA(s)};
    return i;
  }

  {
    const size_t capa2be = fio_string_capa4len(len);
    char *buf = (char *)FIO_MEM_REALLOC_(NULL, 0, capa2be, 0);
    if (!buf)
      return i;
    buf[len] = 0;
    i = (fio_str_info_s){.buf = buf, .len = len, .capa = capa2be};
  }
  FIO_STR_BIG_CAPA_SET(s, i.capa);
  FIO_STR_BIG_DATA(s) = i.buf;
  FIO_STR_BIG_LEN_SET(s, len);
  if (str)
    FIO_MEMCPY(FIO_STR_BIG_DATA(s), str, len);
  return i;
}

/**
 * Initializes the container with a copy of an existing String object.
 *
 * The string is always copied and the final string must be destroyed (using the
 * `destroy` function).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, init_copy2)(FIO_STR_PTR dest,
                                                            FIO_STR_PTR src) {
  fio_str_info_s i;
  i = FIO_NAME(FIO_STR_NAME, info)(src);
  i = FIO_NAME(FIO_STR_NAME, init_copy)(dest, i.buf, i.len);
  return i;
}

/* *****************************************************************************
String Information (inline)
***************************************************************************** */

/** Returns a pointer (`char *`) to the String's content. */
FIO_IFUNC char *FIO_NAME(FIO_STR_NAME, ptr)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, NULL);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  char *results[] = {(FIO_STR_BIG_DATA(s)), (FIO_STR_SMALL_DATA(s))};
  return results[FIO_STR_IS_SMALL(s)];
}

/** Returns the String's length in bytes. */
FIO_IFUNC size_t FIO_NAME(FIO_STR_NAME, len)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 0);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  size_t results[] = {(FIO_STR_BIG_LEN(s)), (FIO_STR_SMALL_LEN(s))};
  return results[FIO_STR_IS_SMALL(s)];
}

/** Returns the String's existing capacity (total used & available memory). */
FIO_IFUNC size_t FIO_NAME(FIO_STR_NAME, capa)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 0);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  if (FIO_STR_IS_SMALL(s))
    return FIO_STR_SMALL_CAPA(s);
  if (FIO_STR_BIG_IS_DYNAMIC(s))
    return FIO_STR_BIG_CAPA(s);
  return 0;
}

/**
 * Sets the new String size without reallocating any memory (limited by
 * existing capacity).
 */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, resize)(FIO_STR_PTR s_,
                                                        size_t size) {
  fio_str_info_s i = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, i);
  i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa) {
    return i;
  }
  /* resize may be used to reserve memory in advance while setting size  */
  if (i.capa < size) {
    fio_string_write(&i,
                     FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                     NULL,
                     size - i.len);
  } else {
    i.len = size;
    i.buf[i.len] = 0;
  }
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);

  return i;
}

/**
 * Prevents further manipulations to the String's content.
 */
FIO_IFUNC void FIO_NAME(FIO_STR_NAME, freeze)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(s_);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  FIO_STR_FREEZE_(s);
}

/**
 * Returns true if the string is frozen.
 */
FIO_IFUNC uint8_t FIO_NAME_BL(FIO_STR_NAME, frozen)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 1);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  return FIO_STR_IS_FROZEN(s);
}

/** Returns 1 if memory was allocated and (the String must be destroyed). */
FIO_IFUNC int FIO_NAME_BL(FIO_STR_NAME, allocated)(const FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 0);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  return (!FIO_STR_IS_SMALL(s) & FIO_STR_BIG_IS_DYNAMIC(s));
}

/**
 * Binary comparison returns `1` if both strings are equal and `0` if not.
 */
FIO_IFUNC int FIO_NAME_BL(FIO_STR_NAME, eq)(const FIO_STR_PTR str1_,
                                            const FIO_STR_PTR str2_) {
  if (str1_ == str2_)
    return 1;
  FIO_PTR_TAG_VALID_OR_RETURN(str1_, 0);
  FIO_PTR_TAG_VALID_OR_RETURN(str2_, 0);
  fio_buf_info_s s1 = FIO_NAME(FIO_STR_NAME, buf)(str1_);
  fio_buf_info_s s2 = FIO_NAME(FIO_STR_NAME, buf)(str2_);
  return FIO_BUF_INFO_IS_EQ(s1, s2);
}

/**
 * Returns the string's Risky Hash value.
 *
 * Note: Hash algorithm might change without notice.
 */
FIO_IFUNC uint64_t FIO_NAME(FIO_STR_NAME, hash)(const FIO_STR_PTR s_,
                                                uint64_t seed) {
  fio_buf_info_s i = FIO_NAME(FIO_STR_NAME, buf)(s_);
  return fio_risky_hash((void *)i.buf, i.len, seed);
}

/* *****************************************************************************
String API - Content Manipulation and Review (inline)
***************************************************************************** */

/** Writes data at the end of the String. */
FIO_IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write)(FIO_STR_PTR s_,
                                                       const void *src,
                                                       size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write(&i, FIO_NAME(FIO_STR_NAME, __realloc_func)(s_), src, len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/* *****************************************************************************


                             String Implementation

                               IMPLEMENTATION


***************************************************************************** */

/* *****************************************************************************
String Core Callbacks - Memory management
***************************************************************************** */
FIO_SFUNC int FIO_NAME(FIO_STR_NAME, __default_reallocate)(fio_str_info_s *dest,
                                                           size_t new_capa) {
  new_capa = fio_string_capa4len(new_capa);
  void *tmp = FIO_MEM_REALLOC_(dest->buf, dest->capa, new_capa, dest->len);
  if (!tmp)
    return -1;
  dest->capa = new_capa;
  dest->buf = (char *)tmp;
  return 0;
}
FIO_SFUNC int FIO_NAME(FIO_STR_NAME,
                       __default_copy_and_reallocate)(fio_str_info_s *dest,
                                                      size_t new_capa) {
  new_capa = fio_string_capa4len(new_capa);
  void *tmp = FIO_MEM_REALLOC_(NULL, 0, new_capa, 0);
  if (!tmp)
    return -1;
  if (dest->len)
    FIO_MEMCPY(tmp, dest->buf, dest->len);
  dest->capa = new_capa;
  dest->buf = (char *)tmp;
  return 0;
}
FIO_SFUNC void FIO_NAME(FIO_STR_NAME, __default_free)(void *ptr) {
  FIO_MEM_FREE_(ptr, -1);
}
FIO_SFUNC void FIO_NAME(FIO_STR_NAME, __default_free2)(fio_str_info_s str) {
  FIO_MEM_FREE_(str.buf, str.capa);
}
FIO_SFUNC void FIO_NAME(FIO_STR_NAME, __default_free_noop)(void *str) {
  (void)str;
}
FIO_SFUNC void FIO_NAME(FIO_STR_NAME,
                        __default_free_noop2)(fio_str_info_s str) {
  (void)str;
}

/* *****************************************************************************
External functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
String Implementation - Memory management
***************************************************************************** */

/** Frees the pointer returned by `detach`. */
SFUNC void FIO_NAME(FIO_STR_NAME, dealloc)(void *ptr) {
  FIO_MEM_FREE_(ptr, -1);
}

/**
 * Reserves at least `amount` of bytes for the string's data (reserved count
 * includes used data).
 *
 * Returns the current state of the String.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              FIO_STR_RESERVE_NAME)(FIO_STR_PTR s_,
                                                    size_t amount) {
  fio_str_info_s state = {0};
  FIO_PTR_TAG_VALID_OR_RETURN(s_, state);
  FIO_NAME(FIO_STR_NAME, s) *const s =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s_);
  state = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (FIO_STR_IS_FROZEN(s))
    return state;
  if (state.capa < amount) {
    FIO_NAME(FIO_STR_NAME, __realloc_func)(s_)(&state, amount);
    state.buf[state.len] = 0;
    FIO_NAME(FIO_STR_NAME, __info_update)(s_, state);
  } else if (state.capa > FIO_STR_SMALL_CAPA(s) &&
             amount <= FIO_STR_SMALL_CAPA(s) &&
             state.len <= FIO_STR_SMALL_CAPA(s)) {
    FIO_NAME(FIO_STR_NAME, s) tmp;
    state = FIO_NAME(FIO_STR_NAME, init_copy)((FIO_STR_PTR)FIO_PTR_TAG(&tmp),
                                              state.buf,
                                              state.len);
    FIO_NAME(FIO_STR_NAME, destroy)(s_);
    *s = tmp;
  }
  return state;
}

/* *****************************************************************************
String Implementation - UTF-8 State
***************************************************************************** */

/** Returns 1 if the String is UTF-8 valid and 0 if not. */
SFUNC size_t FIO_NAME(FIO_STR_NAME, utf8_valid)(FIO_STR_PTR s_) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, 0);
  fio_str_info_s state = FIO_NAME(FIO_STR_NAME, info)(s_);
  return fio_string_utf8_len(state);
}

/** Returns the String's length in UTF-8 characters. */
SFUNC size_t FIO_NAME(FIO_STR_NAME, utf8_len)(FIO_STR_PTR s_) {
  fio_str_info_s state = FIO_NAME(FIO_STR_NAME, info)(s_);
  return fio_string_utf8_len(state);
}

/**
 * Takes a UTF-8 character selection information (UTF-8 position and length)
 * and updates the same variables so they reference the raw byte slice
 * information.
 *
 * If the String isn't UTF-8 valid up to the requested selection, than `pos`
 * will be updated to `-1` otherwise values are always positive.
 *
 * The returned `len` value may be shorter than the original if there wasn't
 * enough data left to accommodate the requested length. When a `len` value of
 * `0` is returned, this means that `pos` marks the end of the String.
 *
 * Returns -1 on error and 0 on success.
 */
SFUNC int FIO_NAME(FIO_STR_NAME,
                   utf8_select)(FIO_STR_PTR s_, intptr_t *pos, size_t *len) {
  FIO_PTR_TAG_VALID_OR_RETURN(s_, -1);
  fio_str_info_s state = FIO_NAME(FIO_STR_NAME, info)(s_);
  return fio_string_utf8_select(state, pos, len);
}

/* *****************************************************************************
String Implementation - Content Manipulation and Review
***************************************************************************** */

/**
 * Writes a number at the end of the String using normal base 10 notation.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_i)(FIO_STR_PTR s_,
                                                     int64_t num) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_i(&i, FIO_NAME(FIO_STR_NAME, __realloc_func)(s_), num);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes a number at the end of the String using Hex (base 16) notation.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_hex)(FIO_STR_PTR s_,
                                                       int64_t num) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_hex(&i, FIO_NAME(FIO_STR_NAME, __realloc_func)(s_), num);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes a number at the end of the String using binary notation.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_bin)(FIO_STR_PTR s_,
                                                       int64_t num) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_bin(&i, FIO_NAME(FIO_STR_NAME, __realloc_func)(s_), num);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Appends the `src` String to the end of the `dest` String.
 *
 * If `dest` is empty, the resulting Strings will be equal.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, concat)(FIO_STR_PTR dest_,
                                                    FIO_STR_PTR const src_) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(dest_);
  if (!i.capa)
    return i;
  FIO_PTR_TAG_VALID_OR_RETURN(src_, i);
  fio_str_info_s src = FIO_NAME(FIO_STR_NAME, info)(src_);
  if (!src.len)
    return i;
  fio_string_write(&i,
                   FIO_NAME(FIO_STR_NAME, __realloc_func)(dest_),
                   src.buf,
                   src.len);
  FIO_NAME(FIO_STR_NAME, __info_update)(dest_, i);
  return i;
}

/**
 * Replaces the data in the String - replacing `old_len` bytes starting at
 * `start_pos`, with the data at `src` (`src_len` bytes long).
 *
 * Negative `start_pos` values are calculated backwards, `-1` == end of
 * String.
 *
 * When `old_len` is zero, the function will insert the data at `start_pos`.
 *
 * If `src_len == 0` than `src` will be ignored and the data marked for
 * replacement will be erased.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, replace)(FIO_STR_PTR s_,
                                                     intptr_t start_pos,
                                                     size_t old_len,
                                                     const void *src,
                                                     size_t src_len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_replace(&i,
                     FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                     start_pos,
                     old_len,
                     src,
                     src_len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes a number at the end of the String using binary notation.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              __write2)(FIO_STR_PTR s_,
                                        const fio_string_write_s srcs[]) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write2 FIO_NOOP(&i,
                             FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                             srcs);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes to the String using a vprintf like interface.
 *
 * Data is written to the end of the String.
 */
SFUNC fio_str_info_s __attribute__((format(FIO___PRINTF_STYLE, 2, 0)))
FIO_NAME(FIO_STR_NAME,
         vprintf)(FIO_STR_PTR s_, const char *format, va_list argv) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_vprintf(&i,
                     FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                     format,
                     argv);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes to the String using a printf like interface.
 *
 * Data is written to the end of the String.
 */
SFUNC fio_str_info_s __attribute__((format(FIO___PRINTF_STYLE, 2, 3)))
FIO_NAME(FIO_STR_NAME, printf)(FIO_STR_PTR s_, const char *format, ...) {
  va_list argv;
  va_start(argv, format);
  fio_str_info_s state = FIO_NAME(FIO_STR_NAME, vprintf)(s_, format, argv);
  va_end(argv);
  return state;
}

/* *****************************************************************************
String API - C / JSON escaping
***************************************************************************** */

/**
 * Writes data at the end of the String, escaping the data using JSON semantics.
 *
 * The JSON semantic are common to many programming languages, promising a UTF-8
 * String while making it easy to read and copy the string during debugging.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_escape)(FIO_STR_PTR s_,
                                                          const void *src,
                                                          size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_escape(&i,
                          FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                          src,
                          len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes an escaped data into the string after unescaping the data.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, write_unescape)(FIO_STR_PTR s_,
                                                            const void *src,
                                                            size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_unescape(&i,
                            FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                            src,
                            len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/* *****************************************************************************
String - Base64 support
***************************************************************************** */

/**
 * Writes data at the end of the String, encoding the data as Base64 encoded
 * data.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_base64enc)(FIO_STR_PTR s_,
                                               const void *data,
                                               size_t len,
                                               uint8_t url_encoded) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_base64enc(&i,
                             FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                             data,
                             len,
                             url_encoded);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Writes decoded base64 data to the end of the String.
 */
IFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME,
                              write_base64dec)(FIO_STR_PTR s_,
                                               const void *encoded_,
                                               size_t len) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_write_base64dec(&i,
                             FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                             encoded_,
                             len);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/* *****************************************************************************
String - read file
***************************************************************************** */

/**
 * Reads data from a file descriptor `fd` at offset `start_at` and pastes it's
 * contents (or a slice of it) at the end of the String. If `limit == 0`, than
 * the data will be read until EOF.
 *
 * The file should be a regular file or the operation might fail (can't be used
 * for sockets).
 *
 * The file descriptor will remain open and should be closed manually.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, readfd)(FIO_STR_PTR s_,
                                                    int fd,
                                                    intptr_t start_at,
                                                    intptr_t limit) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_readfd(&i,
                    FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                    fd,
                    start_at,
                    limit);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/**
 * Opens the file `filename` and pastes it's contents (or a slice ot it) at
 * the end of the String. If `limit == 0`, than the data will be read until
 * EOF.
 *
 * If the file can't be located, opened or read, or if `start_at` is beyond
 * the EOF position, NULL is returned in the state's `data` field.
 */
SFUNC fio_str_info_s FIO_NAME(FIO_STR_NAME, readfile)(FIO_STR_PTR s_,
                                                      const char *filename,
                                                      intptr_t start_at,
                                                      intptr_t limit) {
  fio_str_info_s i = FIO_NAME(FIO_STR_NAME, info)(s_);
  if (!i.capa)
    return i;
  fio_string_readfile(&i,
                      FIO_NAME(FIO_STR_NAME, __realloc_func)(s_),
                      filename,
                      start_at,
                      limit);
  FIO_NAME(FIO_STR_NAME, __info_update)(s_, i);
  return i;
}

/* *****************************************************************************


                                    String Test


***************************************************************************** */
#ifdef FIO_STR_WRITE_TEST_FUNC

/**
 * Tests the fio_str functionality.
 */
SFUNC void FIO_NAME_TEST(stl, FIO_STR_NAME)(void) {
  FIO_NAME(FIO_STR_NAME, s) str = {0}; /* test zeroed out memory */
#define FIO__STR_SMALL_CAPA FIO_STR_SMALL_CAPA(&str)
  fprintf(
      stderr,
      "* Testing core string features for " FIO_MACRO2STR(FIO_STR_NAME) ".\n");
  fprintf(stderr,
          "* String container size (without wrapper): %zu\n",
          sizeof(FIO_NAME(FIO_STR_NAME, s)));
  fprintf(stderr,
          "* Self-contained capacity (FIO_STR_SMALL_CAPA): %zu\n",
          FIO__STR_SMALL_CAPA);
  FIO_ASSERT(!FIO_NAME_BL(FIO_STR_NAME, frozen)(&str), "new string is frozen");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(&str) == FIO__STR_SMALL_CAPA,
             "small string capacity returned %zu",
             FIO_NAME(FIO_STR_NAME, capa)(&str));
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(&str) == 0,
             "small string length reporting error!");
  FIO_ASSERT(
      FIO_NAME(FIO_STR_NAME, ptr)(&str) == ((char *)(&str) + 1),
      "small string pointer reporting error (%zd offset)!",
      (ssize_t)(((char *)(&str) + 1) - FIO_NAME(FIO_STR_NAME, ptr)(&str)));
  FIO_NAME(FIO_STR_NAME, write)(&str, "World", 4);
  FIO_ASSERT(FIO_STR_IS_SMALL(&str),
             "small string writing error - not small on small write!");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(&str) == FIO__STR_SMALL_CAPA,
             "Small string capacity reporting error after write!");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(&str) == 4,
             "small string length reporting error after write!");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, ptr)(&str) == (char *)&str + 1,
             "small string pointer reporting error after write!");
  FIO_ASSERT(!FIO_NAME(FIO_STR_NAME, ptr)(&str)[4] &&
                 strlen(FIO_NAME(FIO_STR_NAME, ptr)(&str)) == 4,
             "small string NUL missing after write (%zu)!",
             strlen(FIO_NAME(FIO_STR_NAME, ptr)(&str)));
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(&str), "Worl"),
             "small string write error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(&str));
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, ptr)(&str) ==
                 FIO_NAME(FIO_STR_NAME, info)(&str).buf,
             "small string `data` != `info.buf` (%p != %p)",
             (void *)FIO_NAME(FIO_STR_NAME, ptr)(&str),
             (void *)FIO_NAME(FIO_STR_NAME, info)(&str).buf);

  FIO_NAME(FIO_STR_NAME, FIO_STR_RESERVE_NAME)
  (&str, sizeof(FIO_NAME(FIO_STR_NAME, s)));
  FIO_ASSERT(!FIO_STR_IS_SMALL(&str),
             "Long String reporting as small after capacity update!");
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(&str) >=
                 sizeof(FIO_NAME(FIO_STR_NAME, s)) - 1,
             "Long String capacity update error (%zu != %zu)!",
             FIO_NAME(FIO_STR_NAME, capa)(&str),
             FIO_STR_SMALL_CAPA(&str));

  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, ptr)(&str) ==
                 FIO_NAME(FIO_STR_NAME, info)(&str).buf,
             "Long String `ptr` !>= "
             "`cstr(s).buf` (%p != %p)",
             (void *)FIO_NAME(FIO_STR_NAME, ptr)(&str),
             (void *)FIO_NAME(FIO_STR_NAME, info)(&str).buf);

#if FIO_STR_OPTIMIZE4IMMUTABILITY
  /* immutable string length is updated after `reserve` to reflect new capa */
  FIO_NAME(FIO_STR_NAME, resize)(&str, 4);
#endif
  FIO_ASSERT(
      FIO_NAME(FIO_STR_NAME, len)(&str) == 4,
      "Long String length changed during conversion from small string (%zu)!",
      FIO_NAME(FIO_STR_NAME, len)(&str));
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, ptr)(&str) == str.buf,
             "Long String pointer reporting error after capacity update!");
  FIO_ASSERT(strlen(FIO_NAME(FIO_STR_NAME, ptr)(&str)) == 4,
             "Long String NUL missing after capacity update (%zu)!",
             strlen(FIO_NAME(FIO_STR_NAME, ptr)(&str)));
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(&str), "Worl"),
             "Long String value changed after capacity update (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(&str));

  FIO_NAME(FIO_STR_NAME, write)(&str, "d!", 2);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(&str), "World!"),
             "Long String `write` error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(&str));

  FIO_NAME(FIO_STR_NAME, replace)(&str, 0, 0, "Hello ", 6);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(&str), "Hello World!"),
             "Long String `insert` error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(&str));

  FIO_NAME(FIO_STR_NAME, resize)(&str, 6);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(&str), "Hello "),
             "Long String `resize` clipping error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(&str));

  FIO_NAME(FIO_STR_NAME, replace)(&str, 6, 0, "My World!", 9);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(&str), "Hello My World!"),
             "Long String `replace` error when testing overflow (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(&str));

  FIO_NAME(FIO_STR_NAME, FIO_STR_RESERVE_NAME)
  (&str, FIO_NAME(FIO_STR_NAME, len)(&str)); /* may truncate */

  FIO_NAME(FIO_STR_NAME, replace)(&str, -10, 2, "Big", 3);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(&str), "Hello Big World!"),
             "Long String `replace` error when testing splicing (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(&str));

  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(&str) ==
                     fio_string_capa4len(strlen("Hello Big World!")) ||
                 !FIO_NAME_BL(FIO_STR_NAME, allocated)(&str),
             "Long String `replace` capacity update error "
             "(%zu >=? %zu)!",
             FIO_NAME(FIO_STR_NAME, capa)(&str),
             fio_string_capa4len(strlen("Hello Big World!")));

  if (FIO_NAME(FIO_STR_NAME, len)(&str) < (sizeof(str) - 2)) {
    FIO_NAME(FIO_STR_NAME, compact)(&str);
    FIO_ASSERT(FIO_STR_IS_SMALL(&str),
               "Compacting didn't change String to small!");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(&str) == strlen("Hello Big World!"),
               "Compacting altered String length! (%zu != %zu)!",
               FIO_NAME(FIO_STR_NAME, len)(&str),
               strlen("Hello Big World!"));
    FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(&str), "Hello Big World!"),
               "Compact data error (%s)!",
               FIO_NAME(FIO_STR_NAME, ptr)(&str));
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(&str) == sizeof(str) - 2,
               "Compacted String capacity reporting error!");
  } else {
    FIO_LOG_DEBUG("* Skipped `compact` test (irrelevant for type).");
  }

  {
    FIO_NAME(FIO_STR_NAME, freeze)(&str);
    FIO_ASSERT(FIO_NAME_BL(FIO_STR_NAME, frozen)(&str),
               "Frozen String not flagged as frozen.");
    fio_str_info_s old_state = FIO_NAME(FIO_STR_NAME, info)(&str);
    FIO_NAME(FIO_STR_NAME, write)(&str, "more data to be written here", 28);
    FIO_NAME(FIO_STR_NAME, replace)
    (&str, 2, 1, "more data to be written here", 28);
    fio_str_info_s new_state = FIO_NAME(FIO_STR_NAME, info)(&str);
    FIO_ASSERT(old_state.len == new_state.len, "Frozen String length changed!");
    FIO_ASSERT(old_state.buf == new_state.buf,
               "Frozen String pointer changed!");
    FIO_ASSERT(
        old_state.capa == new_state.capa,
        "Frozen String capacity changed (allowed, but shouldn't happen)!");
    FIO_STR_THAW_(&str);
  }
  FIO_NAME(FIO_STR_NAME, printf)(&str, " %u", 42);
  FIO_ASSERT(!strcmp(FIO_NAME(FIO_STR_NAME, ptr)(&str), "Hello Big World! 42"),
             "`printf` data error (%s)!",
             FIO_NAME(FIO_STR_NAME, ptr)(&str));

  {
    FIO_NAME(FIO_STR_NAME, s) str2 = FIO_STR_INIT;
    FIO_NAME(FIO_STR_NAME, concat)(&str2, &str);
    FIO_ASSERT(FIO_NAME_BL(FIO_STR_NAME, eq)(&str, &str2),
               "`concat` error, strings not equal (%s != %s)!",
               FIO_NAME(FIO_STR_NAME, ptr)(&str),
               FIO_NAME(FIO_STR_NAME, ptr)(&str2));
    FIO_NAME(FIO_STR_NAME, write)(&str2, ":extra data", 11);
    FIO_ASSERT(!FIO_NAME_BL(FIO_STR_NAME, eq)(&str, &str2),
               "`write` error after copy, strings equal "
               "((%zu)%s == (%zu)%s)!",
               FIO_NAME(FIO_STR_NAME, len)(&str),
               FIO_NAME(FIO_STR_NAME, ptr)(&str),
               FIO_NAME(FIO_STR_NAME, len)(&str2),
               FIO_NAME(FIO_STR_NAME, ptr)(&str2));

    FIO_NAME(FIO_STR_NAME, destroy)(&str2);
  }

  FIO_NAME(FIO_STR_NAME, destroy)(&str);

  FIO_NAME(FIO_STR_NAME, write_i)(&str, -42);
  FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(&str) == 3 &&
                 !memcmp("-42", FIO_NAME(FIO_STR_NAME, ptr)(&str), 3),
             "write_i output error ((%zu) %s != -42)",
             FIO_NAME(FIO_STR_NAME, len)(&str),
             FIO_NAME(FIO_STR_NAME, ptr)(&str));
  FIO_NAME(FIO_STR_NAME, destroy)(&str);
#ifndef FIO___CSTL_NON_COMBINED_INCLUSION
  {
    fprintf(stderr, "* Testing string `readfile`.\n");
    FIO_NAME(FIO_STR_NAME, s) *s = FIO_NAME(FIO_STR_NAME, new)();
    FIO_ASSERT(FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_STR_NAME, s), s),
               "error, string not allocated (%p)!",
               (void *)s);
    fio_str_info_s state = FIO_NAME(FIO_STR_NAME, readfile)(s, __FILE__, 0, 0);

    FIO_ASSERT(state.len && state.buf,
               "error, no data was read for file %s!",
               __FILE__);

    FIO_ASSERT(!memcmp(state.buf,
                       "/* "
                       "******************************************************"
                       "***********************",
                       80),
               "content error, header mismatch!\n %s",
               state.buf);
    fprintf(stderr, "* Testing UTF-8 validation and length.\n");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, utf8_valid)(s),
               "`utf8_valid` error, code in this file "
               "should be valid!");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, utf8_len)(s) &&
                   (FIO_NAME(FIO_STR_NAME, utf8_len)(s) <=
                    FIO_NAME(FIO_STR_NAME, len)(s)) &&
                   (FIO_NAME(FIO_STR_NAME, utf8_len)(s) >=
                    (FIO_NAME(FIO_STR_NAME, len)(s)) >> 1),
               "`utf8_len` error, invalid value (%zu / %zu!",
               FIO_NAME(FIO_STR_NAME, utf8_len)(s),
               FIO_NAME(FIO_STR_NAME, len)(s));

    if (1) {
      /* String content == whole file (this file) */
      intptr_t pos = -11;
      size_t len = 20;
      fprintf(stderr, "* Testing UTF-8 positioning.\n");

      FIO_ASSERT(FIO_NAME(FIO_STR_NAME, utf8_select)(s, &pos, &len) == 0,
                 "`select` returned error for negative "
                 "pos! (%zd, %zu)",
                 (ssize_t)pos,
                 len);
      FIO_ASSERT(pos ==
                     (intptr_t)state.len - 10, /* no UTF-8 bytes in this file */
                 "`utf8_select` error, negative position "
                 "invalid! (%zd)",
                 (ssize_t)pos);
      FIO_ASSERT(len == 10,
                 "`utf8_select` error, trancated length "
                 "invalid! (%zd)",
                 (ssize_t)len);
      pos = 10;
      len = 20;
      FIO_ASSERT(FIO_NAME(FIO_STR_NAME, utf8_select)(s, &pos, &len) == 0,
                 "`utf8_select` returned error! (%zd, %zu)",
                 (ssize_t)pos,
                 len);
      FIO_ASSERT(pos == 10,
                 "`utf8_select` error, position invalid! (%zd)",
                 (ssize_t)pos);
      FIO_ASSERT(len == 20,
                 "`utf8_select` error, length invalid! (%zd)",
                 (ssize_t)len);
    }
    FIO_NAME(FIO_STR_NAME, free)(s);
  }
#endif /* FIO___CSTL_NON_COMBINED_INCLUSION */
  FIO_NAME(FIO_STR_NAME, destroy)(&str);
  if (1) {
    /* Testing Static initialization and writing */
#if FIO_STR_OPTIMIZE4IMMUTABILITY
    FIO_NAME(FIO_STR_NAME, init_const)(&str, "Welcome", 7);
#else
    str = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT_STATIC("Welcome");
#endif
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(&str) == 0 ||
                   FIO_STR_IS_SMALL(&str),
               "Static string capacity non-zero.");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(&str) > 0,
               "Static string length should be automatically calculated.");
    FIO_ASSERT(!FIO_NAME_BL(FIO_STR_NAME, allocated)(&str),
               "Static strings shouldn't be dynamic.");
    FIO_NAME(FIO_STR_NAME, destroy)(&str);

#if FIO_STR_OPTIMIZE4IMMUTABILITY
    FIO_NAME(FIO_STR_NAME, init_const)
    (&str,
     "Welcome to a very long static string that should not fit within a "
     "containing struct... hopefuly",
     95);
#else
    str = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT_STATIC(
        "Welcome to a very long static string that should not fit within a "
        "containing struct... hopefuly");
#endif
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, capa)(&str) == 0 ||
                   FIO_STR_IS_SMALL(&str),
               "Static string capacity non-zero.");
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(&str) > 0,
               "Static string length should be automatically calculated.");
    FIO_ASSERT(!FIO_NAME_BL(FIO_STR_NAME, allocated)(&str),
               "Static strings shouldn't be dynamic.");
    FIO_NAME(FIO_STR_NAME, destroy)(&str);

#if FIO_STR_OPTIMIZE4IMMUTABILITY
    FIO_NAME(FIO_STR_NAME, init_const)(&str, "Welcome", 7);
#else
    str = (FIO_NAME(FIO_STR_NAME, s))FIO_STR_INIT_STATIC("Welcome");
#endif
    fio_str_info_s state = FIO_NAME(FIO_STR_NAME, write)(&str, " Home", 5);
    FIO_ASSERT(state.capa > 0, "Static string not converted to non-static.");
    FIO_ASSERT(FIO_NAME_BL(FIO_STR_NAME, allocated)(&str) ||
                   FIO_STR_IS_SMALL(&str),
               "String should be dynamic after `write`.");

    char *cstr = FIO_NAME(FIO_STR_NAME, detach)(&str);
    FIO_ASSERT(cstr, "`detach` returned NULL");
    FIO_ASSERT(!memcmp(cstr, "Welcome Home\0", 13),
               "`detach` string error: %s",
               cstr);
    FIO_MEM_FREE(cstr, state.capa);
    FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(&str) == 0,
               "`detach` data wasn't cleared.");
    FIO_NAME(FIO_STR_NAME, destroy)
    (&str); /* does nothing, but what the heck... */
  }
  {
    fprintf(stderr, "* Testing Base64 encoding / decoding.\n");
    FIO_NAME(FIO_STR_NAME, destroy)(&str); /* does nothing, but why not... */

    FIO_NAME(FIO_STR_NAME, s) b64message = FIO_STR_INIT;
    fio_str_info_s b64i = FIO_NAME(
        FIO_STR_NAME,
        write)(&b64message, "Hello World, this is the voice of peace:)", 41);
    for (int i = 0; i < 256; ++i) {
      uint8_t c = i;
      b64i = FIO_NAME(FIO_STR_NAME, write)(&b64message, &c, 1);
      FIO_ASSERT(FIO_NAME(FIO_STR_NAME, len)(&b64message) == (size_t)(42 + i),
                 "Base64 message length error (%zu != %zu)",
                 FIO_NAME(FIO_STR_NAME, len)(&b64message),
                 (size_t)(42 + i));
      FIO_ASSERT(FIO_NAME(FIO_STR_NAME, ptr)(&b64message)[41 + i] == (char)c,
                 "Base64 message data error");
    }
    fio_str_info_s encoded =
        FIO_NAME(FIO_STR_NAME, write_base64enc)(&str, b64i.buf, b64i.len, 1);
    /* prevent encoded data from being deallocated during unencoding */
    encoded = FIO_NAME(FIO_STR_NAME, FIO_STR_RESERVE_NAME)(
        &str,
        encoded.len + ((encoded.len >> 2) * 3) + 8);
    fio_str_info_s decoded;
    {
      FIO_NAME(FIO_STR_NAME, s) tmps;
      FIO_NAME(FIO_STR_NAME, init_copy2)(&tmps, &str);
      decoded = FIO_NAME(FIO_STR_NAME,
                         write_base64dec)(&str,
                                          FIO_NAME(FIO_STR_NAME, ptr)(&tmps),
                                          FIO_NAME(FIO_STR_NAME, len)(&tmps));
      FIO_NAME(FIO_STR_NAME, destroy)(&tmps);
      encoded.buf = decoded.buf;
    }
    FIO_ASSERT(encoded.len, "Base64 encoding failed");
    FIO_ASSERT(decoded.len > encoded.len,
               "Base64 decoding failed:\n%s",
               encoded.buf);
    FIO_ASSERT(b64i.len == decoded.len - encoded.len,
               "Base 64 roundtrip length error, %zu != %zu (%zu - %zu):\n %s",
               b64i.len,
               decoded.len - encoded.len,
               decoded.len,
               encoded.len,
               decoded.buf);

    FIO_ASSERT(!memcmp(b64i.buf, decoded.buf + encoded.len, b64i.len),
               "Base 64 roundtrip failed:\n %s",
               decoded.buf);
    FIO_NAME(FIO_STR_NAME, destroy)(&b64message);
    FIO_NAME(FIO_STR_NAME, destroy)(&str);
  }
  {
    fprintf(stderr, "* Testing JSON style character escaping / unescaping.\n");
    FIO_NAME(FIO_STR_NAME, s) unescaped = FIO_STR_INIT;
    fio_str_info_s ue;
    const char *utf8_sample = /* three hearts, small-big-small*/
        "\xf0\x9f\x92\x95\xe2\x9d\xa4\xef\xb8\x8f\xf0\x9f\x92\x95";
    FIO_NAME(FIO_STR_NAME, write)(&unescaped, utf8_sample, strlen(utf8_sample));
    for (int i = 0; i < 256; ++i) {
      uint8_t c = i;
      ue = FIO_NAME(FIO_STR_NAME, write)(&unescaped, &c, 1);
    }
    fio_str_info_s encoded =
        FIO_NAME(FIO_STR_NAME, write_escape)(&str, ue.buf, ue.len);
    // fprintf(stderr, "* %s\n", encoded.buf);
    fio_str_info_s decoded;
    {
      FIO_NAME(FIO_STR_NAME, s) tmps;
      FIO_NAME(FIO_STR_NAME, init_copy2)(&tmps, &str);
      decoded = FIO_NAME(FIO_STR_NAME,
                         write_unescape)(&str,
                                         FIO_NAME(FIO_STR_NAME, ptr)(&tmps),
                                         FIO_NAME(FIO_STR_NAME, len)(&tmps));
      FIO_NAME(FIO_STR_NAME, destroy)(&tmps);
      encoded.buf = decoded.buf;
    }
    FIO_ASSERT(!memcmp(encoded.buf, utf8_sample, strlen(utf8_sample)),
               "valid UTF-8 data shouldn't be escaped:\n%.*s\n%s",
               (int)encoded.len,
               encoded.buf,
               decoded.buf);
    FIO_ASSERT(encoded.len, "JSON encoding failed");
    FIO_ASSERT(decoded.len > encoded.len,
               "JSON decoding failed:\n%s",
               encoded.buf);
    FIO_ASSERT(ue.len == decoded.len - encoded.len,
               "JSON roundtrip length error, %zu != %zu (%zu - %zu):\n %s",
               ue.len,
               decoded.len - encoded.len,
               decoded.len,
               encoded.len,
               decoded.buf);

    FIO_ASSERT(!memcmp(ue.buf, decoded.buf + encoded.len, ue.len),
               "JSON roundtrip failed:\n %s",
               decoded.buf);
    FIO_NAME(FIO_STR_NAME, destroy)(&unescaped);
    FIO_NAME(FIO_STR_NAME, destroy)(&str);
  }
}
#undef FIO__STR_SMALL_CAPA
#undef FIO_STR_WRITE_TEST_FUNC
#endif /* FIO_STR_WRITE_TEST_FUNC */

/* *****************************************************************************
String Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */

#undef FIO_STR_SMALL
#undef FIO_STR_SMALL_CAPA
#undef FIO_STR_SMALL_DATA
#undef FIO_STR_SMALL_LEN
#undef FIO_STR_SMALL_LEN_SET

#undef FIO_STR_BIG_CAPA
#undef FIO_STR_BIG_CAPA_SET
#undef FIO_STR_BIG_DATA
#undef FIO_STR_BIG_FREE_BUF
#undef FIO_STR_BIG_IS_DYNAMIC
#undef FIO_STR_BIG_LEN
#undef FIO_STR_BIG_LEN_SET
#undef FIO_STR_BIG_SET_STATIC

#undef FIO_STR_FREEZE_

#undef FIO_STR_IS_FROZEN
#undef FIO_STR_IS_SMALL
#undef FIO_STR_NAME

#undef FIO_STR_OPTIMIZE4IMMUTABILITY
#undef FIO_STR_OPTIMIZE_EMBEDDED
#undef FIO_STR_PTR
#undef FIO_STR_THAW_
#undef FIO_STR_RESERVE_NAME

#endif /* FIO_STR_NAME */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___       /* Development inclusion - ignore line */
#define FIO_ARRAY_NAME ary /* Development inclusion - ignore line */
#include "./include.h"     /* Development inclusion - ignore line */
#endif                     /* Development inclusion - ignore line */
/* *****************************************************************************




                            Dynamic Arrays



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */

#ifdef FIO_ARRAY_NAME

#ifdef FIO_ARRAY_TYPE_STR
#ifndef FIO_ARRAY_TYPE
#define FIO_ARRAY_TYPE fio_keystr_s
#endif
#ifndef FIO_ARRAY_TYPE_COPY
#define FIO_ARRAY_TYPE_COPY(dest, src) ((dest) = fio_keystr_copy((src)))
#endif
#ifndef FIO_ARRAY_TYPE_DESTROY
#define FIO_ARRAY_TYPE_DESTROY(obj) fio_keystr_destroy(&(obj));
#endif
#ifndef FIO_ARRAY_TYPE_CMP
#define FIO_ARRAY_TYPE_CMP(a, b) fio_keystr_is_eq((a), (b))
#endif
#undef FIO_ARRAY_DESTROY_AFTER_COPY
#define FIO_ARRAY_DESTROY_AFTER_COPY 1
#endif

#ifndef FIO_ARRAY_TYPE
/** The type for array elements (an array of FIO_ARRAY_TYPE) */
#define FIO_ARRAY_TYPE void *
/** An invalid value for that type (if any). */
#define FIO_ARRAY_TYPE_INVALID        NULL
#define FIO_ARRAY_TYPE_INVALID_SIMPLE 1
#else
#ifndef FIO_ARRAY_TYPE_INVALID
/** An invalid value for that type (if any). */
#define FIO_ARRAY_TYPE_INVALID        ((FIO_ARRAY_TYPE){0})
/* internal flag - do not set */
#define FIO_ARRAY_TYPE_INVALID_SIMPLE 1
#endif
#endif

#ifndef FIO_ARRAY_TYPE_INVALID_SIMPLE
/** Is the FIO_ARRAY_TYPE_INVALID object memory is all zero? (yes = 1) */
#define FIO_ARRAY_TYPE_INVALID_SIMPLE 0
#endif

#ifndef FIO_ARRAY_TYPE_COPY
/** Handles a copy operation for an array's element. */
#define FIO_ARRAY_TYPE_COPY(dest, src) (dest) = (src)
/* internal flag - do not set */
#define FIO_ARRAY_TYPE_COPY_SIMPLE 1
#endif

#ifndef FIO_ARRAY_TYPE_DESTROY
/** Handles a destroy / free operation for an array's element. */
#define FIO_ARRAY_TYPE_DESTROY(obj)
/* internal flag - do not set */
#define FIO_ARRAY_TYPE_DESTROY_SIMPLE 1
#endif

#ifndef FIO_ARRAY_TYPE_CMP
/** Handles a comparison operation for an array's element. */
#define FIO_ARRAY_TYPE_CMP(a, b) (a) == (b)
/* internal flag - do not set */
#define FIO_ARRAY_TYPE_CMP_SIMPLE 1
#endif

#ifndef FIO_ARRAY_TYPE_CONCAT_COPY
#define FIO_ARRAY_TYPE_CONCAT_COPY        FIO_ARRAY_TYPE_COPY
#define FIO_ARRAY_TYPE_CONCAT_COPY_SIMPLE FIO_ARRAY_TYPE_COPY_SIMPLE
#endif
/**
 * The FIO_ARRAY_DESTROY_AFTER_COPY macro should be set if
 * FIO_ARRAY_TYPE_DESTROY should be called after FIO_ARRAY_TYPE_COPY when an
 * object is removed from the array after being copied to an external container
 * (an `old` pointer)
 */
#ifndef FIO_ARRAY_DESTROY_AFTER_COPY
#if !FIO_ARRAY_TYPE_DESTROY_SIMPLE && !FIO_ARRAY_TYPE_COPY_SIMPLE
#define FIO_ARRAY_DESTROY_AFTER_COPY 1
#else
#define FIO_ARRAY_DESTROY_AFTER_COPY 0
#endif
#endif

/* Extra empty slots when allocating memory. */
#ifndef FIO_ARRAY_PADDING
#define FIO_ARRAY_PADDING 4
#endif

/*
 * Uses the array structure to embed object, if there's space for them.
 *
 * This optimizes small arrays and specifically touplets. For `void *` type
 * arrays this allows for 2 objects to be embedded, resulting in faster access
 * due to cache locality and reduced pointer redirection.
 *
 * For large arrays, it is better to disable this feature.
 *
 * Note: values larger than 1 add a memory allocation cost to the array
 * container, adding enough room for at least `FIO_ARRAY_ENABLE_EMBEDDED - 1`
 * items.
 */
#ifndef FIO_ARRAY_ENABLE_EMBEDDED
#define FIO_ARRAY_ENABLE_EMBEDDED 1
#endif

/* Sets memory growth to exponentially increase. Consumes more memory. */
#ifndef FIO_ARRAY_EXPONENTIAL
#define FIO_ARRAY_EXPONENTIAL 0
#endif

#undef FIO_ARRAY_SIZE2WORDS
#define FIO_ARRAY_SIZE2WORDS(size)                                             \
  ((sizeof(FIO_ARRAY_TYPE) & 1)   ? (((size) & (~15)) + 16)                    \
   : (sizeof(FIO_ARRAY_TYPE) & 2) ? (((size) & (~7)) + 8)                      \
   : (sizeof(FIO_ARRAY_TYPE) & 4) ? (((size) & (~3)) + 4)                      \
   : (sizeof(FIO_ARRAY_TYPE) & 8) ? (((size) & (~1)) + 2)                      \
                                  : (size))

/* *****************************************************************************
Dynamic Arrays - type
***************************************************************************** */

/** an Array type. */
typedef struct FIO_NAME(FIO_ARRAY_NAME, s) {
  /* start common header (with embedded array type) */
  /** the offser to the first item. */
  uint32_t start;
  /** The offset to the first empty location the array. */
  uint32_t end;
  /* end common header (with embedded array type) */
  /** The array's capacity - limited to 32bits, but we use the extra padding. */
  uintptr_t capa;
  /** a pointer to the array's memory (if not embedded) */
  FIO_ARRAY_TYPE *ary;
#if FIO_ARRAY_ENABLE_EMBEDDED > 1
  /** Do we wanted larger small-array optimizations? */
  FIO_ARRAY_TYPE
  extra_memory_for_embedded_arrays[(FIO_ARRAY_ENABLE_EMBEDDED - 1)]
#endif
} FIO_NAME(FIO_ARRAY_NAME, s);

#ifdef FIO_PTR_TAG_TYPE
#define FIO_ARRAY_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, s) *
#endif

/* *****************************************************************************
Dynamic Arrays - API
***************************************************************************** */

#ifndef FIO_ARRAY_INIT
/* Initialization macro. */
#define FIO_ARRAY_INIT                                                         \
  { 0 }
#endif

#ifndef FIO_REF_CONSTRUCTOR_ONLY

/* Allocates a new array object on the heap and initializes it's memory. */
FIO_IFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, new)(void);

/* Frees an array's internal data AND it's container! */
FIO_IFUNC void FIO_NAME(FIO_ARRAY_NAME, free)(FIO_ARRAY_PTR ary);

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/* Destroys any objects stored in the array and frees the internal state. */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, destroy)(FIO_ARRAY_PTR ary);

/** Returns the number of elements in the Array. */
FIO_IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, count)(FIO_ARRAY_PTR ary);

/** Returns the current, temporary, array capacity (it's dynamic). */
FIO_IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, capa)(FIO_ARRAY_PTR ary);

/**
 * Returns 1 if the array is embedded, 0 if it has memory allocated and -1 on an
 * error.
 */
FIO_IFUNC int FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(FIO_ARRAY_PTR ary);

/**
 * Returns a pointer to the C array containing the objects.
 */
FIO_IFUNC FIO_ARRAY_TYPE *FIO_NAME2(FIO_ARRAY_NAME, ptr)(FIO_ARRAY_PTR ary);

/**
 * Reserves a minimal capacity for the array.
 *
 * If `capa` is negative, new memory will be allocated at the beginning of the
 * array rather then it's end.
 *
 * Returns the array's new capacity.
 *
 * Note: the reserved capacity includes existing data. If the requested reserved
 * capacity is equal (or less) then the existing capacity, nothing will be done.
 */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, reserve)(FIO_ARRAY_PTR ary,
                                                 int32_t capa);

/**
 * Adds all the items in the `src` Array to the end of the `dest` Array.
 *
 * The `src` Array remain untouched.
 *
 * Always returns the destination array (`dest`).
 */
SFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, concat)(FIO_ARRAY_PTR dest,
                                                     FIO_ARRAY_PTR src);

/**
 * Sets `index` to the value in `data`.
 *
 * If `index` is negative, it will be counted from the end of the Array (-1 ==
 * last element).
 *
 * If `old` isn't NULL, the existing data will be copied to the location pointed
 * to by `old` before the copy in the Array is destroyed.
 *
 * Returns a pointer to the new object, or NULL on error.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, set)(FIO_ARRAY_PTR ary,
                                                    int32_t index,
                                                    FIO_ARRAY_TYPE data,
                                                    FIO_ARRAY_TYPE *old);

/**
 * Returns the value located at `index` (no copying is performed).
 *
 * If `index` is negative, it will be counted from the end of the Array (-1 ==
 * last element).
 */
FIO_IFUNC FIO_ARRAY_TYPE FIO_NAME(FIO_ARRAY_NAME, get)(FIO_ARRAY_PTR ary,
                                                       int32_t index);

/**
 * Returns the index of the object or -1 if the object wasn't found.
 *
 * If `start_at` is negative (i.e., -1), than seeking will be performed in
 * reverse, where -1 == last index (-2 == second to last, etc').
 */
SFUNC int32_t FIO_NAME(FIO_ARRAY_NAME, find)(FIO_ARRAY_PTR ary,
                                             FIO_ARRAY_TYPE data,
                                             int32_t start_at);

/**
 * Removes an object from the array, MOVING all the other objects to prevent
 * "holes" in the data.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns 0 on success and -1 on error.
 *
 * This action is O(n) where n in the length of the array.
 * It could get expensive.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, remove)(FIO_ARRAY_PTR ary,
                                           int32_t index,
                                           FIO_ARRAY_TYPE *old);

/**
 * Removes all occurrences of an object from the array (if any), MOVING all the
 * existing objects to prevent "holes" in the data.
 *
 * Returns the number of items removed.
 *
 * This action is O(n) where n in the length of the array.
 * It could get expensive.
 */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, remove2)(FIO_ARRAY_PTR ary,
                                                 FIO_ARRAY_TYPE data);

/** Attempts to lower the array's memory consumption. */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, compact)(FIO_ARRAY_PTR ary);

/**
 * Pushes an object to the end of the Array. Returns a pointer to the new object
 * or NULL on error.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, push)(FIO_ARRAY_PTR ary,
                                                     FIO_ARRAY_TYPE data);

/**
 * Removes an object from the end of the Array.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns -1 on error (Array is empty) and 0 on success.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, pop)(FIO_ARRAY_PTR ary, FIO_ARRAY_TYPE *old);

/**
 * Unshifts an object to the beginning of the Array. Returns a pointer to the
 * new object or NULL on error.
 *
 * This could be expensive, causing `memmove`.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, unshift)(FIO_ARRAY_PTR ary,
                                                        FIO_ARRAY_TYPE data);

/**
 * Removes an object from the beginning of the Array.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns -1 on error (Array is empty) and 0 on success.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, shift)(FIO_ARRAY_PTR ary,
                                          FIO_ARRAY_TYPE *old);

/** Iteration information structure passed to the callback. */
typedef struct FIO_NAME(FIO_ARRAY_NAME, each_s) {
  /** The array iterated. Once set, cannot be safely changed. */
  FIO_ARRAY_PTR const parent;
  /** The current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct FIO_NAME(FIO_ARRAY_NAME, each_s) * info);
  /** Opaque user data. */
  void *udata;
  /** The object / value at the current index. */
  FIO_ARRAY_TYPE value;
  /* memory padding used for FIOBJ */
  uint64_t padding;
} FIO_NAME(FIO_ARRAY_NAME, each_s);

/**
 * Iteration using a callback for each entry in the array.
 *
 * The callback task function must accept an each_s pointer, see above.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME,
                        each)(FIO_ARRAY_PTR ary,
                              int (*task)(FIO_NAME(FIO_ARRAY_NAME, each_s) *
                                          info),
                              void *udata,
                              int32_t start_at);

#ifndef FIO_ARRAY_EACH
/**
 * Iterates through the array using a `for` loop.
 *
 * Access the object with the pointer `pos`. The `pos` variable can be named
 * however you please.
 *
 * Avoid editing the array during a FOR loop, although I hope it's possible, I
 * wouldn't count on it.
 *
 * **Note**: this variant supports automatic pointer tagging / untagging.
 */
#define FIO_ARRAY_EACH(array_name, array, pos)                                 \
  for (FIO_NAME(array_name, ____type_t)                                        \
           *first___ai = NULL,                                                 \
           *pos = FIO_NAME(array_name, each_next)((array), &first___ai, NULL); \
       pos;                                                                    \
       pos = FIO_NAME(array_name, each_next)((array), &first___ai, pos))
#endif

/**
 * Returns a pointer to the (next) object in the array.
 *
 * Returns a pointer to the first object if `pos == NULL` and there are objects
 * in the array.
 *
 * The first pointer is automatically set and it allows object insertions and
 * memory effecting functions to be called from within the loop.
 *
 * If the object in `pos` (or an object before it) were removed, consider
 * passing `pos-1` to the function, to avoid skipping any elements while
 * looping.
 *
 * Returns the next object if both `first` and `pos` are valid.
 *
 * Returns NULL if `pos` was the last object or no object exist.
 *
 * Returns the first object if either `first` or `pos` are invalid.
 *
 */
FIO_IFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME,
                                   each_next)(FIO_ARRAY_PTR ary,
                                              FIO_ARRAY_TYPE **first,
                                              FIO_ARRAY_TYPE *pos);

/* *****************************************************************************
Dynamic Arrays - embedded arrays
***************************************************************************** */
typedef struct {
  /* start common header */
  /** the offset to the first item. */
  uint32_t start;
  /** The offset to the first empty location the array. */
  uint32_t end;
  /* end common header */
  FIO_ARRAY_TYPE embedded[];
} FIO_NAME(FIO_ARRAY_NAME, ___embedded_s);

#define FIO_ARRAY2EMBEDDED(a) ((FIO_NAME(FIO_ARRAY_NAME, ___embedded_s) *)(a))

#if FIO_ARRAY_ENABLE_EMBEDDED
#define FIO_ARRAY_IS_EMBEDDED(a)                                               \
  ((sizeof(FIO_ARRAY_TYPE) +                                                   \
    sizeof(FIO_NAME(FIO_ARRAY_NAME, ___embedded_s))) <=                        \
       sizeof(FIO_NAME(FIO_ARRAY_NAME, s)) &&                                  \
   (((a)->start > (a)->end) || !(a)->ary))
#define FIO_ARRAY_IS_EMBEDDED_PTR(ary, ptr)                                    \
  ((sizeof(FIO_ARRAY_TYPE) +                                                   \
    sizeof(FIO_NAME(FIO_ARRAY_NAME, ___embedded_s))) <=                        \
       sizeof(FIO_NAME(FIO_ARRAY_NAME, s)) &&                                  \
   (uintptr_t)(ptr) > (uintptr_t)(ary) &&                                      \
   (uintptr_t)(ptr) < (uintptr_t)((ary) + 1))
#define FIO_ARRAY_EMBEDDED_CAPA                                                \
  ((sizeof(FIO_ARRAY_TYPE) +                                                   \
    sizeof(FIO_NAME(FIO_ARRAY_NAME, ___embedded_s))) >                         \
           sizeof(FIO_NAME(FIO_ARRAY_NAME, s))                                 \
       ? 0                                                                     \
       : ((sizeof(FIO_NAME(FIO_ARRAY_NAME, s)) -                               \
           sizeof(FIO_NAME(FIO_ARRAY_NAME, ___embedded_s))) /                  \
          sizeof(FIO_ARRAY_TYPE)))

#else
#define FIO_ARRAY_IS_EMBEDDED(a)            0
#define FIO_ARRAY_IS_EMBEDDED_PTR(ary, ptr) 0
#define FIO_ARRAY_EMBEDDED_CAPA             0

#endif /* FIO_ARRAY_ENABLE_EMBEDDED */
/* *****************************************************************************
Inlined functions
***************************************************************************** */
#ifndef FIO_REF_CONSTRUCTOR_ONLY
/* Allocates a new array object on the heap and initializes it's memory. */
FIO_IFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, new)(void) {
  FIO_NAME(FIO_ARRAY_NAME, s) *a =
      (FIO_NAME(FIO_ARRAY_NAME, s) *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*a), 0);
  if (!FIO_MEM_REALLOC_IS_SAFE_ && a) {
    *a = (FIO_NAME(FIO_ARRAY_NAME, s))FIO_ARRAY_INIT;
  }
  return (FIO_ARRAY_PTR)FIO_PTR_TAG(a);
}

/* Frees an array's internal data AND it's container! */
FIO_IFUNC void FIO_NAME(FIO_ARRAY_NAME, free)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(ary_);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  FIO_NAME(FIO_ARRAY_NAME, destroy)(ary_);
  FIO_MEM_FREE_(ary, sizeof(*ary));
}
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/** Returns the number of elements in the Array. */
FIO_IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, count)(FIO_ARRAY_PTR ary_) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0: return ary->end - ary->start;
  case 1: return ary->start;
  }
  return 0;
}

/** Returns the current, temporary, array capacity (it's dynamic). */
FIO_IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, capa)(FIO_ARRAY_PTR ary_) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0: return ary->capa;
  case 1: return FIO_ARRAY_EMBEDDED_CAPA;
  }
  return 0;
}

/**
 * Returns a pointer to the C array containing the objects.
 */
FIO_IFUNC FIO_ARRAY_TYPE *FIO_NAME2(FIO_ARRAY_NAME, ptr)(FIO_ARRAY_PTR ary_) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0: return ary->ary + ary->start;
  case 1: return FIO_ARRAY2EMBEDDED(ary)->embedded;
  }
  return NULL;
}

/**
 * Returns 1 if the array is embedded, 0 if it has memory allocated and -1 on an
 * error.
 */
FIO_IFUNC int FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN(ary_, -1);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  return FIO_ARRAY_IS_EMBEDDED(ary);
  (void)ary; /* if unused (never embedded) */
}

/**
 * Returns the value located at `index` (no copying is performed).
 *
 * If `index` is negative, it will be counted from the end of the Array (-1 ==
 * last element).
 */
FIO_IFUNC FIO_ARRAY_TYPE FIO_NAME(FIO_ARRAY_NAME, get)(FIO_ARRAY_PTR ary_,
                                                       int32_t index) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  FIO_ARRAY_TYPE *a;
  size_t count;
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    a = ary->ary + ary->start;
    count = ary->end - ary->start;
    break;
  case 1:
    a = FIO_ARRAY2EMBEDDED(ary)->embedded;
    count = ary->start;
    break;
  default: return FIO_ARRAY_TYPE_INVALID;
  }

  if (index < 0) {
    index += count;
    if (index < 0)
      return FIO_ARRAY_TYPE_INVALID;
  }
  if ((uint32_t)index >= count)
    return FIO_ARRAY_TYPE_INVALID;
  return a[index];
}

/* Returns a pointer to the (next) object in the array. */
FIO_IFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME,
                                   each_next)(FIO_ARRAY_PTR ary_,
                                              FIO_ARRAY_TYPE **first,
                                              FIO_ARRAY_TYPE *pos) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  int32_t count;
  FIO_ARRAY_TYPE *a;
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    count = ary->end - ary->start;
    a = ary->ary + ary->start;
    break;
  case 1:
    count = ary->start;
    a = FIO_ARRAY2EMBEDDED(ary)->embedded;
    break;
  default: return NULL;
  }
  intptr_t i;
  if (!count || !first)
    return NULL;
  if (!pos || !(*first) || (*first) > pos) {
    i = -1;
  } else {
    i = (intptr_t)(pos - (*first));
  }
  *first = a;
  ++i;
  if (i >= count)
    return NULL;
  return i + a;
}

/** Used internally for the EACH macro */
typedef FIO_ARRAY_TYPE FIO_NAME(FIO_ARRAY_NAME, ____type_t);

/* *****************************************************************************
Exported functions
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
/* *****************************************************************************
Helper macros
***************************************************************************** */
#if FIO_ARRAY_EXPONENTIAL
#define FIO_ARRAY_ADD2CAPA(capa) (((capa) << 1) + FIO_ARRAY_PADDING)
#else
#define FIO_ARRAY_ADD2CAPA(capa) ((capa) + FIO_ARRAY_PADDING)
#endif

/* *****************************************************************************
Dynamic Arrays - internal helpers
***************************************************************************** */

#define FIO_ARRAY_POS2ABS(ary, pos)                                            \
  (pos >= 0 ? (ary->start + pos) : (ary->end - pos))

#define FIO_ARRAY_AB_CT(cond, a, b) ((b) ^ ((0 - ((cond)&1)) & ((a) ^ (b))))

/* *****************************************************************************
Dynamic Arrays - implementation
***************************************************************************** */

/* Destroys any objects stored in the array and frees the internal state. */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, destroy)(FIO_ARRAY_PTR ary_) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  union {
    FIO_NAME(FIO_ARRAY_NAME, s) a;
    FIO_NAME(FIO_ARRAY_NAME, ___embedded_s) e;
  } tmp = {.a = *ary};
  *ary = (FIO_NAME(FIO_ARRAY_NAME, s))FIO_ARRAY_INIT;

  switch (
      FIO_NAME_BL(FIO_ARRAY_NAME, embedded)((FIO_ARRAY_PTR)FIO_PTR_TAG(&tmp))) {
  case 0:
#if !FIO_ARRAY_TYPE_DESTROY_SIMPLE
    for (size_t i = tmp.a.start; i < tmp.a.end; ++i) {
      FIO_ARRAY_TYPE_DESTROY(tmp.a.ary[i]);
    }
#endif
    FIO_MEM_FREE_(tmp.a.ary, tmp.a.capa * sizeof(*tmp.a.ary));
    return;
  case 1:
#if !FIO_ARRAY_TYPE_DESTROY_SIMPLE
    while (tmp.e.start--) {
      FIO_ARRAY_TYPE_DESTROY((tmp.e.embedded[tmp.e.start]));
    }
#endif
    return;
  }
  return;
}

/** Reserves a minimal capacity for the array. */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, reserve)(FIO_ARRAY_PTR ary_,
                                                 int32_t capa_) {
  const uint32_t abs_capa =
      (capa_ >= 0) ? (uint32_t)capa_ : (uint32_t)(0 - capa_);
  const uint32_t capa = FIO_ARRAY_SIZE2WORDS(abs_capa);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  FIO_ARRAY_TYPE *tmp;
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    if (abs_capa <= ary->capa)
      return ary->capa;
    /* objects don't move, use the system's realloc */
    if ((capa_ >= 0) || (capa_ < 0 && ary->start > 0)) {
      tmp = (FIO_ARRAY_TYPE *)FIO_MEM_REALLOC_(ary->ary,
                                               0,
                                               sizeof(*tmp) * capa,
                                               sizeof(*tmp) * ary->end);
      if (!tmp)
        return ary->capa;
      ary->capa = capa;
      ary->ary = tmp;
      return capa;
    } else {
      /* moving objects, starting with a fresh piece of memory */
      tmp = (FIO_ARRAY_TYPE *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*tmp) * capa, 0);
      const uint32_t count = ary->end - ary->start;
      if (!tmp)
        return ary->capa;
      if (capa_ >= 0) {
        /* copy items at begining of memory stack */
        if (count) {
          FIO_MEMCPY(tmp, ary->ary + ary->start, count * sizeof(*tmp));
        }
        FIO_MEM_FREE_(ary->ary, sizeof(*ary->ary) * ary->capa);
        *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
            .start = 0,
            .end = count,
            .capa = capa,
            .ary = tmp,
        };
        return capa;
      }
      /* copy items at ending of memory stack */
      if (count) {
        FIO_MEMCPY(tmp + (capa - count),
                   ary->ary + ary->start,
                   count * sizeof(*tmp));
      }
      FIO_MEM_FREE_(ary->ary, sizeof(*ary->ary) * ary->capa);
      *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
          .start = (capa - count),
          .end = capa,
          .capa = capa,
          .ary = tmp,
      };
    }
    return capa;
  case 1:
    if (abs_capa <= FIO_ARRAY_EMBEDDED_CAPA)
      return FIO_ARRAY_EMBEDDED_CAPA;
    tmp = (FIO_ARRAY_TYPE *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*tmp) * capa, 0);
    if (!tmp)
      return FIO_ARRAY_EMBEDDED_CAPA;
    if (capa_ >= 0) {
      /* copy items at beginning of memory stack */
      if (ary->start) {
        FIO_MEMCPY(tmp,
                   FIO_ARRAY2EMBEDDED(ary)->embedded,
                   ary->start * sizeof(*tmp));
      }
      *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
          .start = 0,
          .end = ary->start,
          .capa = capa,
          .ary = tmp,
      };
      return capa;
    }
    /* copy items at ending of memory stack */
    if (ary->start) {
      FIO_MEMCPY(tmp + (capa - ary->start),
                 FIO_ARRAY2EMBEDDED(ary)->embedded,
                 ary->start * sizeof(*tmp));
    }
    *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
        .start = (capa - ary->start),
        .end = capa,
        .capa = capa,
        .ary = tmp,
    };
    return capa;
  default: return 0;
  }
}

/**
 * Adds all the items in the `src` Array to the end of the `dest` Array.
 *
 * The `src` Array remain untouched.
 *
 * Returns `dest` on success or NULL on error (i.e., no memory).
 */
SFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, concat)(FIO_ARRAY_PTR dest_,
                                                     FIO_ARRAY_PTR src_) {
  FIO_PTR_TAG_VALID_OR_RETURN(dest_, (FIO_ARRAY_PTR)NULL);
  FIO_PTR_TAG_VALID_OR_RETURN(src_, (FIO_ARRAY_PTR)NULL);
  FIO_NAME(FIO_ARRAY_NAME, s) *dest =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), dest_);
  FIO_NAME(FIO_ARRAY_NAME, s) *src =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), src_);
  if (!dest || !src)
    return dest_;
  const uint32_t offset = FIO_NAME(FIO_ARRAY_NAME, count)(dest_);
  const uint32_t added = FIO_NAME(FIO_ARRAY_NAME, count)(src_);
  const uint32_t total = offset + added;
  if (!added)
    return dest_;

  if (total < offset || total + offset < total)
    return NULL; /* item count overflow */

  const uint32_t capa = FIO_NAME(FIO_ARRAY_NAME, reserve)(dest_, total);

  if (!FIO_ARRAY_IS_EMBEDDED(dest) && dest->start + total > capa) {
    /* we need to move the existing items due to the offset */
    FIO_MEMMOVE(dest->ary,
                dest->ary + dest->start,
                (dest->end - dest->start) * sizeof(*dest->ary));
    dest->start = 0;
    dest->end = offset;
  }
#if FIO_ARRAY_TYPE_CONCAT_COPY_SIMPLE
  /* copy data */
  FIO_MEMCPY(FIO_NAME2(FIO_ARRAY_NAME, ptr)(dest_) + offset,
             FIO_NAME2(FIO_ARRAY_NAME, ptr)(src_),
             added);
#else
  {
    FIO_ARRAY_TYPE *const a1 = FIO_NAME2(FIO_ARRAY_NAME, ptr)(dest_);
    FIO_ARRAY_TYPE *const a2 = FIO_NAME2(FIO_ARRAY_NAME, ptr)(src_);
    for (uint32_t i = 0; i < added; ++i) {
      FIO_ARRAY_TYPE_CONCAT_COPY(a1[i + offset], a2[i]);
    }
  }
#endif /* FIO_ARRAY_TYPE_CONCAT_COPY_SIMPLE */
  /* update dest */
  if (!FIO_ARRAY_IS_EMBEDDED(dest)) {
    dest->end += added;
    return dest_;
  } else
    dest->start = total;
  return dest_;
}

/**
 * Sets `index` to the value in `data`.
 *
 * If `index` is negative, it will be counted from the end of the Array (-1 ==
 * last element).
 *
 * If `old` isn't NULL, the existing data will be copied to the location pointed
 * to by `old` before the copy in the Array is destroyed.
 *
 * Returns a pointer to the new object, or NULL on error.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, set)(FIO_ARRAY_PTR ary_,
                                                    int32_t index,
                                                    FIO_ARRAY_TYPE data,
                                                    FIO_ARRAY_TYPE *old) {
  FIO_ARRAY_TYPE *a = NULL;
  FIO_NAME(FIO_ARRAY_NAME, s) * ary;
  uint32_t count;
  uint8_t pre_existing = 1;

  FIO_PTR_TAG_VALID_OR_GOTO(ary_, invalid);

  ary = FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);

  if (index < 0) {
    index += count;
    if (index < 0)
      goto negative_expansion;
  }

  if ((uint32_t)index >= count) {
    if ((uint32_t)index == count)
      FIO_NAME(FIO_ARRAY_NAME, reserve)(ary_, FIO_ARRAY_ADD2CAPA(index));
    else
      FIO_NAME(FIO_ARRAY_NAME, reserve)(ary_, (uint32_t)index + 1);
    if (FIO_ARRAY_IS_EMBEDDED(ary))
      goto expand_embedded;
    goto expansion;
  }

  a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);

done:

  /* copy / clear object */
  if (pre_existing) {
    if (old) {
      FIO_ARRAY_TYPE_COPY(old[0], a[index]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(a[index]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(a[index]);
    }
  } else if (old) {
    FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY_TYPE_INVALID);
  }
  FIO_ARRAY_TYPE_COPY(a[index], FIO_ARRAY_TYPE_INVALID);
  FIO_ARRAY_TYPE_COPY(a[index], data);
  return a + index;

expansion:

  pre_existing = 0;
  a = ary->ary;
  {
    uint8_t was_moved = 0;
    /* test if we need to move objects to make room at the end */
    if (ary->start + index >= ary->capa) {
      FIO_MEMMOVE(ary->ary, ary->ary + ary->start, (count) * sizeof(*ary->ary));
      ary->start = 0;
      ary->end = index + 1;
      was_moved = 1;
    }
    /* initialize memory in between objects */
    if (was_moved || !FIO_MEM_REALLOC_IS_SAFE_ ||
        !FIO_ARRAY_TYPE_INVALID_SIMPLE) {
#if FIO_ARRAY_TYPE_INVALID_SIMPLE
      FIO_MEMSET(a + count, 0, (index - count) * sizeof(*ary->ary));
#else
      for (size_t i = count; i <= (size_t)index; ++i) {
        FIO_ARRAY_TYPE_COPY(a[i], FIO_ARRAY_TYPE_INVALID);
      }
#endif
    }
    ary->end = index + 1;
  }
  goto done;

expand_embedded:
  pre_existing = 0;
  ary->start = index + 1;
  a = FIO_ARRAY2EMBEDDED(ary)->embedded;
  goto done;

negative_expansion:
  pre_existing = 0;
  FIO_NAME(FIO_ARRAY_NAME, reserve)(ary_, (index - count));
  index = 0 - index;

  if ((FIO_ARRAY_IS_EMBEDDED(ary)))
    goto negative_expansion_embedded;
  a = ary->ary;
  if (index > (int32_t)ary->start) {
    FIO_MEMMOVE(a + index, a + ary->start, count * sizeof(*a));
    ary->end = index + count;
    ary->start = index;
  }
  index = ary->start - index;
  if ((uint32_t)(index + 1) < ary->start) {
#if FIO_ARRAY_TYPE_INVALID_SIMPLE
    FIO_MEMSET(a + index, 0, (ary->start - index) * (sizeof(*a)));
#else
    for (size_t i = index; i < (size_t)ary->start; ++i) {
      FIO_ARRAY_TYPE_COPY(a[i], FIO_ARRAY_TYPE_INVALID);
    }
#endif
  }
  ary->start = index;
  goto done;

negative_expansion_embedded:
  a = FIO_ARRAY2EMBEDDED(ary)->embedded;
  FIO_MEMMOVE(a + index, a, count * count * sizeof(*a));
#if FIO_ARRAY_TYPE_INVALID_SIMPLE
  FIO_MEMSET(a, 0, index * (sizeof(a)));
#else
  for (size_t i = 0; i < (size_t)index; ++i) {
    FIO_ARRAY_TYPE_COPY(a[i], FIO_ARRAY_TYPE_INVALID);
  }
#endif
  index = 0;
  goto done;

invalid:
  FIO_ARRAY_TYPE_DESTROY(data);
  if (old) {
    FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY_TYPE_INVALID);
  }

  return a;
}

/**
 * Returns the index of the object or -1 if the object wasn't found.
 *
 * If `start_at` is negative (i.e., -1), than seeking will be performed in
 * reverse, where -1 == last index (-2 == second to last, etc').
 */
SFUNC int32_t FIO_NAME(FIO_ARRAY_NAME, find)(FIO_ARRAY_PTR ary_,
                                             FIO_ARRAY_TYPE data,
                                             int32_t start_at) {
  FIO_ARRAY_TYPE *a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
  if (!a)
    return -1;
  size_t count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);
  if (start_at >= 0) {
    /* seek forwards */
    if ((uint32_t)start_at >= count)
      start_at = count;
    while ((uint32_t)start_at < count) {
      if (FIO_ARRAY_TYPE_CMP(a[start_at], data))
        return start_at;
      ++start_at;
    }
  } else {
    /* seek backwards */
    if (start_at + (int32_t)count < 0)
      return -1;
    count += start_at;
    count += 1;
    while (count--) {
      if (FIO_ARRAY_TYPE_CMP(a[count], data))
        return count;
    }
  }
  return -1;
}

/**
 * Removes an object from the array, MOVING all the other objects to prevent
 * "holes" in the data.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns 0 on success and -1 on error.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, remove)(FIO_ARRAY_PTR ary_,
                                           int32_t index,
                                           FIO_ARRAY_TYPE *old) {
  FIO_ARRAY_TYPE *a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  size_t count;
  if (!a)
    goto invalid;
  count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);

  if (index < 0) {
    index += count;
    if (index < 0) {
      FIO_LOG_WARNING(
          FIO_MACRO2STR(FIO_NAME(FIO_ARRAY_NAME,
                                 remove)) " called with a negative index lower "
                                          "than the element count.");
      goto invalid;
    }
  }
  if ((uint32_t)index >= count)
    goto invalid;
  if (!index) {
    FIO_NAME(FIO_ARRAY_NAME, shift)(ary_, old);
    return 0;
  }
  if ((uint32_t)index + 1 == count) {
    FIO_NAME(FIO_ARRAY_NAME, pop)(ary_, old);
    return 0;
  }

  if (old) {
    FIO_ARRAY_TYPE_COPY(*old, a[index]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
    FIO_ARRAY_TYPE_DESTROY(a[index]);
#endif
  } else {
    FIO_ARRAY_TYPE_DESTROY(a[index]);
  }

  if ((uint32_t)(index + 1) < count) {
    FIO_MEMMOVE(a + index, a + index + 1, (count - (index + 1)) * sizeof(*a));
  }
  FIO_ARRAY_TYPE_COPY((a + (count - 1))[0], FIO_ARRAY_TYPE_INVALID);

  if (FIO_ARRAY_IS_EMBEDDED(ary))
    goto embedded;
  --ary->end;
  return 0;

embedded:
  --ary->start;
  return 0;

invalid:
  if (old) {
    FIO_ARRAY_TYPE_COPY(*old, FIO_ARRAY_TYPE_INVALID);
  }
  return -1;
}

/**
 * Removes all occurrences of an object from the array (if any), MOVING all the
 * existing objects to prevent "holes" in the data.
 *
 * Returns the number of items removed.
 */
SFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME, remove2)(FIO_ARRAY_PTR ary_,
                                                 FIO_ARRAY_TYPE data) {
  FIO_ARRAY_TYPE *a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  size_t count;
  if (!a)
    return 0;
  count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);

  size_t c = 0;
  size_t i = 0;
  while ((i + c) < count) {
    if (!(FIO_ARRAY_TYPE_CMP(a[i + c], data))) {
      a[i] = a[i + c];
      ++i;
      continue;
    }
    FIO_ARRAY_TYPE_DESTROY(a[i + c]);
    ++c;
  }
  if (c && FIO_MEM_REALLOC_IS_SAFE_) {
    /* keep memory zeroed out */
    FIO_MEMSET(a + i, 0, sizeof(*a) * c);
  }
  if (!FIO_ARRAY_IS_EMBEDDED_PTR(ary, a)) {
    ary->end = ary->start + i;
    return c;
  }
  ary->start = i;
  return c;
}

/** Attempts to lower the array's memory consumption. */
SFUNC void FIO_NAME(FIO_ARRAY_NAME, compact)(FIO_ARRAY_PTR ary_) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(ary_);
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  size_t count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);
  FIO_ARRAY_TYPE *tmp = NULL;

  if (count <= FIO_ARRAY_EMBEDDED_CAPA)
    goto re_embed;

  tmp = (FIO_ARRAY_TYPE *)
      FIO_MEM_REALLOC_(NULL, 0, (ary->end - ary->start) * sizeof(*tmp), 0);
  if (!tmp)
    return;
  FIO_MEMCPY(tmp, ary->ary + ary->start, count * sizeof(*ary->ary));
  FIO_MEM_FREE_(ary->ary, ary->capa * sizeof(*ary->ary));
  *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
      .start = 0,
      .end = (ary->end - ary->start),
      .capa = (ary->end - ary->start),
      .ary = tmp,
  };
  return;

re_embed:
  if (!FIO_ARRAY_IS_EMBEDDED(ary)) {
    tmp = ary->ary;
    uint32_t offset = ary->start;
    size_t old_capa = ary->capa;
    *ary = (FIO_NAME(FIO_ARRAY_NAME, s)){
        .start = (uint32_t)count,
    };
    if (count) {
      FIO_MEMCPY(FIO_ARRAY2EMBEDDED(ary)->embedded,
                 tmp + offset,
                 count * sizeof(*tmp));
    }
    if (tmp) {
      FIO_MEM_FREE_(tmp, sizeof(*tmp) * old_capa);
      (void)old_capa; /* if unused */
    }
  }
  return;
}
/**
 * Pushes an object to the end of the Array. Returns NULL on error.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, push)(FIO_ARRAY_PTR ary_,
                                                     FIO_ARRAY_TYPE data) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    if (ary->end == ary->capa) {
      if (!ary->start) {
        if (FIO_NAME(FIO_ARRAY_NAME,
                     reserve)(ary_, FIO_ARRAY_ADD2CAPA(ary->capa)) == ary->end)
          goto invalid;
      } else {
        const uint32_t new_start = (ary->start >> 2);
        const uint32_t count = ary->end - ary->start;
        if (count)
          FIO_MEMMOVE(ary->ary + new_start,
                      ary->ary + ary->start,
                      count * sizeof(*ary->ary));
        ary->end = count + new_start;
        ary->start = new_start;
      }
    }
    FIO_ARRAY_TYPE_COPY(ary->ary[ary->end], data);
    return ary->ary + (ary->end++);

  case 1:
    if (ary->start == FIO_ARRAY_EMBEDDED_CAPA)
      goto needs_memory_embedded;
    FIO_ARRAY_TYPE_COPY(FIO_ARRAY2EMBEDDED(ary)->embedded[ary->start], data);
    return FIO_ARRAY2EMBEDDED(ary)->embedded + (ary->start++);
  }
invalid:
  FIO_ARRAY_TYPE_DESTROY(data);
  return NULL;

needs_memory_embedded:
  if (FIO_NAME(FIO_ARRAY_NAME,
               reserve)(ary_, FIO_ARRAY_ADD2CAPA(FIO_ARRAY_EMBEDDED_CAPA)) ==
      FIO_ARRAY_EMBEDDED_CAPA)
    goto invalid;
  FIO_ARRAY_TYPE_COPY(ary->ary[ary->end], data);
  return ary->ary + (ary->end++);
}

/**
 * Removes an object from the end of the Array.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns -1 on error (Array is empty) and 0 on success.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, pop)(FIO_ARRAY_PTR ary_,
                                        FIO_ARRAY_TYPE *old) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    if (ary->end == ary->start)
      return -1;
    --ary->end;
    if (old) {
      FIO_ARRAY_TYPE_COPY(*old, ary->ary[ary->end]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(ary->ary[ary->end]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(ary->ary[ary->end]);
    }
    return 0;
  case 1:
    if (!ary->start)
      return -1;
    --ary->start;
    if (old) {
      FIO_ARRAY_TYPE_COPY(*old, FIO_ARRAY2EMBEDDED(ary)->embedded[ary->start]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(FIO_ARRAY2EMBEDDED(ary)->embedded[ary->start]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(FIO_ARRAY2EMBEDDED(ary)->embedded[ary->start]);
    }
    FIO_MEMSET(FIO_ARRAY2EMBEDDED(ary)->embedded + ary->start,
               0,
               sizeof(*ary->ary));
    return 0;
  }
  if (old)
    FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY_TYPE_INVALID);
  return -1;
}

/**
 * Unshifts an object to the beginning of the Array. Returns -1 on error.
 *
 * This could be expensive, causing `memmove`.
 */
SFUNC FIO_ARRAY_TYPE *FIO_NAME(FIO_ARRAY_NAME, unshift)(FIO_ARRAY_PTR ary_,
                                                        FIO_ARRAY_TYPE data) {
  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);
  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    if (!ary->start) {
      if (ary->end == ary->capa) {
        FIO_NAME(FIO_ARRAY_NAME, reserve)
        (ary_, (-1 - (int32_t)FIO_ARRAY_ADD2CAPA(ary->capa)));
        if (!ary->start)
          goto invalid;
      } else {
        const uint32_t new_end = ary->capa - ((ary->capa - ary->end) >> 2);
        const uint32_t count = ary->end - ary->start;
        const uint32_t new_start = new_end - count;
        if (count)
          FIO_MEMMOVE(ary->ary + new_start,
                      ary->ary + ary->start,
                      count * sizeof(*ary->ary));
        ary->end = new_end;
        ary->start = new_start;
      }
    }
    FIO_ARRAY_TYPE_COPY(ary->ary[--ary->start], data);
    return ary->ary + ary->start;

  case 1:
    if (ary->start == FIO_ARRAY_EMBEDDED_CAPA)
      goto needs_memory_embed;
    if (ary->start)
      FIO_MEMMOVE(FIO_ARRAY2EMBEDDED(ary)->embedded + 1,
                  FIO_ARRAY2EMBEDDED(ary)->embedded,
                  sizeof(*ary->ary) * ary->start);
    ++ary->start;
    FIO_ARRAY_TYPE_COPY(FIO_ARRAY2EMBEDDED(ary)->embedded[0], data);
    return FIO_ARRAY2EMBEDDED(ary)->embedded;
  }
invalid:
  FIO_ARRAY_TYPE_DESTROY(data);
  return NULL;

needs_memory_embed:
  if (FIO_NAME(FIO_ARRAY_NAME, reserve)(
          ary_,
          (-1 - (int32_t)FIO_ARRAY_ADD2CAPA(FIO_ARRAY_EMBEDDED_CAPA))) ==
      FIO_ARRAY_EMBEDDED_CAPA)
    goto invalid;
  FIO_ARRAY_TYPE_COPY(ary->ary[--ary->start], data);
  return ary->ary + ary->start;
}

/**
 * Removes an object from the beginning of the Array.
 *
 * If `old` is set, the data is copied to the location pointed to by `old`
 * before the data in the array is destroyed.
 *
 * Returns -1 on error (Array is empty) and 0 on success.
 */
SFUNC int FIO_NAME(FIO_ARRAY_NAME, shift)(FIO_ARRAY_PTR ary_,
                                          FIO_ARRAY_TYPE *old) {

  FIO_NAME(FIO_ARRAY_NAME, s) *ary =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_ARRAY_NAME, s), ary_);

  switch (FIO_NAME_BL(FIO_ARRAY_NAME, embedded)(ary_)) {
  case 0:
    if (ary->end == ary->start)
      return -1;
    if (old) {
      FIO_ARRAY_TYPE_COPY(*old, ary->ary[ary->start]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(ary->ary[ary->start]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(ary->ary[ary->start]);
    }
    ++ary->start;
    return 0;
  case 1:
    if (!ary->start)
      return -1;
    if (old) {
      FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY2EMBEDDED(ary)->embedded[0]);
#if FIO_ARRAY_DESTROY_AFTER_COPY
      FIO_ARRAY_TYPE_DESTROY(FIO_ARRAY2EMBEDDED(ary)->embedded[0]);
#endif
    } else {
      FIO_ARRAY_TYPE_DESTROY(FIO_ARRAY2EMBEDDED(ary)->embedded[0]);
    }
    --ary->start;
    if (ary->start)
      FIO_MEMMOVE(FIO_ARRAY2EMBEDDED(ary)->embedded,
                  FIO_ARRAY2EMBEDDED(ary)->embedded +
                      FIO_ARRAY2EMBEDDED(ary)->start,
                  FIO_ARRAY2EMBEDDED(ary)->start *
                      sizeof(*FIO_ARRAY2EMBEDDED(ary)->embedded));
    FIO_MEMSET(FIO_ARRAY2EMBEDDED(ary)->embedded + ary->start,
               0,
               sizeof(*ary->ary));
    return 0;
  }
  if (old)
    FIO_ARRAY_TYPE_COPY(old[0], FIO_ARRAY_TYPE_INVALID);
  return -1;
}

/**
 * Iteration using a callback for each entry in the array.
 *
 * The callback task function must accept an the entry data as well as an opaque
 * user pointer.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
IFUNC uint32_t FIO_NAME(FIO_ARRAY_NAME,
                        each)(FIO_ARRAY_PTR ary_,
                              int (*task)(FIO_NAME(FIO_ARRAY_NAME, each_s) *
                                          info),
                              void *udata,
                              int32_t start_at) {
  FIO_ARRAY_TYPE *a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
  if (!a)
    return (uint32_t)-1;

  uint32_t count = FIO_NAME(FIO_ARRAY_NAME, count)(ary_);

  if (start_at < 0) {
    start_at = count - start_at;
    if (start_at < 0)
      start_at = 0;
  }

  if (!a || !task)
    return (uint32_t)-1;

  if ((uint32_t)start_at >= count)
    return count;

  FIO_NAME(FIO_ARRAY_NAME, each_s)
  e = {
      .parent = ary_,
      .index = (uint64_t)start_at,
      .task = task,
      .udata = udata,
  };

  while ((uint32_t)e.index < FIO_NAME(FIO_ARRAY_NAME, count)(ary_)) {
    a = FIO_NAME2(FIO_ARRAY_NAME, ptr)(ary_);
    e.value = a[e.index];
    int r = e.task(&e);
    ++e.index;
    if (r == -1) {
      return (uint32_t)(e.index);
    }
  }
  return e.index;
}

/* *****************************************************************************
Dynamic Arrays - test
***************************************************************************** */
#ifdef FIO_TEST_CSTL

/* make suer the functions are defined for the testing */
#ifdef FIO_REF_CONSTRUCTOR_ONLY
IFUNC FIO_ARRAY_PTR FIO_NAME(FIO_ARRAY_NAME, new)(void);
IFUNC void FIO_NAME(FIO_ARRAY_NAME, free)(FIO_ARRAY_PTR ary);
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

#define FIO_ARRAY_TEST_OBJ_SET(dest, val)                                      \
  FIO_MEMSET(&(dest), (int)(val), sizeof(FIO_ARRAY_TYPE))
#define FIO_ARRAY_TEST_OBJ_IS(val)                                             \
  (!FIO_MEMCMP(&o,                                                             \
               FIO_MEMSET(&v, (int)(val), sizeof(v)),                          \
               sizeof(FIO_ARRAY_TYPE)))

FIO_SFUNC int FIO_NAME_TEST(stl, FIO_NAME(FIO_ARRAY_NAME, test_task))(
    FIO_NAME(FIO_ARRAY_NAME, each_s) * i) {
  struct data_s {
    int i;
    int va[];
  } *d = (struct data_s *)i->udata;
  FIO_ARRAY_TYPE v;

  FIO_ARRAY_TEST_OBJ_SET(v, d->va[d->i]);
  ++d->i;
  if (d->va[d->i + 1])
    return 0;
  return -1;
}

FIO_SFUNC void FIO_NAME_TEST(stl, FIO_ARRAY_NAME)(void) {
  FIO_ARRAY_TYPE o;
  FIO_ARRAY_TYPE v;
  FIO_NAME(FIO_ARRAY_NAME, s) a_on_stack = FIO_ARRAY_INIT;
  FIO_ARRAY_PTR a_array[2];
  a_array[0] = (FIO_ARRAY_PTR)FIO_PTR_TAG((&a_on_stack));
  a_array[1] = FIO_NAME(FIO_ARRAY_NAME, new)();
  FIO_ASSERT_ALLOC(a_array[1]);
  /* perform test twice, once for an array on the stack and once for allocate */
  for (int selector = 0; selector < 2; ++selector) {
    FIO_ARRAY_PTR a = a_array[selector];
    fprintf(stderr,
            "* Testing dynamic arrays on the %s (" FIO_MACRO2STR(
                FIO_NAME(FIO_ARRAY_NAME,
                         s)) ").\n"
                             "  This type supports %zu embedded items\n",
            (selector ? "heap" : "stack"),
            FIO_ARRAY_EMBEDDED_CAPA);
    /* Test start here */

    /* test push */
    for (int i = 0; i < (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3; ++i) {
      FIO_ARRAY_TEST_OBJ_SET(o, (i + 1));
      o = *FIO_NAME(FIO_ARRAY_NAME, push)(a, o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1), "push failed (%d)", i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, i);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1), "push-get cycle failed (%d)", i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, -1);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1),
                 "get with -1 returned wrong result (%d)",
                 i);
    }
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   FIO_ARRAY_EMBEDDED_CAPA + 3,
               "push didn't update count correctly (%d != %d)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a),
               (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3);

    /* test pop */
    for (int i = (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3; i--;) {
      FIO_NAME(FIO_ARRAY_NAME, pop)(a, &o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS((i + 1)),
                 "pop value error failed (%d)",
                 i);
    }
    FIO_ASSERT(!FIO_NAME(FIO_ARRAY_NAME, count)(a),
               "pop didn't pop all elements?");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, pop)(a, &o),
               "pop for empty array should return an error.");

    /* test compact with zero elements */
    FIO_NAME(FIO_ARRAY_NAME, compact)(a);
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) == FIO_ARRAY_EMBEDDED_CAPA,
               "compact zero elementes didn't make array embedded?");

    /* test unshift */
    for (int i = (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3; i--;) {
      FIO_ARRAY_TEST_OBJ_SET(o, (i + 1));
      o = *FIO_NAME(FIO_ARRAY_NAME, unshift)(a, o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1), "shift failed (%d)", i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, 0);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1),
                 "unshift-get cycle failed (%d)",
                 i);
      int32_t negative_index = 0 - (((int)(FIO_ARRAY_EMBEDDED_CAPA) + 3) - i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, negative_index);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1),
                 "get with %d returned wrong result.",
                 negative_index);
    }
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   FIO_ARRAY_EMBEDDED_CAPA + 3,
               "unshift didn't update count correctly (%d != %d)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a),
               (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3);

    /* test shift */
    for (int i = 0; i < (int)(FIO_ARRAY_EMBEDDED_CAPA) + 3; ++i) {
      FIO_NAME(FIO_ARRAY_NAME, shift)(a, &o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS((i + 1)),
                 "shift value error failed (%d)",
                 i);
    }
    FIO_ASSERT(!FIO_NAME(FIO_ARRAY_NAME, count)(a),
               "shift didn't shift all elements?");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, shift)(a, &o),
               "shift for empty array should return an error.");

    /* test set from embedded? array */
    FIO_NAME(FIO_ARRAY_NAME, compact)(a);
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) == FIO_ARRAY_EMBEDDED_CAPA,
               "compact zero elementes didn't make array embedded (2)?");
    FIO_ARRAY_TEST_OBJ_SET(o, 1);
    FIO_NAME(FIO_ARRAY_NAME, push)(a, o);
    if (FIO_ARRAY_EMBEDDED_CAPA) {
      FIO_ARRAY_TEST_OBJ_SET(o, 1);
      FIO_NAME(FIO_ARRAY_NAME, set)(a, FIO_ARRAY_EMBEDDED_CAPA, o, &o);
      FIO_ASSERT(FIO_ARRAY_TYPE_CMP(o, FIO_ARRAY_TYPE_INVALID),
                 "set overflow from embedded array should reset `old`");
      FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                     FIO_ARRAY_EMBEDDED_CAPA + 1,
                 "set didn't update count correctly from embedded "
                 "array (%d != %d)",
                 FIO_NAME(FIO_ARRAY_NAME, count)(a),
                 (int)FIO_ARRAY_EMBEDDED_CAPA);
    }

    /* test set from bigger array */
    FIO_ARRAY_TEST_OBJ_SET(o, 1);
    FIO_NAME(FIO_ARRAY_NAME, set)
    (a, ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4), o, &o);
    FIO_ASSERT(FIO_ARRAY_TYPE_CMP(o, FIO_ARRAY_TYPE_INVALID),
               "set overflow should reset `old`");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "set didn't update count correctly (%d != %d)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a),
               (int)((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4));
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) >=
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4),
               "set capa should be above item count");
    if (FIO_ARRAY_EMBEDDED_CAPA) {
      FIO_ARRAY_TYPE_COPY(o, FIO_ARRAY_TYPE_INVALID);
      FIO_NAME(FIO_ARRAY_NAME, set)(a, FIO_ARRAY_EMBEDDED_CAPA, o, &o);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(1),
                 "set overflow lost last item while growing.");
    }
    o = FIO_NAME(FIO_ARRAY_NAME, get)(a, (FIO_ARRAY_EMBEDDED_CAPA + 1) * 2);
    FIO_ASSERT(FIO_ARRAY_TYPE_CMP(o, FIO_ARRAY_TYPE_INVALID),
               "set overflow should have memory in the middle set to invalid "
               "objetcs.");
    FIO_ARRAY_TEST_OBJ_SET(o, 2);
    FIO_NAME(FIO_ARRAY_NAME, set)(a, 0, o, &o);
    FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(1),
               "set should set `old` to previous value");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "set item count error");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) >=
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "set capa should be above item count");

    /* test find TODO: test with uninitialized array */
    FIO_ARRAY_TEST_OBJ_SET(o, 99);
    if (FIO_ARRAY_TYPE_CMP(o, FIO_ARRAY_TYPE_INVALID)) {
      FIO_ARRAY_TEST_OBJ_SET(o, 100);
    }
    int found = FIO_NAME(FIO_ARRAY_NAME, find)(a, o, 0);
    FIO_ASSERT(found == -1,
               "seeking for an object that doesn't exist should fail.");
    FIO_ARRAY_TEST_OBJ_SET(o, 1);
    found = FIO_NAME(FIO_ARRAY_NAME, find)(a, o, 1);
    FIO_ASSERT(found == ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4),
               "seeking for an object returned the wrong index.");
    FIO_ASSERT(found == FIO_NAME(FIO_ARRAY_NAME, find)(a, o, -1),
               "seeking for an object in reverse returned the wrong index.");
    FIO_ARRAY_TEST_OBJ_SET(o, 2);
    FIO_ASSERT(
        !FIO_NAME(FIO_ARRAY_NAME, find)(a, o, -2),
        "seeking for an object in reverse (2) returned the wrong index.");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "find should have side-effects - count error");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) >=
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) + 1,
               "find should have side-effects - capa error");

    /* test remove */
    FIO_NAME(FIO_ARRAY_NAME, remove)(a, found, &o);
    FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(1), "remove didn't copy old data?");
    o = FIO_NAME(FIO_ARRAY_NAME, get)(a, 0);
    FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(2), "remove removed more?");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4),
               "remove with didn't update count correctly (%d != %s)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a),
               (int)((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4));
    o = FIO_NAME(FIO_ARRAY_NAME, get)(a, -1);

    /* test remove2 */
    FIO_ARRAY_TYPE_COPY(o, FIO_ARRAY_TYPE_INVALID);
    FIO_ASSERT((found = FIO_NAME(FIO_ARRAY_NAME, remove2)(a, o)) ==
                   ((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) - 1,
               "remove2 result error, %d != %d items.",
               found,
               (int)((FIO_ARRAY_EMBEDDED_CAPA + 1) * 4) - 1);
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) == 1,
               "remove2 didn't update count correctly (%d != 1)",
               FIO_NAME(FIO_ARRAY_NAME, count)(a));

    /* hopefuly these will end... or crash on error. */
    while (!FIO_NAME(FIO_ARRAY_NAME, pop)(a, NULL)) {
      ;
    }
    while (!FIO_NAME(FIO_ARRAY_NAME, shift)(a, NULL)) {
      ;
    }

    /* test push / unshift alternate */
    FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
    for (int i = 0; i < 4096; ++i) {
      FIO_ARRAY_TEST_OBJ_SET(o, (i + 1));
      FIO_NAME(FIO_ARRAY_NAME, push)(a, o);
      FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) + 1 ==
                     ((uint32_t)(i + 1) << 1),
                 "push-unshift[%d.5] cycle count arror (%d != %d)",
                 i,
                 FIO_NAME(FIO_ARRAY_NAME, count)(a),
                 (((uint32_t)(i + 1) << 1)) - 1);
      FIO_ARRAY_TEST_OBJ_SET(o, (i + 4097));
      FIO_NAME(FIO_ARRAY_NAME, unshift)(a, o);
      FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, count)(a) == ((uint32_t)(i + 1) << 1),
                 "push-unshift[%d] cycle count arror (%d != %d)",
                 i,
                 FIO_NAME(FIO_ARRAY_NAME, count)(a),
                 ((uint32_t)(i + 1) << 1));
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, 0);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 4097),
                 "unshift-push cycle failed (%d)",
                 i);
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, -1);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS(i + 1),
                 "push-shift cycle failed (%d)",
                 i);
    }
    for (int i = 0; i < 4096; ++i) {
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, i);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS((4096 * 2) - i),
                 "item value error at index %d",
                 i);
    }
    for (int i = 0; i < 4096; ++i) {
      o = FIO_NAME(FIO_ARRAY_NAME, get)(a, i + 4096);
      FIO_ASSERT(FIO_ARRAY_TEST_OBJ_IS((1 + i)),
                 "item value error at index %d",
                 i + 4096);
    }
#if DEBUG
    for (int i = 0; i < 2; ++i) {
      FIO_LOG_DEBUG2(
          "\t- " FIO_MACRO2STR(
              FIO_NAME(FIO_ARRAY_NAME, s)) " after push/unshit cycle%s:\n"
                                           "\t\t- item count: %d items\n"
                                           "\t\t- capacity:   %d items\n"
                                           "\t\t- memory:     %d bytes\n",
          (i ? " after compact" : ""),
          FIO_NAME(FIO_ARRAY_NAME, count)(a),
          FIO_NAME(FIO_ARRAY_NAME, capa)(a),
          FIO_NAME(FIO_ARRAY_NAME, capa)(a) * sizeof(FIO_ARRAY_TYPE));
      FIO_NAME(FIO_ARRAY_NAME, compact)(a);
    }
#endif /* DEBUG */

    FIO_ARRAY_TYPE_COPY(o, FIO_ARRAY_TYPE_INVALID);
/* test set with NULL, hopefully a bug will cause a crash */
#if FIO_ARRAY_TYPE_DESTROY_SIMPLE
    for (int i = 0; i < 4096; ++i) {
      FIO_NAME(FIO_ARRAY_NAME, set)(a, i, o, NULL);
    }
#else
    /*
     * we need to clear the memory to make sure a cleanup actions don't get
     * unexpected values.
     */
    for (int i = 0; i < (4096 * 2); ++i) {
      FIO_ARRAY_TYPE_COPY((FIO_NAME2(FIO_ARRAY_NAME, ptr)(a)[i]),
                          FIO_ARRAY_TYPE_INVALID);
    }

#endif

    /* TODO: test concat */

    /* test each */
    {
      struct data_s {
        int i;
        int va[10];
      } d = {1, {1, 8, 2, 7, 3, 6, 4, 5}};
      FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
      for (int i = 0; d.va[i]; ++i) {
        FIO_ARRAY_TEST_OBJ_SET(o, d.va[i]);
        FIO_NAME(FIO_ARRAY_NAME, push)(a, o);
      }

      int index = FIO_NAME(FIO_ARRAY_NAME, each)(
          a,
          FIO_NAME_TEST(stl, FIO_NAME(FIO_ARRAY_NAME, test_task)),
          (void *)&d,
          d.i);
      FIO_ASSERT(index == d.i,
                 "index rerturned from each should match next object");
      FIO_ASSERT(*(char *)&d.va[d.i],
                 "array each error (didn't stop in time?).");
      FIO_ASSERT(!(*(char *)&d.va[d.i + 1]),
                 "array each error (didn't stop in time?).");
    }
#if FIO_ARRAY_TYPE_DESTROY_SIMPLE
    {
      FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
      size_t max_items = 63;
      FIO_ARRAY_TYPE tmp[64];
      for (size_t i = 0; i < max_items; ++i) {
        FIO_MEMSET(tmp + i, i + 1, sizeof(*tmp));
      }
      for (size_t items = 0; items <= max_items; items = ((items << 1) | 1)) {
        FIO_LOG_DEBUG2("* testing the FIO_ARRAY_EACH macro with %zu items.",
                       items);
        size_t i = 0;
        for (i = 0; i < items; ++i)
          FIO_NAME(FIO_ARRAY_NAME, push)(a, tmp[i]);
        i = 0;
        FIO_ARRAY_EACH(FIO_ARRAY_NAME, a, pos) {
          FIO_ASSERT(!memcmp(tmp + i, pos, sizeof(*pos)),
                     "FIO_ARRAY_EACH pos is at wrong index %zu != %zu",
                     (size_t)(pos - FIO_NAME2(FIO_ARRAY_NAME, ptr)(a)),
                     i);
          ++i;
        }
        FIO_ASSERT(i == items,
                   "FIO_ARRAY_EACH macro count error - didn't review all "
                   "items? %zu != %zu ",
                   i,
                   items);
        FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
      }
    }
#endif
    /* test destroy */
    FIO_NAME(FIO_ARRAY_NAME, destroy)(a);
    FIO_ASSERT(!FIO_NAME(FIO_ARRAY_NAME, count)(a),
               "destroy didn't clear count.");
    FIO_ASSERT(FIO_NAME(FIO_ARRAY_NAME, capa)(a) == FIO_ARRAY_EMBEDDED_CAPA,
               "destroy capa error.");
    /* Test end here */
  }
  FIO_NAME(FIO_ARRAY_NAME, free)(a_array[1]);
}
#undef FIO_ARRAY_TEST_OBJ_SET
#undef FIO_ARRAY_TEST_OBJ_IS

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Dynamic Arrays - cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_ARRAY_NAME */

#undef FIO_ARRAY_NAME
#undef FIO_ARRAY_TYPE
#undef FIO_ARRAY_ENABLE_EMBEDDED
#undef FIO_ARRAY_TYPE_INVALID
#undef FIO_ARRAY_TYPE_INVALID_SIMPLE
#undef FIO_ARRAY_TYPE_COPY
#undef FIO_ARRAY_TYPE_COPY_SIMPLE
#undef FIO_ARRAY_TYPE_CONCAT_COPY
#undef FIO_ARRAY_TYPE_CONCAT_COPY_SIMPLE
#undef FIO_ARRAY_TYPE_DESTROY
#undef FIO_ARRAY_TYPE_DESTROY_SIMPLE
#undef FIO_ARRAY_DESTROY_AFTER_COPY
#undef FIO_ARRAY_TYPE_CMP
#undef FIO_ARRAY_TYPE_CMP_SIMPLE
#undef FIO_ARRAY_PADDING
#undef FIO_ARRAY_SIZE2WORDS
#undef FIO_ARRAY_POS2ABS
#undef FIO_ARRAY_AB_CT
#undef FIO_ARRAY_PTR
#undef FIO_ARRAY_EXPONENTIAL
#undef FIO_ARRAY_ADD2CAPA
#undef FIO_ARRAY_IS_EMBEDDED
#undef FIO_ARRAY_IS_EMBEDDED_PTR
#undef FIO_ARRAY_EMBEDDED_CAPA
#undef FIO_ARRAY2EMBEDDED
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___        /* Development inclusion - ignore line */
#define FIO_MAP_NAME map    /* Development inclusion - ignore line */
#define FIO_MAP_TEST        /* Development inclusion - ignore line */
#define FIO_MAP_KEY  size_t /* Development inclusion - ignore line */
#include "./include.h"      /* Development inclusion - ignore line */
#endif                      /* Development inclusion - ignore line */
/* *****************************************************************************




                  Unordered/Ordered Map Implementation



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_UMAP_NAME)
#define FIO_MAP_NAME FIO_UMAP_NAME
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 0
#elif defined(FIO_OMAP_NAME)
#define FIO_MAP_NAME FIO_OMAP_NAME
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 1
#endif

#if defined(FIO_MAP_NAME)
/* *****************************************************************************
Map Settings - Sets have only keys (value == key) - Hash Maps have values
***************************************************************************** */

/* if FIO_MAP_KEY_KSTR is defined, use fio_keystr_s keys */
#ifdef FIO_MAP_KEY_KSTR
#define FIO_MAP_KEY                  fio_str_info_s
#define FIO_MAP_KEY_INTERNAL         fio_keystr_s
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_keystr_info(&(k))
#define FIO_MAP_KEY_COPY(dest, src)                                            \
  (dest) = fio_keystr_copy((src), FIO_NAME(FIO_MAP_NAME, __key_alloc))
#define FIO_MAP_KEY_CMP(a, b) fio_keystr_is_eq2((a), (b))
#define FIO_MAP_KEY_DESTROY(key)                                               \
  fio_keystr_destroy(&(key), FIO_NAME(FIO_MAP_NAME, __key_free))
#define FIO_MAP_KEY_DISCARD(key)
FIO_SFUNC void *FIO_NAME(FIO_MAP_NAME, __key_alloc)(size_t len) {
  return FIO_MEM_REALLOC_(NULL, 0, len, 0);
}
FIO_SFUNC void FIO_NAME(FIO_MAP_NAME, __key_free)(void *ptr, size_t len) {
  FIO_MEM_FREE_(ptr, len);
  (void)len; /* if unused */
}
#undef FIO_MAP_KEY_KSTR

/* if FIO_MAP_KEY is undefined, assume String keys (using `fio_bstr`). */
#elif !defined(FIO_MAP_KEY) || defined(FIO_MAP_KEY_BSTR)
#define FIO_MAP_KEY                  fio_str_info_s
#define FIO_MAP_KEY_INTERNAL         char *
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_bstr_info((k))
#define FIO_MAP_KEY_COPY(dest, src)                                            \
  (dest) = fio_bstr_write(NULL, (src).buf, (src).len)
#define FIO_MAP_KEY_CMP(a, b)    fio_bstr_is_eq2info((a), (b))
#define FIO_MAP_KEY_DESTROY(key) fio_bstr_free((key))
#define FIO_MAP_KEY_DISCARD(key)
#endif
#undef FIO_MAP_KEY_BSTR

#ifndef FIO_MAP_KEY_INTERNAL
#define FIO_MAP_KEY_INTERNAL FIO_MAP_KEY
#endif

#ifndef FIO_MAP_KEY_FROM_INTERNAL
#define FIO_MAP_KEY_FROM_INTERNAL(o) o
#endif

#ifndef FIO_MAP_KEY_COPY
#define FIO_MAP_KEY_COPY(dest, src) (dest) = (src)
#endif

#ifndef FIO_MAP_KEY_CMP
#define FIO_MAP_KEY_CMP(a, b) (a) == (b)
#endif

#ifndef FIO_MAP_KEY_DESTROY
#define FIO_MAP_KEY_DESTROY(o)
#define FIO_MAP_KEY_DESTROY_SIMPLE 1
#endif

#ifndef FIO_MAP_KEY_DISCARD
#define FIO_MAP_KEY_DISCARD(o)
#endif

/* FIO_MAP_HASH_FN(key) - used instead of providing a hash value. */
#ifndef FIO_MAP_HASH_FN
#undef FIO_MAP_RECALC_HASH
#endif

/* FIO_MAP_RECALC_HASH - if true, hash values won't be cached. */
#ifndef FIO_MAP_RECALC_HASH
#define FIO_MAP_RECALC_HASH 0
#endif

#ifdef FIO_MAP_VALUE_BSTR
#define FIO_MAP_VALUE                  fio_str_info_s
#define FIO_MAP_VALUE_INTERNAL         char *
#define FIO_MAP_VALUE_FROM_INTERNAL(v) fio_bstr_info((v))
#define FIO_MAP_VALUE_COPY(dest, src)                                          \
  (dest) = fio_bstr_write(NULL, (src).buf, (src).len)
#define FIO_MAP_VALUE_DESTROY(v) fio_bstr_free((v))
#define FIO_MAP_VALUE_DISCARD(v)
#endif

#ifdef FIO_MAP_VALUE
#define FIO_MAP_GET_T FIO_MAP_VALUE
#else
#define FIO_MAP_GET_T FIO_MAP_KEY
#endif

#ifndef FIO_MAP_VALUE_INTERNAL
#define FIO_MAP_VALUE_INTERNAL FIO_MAP_VALUE
#endif

#ifndef FIO_MAP_VALUE_FROM_INTERNAL
#ifdef FIO_MAP_VALUE
#define FIO_MAP_VALUE_FROM_INTERNAL(o) o
#else
#define FIO_MAP_VALUE_FROM_INTERNAL(o)
#endif
#endif

#ifndef FIO_MAP_VALUE_COPY
#ifdef FIO_MAP_VALUE
#define FIO_MAP_VALUE_COPY(dest, src) (dest) = (src)
#else
#define FIO_MAP_VALUE_COPY(dest, src)
#endif
#endif

#ifndef FIO_MAP_VALUE_DESTROY
#define FIO_MAP_VALUE_DESTROY(o)
#define FIO_MAP_VALUE_DESTROY_SIMPLE 1
#endif

#ifndef FIO_MAP_VALUE_DISCARD
#define FIO_MAP_VALUE_DISCARD(o)
#endif

#ifdef FIO_MAP_LRU
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 1 /* required for least recently used order */
#endif

/* test if FIO_MAP_ORDERED was defined as an empty macro */
#if defined(FIO_MAP_ORDERED) && ((0 - FIO_MAP_ORDERED - 1) == 1)
#undef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 1 /* assume developer's intention */
#endif

#ifndef FIO_MAP_ORDERED
#define FIO_MAP_ORDERED 0
#endif

/* *****************************************************************************
Pointer Tagging Support
***************************************************************************** */

#ifdef FIO_PTR_TAG_TYPE
#define FIO_MAP_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_MAP_PTR FIO_NAME(FIO_MAP_NAME, s) *
#endif
#define FIO_MAP_T FIO_NAME(FIO_MAP_NAME, s)

/* *****************************************************************************
Map Types
***************************************************************************** */

/** internal object data representation */
typedef struct FIO_NAME(FIO_MAP_NAME, node_s) FIO_NAME(FIO_MAP_NAME, node_s);

/** A Hash Map / Set type */
typedef struct FIO_NAME(FIO_MAP_NAME, s) {
  uint32_t bits;
  uint32_t count;
  FIO_NAME(FIO_MAP_NAME, node_s) * map;
#if FIO_MAP_ORDERED
  FIO_INDEXED_LIST32_HEAD head;
#endif
} FIO_NAME(FIO_MAP_NAME, s);

/** internal object data representation */
struct FIO_NAME(FIO_MAP_NAME, node_s) {
#if !FIO_MAP_RECALC_HASH
  uint64_t hash;
#endif
  FIO_MAP_KEY_INTERNAL key;
#ifdef FIO_MAP_VALUE
  FIO_MAP_VALUE_INTERNAL value;
#endif
#if FIO_MAP_ORDERED
  FIO_INDEXED_LIST32_NODE node;
#endif
};

/** Map iterator type */
typedef struct {
  /** the key in the current position */
  FIO_MAP_KEY key;
#ifdef FIO_MAP_VALUE
  /** the value in the current position */
  FIO_MAP_VALUE value;
#endif
#if !FIO_MAP_RECALC_HASH
  /** the hash for the current position */
  uint64_t hash;
#endif
  struct {                   /* internal usage, do not access */
    uint32_t index;          /* the index in the internal map */
    uint32_t pos;            /* the position in the ordering scheme */
    uintptr_t map_validator; /* map mutation guard */
  } private_;
} FIO_NAME(FIO_MAP_NAME, iterator_s);

#ifndef FIO_MAP_INIT
/* Initialization macro. */
#define FIO_MAP_INIT                                                           \
  { 0 }
#define FIO_MAP_INIT                                                           \
  { 0 }
#endif

/* *****************************************************************************
Construction / Deconstruction
***************************************************************************** */

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY

/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC FIO_MAP_PTR FIO_NAME(FIO_MAP_NAME, new)(void);

/* Frees any internal data AND the object's container! */
FIO_IFUNC void FIO_NAME(FIO_MAP_NAME, free)(FIO_MAP_PTR map);

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/** Destroys the object, reinitializing its container. */
SFUNC void FIO_NAME(FIO_MAP_NAME, destroy)(FIO_MAP_PTR map);

/* *****************************************************************************
Map State
***************************************************************************** */

/** Theoretical map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME, capa)(FIO_MAP_PTR map);

/** The number of objects in the map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME, count)(FIO_MAP_PTR map);

/** Reserves at minimum the capacity requested. */
SFUNC void FIO_NAME(FIO_MAP_NAME, reserve)(FIO_MAP_PTR map, size_t capa);

/** Returns the key value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP_KEY FIO_NAME(FIO_MAP_NAME,
                               node2key)(FIO_NAME(FIO_MAP_NAME, node_s) * node);

/** Returns the hash value associated with the node's pointer (see set_ptr). */
FIO_IFUNC uint64_t FIO_NAME(FIO_MAP_NAME,
                            node2hash)(FIO_NAME(FIO_MAP_NAME, node_s) * node);

#ifdef FIO_MAP_VALUE
/** Returns the value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP_VALUE FIO_NAME(FIO_MAP_NAME,
                                 node2val)(FIO_NAME(FIO_MAP_NAME, node_s) *
                                           node);
#endif

/** Returns the key value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP_KEY_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2key_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node);

#ifdef FIO_MAP_VALUE
/** Returns the value associated with the node's pointer (see set_ptr). */
FIO_IFUNC FIO_MAP_VALUE_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2val_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node);
#endif

/* *****************************************************************************
Adding / Removing Elements from the Map
***************************************************************************** */

/** Removes an object in the map, returning a pointer to the map data. */
SFUNC int FIO_NAME(FIO_MAP_NAME, remove)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                         uint64_t hash,
#endif
                                         FIO_MAP_KEY key,
#ifdef FIO_MAP_VALUE
                                         FIO_MAP_VALUE_INTERNAL *old
#else
                                         FIO_MAP_KEY_INTERNAL *old
#endif
);

/** Evicts elements in order least recently used (LRU), FIFO or undefined. */
SFUNC void FIO_NAME(FIO_MAP_NAME, evict)(FIO_MAP_PTR map,
                                         size_t number_of_elements);

/** Removes all objects from the map, without releasing the map's resources. */
SFUNC void FIO_NAME(FIO_MAP_NAME, clear)(FIO_MAP_PTR map);

/** Attempts to minimize memory use. */
SFUNC void FIO_NAME(FIO_MAP_NAME, compact)(FIO_MAP_PTR map);

/** Gets a value from the map, if exists. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, get)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                    uint64_t hash,
#endif
                                                    FIO_MAP_KEY key);

/** Sets a value in the map, hash maps will overwrite existing data if any. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, set)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                    uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                                                    FIO_MAP_KEY key,
                                                    FIO_MAP_VALUE obj,
                                                    FIO_MAP_VALUE_INTERNAL *old
#else
                                                    FIO_MAP_KEY key
#endif
);

/** Sets a value in the map if not set previously. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, set_if_missing)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                               uint64_t hash,
#endif
                                                               FIO_MAP_KEY key
#ifdef FIO_MAP_VALUE
                                                               ,
                                                               FIO_MAP_VALUE obj
#endif
);

/**
 * The core set function.
 *
 * This function returns `NULL` on error (errors are logged).
 *
 * If the map is a hash map, overwriting the value (while keeping the key) is
 * possible. In this case the `old` pointer is optional, and if set than the old
 * data will be copied to over during an overwrite.
 *
 * NOTE: the function returns a pointer to the map's internal storage.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME, set_ptr)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                    uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                                    FIO_MAP_KEY key,
                                    FIO_MAP_VALUE val,
                                    FIO_MAP_VALUE_INTERNAL *old,
                                    int overwrite
#else
                                    FIO_MAP_KEY key
#endif
    );

/**
 * The core get function. This function returns NULL if item is missing.
 *
 * NOTE: the function returns a pointer to the map's internal storage.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME, get_ptr)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                    uint64_t hash,
#endif
                                    FIO_MAP_KEY key);
/* *****************************************************************************
Map Iteration and Traversal
***************************************************************************** */

/**
 * Returns the next iterator object after `current_pos` or the first if `NULL`.
 *
 * Note that adding objects to the map or rehashing between iterations could
 * incur performance penalties when re-setting and re-seeking the previous
 * iterator position.
 *
 * Adding objects to, or rehashing, an unordered maps could invalidate the
 * iterator object completely as the ordering may have changed and so the "next"
 * object might be any object in the map.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, iterator_s)
    FIO_NAME(FIO_MAP_NAME,
             get_next)(FIO_MAP_PTR map,
                       FIO_NAME(FIO_MAP_NAME, iterator_s) * current_pos);

/**
 * Returns the next iterator object after `current_pos` or the last if `NULL`.
 *
 * See notes in `get_next`.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, iterator_s)
    FIO_NAME(FIO_MAP_NAME,
             get_prev)(FIO_MAP_PTR map,
                       FIO_NAME(FIO_MAP_NAME, iterator_s) * current_pos);

/** Returns 1 if the iterator is out of bounds, otherwise returns 0. */
FIO_IFUNC int FIO_NAME(FIO_MAP_NAME,
                       iterator_is_valid)(FIO_NAME(FIO_MAP_NAME, iterator_s) *
                                          iterator);

/** Returns a pointer to the node object in the internal map. */
FIO_IFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME,
             iterator2node)(FIO_MAP_PTR map,
                            FIO_NAME(FIO_MAP_NAME, iterator_s) * iterator);

#ifndef FIO_MAP_EACH
/** Iterates through the map using an iterator object. */
#define FIO_MAP_EACH(map_name, map_ptr, i)                                     \
  for (FIO_NAME(map_name, iterator_s)                                          \
           i = FIO_NAME(map_name, get_next)(map_ptr, NULL);                    \
       FIO_NAME(map_name, iterator_is_valid)(&i);                              \
       i = FIO_NAME(map_name, get_next)(map_ptr, &i))
/** Iterates through the map using an iterator object. */
#define FIO_MAP_EACH_REVERSED(map_name, map_ptr, i)                            \
  for (FIO_NAME(map_name, iterator_s)                                          \
           i = FIO_NAME(map_name, get_prev)(map_ptr, NULL);                    \
       FIO_NAME(map_name, iterator_is_valid)(&i);                              \
       i = FIO_NAME(map_name, get_prev)(map_ptr, &i))
#endif

/** Iteration information structure passed to the callback. */
typedef struct FIO_NAME(FIO_MAP_NAME, each_s) {
  /** The being iterated. Once set, cannot be safely changed. */
  FIO_MAP_PTR const parent;
  /** The current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct FIO_NAME(FIO_MAP_NAME, each_s) * info);
  /** Opaque user data. */
  void *udata;
#ifdef FIO_MAP_VALUE
  /** The object's value at the current index. */
  FIO_MAP_VALUE value;
#endif
  /** The object's key the current index. */
  FIO_MAP_KEY key;
} FIO_NAME(FIO_MAP_NAME, each_s);

/**
 * Iteration using a callback for each element in the map.
 *
 * The callback task function must accept an each_s pointer, see above.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
SFUNC uint32_t FIO_NAME(FIO_MAP_NAME,
                        each)(FIO_MAP_PTR map,
                              int (*task)(FIO_NAME(FIO_MAP_NAME, each_s) *),
                              void *udata,
                              ssize_t start_at);

/* *****************************************************************************
Optional Sorting Support - TODO? (convert to array, sort, rehash)
***************************************************************************** */

#if defined(FIO_MAP_KEY_IS_GREATER_THAN) && !defined(FIO_SORT_TYPE) &&         \
    FIO_MAP_ORDERED
#undef FIO_SORT_NAME
#endif

/* *****************************************************************************
Map Implementation - inlined static functions
***************************************************************************** */

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY
/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC FIO_MAP_PTR FIO_NAME(FIO_MAP_NAME, new)(void) {
  FIO_NAME(FIO_MAP_NAME, s) *o =
      (FIO_NAME(FIO_MAP_NAME, s) *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*o), 0);
  if (!o)
    return (FIO_MAP_PTR)NULL;
  *o = (FIO_NAME(FIO_MAP_NAME, s))FIO_MAP_INIT;
  return (FIO_MAP_PTR)FIO_PTR_TAG(o);
}
/* Frees any internal data AND the object's container! */
FIO_IFUNC void FIO_NAME(FIO_MAP_NAME, free)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, destroy)(map);
  FIO_NAME(FIO_MAP_NAME, s) *o =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_MAP_NAME, s), map);
  FIO_MEM_FREE_(o, sizeof(*o));
}
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/* Theoretical map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME, capa)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, 0);
  FIO_MAP_T *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (o->map)
    return (uint32_t)((size_t)1ULL << o->bits);
  return 0;
}

/* The number of objects in the map capacity. */
FIO_IFUNC uint32_t FIO_NAME(FIO_MAP_NAME, count)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, 0);
  return ((FIO_NAME(FIO_MAP_NAME, s) *)FIO_PTR_UNTAG(map))->count;
}

/** Returns 1 if the iterator points to a valid object, otherwise returns 0. */
FIO_IFUNC int FIO_NAME(FIO_MAP_NAME,
                       iterator_is_valid)(FIO_NAME(FIO_MAP_NAME, iterator_s) *
                                          iterator) {
  return (iterator && iterator->private_.map_validator);
}

/** Returns the key value associated with the node's pointer. */
FIO_IFUNC FIO_MAP_KEY FIO_NAME(FIO_MAP_NAME,
                               node2key)(FIO_NAME(FIO_MAP_NAME, node_s) *
                                         node) {
  FIO_MAP_KEY r = (FIO_MAP_KEY){0};
  if (!node)
    return r;
  return FIO_MAP_KEY_FROM_INTERNAL(node->key);
}

/** Returns the hash value associated with the node's pointer. */
FIO_IFUNC uint64_t FIO_NAME(FIO_MAP_NAME,
                            node2hash)(FIO_NAME(FIO_MAP_NAME, node_s) * node) {
  uint32_t r = (uint32_t){0};
  if (!node)
    return r;
#if FIO_MAP_RECALC_HASH
  FIO_MAP_KEY k = FIO_MAP_KEY_FROM_INTERNAL(node->key);
  uint64_t hash = FIO_MAP_HASH_FN(k);
  hash += !hash;
  return hash;
#else
  return node->hash;
#endif
}

#ifdef FIO_MAP_VALUE
/** Returns the value associated with the node's pointer. */
FIO_IFUNC FIO_MAP_VALUE FIO_NAME(FIO_MAP_NAME,
                                 node2val)(FIO_NAME(FIO_MAP_NAME, node_s) *
                                           node) {
  FIO_MAP_VALUE r = (FIO_MAP_VALUE){0};
  if (!node)
    return r;
  return FIO_MAP_VALUE_FROM_INTERNAL(node->value);
}
#else
/* If called for a node without a value, returns the key (simplifies stuff). */
FIO_IFUNC FIO_MAP_KEY FIO_NAME(FIO_MAP_NAME,
                               node2val)(FIO_NAME(FIO_MAP_NAME, node_s) *
                                         node) {
  return FIO_NAME(FIO_MAP_NAME, node2key)(node);
}
#endif

/** Returns the key value associated with the node's pointer. */
FIO_IFUNC FIO_MAP_KEY_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2key_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node) {
  if (!node)
    return NULL;
  return &node->key;
}

#ifdef FIO_MAP_VALUE
/** Returns the value associated with the node's pointer. */
FIO_IFUNC FIO_MAP_VALUE_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2val_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node) {
  if (!node)
    return NULL;
  return &node->value;
}
#else
/* If called for a node without a value, returns the key (simplifies stuff). */
FIO_IFUNC FIO_MAP_KEY_INTERNAL *FIO_NAME(FIO_MAP_NAME, node2val_ptr)(
    FIO_NAME(FIO_MAP_NAME, node_s) * node) {
  return FIO_NAME(FIO_MAP_NAME, node2key_ptr)(node);
}
#endif

/** Gets a value from the map, if exists. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, get)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                    uint64_t hash,
#endif
                                                    FIO_MAP_KEY key) {
  return FIO_NAME(FIO_MAP_NAME, node2val)(FIO_NAME(FIO_MAP_NAME, get_ptr)(map,
#if !defined(FIO_MAP_HASH_FN)
                                                                          hash,
#endif
                                                                          key));
}

/** Sets a value in the map, hash maps will overwrite existing data if any. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, set)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                    uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                                                    FIO_MAP_KEY key,
                                                    FIO_MAP_VALUE obj,
                                                    FIO_MAP_VALUE_INTERNAL *old
#else
                                                    FIO_MAP_KEY key
#endif
) {
  return FIO_NAME(FIO_MAP_NAME, node2val)(FIO_NAME(FIO_MAP_NAME, set_ptr)(map,
#if !defined(FIO_MAP_HASH_FN)
                                                                          hash,
#endif
                                                                          key
#ifdef FIO_MAP_VALUE
                                                                          ,
                                                                          obj,
                                                                          old,
                                                                          1
#endif
                                                                          ));
}

/** Sets a value in the map if not set previously. */
FIO_IFUNC FIO_MAP_GET_T FIO_NAME(FIO_MAP_NAME, set_if_missing)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                                               uint64_t hash,
#endif
                                                               FIO_MAP_KEY key
#ifdef FIO_MAP_VALUE
                                                               ,
                                                               FIO_MAP_VALUE obj
#endif
) {
  return FIO_NAME(FIO_MAP_NAME, node2val)(FIO_NAME(FIO_MAP_NAME, set_ptr)(map,
#if !defined(FIO_MAP_HASH_FN)
                                                                          hash,
#endif
                                                                          key
#ifdef FIO_MAP_VALUE
                                                                          ,
                                                                          obj,
                                                                          NULL,
                                                                          0
#endif
                                                                          ));
}

/** Returns a pointer to the node object in the internal map. */
FIO_IFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME,
             iterator2node)(FIO_MAP_PTR map,
                            FIO_NAME(FIO_MAP_NAME, iterator_s) * iterator) {
  FIO_NAME(FIO_MAP_NAME, node_s) *node = NULL;
  if (!iterator || !iterator->private_.map_validator)
    return node;
  FIO_PTR_TAG_VALID_OR_RETURN(map, node);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  node = o->map + iterator->private_.index;
  return node;
}

/* *****************************************************************************
Map Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Internal Helpers
***************************************************************************** */

#ifndef FIO_MAP_ATTACK_LIMIT
#define FIO_MAP_ATTACK_LIMIT 16
#endif
#ifndef FIO_MAP_CUCKOO_STEPS
/* Prime numbers are better */
#define FIO_MAP_CUCKOO_STEPS (0x43F82D0BUL) /* a big high prime */
#endif
#ifndef FIO_MAP_SEEK_LIMIT
#define FIO_MAP_SEEK_LIMIT 13U
#endif
#ifndef FIO_MAP_ARRAY_LOG_LIMIT
#define FIO_MAP_ARRAY_LOG_LIMIT 3
#endif
#ifndef FIO_MAP_CAPA
#define FIO_MAP_CAPA(bits) ((size_t)1ULL << bits)
#endif

#ifndef FIO_MAP_IS_SPARSE
#define FIO_MAP_IS_SPARSE(map)                                                 \
  (o->bits > FIO_MAP_ARRAY_LOG_LIMIT && ((capa >> 2) > o->count))
#endif

/* The number of objects in the map capacity. */
FIO_IFUNC uint8_t *FIO_NAME(FIO_MAP_NAME,
                            __imap)(FIO_NAME(FIO_MAP_NAME, s) * o) {
  // FIO_ASSERT(o && o->map, "shouldn't have been called.");
  return (uint8_t *)(o->map + FIO_MAP_CAPA(o->bits));
}

FIO_IFUNC uint64_t FIO_NAME(FIO_MAP_NAME,
                            __byte_hash)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                         uint64_t hash) {
  hash = (hash >> o->bits);
  hash &= 0xFF;
  hash += !(hash);
  hash -= (hash == 255);
  return hash;
}

FIO_IFUNC uint64_t FIO_NAME(FIO_MAP_NAME,
                            __is_eq_hash)(FIO_NAME(FIO_MAP_NAME, node_s) * o,
                                          uint64_t hash) {
#if FIO_MAP_RECALC_HASH && defined(FIO_MAP_HASH_FN)
  uint64_t khash = FIO_MAP_HASH_FN(FIO_MAP_KEY_FROM_INTERNAL(o->key));
  khash += !khash;
#else
  const uint64_t khash = o->hash;
#endif
  return (khash == hash);
}

FIO_SFUNC uint32_t FIO_NAME(FIO_MAP_NAME,
                            __index)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                     FIO_MAP_KEY key,
                                     uint64_t hash) {
  uint32_t r = (uint32_t)-1;
  if (!o->map)
    return r;
  static int guard_print = 0;
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  size_t capa = FIO_MAP_CAPA(o->bits);
  size_t bhash = FIO_NAME(FIO_MAP_NAME, __byte_hash)(o, hash);
  size_t guard = FIO_MAP_ATTACK_LIMIT + 1;
  if (o->bits > FIO_MAP_ARRAY_LOG_LIMIT) { /* treat as map */
    uint64_t bhash64 = bhash | (bhash << 8);
    bhash64 |= bhash64 << 16;
    bhash64 |= bhash64 << 32;
    bhash64 = ~bhash64;
    const uintptr_t pos_mask = capa - 1;
    const uint_fast8_t offsets[8] = {0, 3, 8, 17, 28, 41, 58, 60};
    for (uintptr_t pos = hash, c = 0; c < FIO_MAP_SEEK_LIMIT;
         (pos += FIO_MAP_CUCKOO_STEPS), ++c) {
      uint64_t comb = imap[(pos + offsets[0]) & pos_mask];
      comb |= ((uint64_t)imap[(pos + offsets[1]) & pos_mask]) << (1 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[2]) & pos_mask]) << (2 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[3]) & pos_mask]) << (3 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[4]) & pos_mask]) << (4 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[5]) & pos_mask]) << (5 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[6]) & pos_mask]) << (6 * 8);
      comb |= ((uint64_t)imap[(pos + offsets[7]) & pos_mask]) << (7 * 8);
      const uint64_t has_possible_match =
          (((comb ^ bhash64) & 0x7F7F7F7F7F7F7F7FULL) + 0x0101010101010101ULL) &
          0x8080808080808080ULL;
      if (has_possible_match) {
        /* there was a 7 bit match in one of the bytes in this 8 byte group */
        for (size_t i = 0; i < 8; ++i) {
          const uint32_t tmp = (pos + offsets[i]) & pos_mask;
          if (imap[tmp] != bhash)
            continue;
          /* test key and hash equality */
          if (FIO_NAME(FIO_MAP_NAME, __is_eq_hash)(o->map + tmp, hash)) {
            if (FIO_MAP_KEY_CMP(o->map[tmp].key, key)) {
              guard_print = 0;
              return (r = tmp);
            }
            if (!(--guard)) {
              if (!guard_print)
                FIO_LOG_SECURITY("hash map " FIO_MACRO2STR(
                    FIO_NAME(FIO_MAP_NAME, s)) " under attack?");
              guard_print = 1;
              return (r = tmp);
            }
          }
        }
      }
      const uint64_t has_possible_full_byte =
          (((comb)&0x7F7F7F7F7F7F7F7FULL) + 0x0101010101010101ULL) &
          0x8080808080808080ULL;
      const uint64_t has_possible_empty_byte =
          (((~comb) & 0x7F7F7F7F7F7F7F7FULL) + 0x0101010101010101ULL) &
          0x8080808080808080ULL;
      if (!(has_possible_full_byte | has_possible_empty_byte))
        continue;
      /* there was a 7 bit match for a possible free space in this group */
      for (int i = 0; i < 8; ++i) {
        const uint32_t tmp = (pos + offsets[i]) & pos_mask;
        if (!imap[tmp])
          return (r = tmp); /* empty slot always ends search */
        if (r > pos_mask && imap[tmp] == 255)
          r = tmp; /* mark hole to be filled */
      }
    }
    return r;
  } /* treat as array */
  for (size_t i = 0; i < capa; ++i) {
    if (!imap[i])
      return (r = i);
    if (imap[i] == bhash) {
      /* test key and hash equality */
      if (FIO_NAME(FIO_MAP_NAME, __is_eq_hash)(o->map + i, hash)) {
        if (FIO_MAP_KEY_CMP(o->map[i].key, key)) {
          guard_print = 0;
          return (r = i);
        }
        if (!(--guard)) {
          if (!guard_print)
            FIO_LOG_SECURITY("hash map " FIO_MACRO2STR(
                FIO_NAME(FIO_MAP_NAME, s)) " under attack?");
          guard_print = 1;
          return (r = i);
        }
      }
    }
    if (imap[i] == 0xFF)
      r = i; /* a free spot is available*/
  }
  return r;
}
/* deallocate the map's memory. */
FIO_SFUNC void FIO_NAME(FIO_MAP_NAME,
                        __dealloc_map)(FIO_NAME(FIO_MAP_NAME, s) * o) {
  if (!o->bits || !o->map)
    return;
  const size_t capa = FIO_MAP_CAPA(o->bits);
  FIO_MEM_FREE_(o->map, (capa * sizeof(*o->map)) + capa);
  (void)capa;
}

/** duplicates an objects between two maps. */
FIO_IFUNC int FIO_NAME(FIO_MAP_NAME,
                       __copy_obj)(FIO_NAME(FIO_MAP_NAME, s) * dest,
                                   FIO_NAME(FIO_MAP_NAME, node_s) * o,
                                   uint32_t internal) {
  FIO_MAP_KEY key = FIO_MAP_KEY_FROM_INTERNAL(o->key);
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(dest);
#if FIO_MAP_RECALC_HASH
  uint64_t ohash = FIO_MAP_HASH_FN(key);
  ohash += !ohash;
#else
  const uint64_t ohash = o->hash;
#endif
  uint32_t i = FIO_NAME(FIO_MAP_NAME, __index)(dest, key, ohash);
  if (i == (uint32_t)-1 || (imap[i] + 1) > 1)
    return -1;
  if (internal) {
    dest->map[i] = *o;
    imap[i] = FIO_NAME(FIO_MAP_NAME, __byte_hash)(dest, ohash);
#if FIO_MAP_ORDERED
    if (dest->count) { /* update ordering */
      FIO_INDEXED_LIST_PUSH(dest->map, node, dest->head, i);
    } else { /* set first order */
      dest->map[i].node.next = dest->map[i].node.prev = i;
      dest->head = i;
    }
#endif
    ++dest->count;
    return 0;
  }
  imap[i] = FIO_NAME(FIO_MAP_NAME, __byte_hash)(dest, ohash);
  FIO_MAP_KEY_COPY(dest->map[i].key, FIO_MAP_KEY_FROM_INTERNAL(o->key));
  FIO_MAP_VALUE_COPY(dest->map[i].value, FIO_MAP_VALUE_FROM_INTERNAL(o->value));
#if !FIO_MAP_RECALC_HASH
  dest->map[i].hash = o->hash;
#endif
#if FIO_MAP_ORDERED
  if (dest->count) { /* update ordering */
    FIO_INDEXED_LIST_PUSH(dest->map, node, dest->head, i);
  } else { /* set first order */
    dest->map[i].node.next = dest->map[i].node.prev = i;
    dest->head = i;
  }
#endif
  ++dest->count;
  return 0;
}

/** duplicates a map to a new copy (usually for rehashing / reserving space). */
FIO_IFUNC FIO_NAME(FIO_MAP_NAME, s)
    FIO_NAME(FIO_MAP_NAME, __duplicate)(FIO_NAME(FIO_MAP_NAME, s) * o,
                                        uint32_t bits,
                                        uint32_t internal) {
  FIO_NAME(FIO_MAP_NAME, s) cpy = {0};
  if (bits > 31)
    return cpy;
  size_t capa = FIO_MAP_CAPA(bits);
  cpy.map = (FIO_NAME(FIO_MAP_NAME, node_s) *)
      FIO_MEM_REALLOC_(NULL, 0, ((capa * sizeof(*cpy.map)) + capa), 0);
  if (!cpy.map)
    return cpy;
  if (!FIO_MEM_REALLOC_IS_SAFE_) {
    /* set only the imap, the rest can be junk data */
    FIO_MEMSET((cpy.map + capa), 0, capa);
  }
  cpy.bits = bits;
  if (!o->count)
    return cpy;
#if FIO_MAP_ORDERED
  /* copy objects in order */
  FIO_INDEXED_LIST_EACH(o->map, node, o->head, i) {
    if (FIO_NAME(FIO_MAP_NAME, __copy_obj)(&cpy, o->map + i, internal))
      goto error;
  }
#else
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  capa = FIO_MAP_CAPA(o->bits);
  if (FIO_MAP_IS_SPARSE(o)) { /* sparsely populated */
    for (size_t i = 0; i < capa; i += 8) {
      uint64_t comb = *((uint64_t *)(imap + i));
      if (!comb || comb == 0xFFFFFFFFFFFFFFFFULL)
        continue;
      for (size_t j = 0; j < 8; ++j) {
        const size_t tmp = j + i;
        if (!imap[tmp] || imap[tmp] == 0xFF)
          continue;
        if (FIO_NAME(FIO_MAP_NAME, __copy_obj)(&cpy, o->map + tmp, internal))
          goto error;
      }
    }
    return cpy;
  } /* review as array */
  for (size_t i = 0; i < capa; ++i) {
    if (!imap[i] || imap[i] == 0xFF)
      continue;
    if (FIO_NAME(FIO_MAP_NAME, __copy_obj)(&cpy, o->map + i, internal))
      goto error;
  }
#endif
  return cpy;
error:
  FIO_NAME(FIO_MAP_NAME, __dealloc_map)(&cpy);
  cpy = (FIO_NAME(FIO_MAP_NAME, s)){0};
  return cpy;
}

/* destroys all objects in the map, without(!) resetting the `imap`. */
FIO_SFUNC void FIO_NAME(FIO_MAP_NAME,
                        __destroy_objects)(FIO_NAME(FIO_MAP_NAME, s) * o) {
#if FIO_MAP_VALUE_DESTROY_SIMPLE && FIO_MAP_KEY_DESTROY_SIMPLE
  (void)o;
  return;
#else
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  const size_t capa = FIO_MAP_CAPA(o->bits);
  if (FIO_MAP_IS_SPARSE(o)) {
    for (size_t i = 0; i < capa; i += 8) {
      uint64_t comb = *((uint64_t *)(imap + i));
      if (!comb || comb == 0xFFFFFFFFFFFFFFFFULL)
        continue;
      for (size_t j = i; j < i + 8; ++j) {
        FIO_MAP_KEY_DESTROY(o->map[j].key);
        FIO_MAP_VALUE_DESTROY(o->map[j].value);
      }
    }
  } else { /* review as array */
    for (size_t i = 0; i < capa; ++i) {
      if (!imap[i] || imap[i] == 0xFF)
        continue;
      FIO_MAP_KEY_DESTROY(o->map[i].key);
      FIO_MAP_VALUE_DESTROY(o->map[i].value);
    }
  }
#endif /* FIO_MAP_VALUE_DESTROY_SIMPLE */
}

/* *****************************************************************************
API implementation
***************************************************************************** */

/** Reserves at minimum the capacity requested. */
SFUNC void FIO_NAME(FIO_MAP_NAME, reserve)(FIO_MAP_PTR map, size_t capa) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (FIO_MAP_CAPA(o->bits) >= capa || (capa >> 31))
    return;
  uint_fast8_t bits = o->bits + 1;
  while (FIO_MAP_CAPA(bits) < capa)
    ++bits;
  FIO_NAME(FIO_MAP_NAME, s)
  cpy = FIO_NAME(FIO_MAP_NAME, __duplicate)(o, bits, 1);
  if (!cpy.map)
    return;
  FIO_NAME(FIO_MAP_NAME, __dealloc_map)(o);
  *o = cpy;
}

/* Removes all objects from the map, without releasing the map's resources. */
SFUNC void FIO_NAME(FIO_MAP_NAME, clear)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (!o->map || !o->count)
    return;
  FIO_NAME(FIO_MAP_NAME, __destroy_objects)(o);
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  const size_t capa = FIO_MAP_CAPA(o->bits);
  FIO_MEMSET(imap, 0, capa);
  o->count = 0;
#if FIO_MAP_ORDERED
  o->head = 0;
#endif
}

/** Attempts to minimize memory use. */
SFUNC void FIO_NAME(FIO_MAP_NAME, compact)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (!o->map || !o->count)
    return;
  uint32_t bits = o->bits;
  while ((bits >> 1) > o->count)
    bits >>= 1;
  for (;;) {
    if (bits == o->bits)
      return;
    FIO_NAME(FIO_MAP_NAME, s)
    cpy = FIO_NAME(FIO_MAP_NAME, __duplicate)(o, bits, 1);
    if (!cpy.map) {
      ++bits;
      continue;
    }
    FIO_NAME(FIO_MAP_NAME, __dealloc_map)(o);
    *o = cpy;
    return;
  }
}

/* Frees any internal data AND the object's container! */
SFUNC void FIO_NAME(FIO_MAP_NAME, destroy)(FIO_MAP_PTR map) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (o->map && o->count)
    FIO_NAME(FIO_MAP_NAME, __destroy_objects)(o);
  FIO_NAME(FIO_MAP_NAME, __dealloc_map)(o);
  *o = (FIO_NAME(FIO_MAP_NAME, s))FIO_MAP_INIT;
  return;
}

/** Evicts elements least recently used (LRU), FIFO or undefined. */
SFUNC void FIO_NAME(FIO_MAP_NAME, evict)(FIO_MAP_PTR map,
                                         size_t number_of_elements) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(map);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (!o->count)
    return;
  if (number_of_elements >= o->count) {
    FIO_NAME(FIO_MAP_NAME, clear)(map);
    return;
  }
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
#ifdef FIO_MAP_LRU /* remove last X elements from the list */
  FIO_INDEXED_LIST_EACH_REVERSED(o->map, node, o->head, i) {
    FIO_MAP_KEY_DESTROY(o->map[i].key);
    FIO_MAP_VALUE_DESTROY(o->map[i].value);
    FIO_INDEXED_LIST_REMOVE(o->map, node, i);
    imap[i] = 0xFF;
    --o->count;
    if (!(--number_of_elements))
      return;
  }
#elif FIO_MAP_ORDERED /* remove first X elements from the list */
  FIO_INDEXED_LIST_EACH(o->map, node, o->head, i) {
    FIO_MAP_KEY_DESTROY(o->map[i].key);
    FIO_MAP_VALUE_DESTROY(o->map[i].value);
    FIO_INDEXED_LIST_REMOVE(o->map, node, i);
    imap[i] = 0xFF;
    --o->count;
    if (!(--number_of_elements)) {
      o->head = o->map[i].node.next;
      return;
    }
  }
#else                 /* remove whatever... */
  if (o->bits > FIO_MAP_ARRAY_LOG_LIMIT) {
    /* map is scattered */
    uint32_t pos_mask = (uint32_t)(FIO_MAP_CAPA(o->bits) - 1);
    uint32_t pos = *(uint32_t *)o->map;
    for (int i = 0; i < 3; ++i) {
      struct timespec t = {0};
      clock_gettime(CLOCK_MONOTONIC, &t);
      pos *= t.tv_nsec ^ t.tv_sec ^ (uintptr_t)imap;
      pos ^= pos >> 7;
    }
    for (;;) { /* a bit of non-random randomness... */
      uint32_t offset = ((pos << 3)) & pos_mask;
      for (uint_fast8_t i = 0; i < 8; ++i) { /* ordering bias? vs performance */
        const uint32_t tmp = offset + i;
        if (!imap[tmp] || imap[tmp] == 0xFF)
          continue;
        FIO_MAP_KEY_DESTROY(o->map[tmp].key);
        FIO_MAP_VALUE_DESTROY(o->map[tmp].value);
        imap[tmp] = 0xFF;
        --o->count;
        if (!(--number_of_elements))
          return;
      }
      pos += FIO_MAP_CUCKOO_STEPS;
    }
  }
  /* map is a simple array */
  while (number_of_elements--) {
    FIO_MAP_KEY_DESTROY(o->map[number_of_elements].key);
    FIO_MAP_VALUE_DESTROY(o->map[number_of_elements].value);
    imap[number_of_elements] = 0xFF;
  }
#endif                /* FIO_MAP_LRU / FIO_MAP_ORDERED */
}

/* *****************************************************************************
The Map set/get functions
***************************************************************************** */

/**
 * The core get function. This function returns NULL if item is missing.
 *
 * NOTE: the function returns the internal representation of objects.
 */
SFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME, get_ptr)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                    uint64_t hash,
#endif
                                    FIO_MAP_KEY key) {
  FIO_NAME(FIO_MAP_NAME, node_s) *r = NULL;
  FIO_PTR_TAG_VALID_OR_RETURN(map, r);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (!o->count)
    return r;
#if defined(FIO_MAP_HASH_FN)
  uint64_t hash = FIO_MAP_HASH_FN(key);
#endif
  hash += !hash;
  uint32_t pos = FIO_NAME(FIO_MAP_NAME, __index)(o, key, hash);
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  if (pos == (uint32_t)-1 || !imap[pos] || imap[pos] == 0xFF)
    return r;
#ifdef FIO_MAP_LRU
  if (o->head != pos) {
    FIO_INDEXED_LIST_REMOVE(o->map, node, pos);
    FIO_INDEXED_LIST_PUSH(o->map, node, o->head, pos);
    o->head = pos;
  }
#endif
  r = o->map + pos;
  return r;
}

/** sets / removes an object in the map, returning a pointer to the map data. */
SFUNC FIO_NAME(FIO_MAP_NAME, node_s) *
    FIO_NAME(FIO_MAP_NAME, set_ptr)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                    uint64_t hash,
#endif
#ifdef FIO_MAP_VALUE
                                    FIO_MAP_KEY key,
                                    FIO_MAP_VALUE val,
                                    FIO_MAP_VALUE_INTERNAL *old,
                                    int overwrite
#else
                                    FIO_MAP_KEY key
#endif
    ) {
  FIO_NAME(FIO_MAP_NAME, node_s) *r = NULL;
#ifdef FIO_MAP_VALUE
  if (old)
    *old = (FIO_MAP_VALUE_INTERNAL){0};
#endif
  FIO_NAME(FIO_MAP_NAME, s) * o;
#if defined(FIO_MAP_HASH_FN)
  uint64_t hash;
#endif
  uint32_t pos;
  uint8_t *imap = NULL;

  FIO_PTR_TAG_VALID_OR_GOTO(map, relinquish_attempt);
  o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
#if defined(FIO_MAP_HASH_FN)
  hash = FIO_MAP_HASH_FN(key);
#endif
  hash += !hash; /* hash is never zero */
  /* find the object's (potential) position in the array */
  for (int i = 0;;) {
    pos = FIO_NAME(FIO_MAP_NAME, __index)(o, key, hash);
    if (pos != (uint32_t)-1)
      break;
    if (i == 2)
      goto internal_error;
    FIO_NAME(FIO_MAP_NAME, s)
    tmp = FIO_NAME(FIO_MAP_NAME, __duplicate)(o, o->bits + (++i), 1);
    if (!tmp.map) /* no memory? something bad? */
      goto internal_error;
    FIO_NAME(FIO_MAP_NAME, __dealloc_map)(o);
    *o = tmp;
  }
  /* imap may have been reallocated, collect info now. */
  imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  /* set return value */
  r = o->map + pos;

  if (!imap[pos] || imap[pos] == 0xFF) {
    /* insert new object */
    imap[pos] = FIO_NAME(FIO_MAP_NAME, __byte_hash)(o, hash);
#if !FIO_MAP_RECALC_HASH
    r->hash = hash;
#endif
    FIO_MAP_KEY_COPY(r->key, key);
    FIO_MAP_VALUE_COPY(r->value, val);
#if FIO_MAP_ORDERED
    if (o->count) { /* update ordering */
      FIO_INDEXED_LIST_PUSH(o->map, node, o->head, pos);
#ifdef FIO_MAP_LRU
      o->head = pos;                 /* update LRU head */
      if (FIO_MAP_LRU == o->count) { /* limit reached - evict 1 LRU element */
        uint32_t to_evict = o->map[pos].node.prev;
        FIO_MAP_KEY_DESTROY(o->map[to_evict].key);
        FIO_MAP_VALUE_DESTROY(o->map[to_evict].value);
        FIO_INDEXED_LIST_REMOVE(o->map, node, to_evict);
        imap[to_evict] = 0xFF;
        --o->count;
      }
#endif       /* FIO_MAP_LRU */
    } else { /* set first order */
      o->map[pos].node.next = o->map[pos].node.prev = pos;
      o->head = pos;
    }
#endif /* FIO_MAP_ORDERED */
    ++o->count;
    return r;
  }

#ifdef FIO_MAP_LRU
  /* update ordering (even if not overwriting) */
  if (o->head != pos) {
    FIO_INDEXED_LIST_REMOVE(o->map, node, pos);
    FIO_INDEXED_LIST_PUSH(o->map, node, o->head, pos);
    o->head = pos;
  }
#endif

#ifdef FIO_MAP_VALUE
  if (overwrite) {
    /* overwrite existing object (only relevant for hash maps) */
    FIO_MAP_KEY_DISCARD(key);
    if (!old) {
      FIO_MAP_VALUE_DESTROY(o->map[pos].value);
      FIO_MAP_VALUE_COPY(o->map[pos].value, val);
      return r;
    }
    *old = o->map[pos].value;
    o->map[pos].value = (FIO_MAP_VALUE_INTERNAL){0};
    FIO_MAP_VALUE_COPY(o->map[pos].value, val);
    return r;
  }
#endif
relinquish_attempt:
  /* discard attempt */
  FIO_MAP_KEY_DISCARD(key);
  FIO_MAP_VALUE_DISCARD(val);
  return r;
internal_error:
  FIO_MAP_KEY_DISCARD(key);
  FIO_MAP_VALUE_DISCARD(val);
  FIO_LOG_ERROR("unknown error occurred trying to add an entry to the map");
  FIO_ASSERT_DEBUG(0, "these errors shouldn't happen");
  return r;
}

/* *****************************************************************************
The Map remove function
***************************************************************************** */

/** Removes an object in the map, returning a pointer to the map data. */
SFUNC int FIO_NAME(FIO_MAP_NAME, remove)(FIO_MAP_PTR map,
#if !defined(FIO_MAP_HASH_FN)
                                         uint64_t hash,
#endif
                                         FIO_MAP_KEY key,
#ifdef FIO_MAP_VALUE
                                         FIO_MAP_VALUE_INTERNAL *old
#else
                                         FIO_MAP_KEY_INTERNAL *old
#endif
) {
#ifdef FIO_MAP_VALUE
  if (old)
    *old = (FIO_MAP_VALUE_INTERNAL){0};
#else
  if (old)
    *old = (FIO_MAP_KEY_INTERNAL){0};
#endif

  FIO_PTR_TAG_VALID_OR_RETURN(map, -1);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
#if defined(FIO_MAP_HASH_FN)
  uint64_t hash = FIO_MAP_HASH_FN(key);
#endif
  hash += !hash; /* hash is never zero */
  uint32_t pos = FIO_NAME(FIO_MAP_NAME, __index)(o, key, hash);
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);

  if (pos == (uint32_t)-1 || !imap[pos] || imap[pos] == 0xFF)
    return -1;

  imap[pos] = 0xFF; /* mark hole and update count */
  --o->count;

#if FIO_MAP_ORDERED
  /* update ordering */
  if (o->head == pos)
    o->head = o->map[pos].node.next;
  if (o->head == pos)
    o->head = 0;
  else {
    FIO_INDEXED_LIST_REMOVE(o->map, node, pos);
  }
#endif

/* destroy data, copy to `old` pointer if necessary. */
#ifdef FIO_MAP_VALUE
  FIO_MAP_KEY_DESTROY(o->map[pos].key);
  o->map[pos].key = (FIO_MAP_KEY_INTERNAL){0};
  if (!old) {
    FIO_MAP_VALUE_DESTROY(o->map[pos].value);
  } else {
    *old = o->map[pos].value;
  }
  o->map[pos].value = (FIO_MAP_VALUE_INTERNAL){0};
#else
  if (!old) {
    FIO_MAP_KEY_DESTROY(o->map[pos].key);
  } else {
    *old = o->map[pos].key;
  }
  o->map[pos].key = (FIO_MAP_KEY_INTERNAL){0};
#endif
#if !FIO_MAP_RECALC_HASH && defined(DEBUG)
  o->map[pos].hash = 0; /* not necessary, but ... good for debugging? */
#endif
  return 0;
}

/* *****************************************************************************
Map Iteration
***************************************************************************** */

/** Returns the next iterator position after `current_pos`, first if `NULL`. */
SFUNC FIO_NAME(FIO_MAP_NAME, iterator_s)
    FIO_NAME(FIO_MAP_NAME,
             get_next)(FIO_MAP_PTR map,
                       FIO_NAME(FIO_MAP_NAME, iterator_s) * current_pos) {
  FIO_NAME(FIO_MAP_NAME, iterator_s) r = {.private_.pos = 0};
  FIO_PTR_TAG_VALID_OR_RETURN(map, r);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (!o->count)
    return r;
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  size_t capa = FIO_MAP_CAPA(o->bits);
  size_t pos_counter = 0;
  if (!current_pos || !current_pos->private_.map_validator) {
    goto find_pos;
  }
  if (current_pos->private_.pos + 1 == o->count)
    return r;
  r.private_.pos = current_pos->private_.pos + 1;
  if (current_pos->private_.map_validator != (uintptr_t)o) {
    goto refind_pos;
  }
  r.private_.index = current_pos->private_.index;

#if !FIO_MAP_RECALC_HASH
#define FIO_MAP___EACH_COPY_HASH() r.hash = o->map[r.private_.index].hash
#else
#define FIO_MAP___EACH_COPY_HASH()
#endif

#ifdef FIO_MAP_VALUE
#define FIO_MAP___EACH_COPY_DATA()                                             \
  FIO_MAP___EACH_COPY_HASH();                                                  \
  r.private_.map_validator = (uintptr_t)o;                                     \
  r.key = FIO_MAP_KEY_FROM_INTERNAL(o->map[r.private_.index].key);             \
  r.value = FIO_MAP_VALUE_FROM_INTERNAL(o->map[r.private_.index].value)
#else
#define FIO_MAP___EACH_COPY_DATA()                                             \
  FIO_MAP___EACH_COPY_HASH();                                                  \
  r.private_.map_validator = (uintptr_t)o;                                     \
  r.key = FIO_MAP_KEY_FROM_INTERNAL(o->map[r.private_.index].key)
#endif

/* start seeking at the position inherited from current_pos */
#if FIO_MAP_ORDERED
  (void)imap; /* unused in ordered maps */
  (void)capa; /* unused in ordered maps */
  r.private_.index = o->map[r.private_.index].node.next;
  if (r.private_.index == o->head)
    goto not_found;
  FIO_MAP___EACH_COPY_DATA();
  return r;
#else
  if (FIO_MAP_IS_SPARSE(o)) { /* sparsely populated */
    while ((++r.private_.index) & 7) {
      if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
        continue;
      FIO_MAP___EACH_COPY_DATA();
      return r;
    }
    while (r.private_.index < capa) {
      uint64_t simd = *(uint64_t *)(imap + r.private_.index);
      if (!simd || simd == 0xFFFFFFFFFFFFFFFFULL) {
        r.private_.index += 8;
        continue;
      }
      for (int i = 0; i < 8; (++i), (++r.private_.index)) {
        if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
          continue;
        FIO_MAP___EACH_COPY_DATA();
        return r;
      }
    }
    goto not_found;
  }
  /* review as array */
  while ((++r.private_.index) < capa) {
    if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
      continue;
    FIO_MAP___EACH_COPY_DATA();
    return r;
  }
  goto not_found;
#endif /* FIO_MAP_ORDERED */

refind_pos:
  if (current_pos->private_.index)
    goto not_found;
find_pos:
/* first seek... re-start seeking */
#if FIO_MAP_ORDERED
  FIO_INDEXED_LIST_EACH(o->map, node, o->head, i) {
    if (pos_counter != r.private_.pos) {
      ++pos_counter;
      continue;
    }
    r.private_.index = i;
    FIO_MAP___EACH_COPY_DATA();
    return r;
  }
  goto not_found;
#else
  if (FIO_MAP_IS_SPARSE(o)) { /* sparsely populated */
    while (r.private_.index < capa) {
      uint64_t simd = *(uint64_t *)(imap + r.private_.index);
      if (!simd || simd == 0xFFFFFFFFFFFFFFFFULL) {
        r.private_.index += 8;
        continue;
      }
      for (int i = 0; i < 8; (++i), (++r.private_.index)) {
        if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
          continue;
        if (pos_counter != r.private_.pos) {
          ++pos_counter;
          continue;
        }
        FIO_MAP___EACH_COPY_DATA();
        return r;
      }
    }
    goto not_found;
  }
  /* review as array */
  while (r.private_.index < capa) {
    if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF) {
      ++r.private_.index;
      continue;
    }
    FIO_MAP___EACH_COPY_DATA();
    return r;
  }
#endif /* FIO_MAP_ORDERED */

not_found:
  return (r = (FIO_NAME(FIO_MAP_NAME, iterator_s)){.private_.pos = 0});
  FIO_ASSERT_DEBUG(0, "should this happen? ever?");
}

/** Returns the next iterator position after `current_pos`, first if `NULL`. */
SFUNC FIO_NAME(FIO_MAP_NAME, iterator_s)
    FIO_NAME(FIO_MAP_NAME,
             get_prev)(FIO_MAP_PTR map,
                       FIO_NAME(FIO_MAP_NAME, iterator_s) * current_pos) {
  FIO_NAME(FIO_MAP_NAME, iterator_s) r = {.private_.pos = 0};
  FIO_PTR_TAG_VALID_OR_RETURN(map, r);
  FIO_NAME(FIO_MAP_NAME, s) *o = FIO_PTR_TAG_GET_UNTAGGED(FIO_MAP_T, map);
  if (!o->count)
    return r;
#if !FIO_MAP_ORDERED
  uint8_t *imap = FIO_NAME(FIO_MAP_NAME, __imap)(o);
  size_t capa = FIO_MAP_CAPA(o->bits);
#endif
  size_t pos_counter = o->count;
  if (!current_pos || !current_pos->private_.map_validator) {
    r.private_.map_validator = (uintptr_t)o;
    r.private_.pos = o->count;
    goto find_pos;
  }
  if (!current_pos->private_.pos)
    return r;
  r.private_.pos = current_pos->private_.pos - 1;
  r.private_.map_validator = (uintptr_t)o;
  if (current_pos->private_.map_validator != (uintptr_t)o) {
    goto refind_pos;
  }
  r.private_.index = current_pos->private_.index;

/* start seeking at the position inherited from current_pos */
#if FIO_MAP_ORDERED
  if (r.private_.index == o->head)
    goto not_found;
  r.private_.index = o->map[r.private_.index].node.prev;
  FIO_MAP___EACH_COPY_DATA();
  return r;
#else
  if (FIO_MAP_IS_SPARSE(o)) { /* sparsely populated */
    while ((--r.private_.index) & 7) {
      if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
        continue;
      FIO_MAP___EACH_COPY_DATA();
      return r;
    }
    while (r.private_.index) {
      uint64_t simd = *(uint64_t *)(imap + (r.private_.index - 8));
      if (!simd || simd == 0xFFFFFFFFFFFFFFFFULL) {
        r.private_.index -= 8;
        continue;
      }
      for (int i = 0; i < 8; ++i) {
        --r.private_.index;
        if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
          continue;
        FIO_MAP___EACH_COPY_DATA();
        return r;
      }
    }
    goto not_found;
  }
  /* review as array */
  while (r.private_.index--) {
    if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
      continue;
    FIO_MAP___EACH_COPY_DATA();
    return r;
  }
  goto not_found;
#endif /* FIO_MAP_ORDERED */

refind_pos:
  if (current_pos->private_.index)
    goto not_found;
find_pos:
/* first seek... re-start seeking */
#if FIO_MAP_ORDERED
  FIO_INDEXED_LIST_EACH_REVERSED(o->map, node, o->head, i) {
    if (pos_counter != r.private_.pos) {
      --pos_counter;
      continue;
    }
    r.private_.index = i;
    FIO_MAP___EACH_COPY_DATA();
    return r;
  }
  goto not_found;
#else
  r.private_.index = capa;
  if (FIO_MAP_IS_SPARSE(o)) { /* sparsely populated */
    while (r.private_.index) {
      uint64_t simd = *(uint64_t *)(imap + r.private_.index);
      if (!simd || simd == 0xFFFFFFFFFFFFFFFFULL) {
        r.private_.index -= 8;
        continue;
      }
      for (int i = 0; i < 8; (++i), (--r.private_.index)) {
        if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
          continue;
        if (pos_counter != r.private_.pos) {
          ++pos_counter;
          continue;
        }
        FIO_MAP___EACH_COPY_DATA();
        return r;
      }
    }
    goto not_found;
  }
  /* review as array */
  while ((r.private_.index--)) {
    if (!imap[r.private_.index] || imap[r.private_.index] == 0xFF)
      continue;
    FIO_MAP___EACH_COPY_DATA();
    return r;
  }
#endif /* FIO_MAP_ORDERED */

not_found:
  return (r = (FIO_NAME(FIO_MAP_NAME, iterator_s)){.private_.pos = 0});
  FIO_ASSERT_DEBUG(0, "should this happen? ever?");
}
#undef FIO_MAP___EACH_COPY_HASH
#undef FIO_MAP___EACH_COPY_DATA

/**
 * Iteration using a callback for each element in the map.
 *
 * The callback task function must accept an each_s pointer, see above.
 *
 * If the callback returns -1, the loop is broken. Any other value is ignored.
 *
 * Returns the relative "stop" position, i.e., the number of items processed +
 * the starting point.
 */
SFUNC uint32_t FIO_NAME(FIO_MAP_NAME,
                        each)(FIO_MAP_PTR map,
                              int (*task)(FIO_NAME(FIO_MAP_NAME, each_s) *),
                              void *udata,
                              ssize_t start_at) {
  FIO_PTR_TAG_VALID_OR_RETURN(map, 1);
  FIO_NAME(FIO_MAP_NAME, each_s)
  e = {
      .parent = map,
      .task = task,
      .udata = udata,
  };
  FIO_NAME(FIO_MAP_NAME, s) *o =
      FIO_PTR_TAG_GET_UNTAGGED(FIO_NAME(FIO_MAP_NAME, s), map);
  if (start_at < 0) {
    start_at += o->count;
    if (start_at < 0)
      start_at = 0;
  } else if (start_at > o->count)
    return o->count;
  FIO_NAME(FIO_MAP_NAME, iterator_s) i = {.private_.pos = 0};
  for (;;) {
    i = FIO_NAME(FIO_MAP_NAME, get_next)(map, &i);
    if (!FIO_NAME(FIO_MAP_NAME, iterator_is_valid)(&i))
      return o->count;
    e.index = i.private_.pos;
    e.key = i.key;
#ifdef FIO_MAP_VALUE
    e.value = i.value;
#endif
    if (e.task(&e))
      return e.index + 1;
  }
  return o->count;
}

/* *****************************************************************************
Speed Testing
***************************************************************************** */

/* *****************************************************************************
Map Testing
***************************************************************************** */
#ifdef FIO_MAP_TEST

#ifdef FIO_MAP_HASH_FN
#define FIO___M_HASH(k)
#else
#define FIO___M_HASH(k) (k),
#endif
#ifdef FIO_MAP_VALUE
#define FIO___M_VAL(v) , (v)
#define FIO___M_OLD    , NULL
#else
#define FIO___M_VAL(v)
#define FIO___M_OLD
#endif

FIO_SFUNC void FIO_NAME_TEST(stl, FIO_MAP_NAME)(void) {
  /* testing only only works with integer external types */
  fprintf(stderr,
          "* Testing maps with key " FIO_MACRO2STR(
              FIO_MAP_KEY) " (=> " FIO_MACRO2STR(FIO_MAP_VALUE) ").\n");
  { /* test set / get overwrite , FIO_MAP_EACH and evict */
    FIO_NAME(FIO_MAP_NAME, s) map = FIO_MAP_INIT;
    for (size_t i = 1; i < (1UL << (FIO_MAP_ARRAY_LOG_LIMIT + 5)); ++i) {
      FIO_NAME(FIO_MAP_NAME, set)
      (&map, FIO___M_HASH(i) i FIO___M_VAL(i) FIO___M_OLD);
      FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == i,
                 "map `set` failed? %zu != %zu",
                 (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
                 i);
      for (size_t j = ((i << 2) + 1); j < i; ++j) { /* effects LRU ordering */
        FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, get_ptr)(&map, FIO___M_HASH(j) j) &&
                       FIO_NAME(FIO_MAP_NAME, node2val)(
                           FIO_NAME(FIO_MAP_NAME,
                                    get_ptr)(&map, FIO___M_HASH(j) j)) == j,
                   "map `get` failed? %zu/%zu (%p)",
                   j,
                   i,
                   FIO_NAME(FIO_MAP_NAME, get_ptr)(&map, FIO___M_HASH(j) j));
        FIO_NAME(FIO_MAP_NAME, set)
        (&map, FIO___M_HASH(j) j FIO___M_VAL(j) FIO___M_OLD);
        FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == i,
                   "map `set` added an item that already exists? %zu != %zu",
                   (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
                   i);
      }
    }
    /* test FIO_MAP_EACH and ordering */
    uint32_t count = FIO_NAME(FIO_MAP_NAME, count)(&map);
    uint32_t loop_test = 0;
    FIO_MAP_EACH(FIO_MAP_NAME, &map, i) {
      /* test ordering */
#ifdef FIO_MAP_LRU
      FIO_ASSERT(i.key == (count - loop_test),
                 "map FIO_MAP_EACH LRU ordering broken? %zu != %zu",
                 (size_t)(i.key),
                 (size_t)(count - loop_test));
      ++loop_test;
#elif FIO_MAP_ORDERED
      ++loop_test;
      FIO_ASSERT(i.key == loop_test,
                 "map FIO_MAP_EACH LRU ordering broken? %zu != %zu",
                 (size_t)(i.key),
                 (size_t)(loop_test));
#else
      ++loop_test;
#endif
    }
    FIO_ASSERT(loop_test == count,
               "FIO_MAP_EACH failed to iterate all elements? (%zu != %zu",
               (size_t)loop_test != (size_t)count);
    loop_test = 0;
    FIO_MAP_EACH_REVERSED(FIO_MAP_NAME, &map, i) { ++loop_test; }
    FIO_ASSERT(
        loop_test == count,
        "FIO_MAP_EACH_REVERSED failed to iterate all elements? (%zu != %zu",
        (size_t)loop_test != (size_t)count);
    /* test `evict` while we're here */
    FIO_NAME(FIO_MAP_NAME, evict)(&map, (count >> 1));
    FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == (count - (count >> 1)),
               "map `evict` count error %zu != %zu",
               (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
               (size_t)(count - (count >> 1)));
    /* cleanup */
    FIO_NAME(FIO_MAP_NAME, destroy)(&map);
  }
#ifndef FIO_MAP_HASH_FN
  { /* test full collision guard and zero hash*/
    FIO_NAME(FIO_MAP_NAME, s) map = FIO_MAP_INIT;
    fprintf(
        stderr,
        "* Testing full collision guard for " FIO_MACRO2STR(
            FIO_NAME(FIO_MAP_NAME, s)) " - expect SECURITY log messages.\n");
    for (size_t i = 1; i < 4096; ++i) {
      FIO_NAME(FIO_MAP_NAME, set)
      (&map, FIO___M_HASH(0) i FIO___M_VAL(i) FIO___M_OLD);
    }
    FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map),
               "zero hash fails insertion?");
    FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) <= FIO_MAP_ATTACK_LIMIT,
               "map attack guard failed? %zu != %zu",
               (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
               (size_t)FIO_MAP_ATTACK_LIMIT);
    FIO_NAME(FIO_MAP_NAME, destroy)(&map);
  }
#endif
  { /* test reserve, remove */
    FIO_NAME(FIO_MAP_NAME, s) map = FIO_MAP_INIT;
    FIO_NAME(FIO_MAP_NAME, reserve)(&map, 4096);
    FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, capa)(&map) == 4096,
               "map reserve error? %zu != %zu",
               (size_t)FIO_NAME(FIO_MAP_NAME, capa)(&map),
               4096);
    for (size_t i = 1; i < 4096; ++i) {
      FIO_NAME(FIO_MAP_NAME, set)
      (&map, FIO___M_HASH(i) i FIO___M_VAL(i) FIO___M_OLD);
      FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == i, "insertion failed?");
    }
    for (size_t i = 1; i < 4096; ++i) {
      FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, get)(&map, FIO___M_HASH(i) i),
                 "key missing?");
      FIO_NAME(FIO_MAP_NAME, remove)
      (&map, FIO___M_HASH(i) i, NULL);
      FIO_ASSERT(!FIO_NAME(FIO_MAP_NAME, get)(&map, FIO___M_HASH(i) i),
                 "map_remove error?");
      FIO_ASSERT(FIO_NAME(FIO_MAP_NAME, count)(&map) == 4095 - i,
                 "map count error after removal? %zu != %zu",
                 (size_t)FIO_NAME(FIO_MAP_NAME, count)(&map),
                 i);
    }
    FIO_NAME(FIO_MAP_NAME, destroy)(&map);
  }
}
#undef FIO___M_HASH
#undef FIO___M_VAL
#undef FIO___M_OLD

#endif /* FIO_MAP_TEST */
/* *****************************************************************************
Map Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */

#undef FIO_MAP_GET_T
#undef FIO_MAP_ARRAY_LOG_LIMIT
#undef FIO_MAP_ATTACK_LIMIT
#undef FIO_MAP_CAPA
#undef FIO_MAP_CUCKOO_STEPS
#undef FIO_MAP_HASH_FN
#undef FIO_MAP_IS_SPARSE
#undef FIO_MAP_KEY
#undef FIO_MAP_KEY_CMP
#undef FIO_MAP_KEY_COPY
#undef FIO_MAP_KEY_DESTROY
#undef FIO_MAP_KEY_DESTROY_SIMPLE
#undef FIO_MAP_KEY_DISCARD
#undef FIO_MAP_KEY_FROM_INTERNAL
#undef FIO_MAP_KEY_INTERNAL
#undef FIO_MAP_KEY_IS_GREATER_THAN
#undef FIO_MAP_LRU
#undef FIO_MAP_NAME
#undef FIO_MAP_ORDERED
#undef FIO_MAP_PTR
#undef FIO_MAP_RECALC_HASH
#undef FIO_MAP_SEEK_LIMIT
#undef FIO_MAP_T
#undef FIO_MAP_VALUE
#undef FIO_MAP_VALUE_BSTR
#undef FIO_MAP_VALUE_COPY
#undef FIO_MAP_VALUE_DESTROY
#undef FIO_MAP_VALUE_DESTROY_SIMPLE
#undef FIO_MAP_VALUE_DISCARD
#undef FIO_MAP_VALUE_FROM_INTERNAL
#undef FIO_MAP_VALUE_INTERNAL
#undef FIO_OMAP_NAME
#undef FIO_UMAP_NAME
#undef FIO_MAP_TEST

#endif /* FIO_MAP_NAME */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___       /* Development inclusion - ignore line */
#define FIO_LIST_NAME list /* Development inclusion - ignore line */
#include "./include.h"     /* Development inclusion - ignore line */
#endif                     /* Development inclusion - ignore line */
/* *****************************************************************************




                            Linked Lists (embeded)








Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */

/* *****************************************************************************
Linked Lists (embeded) - Type
***************************************************************************** */

#if defined(FIO_LIST_NAME)

#ifndef FIO_LIST_TYPE
/** Name of the list type and function prefix, defaults to FIO_LIST_NAME_s */
#define FIO_LIST_TYPE FIO_NAME(FIO_LIST_NAME, s)
#endif

#ifndef FIO_LIST_NODE_NAME
/** List types must contain at least one node element, defaults to `node`. */
#define FIO_LIST_NODE_NAME node
#endif

#ifdef FIO_PTR_TAG_TYPE
#define FIO_LIST_TYPE_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_LIST_TYPE_PTR FIO_LIST_TYPE *
#endif

/* *****************************************************************************
Linked Lists (embeded) - API
***************************************************************************** */

/** Initialize FIO_LIST_HEAD objects - already defined. */
/* FIO_LIST_INIT(obj) */

/** Returns a non-zero value if there are any linked nodes in the list. */
IFUNC int FIO_NAME(FIO_LIST_NAME, any)(const FIO_LIST_HEAD *head);

/** Returns a non-zero value if the list is empty. */
IFUNC int FIO_NAME_BL(FIO_LIST_NAME, empty)(const FIO_LIST_HEAD *head);

/** Removes a node from the list, Returns NULL if node isn't linked. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME, remove)(FIO_LIST_TYPE_PTR node);

/** Pushes an existing node to the end of the list. Returns node. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME,
                                 push)(FIO_LIST_HEAD *restrict head,
                                       FIO_LIST_TYPE_PTR restrict node);

/** Pops a node from the end of the list. Returns NULL if list is empty. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME, pop)(FIO_LIST_HEAD *head);

/** Adds an existing node to the beginning of the list. Returns node. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME,
                                 unshift)(FIO_LIST_HEAD *restrict head,
                                          FIO_LIST_TYPE_PTR restrict node);

/** Removed a node from the start of the list. Returns NULL if list is empty. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME, shift)(FIO_LIST_HEAD *head);

/** Returns a pointer to a list's element, from a pointer to a node. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME, root)(FIO_LIST_HEAD *ptr);

/* *****************************************************************************
Linked Lists (embeded) - Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/** Returns a non-zero value if there are any linked nodes in the list. */
IFUNC int FIO_NAME(FIO_LIST_NAME, any)(const FIO_LIST_HEAD *head) {
  FIO_PTR_TAG_VALID_OR_RETURN(head, 0);
  head = FIO_PTR_TAG_GET_UNTAGGED(FIO_LIST_HEAD, head);
  return head->next != head;
}

/** Returns a non-zero value if the list is empty. */
IFUNC int FIO_NAME_BL(FIO_LIST_NAME, empty)(const FIO_LIST_HEAD *head) {
  FIO_PTR_TAG_VALID_OR_RETURN(head, 0);
  head = FIO_PTR_TAG_GET_UNTAGGED(FIO_LIST_HEAD, head);
  return head->next == head;
}

/** Removes a node from the list, always returning the node. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME,
                                 remove)(FIO_LIST_TYPE_PTR node_) {
  FIO_PTR_TAG_VALID_OR_RETURN(node_, (FIO_LIST_TYPE_PTR)0);
  FIO_LIST_TYPE *node = (FIO_LIST_TYPE *)(FIO_PTR_UNTAG(node_));
  if (node->FIO_LIST_NODE_NAME.next == &node->FIO_LIST_NODE_NAME)
    return NULL;
  node->FIO_LIST_NODE_NAME.prev->next = node->FIO_LIST_NODE_NAME.next;
  node->FIO_LIST_NODE_NAME.next->prev = node->FIO_LIST_NODE_NAME.prev;
  node->FIO_LIST_NODE_NAME.next = node->FIO_LIST_NODE_NAME.prev =
      &node->FIO_LIST_NODE_NAME;
  return node_;
}

/** Pushes an existing node to the end of the list. Returns node or NULL. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME,
                                 push)(FIO_LIST_HEAD *restrict head,
                                       FIO_LIST_TYPE_PTR restrict node_) {
  FIO_PTR_TAG_VALID_OR_RETURN(head, (FIO_LIST_TYPE_PTR)NULL);
  FIO_PTR_TAG_VALID_OR_RETURN(node_, (FIO_LIST_TYPE_PTR)NULL);
  head = FIO_PTR_TAG_GET_UNTAGGED(FIO_LIST_HEAD, head);
  FIO_LIST_TYPE *restrict node = (FIO_LIST_TYPE *)(FIO_PTR_UNTAG(node_));
  node->FIO_LIST_NODE_NAME.prev = head->prev;
  node->FIO_LIST_NODE_NAME.next = head;
  head->prev->next = &node->FIO_LIST_NODE_NAME;
  head->prev = &node->FIO_LIST_NODE_NAME;
  return node_;
}

/** Pops a node from the end of the list. Returns NULL if list is empty. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME, pop)(FIO_LIST_HEAD *head) {
  FIO_PTR_TAG_VALID_OR_RETURN(head, (FIO_LIST_TYPE_PTR)NULL);
  head = FIO_PTR_TAG_GET_UNTAGGED(FIO_LIST_HEAD, head);
  return FIO_NAME(FIO_LIST_NAME, remove)(
      FIO_PTR_FROM_FIELD(FIO_LIST_TYPE, FIO_LIST_NODE_NAME, head->prev));
}

/** Adds an existing node to the beginning of the list. Returns node or NULL. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME,
                                 unshift)(FIO_LIST_HEAD *restrict head,
                                          FIO_LIST_TYPE_PTR restrict node) {
  FIO_PTR_TAG_VALID_OR_RETURN(head, (FIO_LIST_TYPE_PTR)NULL);
  FIO_PTR_TAG_VALID_OR_RETURN(node, (FIO_LIST_TYPE_PTR)NULL);
  head = FIO_PTR_TAG_GET_UNTAGGED(FIO_LIST_HEAD, head);
  return FIO_NAME(FIO_LIST_NAME, push)(head->next, node);
}

/** Removed a node from the start of the list. Returns NULL if list is empty. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME, shift)(FIO_LIST_HEAD *head) {
  FIO_PTR_TAG_VALID_OR_RETURN(head, (FIO_LIST_TYPE_PTR)NULL);
  head = FIO_PTR_TAG_GET_UNTAGGED(FIO_LIST_HEAD, head);
  return FIO_NAME(FIO_LIST_NAME, remove)(
      FIO_PTR_FROM_FIELD(FIO_LIST_TYPE, FIO_LIST_NODE_NAME, head->next));
}

/** Removed a node from the start of the list. Returns NULL if list is empty. */
IFUNC FIO_LIST_TYPE_PTR FIO_NAME(FIO_LIST_NAME, root)(FIO_LIST_HEAD *ptr) {
  FIO_PTR_TAG_VALID_OR_RETURN(ptr, (FIO_LIST_TYPE_PTR)NULL);
  ptr = FIO_PTR_TAG_GET_UNTAGGED(FIO_LIST_HEAD, ptr);
  return FIO_PTR_FROM_FIELD(FIO_LIST_TYPE, FIO_LIST_NODE_NAME, ptr);
}

/* *****************************************************************************
Linked Lists (embeded) - cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_LIST_NAME
#undef FIO_LIST_TYPE
#undef FIO_LIST_NODE_NAME
#undef FIO_LIST_TYPE_PTR
#endif
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___          /* Development inclusion - ignore line */
#define FIO_REF_NAME long_ref /* Development inclusion - ignore line */
#define FIO_REF_TYPE long     /* Development inclusion - ignore line */
#include "./include.h"        /* Development inclusion - ignore line */
#endif                        /* Development inclusion - ignore line */
/* *****************************************************************************




                      Reference Counting / Wrapper
                   (must be placed after all type macros)


Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#ifdef FIO_REF_NAME

#ifndef fio_atomic_add
#error FIO_REF_NAME requires enabling the FIO_ATOMIC extension.
#endif

#ifndef FIO_REF_TYPE
#define FIO_REF_TYPE FIO_NAME(FIO_REF_NAME, s)
#endif

#ifndef FIO_REF_INIT
#define FIO_REF_INIT(obj)                                                      \
  do {                                                                         \
    if (!FIO_MEM_REALLOC_IS_SAFE_)                                             \
      (obj) = (FIO_REF_TYPE){0};                                               \
  } while (0)
#endif

#ifndef FIO_REF_DESTROY
#define FIO_REF_DESTROY(obj)
#endif

#ifndef FIO_REF_METADATA_INIT
#ifdef FIO_REF_METADATA
#define FIO_REF_METADATA_INIT(meta)                                            \
  do {                                                                         \
    if (!FIO_MEM_REALLOC_IS_SAFE_)                                             \
      (meta) = (FIO_REF_METADATA){0};                                          \
  } while (0)
#else
#define FIO_REF_METADATA_INIT(meta)
#endif
#endif

#ifndef FIO_REF_METADATA_DESTROY
#define FIO_REF_METADATA_DESTROY(meta)
#endif

/**
 * FIO_REF_CONSTRUCTOR_ONLY allows the reference counter constructor (TYPE_new)
 * to be the only constructor function.
 *
 * When set, the reference counting functions will use `X_new` and `X_free`.
 * Otherwise (assuming `X_new` and `X_free` are already defined), the reference
 * counter will define `X_new2` and `X_free2` instead.
 */
#ifdef FIO_REF_CONSTRUCTOR_ONLY
#define FIO_REF_CONSTRUCTOR new
#define FIO_REF_DESTRUCTOR  free
#define FIO_REF_DUPNAME     dup
#else
#define FIO_REF_CONSTRUCTOR new2
#define FIO_REF_DESTRUCTOR  free2
#define FIO_REF_DUPNAME     dup2
#endif

typedef struct {
  volatile size_t ref;
#ifdef FIO_REF_METADATA
  FIO_REF_METADATA metadata;
#endif
} FIO_NAME(FIO_REF_NAME, _wrapper_s);

#ifdef FIO_PTR_TAG_TYPE
#define FIO_REF_TYPE_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_REF_TYPE_PTR FIO_REF_TYPE *
#endif

/* *****************************************************************************
Reference Counter (Wrapper) API
***************************************************************************** */

/** Allocates a reference counted object. */
#ifdef FIO_REF_FLEX_TYPE
IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME,
                                FIO_REF_CONSTRUCTOR)(size_t members);
#else
IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME, FIO_REF_CONSTRUCTOR)(void);
#endif /* FIO_REF_FLEX_TYPE */

/** Increases the reference count. */
FIO_IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME,
                                    FIO_REF_DUPNAME)(FIO_REF_TYPE_PTR wrapped);

/** Frees a reference counted object (or decreases the reference count). */
IFUNC void FIO_NAME(FIO_REF_NAME, FIO_REF_DESTRUCTOR)(FIO_REF_TYPE_PTR wrapped);

#ifdef FIO_REF_METADATA
/** Returns a pointer to the object's metadata, if defined. */
IFUNC FIO_REF_METADATA *FIO_NAME(FIO_REF_NAME,
                                 metadata)(FIO_REF_TYPE_PTR wrapped);
#endif

/* *****************************************************************************
Inline Implementation
***************************************************************************** */
/** Increases the reference count. */
FIO_IFUNC FIO_REF_TYPE_PTR
FIO_NAME(FIO_REF_NAME, FIO_REF_DUPNAME)(FIO_REF_TYPE_PTR wrapped_) {
  FIO_REF_TYPE *wrapped = (FIO_REF_TYPE *)(FIO_PTR_UNTAG(wrapped_));
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      ((FIO_NAME(FIO_REF_NAME, _wrapper_s) *)wrapped) - 1;
  if (!o)
    return wrapped_;
  fio_atomic_add(&o->ref, 1);
  return wrapped_;
}

/** Debugging helper, do not use for data, as returned value is unstable. */
FIO_IFUNC size_t FIO_NAME(FIO_REF_NAME, references)(FIO_REF_TYPE_PTR wrapped_) {
  FIO_REF_TYPE *wrapped = (FIO_REF_TYPE *)(FIO_PTR_UNTAG(wrapped_));
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      ((FIO_NAME(FIO_REF_NAME, _wrapper_s) *)wrapped) - 1;
  if (!o)
    return 0;
  return o->ref;
}

/* *****************************************************************************
Reference Counter (Wrapper) Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

#if defined(DEBUG) || defined(FIO_LEAK_COUNTER)
static size_t FIO_NAME(FIO_REF_NAME, ___leak_tester);
#undef FIO___REF_ON_ALLOC
#define FIO___REF_ON_ALLOC()                                                   \
  fio_atomic_add(&FIO_NAME(FIO_REF_NAME, ___leak_tester), 1)
#undef FIO___REF_ON_FREE
#define FIO___REF_ON_FREE()                                                    \
  fio_atomic_sub(&FIO_NAME(FIO_REF_NAME, ___leak_tester), 1)

FIO_DESTRUCTOR(FIO_NAME(FIO_REF_NAME, ___leak_test)) {
  if (FIO_NAME(FIO_REF_NAME, ___leak_tester)) {
    FIO_LOG_ERROR(
        "(" FIO_MACRO2STR(FIO_REF_NAME) "):\n          "
                                        "%zd memory leak(s) detected for "
                                        "type: " FIO_MACRO2STR(FIO_REF_TYPE),
        FIO_NAME(FIO_REF_NAME, ___leak_tester));
  }
}
#else
#undef FIO___REF_ON_ALLOC
#define FIO___REF_ON_ALLOC()
#undef FIO___REF_ON_FREE
#define FIO___REF_ON_FREE()
#endif /* defined(DEBUG) || defined(FIO_LEAK_COUNTER) */

/** Allocates a reference counted object. */
#ifdef FIO_REF_FLEX_TYPE
IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME,
                                FIO_REF_CONSTRUCTOR)(size_t members) {
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      (FIO_NAME(FIO_REF_NAME, _wrapper_s) *)FIO_MEM_REALLOC_(
          NULL,
          0,
          sizeof(*o) + sizeof(FIO_REF_TYPE) +
              (sizeof(FIO_REF_FLEX_TYPE) * members),
          0);
#else
IFUNC FIO_REF_TYPE_PTR FIO_NAME(FIO_REF_NAME, FIO_REF_CONSTRUCTOR)(void) {
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o = (FIO_NAME(FIO_REF_NAME, _wrapper_s) *)
      FIO_MEM_REALLOC_(NULL, 0, sizeof(*o) + sizeof(FIO_REF_TYPE), 0);
#endif /* FIO_REF_FLEX_TYPE */
  if (!o)
    return (FIO_REF_TYPE_PTR)(o);
  FIO___REF_ON_ALLOC();
  o->ref = 1;
  FIO_REF_METADATA_INIT((o->metadata));
  FIO_REF_TYPE *ret = (FIO_REF_TYPE *)(o + 1);
  FIO_REF_INIT((ret[0]));
  return (FIO_REF_TYPE_PTR)(FIO_PTR_TAG(ret));
  (void)FIO_NAME(FIO_REF_NAME, references);
}

/** Frees a reference counted object (or decreases the reference count). */
IFUNC void FIO_NAME(FIO_REF_NAME,
                    FIO_REF_DESTRUCTOR)(FIO_REF_TYPE_PTR wrapped_) {
  FIO_REF_TYPE *wrapped = (FIO_REF_TYPE *)(FIO_PTR_UNTAG(wrapped_));
  if (!wrapped || !wrapped_)
    return;
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(wrapped_);
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      ((FIO_NAME(FIO_REF_NAME, _wrapper_s) *)wrapped) - 1;
  if (!o)
    return;
  if (fio_atomic_sub_fetch(&o->ref, 1))
    return;
  FIO_REF_DESTROY((wrapped[0]));
  FIO_REF_METADATA_DESTROY((o->metadata));
  FIO_MEM_FREE_(o, sizeof(*o) + sizeof(FIO_REF_TYPE));
  FIO___REF_ON_FREE();
}

#ifdef FIO_REF_METADATA
/** Returns a pointer to the object's metadata, if defined. */
IFUNC FIO_REF_METADATA *FIO_NAME(FIO_REF_NAME,
                                 metadata)(FIO_REF_TYPE_PTR wrapped_) {
  FIO_REF_TYPE *wrapped = (FIO_REF_TYPE *)(FIO_PTR_UNTAG(wrapped_));
  FIO_NAME(FIO_REF_NAME, _wrapper_s) *o =
      ((FIO_NAME(FIO_REF_NAME, _wrapper_s) *)wrapped) - 1;
  return &o->metadata;
}
#endif

/* *****************************************************************************
Reference Counter (Wrapper) Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_REF_NAME
#undef FIO_REF_FLEX_TYPE
#undef FIO_REF_TYPE
#undef FIO_REF_INIT
#undef FIO_REF_DESTROY
#undef FIO_REF_METADATA
#undef FIO_REF_METADATA_INIT
#undef FIO_REF_METADATA_DESTROY
#undef FIO_REF_TYPE_PTR
#undef FIO_REF_CONSTRUCTOR_ONLY
#undef FIO_REF_CONSTRUCTOR
#undef FIO_REF_DUPNAME
#undef FIO_REF_DESTRUCTOR
#endif
/* *****************************************************************************
Pointer Tagging Cleanup
***************************************************************************** */
#ifndef FIO___DEV___
#undef FIO_PTR_TAG
#undef FIO_PTR_UNTAG
#undef FIO_PTR_TAG_TYPE
#undef FIO_PTR_TAG_VALIDATE
#undef FIO_PTR_TAG_VALID_OR_RETURN
#undef FIO_PTR_TAG_VALID_OR_RETURN_VOID
#undef FIO_PTR_TAG_VALID_OR_GOTO
#endif
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___         /* Development inclusion - ignore line */
#define FIO_SORT_NAME num    /* Development inclusion - ignore line */
#define FIO_SORT_TYPE size_t /* Development inclusion - ignore line */
#include "./include.h"       /* Development inclusion - ignore line */
#endif                       /* Development inclusion - ignore line */
/* *****************************************************************************




                          A Good Enough Sorting Helper



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#ifdef FIO_SORT_NAME

/* *****************************************************************************
Sort Settings
***************************************************************************** */

#ifndef FIO_SORT_TYPE
#error FIO_SORT_TYPE must contain a valid type name!
#endif

#ifndef FIO_SORT_THRESHOLD
/** The default threshold below which quicksort delegates to insert sort. */
#define FIO_SORT_THRESHOLD 96
#endif

#ifndef FIO_SORT_SWAP
/** Default swap operation assumes an array and swaps array members */
#define FIO_SORT_SWAP(a, b)                                                    \
  do {                                                                         \
    FIO_SORT_TYPE tmp__ = (a);                                                 \
    (a) = (b);                                                                 \
    (b) = tmp__;                                                               \
  } while (0)
#endif

#ifndef FIO_SORT_IS_BIGGER
/** MUST evaluate as 1 if a > b (zero if equal or smaller). */
#define FIO_SORT_IS_BIGGER(a, b) ((a) > (b))
#endif

/* *****************************************************************************
Sort API
***************************************************************************** */

/* Sorts a `FIO_SORT_TYPE` array with `count` members (quicksort). */
FIO_IFUNC void FIO_NAME(FIO_SORT_NAME, sort)(FIO_SORT_TYPE *array,
                                             size_t count);

/* Insert sort, for small arrays of `FIO_SORT_TYPE`. */
SFUNC void FIO_NAME(FIO_SORT_NAME, isort)(FIO_SORT_TYPE *array, size_t count);

/* Quick sort, for larger arrays of `FIO_SORT_TYPE`. */
SFUNC void FIO_NAME(FIO_SORT_NAME, qsort)(FIO_SORT_TYPE *array, size_t count);

/* *****************************************************************************
Sort Implementation - inlined static functions
see ideas from: https://youtu.be/FJJTYQYB1JQ
***************************************************************************** */

/* Sorts a `FIO_SORT_TYPE` array with `count` members (quicksort). */
FIO_IFUNC void FIO_NAME(FIO_SORT_NAME, sort)(FIO_SORT_TYPE *array,
                                             size_t count) {
  FIO_NAME(FIO_SORT_NAME, qsort)(array, count);
}

/* *****************************************************************************
Sort Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* Insert sort, for small arrays of `FIO_SORT_TYPE`. */
SFUNC void FIO_NAME(FIO_SORT_NAME, isort)(FIO_SORT_TYPE *array, size_t count) {
  /* a fast(ish) small sort on small arrays */
  if ((!count | !array))
    return;
  if (count < 3) { /* special case */
    if (FIO_SORT_IS_BIGGER((array[0]), (array[count == 2])))
      FIO_SORT_SWAP((array[0]), (array[1]));
    return;
  }
  /* place smallest item in position array[0] (guard element) */
  for (size_t pos = 1; pos < count; ++pos) {
    if (FIO_SORT_IS_BIGGER((array[0]), (array[pos]))) {
      FIO_SORT_SWAP((array[0]), (array[pos]));
    }
  }
  /* perform insert sort */
  for (size_t i = 2; i < count; ++i) {
    for (size_t a = i - 1; FIO_SORT_IS_BIGGER((array[a]), (array[a + 1]));
         --a) {
      FIO_SORT_SWAP((array[a]), (array[a + 1]));
    }
  }
}

/* Sorts a `FIO_SORT_TYPE` array with `count` members. */
SFUNC void FIO_NAME(FIO_SORT_NAME, qsort)(FIO_SORT_TYPE *array, size_t count) {
  /* With thanks to Douglas C. Schmidt, as I used his code for reference:
   * https://code.woboq.org/userspace/glibc/stdlib/qsort.c.html
   */
  if ((!count | !array))
    return;
  if (count < FIO_SORT_THRESHOLD) {
    FIO_NAME(FIO_SORT_NAME, isort)(array, count);
    return;
  }
  /* no recursion, setup a stack that can hold log2(count). */
  struct {
    FIO_SORT_TYPE *lo;
    FIO_SORT_TYPE *hi;
  } queue[CHAR_BIT * sizeof(count) + 1], *top = queue;
#define fio_sort___queue_push(l, h)                                            \
  top->lo = l;                                                                 \
  top->hi = h;                                                                 \
  ++top;
  /* push all the array as the first queued partition */
  fio_sort___queue_push(array, array + (count - 1));
  for (;;) {
    FIO_SORT_TYPE *lo;
    FIO_SORT_TYPE *hi;
    FIO_SORT_TYPE *mid;
    --top; /* pop stack */
    lo = top->lo;
    hi = top->hi;
    const size_t slice_len = (hi - lo) + 1;

    /* sort small ranges using insert sort */
    if (slice_len < FIO_SORT_THRESHOLD) {
      FIO_NAME(FIO_SORT_NAME, isort)(lo, slice_len);
      if (queue == top)
        return;
      continue;
    }

    /* select a median element (1 of 3, fist, middle, last). */
    /* this also promises ordering between these 3 elements. */
    mid = lo + ((slice_len) >> 1);
    if (FIO_SORT_IS_BIGGER((lo[0]), (hi[0])))
      FIO_SORT_SWAP((lo[0]), (hi[0]));
    if (FIO_SORT_IS_BIGGER((lo[0]), (mid[0])))
      FIO_SORT_SWAP((lo[0]), (mid[0]));
    else if (FIO_SORT_IS_BIGGER((mid[0]), (hi[0])))
      FIO_SORT_SWAP((hi[0]), (mid[0]));

    /* partition: swap elements and pointers so mid is a partition pivot */
    FIO_SORT_TYPE *left = lo + 1;
    FIO_SORT_TYPE *right = hi - 2;
    /* place mid in the lower partition and update pointer, as it's known */
    FIO_SORT_SWAP((right[1]), (mid[0]));
    mid = right + 1;
    for (;;) {
      /* while order is fine, move on. */
      while (FIO_SORT_IS_BIGGER((mid[0]), (left[0])))
        ++left;
      while (FIO_SORT_IS_BIGGER((right[0]), (mid[0])))
        --right;
      /* order issue encountered (relative to pivot / mid)... */
      if (left < right) {
        /* right now, left is bigger than mid *and* right is smaller... swap. */
        FIO_SORT_SWAP(left[0], right[0]);
        ++left;
        --right;
        continue;
      }
      /* we passed the middle point and so, we can finish partitioning */
      if (left > right)
        break;
      /* left == right (odd numbered array) */
      ++left;
      --right;
      break;
    }
    /* push partitions in order of size to the stack (clears smaller first) */
    if ((right - lo) > (hi - left)) {
      fio_sort___queue_push(lo, right);
      fio_sort___queue_push(left, hi);
    } else {
      fio_sort___queue_push(left, hi);
      fio_sort___queue_push(lo, right);
    }
  }
}
#undef fio_sort___queue_push
/* *****************************************************************************
Testing
***************************************************************************** */
#if defined(FIO_TEST_CSTL) && defined(FIO_SORT_TEST)

FIO_SFUNC int FIO_NAME(fio_qsort___cmp, FIO_SORT_NAME)(FIO_SORT_TYPE *a,
                                                       FIO_SORT_TYPE *b) {
  return (int)(a[0] - b[0]);
}

FIO_SFUNC void FIO_NAME_TEST(stl, FIO_NAME(sort, FIO_SORT_NAME))(void) {
  fprintf(stderr, "* Testing facil.io array sort helper:\n");
  { /* test insert sort of short array */
    size_t mixed[] = {19, 23, 28, 21, 3,  10, 7, 2,  13, 4,  15,
                      29, 26, 16, 24, 22, 11, 5, 14, 31, 25, 8,
                      12, 18, 20, 17, 1,  27, 9, 0,  6,  30};
    size_t ordered[] = {19, 23, 28, 21, 3,  10, 7, 2,  13, 4,  15,
                        29, 26, 16, 24, 22, 11, 5, 14, 31, 25, 8,
                        12, 18, 20, 17, 1,  27, 9, 0,  6,  30};
    const size_t len =
        (sizeof(ordered) / sizeof(ordered[0])) > FIO_SORT_THRESHOLD
            ? FIO_SORT_THRESHOLD
            : (sizeof(ordered) / sizeof(ordered[0]));
    qsort(ordered,
          len,
          sizeof(ordered[0]),
          (int (*)(const void *, const void *))FIO_NAME(fio_qsort___cmp,
                                                        FIO_SORT_NAME));
    FIO_NAME(FIO_SORT_NAME, isort)(mixed, len);
    FIO_ASSERT(!memcmp(mixed, ordered, sizeof(*ordered) * len),
               "short sort failed!");
    clock_t start, end;
    start = clock();
    for (size_t i = 0; i < (1UL << 16); ++i) {
      FIO_COMPILER_GUARD;
      FIO_NAME(FIO_SORT_NAME, sort)(mixed, len);
    }
    end = clock();
    fprintf(stderr,
            "\t* facil.io small sorted test cycles:          %zu\n",
            (size_t)(end - start));
    start = clock();
    for (size_t i = 0; i < (1UL << 16); ++i) {
      FIO_COMPILER_GUARD;
      qsort(mixed,
            len,
            sizeof(mixed[0]),
            (int (*)(const void *, const void *))FIO_NAME(fio_qsort___cmp,
                                                          FIO_SORT_NAME));
    }
    end = clock();
    fprintf(stderr,
            "\t* clib     small sorted test cycles:          %zu\n",
            (size_t)(end - start));
  }
  { /* test quick sort of an array with (1ULL << 18) elements */
    const size_t len = (1ULL << 18);
    size_t *mem =
        (size_t *)FIO_MEM_REALLOC(NULL, 0, (sizeof(*mem) * (len << 1)), 0);
    for (size_t i = 0; i < len; ++i) {
      mem[i] = mem[len + i] = (size_t)rand();
    }
    FIO_NAME(FIO_SORT_NAME, sort)(mem, len);
    qsort(mem + len,
          len,
          sizeof(mem[0]),
          (int (*)(const void *, const void *))FIO_NAME(fio_qsort___cmp,
                                                        FIO_SORT_NAME));
    if (memcmp(mem, mem + len, (sizeof(mem[0]) * len))) {
      size_t i = 0;
      while (mem[i] == mem[len + i] && i < len)
        ++i;
      FIO_ASSERT(0, "fio_sort != clib qsort first error at index %zu", i);
    }
    clock_t start, end, fio_clk = 0, lib_clk = 0;
    for (int count = 0; count < 8; ++count) {
      for (size_t i = 0; i < len; ++i) {
        mem[i] = mem[len + i] = (size_t)rand();
      }
      start = clock();
      FIO_NAME(FIO_SORT_NAME, sort)(mem, len);
      end = clock();
      fio_clk += end - start;
      start = clock();
      qsort(mem + len,
            len,
            sizeof(mem[0]),
            (int (*)(const void *, const void *))FIO_NAME(fio_qsort___cmp,
                                                          FIO_SORT_NAME));
      end = clock();
      lib_clk += end - start;
      FIO_ASSERT(!memcmp(mem, mem + len, (sizeof(mem[0]) * len)),
                 "fio_sort != clib qsort (iteration %zu)",
                 count);
    }
    FIO_MEM_FREE(mem, (sizeof(*mem) * (len << 1)));

    fprintf(stderr,
            "\t* facil.io random quick sort test cycles:     %zu\n",
            (size_t)fio_clk);
    fprintf(stderr,
            "\t* clib     random quick sort test cycles:     %zu\n",
            (size_t)lib_clk);
  }
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_SORT_THRESHOLD
#undef FIO_SORT_TYPE
#undef FIO_SORT_TEST
#undef FIO_SORT_SWAP
#undef FIO_SORT_IS_BIGGER
#undef FIO_SORT_NAME
#endif /* FIO_SORT_NAME */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_CLI        /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                  CLI helpers - command line interface parsing


Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_CLI) && !defined(H___FIO_CLI___H) && !defined(FIO_STL_KEEP__)
#define H___FIO_CLI___H 1

/* *****************************************************************************
Internal Macro Implementation
***************************************************************************** */

/** Used internally. */
#define FIO_CLI_STRING__TYPE_I       0x1
#define FIO_CLI_BOOL__TYPE_I         0x2
#define FIO_CLI_INT__TYPE_I          0x3
#define FIO_CLI_PRINT__TYPE_I        0x4
#define FIO_CLI_PRINT_LINE__TYPE_I   0x5
#define FIO_CLI_PRINT_HEADER__TYPE_I 0x6

/** Indicates the CLI argument should be a String (default). */
#define FIO_CLI_STRING(line) (line), ((char *)FIO_CLI_STRING__TYPE_I)
/** Indicates the CLI argument is a Boolean value. */
#define FIO_CLI_BOOL(line) (line), ((char *)FIO_CLI_BOOL__TYPE_I)
/** Indicates the CLI argument should be an Integer (numerical). */
#define FIO_CLI_INT(line) (line), ((char *)FIO_CLI_INT__TYPE_I)
/** Indicates the CLI string should be printed as is with proper offset. */
#define FIO_CLI_PRINT(line) (line), ((char *)FIO_CLI_PRINT__TYPE_I)
/** Indicates the CLI string should be printed as is with no offset. */
#define FIO_CLI_PRINT_LINE(line) (line), ((char *)FIO_CLI_PRINT_LINE__TYPE_I)
/** Indicates the CLI string should be printed as a header. */
#define FIO_CLI_PRINT_HEADER(line)                                             \
  (line), ((char *)FIO_CLI_PRINT_HEADER__TYPE_I)

/* *****************************************************************************
CLI API
***************************************************************************** */

/**
 * This function parses the Command Line Interface (CLI), creating a temporary
 * "dictionary" that allows easy access to the CLI using their names or aliases.
 *
 * Command line arguments may be typed. If an optional type requirement is
 * provided and the provided arument fails to match the required type, execution
 * will end and an error message will be printed along with a short "help".
 *
 * The function / macro accepts the following arguments:
 * - `argc`: command line argument count.
 * - `argv`: command line argument list (array).
 * - `unnamed_min`: the required minimum of un-named arguments.
 * - `unnamed_max`: the maximum limit of un-named arguments.
 * - `description`: a C string containing the program's description.
 * - named arguments list: a list of C strings describing named arguments.
 *
 * The following optional type requirements are:
 *
 * * FIO_CLI_STRING(desc_line)       - (default) string argument.
 * * FIO_CLI_BOOL(desc_line)         - boolean argument (no value).
 * * FIO_CLI_INT(desc_line)          - integer argument.
 * * FIO_CLI_PRINT_HEADER(desc_line) - extra header for output.
 * * FIO_CLI_PRINT(desc_line)        - extra information for output.
 *
 * Argument names MUST start with the '-' character. The first word starting
 * without the '-' character will begin the description for the CLI argument.
 *
 * The arguments "-?", "-h", "-help" and "--help" are automatically handled
 * unless overridden.
 *
 * Un-named arguments shouldn't be listed in the named arguments list.
 *
 * Example use:
 *
 *    fio_cli_start(argc, argv, 0, 0, "The NAME example accepts the following:",
 *                  FIO_CLI_PRINT_HREADER("Concurrency:"),
 *                  FIO_CLI_INT("-t -thread number of threads to run."),
 *                  FIO_CLI_INT("-w -workers number of workers to run."),
 *                  FIO_CLI_PRINT_HREADER("Address Binding:"),
 *                  "-b, -address the address to bind to.",
 *                  FIO_CLI_INT("-p,-port the port to bind to."),
 *                  FIO_CLI_PRINT("\t\tset port to zero (0) for Unix s."),
 *                  FIO_CLI_PRINT_HREADER("Logging:"),
 *                  FIO_CLI_BOOL("-v -log enable logging."));
 *
 *
 * This would allow access to the named arguments:
 *
 *      fio_cli_get("-b") == fio_cli_get("-address");
 *
 *
 * Once all the data was accessed, free the parsed data dictionary using:
 *
 *      fio_cli_end();
 *
 * It should be noted, arguments will be recognized in a number of forms, i.e.:
 *
 *      app -t=1 -p3000 -a localhost
 *
 * This function is NOT thread safe.
 */
#define fio_cli_start(argc, argv, unnamed_min, unnamed_max, description, ...)  \
  fio_cli_start((argc),                                                        \
                (argv),                                                        \
                (unnamed_min),                                                 \
                (unnamed_max),                                                 \
                (description),                                                 \
                (char const *[]){__VA_ARGS__, (char const *)NULL})
/**
 * Never use the function directly, always use the MACRO, because the macro
 * attaches a NULL marker at the end of the `names` argument collection.
 */
SFUNC void fio_cli_start FIO_NOOP(int argc,
                                  char const *argv[],
                                  int unnamed_min,
                                  int unnamed_max,
                                  char const *description,
                                  char const **names);
/**
 * Clears the memory used by the CLI dictionary, removing all parsed data.
 *
 * This function is NOT thread safe.
 */
SFUNC void fio_cli_end(void);

/** Returns the argument's value as a NUL terminated C String. */
SFUNC char const *fio_cli_get(char const *name);

/** Returns the argument's value as an integer. */
SFUNC int fio_cli_get_i(char const *name);

/** This MACRO returns the argument's value as a boolean. */
#define fio_cli_get_bool(name) (fio_cli_get((name)) != NULL)

/** Returns the number of unnamed argument. */
SFUNC unsigned int fio_cli_unnamed_count(void);

/** Returns the unnamed argument using a 0 based `index`. */
SFUNC char const *fio_cli_unnamed(unsigned int index);

/**
 * Sets the argument's value as a NUL terminated C String (no copy!).
 *
 * CAREFUL: This does not automatically detect aliases or type violations! it
 * will only effect the specific name given, even if invalid. i.e.:
 *
 *     fio_cli_start(argc, argv,
 *                  "this is example accepts the following options:",
 *                  "-p -port the port to bind to", FIO_CLI_INT;
 *
 *     fio_cli_set("-p", "hello"); // fio_cli_get("-p") != fio_cli_get("-port");
 *
 * Note: this does NOT copy the C strings to memory. Memory should be kept alive
 *       until `fio_cli_end` is called.
 *
 * This function is NOT thread safe.
 */
SFUNC void fio_cli_set(char const *name, char const *value);

/** Sets an unrecognized argument at a 0 based `index`. */
SFUNC void fio_cli_unnamed_set(unsigned int index, char const *value);

/**
 * This MACRO is the same as:
 *
 *     if(!fio_cli_get(name)) {
 *       fio_cli_set(name, value)
 *     }
 *
 * See fio_cli_set for notes and restrictions.
 */
#define fio_cli_set_default(name, value)                                       \
  if (!fio_cli_get((name)))                                                    \
    fio_cli_set(name, value);

/* *****************************************************************************
CLI Implementation
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
CLI Data Stores
***************************************************************************** */

typedef struct {
  const char *buf;
  size_t len;
} fio___cli_cstr_s;

#define FIO_RISKY_HASH
#define FIO_UMAP_NAME fio___cli_hash
#define FIO_MAP_VALUE const char *
#define FIO_MAP_KEY   fio___cli_cstr_s
#define FIO_MAP_KEY_CMP(o1, o2)                                                \
  (o1.len == o2.len &&                                                         \
   (!o1.len || o1.buf == o2.buf ||                                             \
    (o1.buf && o2.buf && !FIO_MEMCMP(o1.buf, o2.buf, o1.len))))
#define FIO_MAP_HASH_FN(s)                                                     \
  ((s).buf                                                                     \
       ? fio_risky_hash((s).buf, (s).len, (uint64_t)(uintptr_t)fio_cli_start)  \
       : ((s).len ^ ((s).len << 19)))
#define FIO_STL_KEEP__
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

static fio___cli_hash_s fio___cli_aliases = FIO_MAP_INIT;
static fio___cli_hash_s fio___cli_values = FIO_MAP_INIT;
static size_t fio___cli_unnamed_count = 0;

typedef struct {
  int unnamed_min;
  int unnamed_max;
  int pos;
  int unnamed_count;
  int argc;
  char const **argv;
  char const *description;
  char const **names;
} fio_cli_parser_data_s;

/* *****************************************************************************
Default parameter storage
***************************************************************************** */

typedef struct {
  FIO_LIST_NODE node;
  size_t len;
  char buf[];
} fio___cli_def_str_s;

/* A linked list linking default values */
static FIO_LIST_HEAD fio___cli_default_values;

/** extracts the "default" marker from a string's line */
FIO_SFUNC fio___cli_cstr_s fio___cli_map_line2default(char const *line) {
  fio___cli_cstr_s n = {.buf = line};
  /* skip aliases */
  while (n.buf[n.len] == '-') {
    while (n.buf[n.len] && n.buf[n.len] != ' ' && n.buf[n.len] != ',')
      ++n.len;
    while (n.buf[n.len] && (n.buf[n.len] == ' ' || n.buf[n.len] == ',')) {
      ++n.len;
    }
    n.buf += n.len;
    n.len = 0;
  }
  /* a default is made with (value) or ("value"), both escapable with '\\' */
  if (n.buf[0] != '(')
    goto no_default;
  ++n.buf;
  if (n.buf[0] == '"') {
    ++n.buf;
    /* seek default value end with `")` */
    while (n.buf[n.len] && !(n.buf[n.len] == '"' && n.buf[n.len + 1] == ')'))
      ++n.len;
    if ((n.buf[n.len] != '"' || n.buf[n.len + 1] != ')'))
      goto no_default;
  } else {
    /* seek default value end with `)` */
    while (n.buf[n.len] && n.buf[n.len] != ')')
      ++n.len;
    if (n.buf[n.len] != ')')
      goto no_default;
  }

  return n;
no_default:
  n.buf = NULL;
  n.len = 0;
  return n;
}

FIO_IFUNC fio___cli_cstr_s fio___cli_map_store_default(fio___cli_cstr_s d) {
  fio___cli_cstr_s val = {.buf = NULL, .len = 0};
  if (!d.len || !d.buf)
    return val;
  fio___cli_def_str_s *str = (fio___cli_def_str_s *)
      FIO_MEM_REALLOC_(NULL, 0, (sizeof(*str) + d.len + 1), 0);
  FIO_ASSERT_ALLOC(str);
  FIO_LIST_PUSH(&fio___cli_default_values, &str->node);
  val.buf = str->buf;
  str->len = val.len = d.len;
  str->buf[str->len] = 0;
  FIO_MEMCPY((char *)val.buf, d.buf, val.len);
  FIO_LOG_DEBUG("CLI stored a string: %s (%zu bytes)", str->buf, str->len);
  return val;
}

/* *****************************************************************************
CLI Parsing
***************************************************************************** */

FIO_SFUNC void fio___cli_map_line2alias(char const *line) {
  fio___cli_cstr_s n = {.buf = line};
  /* if a line contains a default value, store that value with the aliases. */
  fio___cli_cstr_s def =
      fio___cli_map_store_default(fio___cli_map_line2default(line));
  while (n.buf[0] == '-') {
    while (n.buf[n.len] && n.buf[n.len] != ' ' && n.buf[n.len] != ',') {
      ++n.len;
    }
    const char *old = NULL;
    fio___cli_hash_set(&fio___cli_aliases, n, (char const *)line, &old);
    if (def.buf) {
      fio___cli_hash_set(&fio___cli_values, n, def.buf, NULL);
    }
#ifdef FIO_LOG_ERROR
    if (old) {
      FIO_LOG_ERROR("CLI argument name conflict detected\n"
                    "         The following two directives conflict:\n"
                    "\t%s\n\t%s\n",
                    old,
                    line);
    }
#endif
    while (n.buf[n.len] && (n.buf[n.len] == ' ' || n.buf[n.len] == ',')) {
      ++n.len;
    }
    n.buf += n.len;
    n.len = 0;
  }
}

FIO_SFUNC char const *fio___cli_get_line_type(fio_cli_parser_data_s *parser,
                                              const char *line) {
  if (!line) {
    return NULL;
  }
  char const **pos = parser->names;
  while (*pos) {
    switch ((intptr_t)*pos) {
    case FIO_CLI_STRING__TYPE_I:     /* fall through */
    case FIO_CLI_BOOL__TYPE_I:       /* fall through */
    case FIO_CLI_INT__TYPE_I:        /* fall through */
    case FIO_CLI_PRINT__TYPE_I:      /* fall through */
    case FIO_CLI_PRINT_LINE__TYPE_I: /* fall through */
    case FIO_CLI_PRINT_HEADER__TYPE_I: /* fall through */ ++pos; continue;
    }
    if (line == *pos) {
      goto found;
    }
    ++pos;
  }
  return NULL;
found:
  switch ((size_t)pos[1]) {
  case FIO_CLI_STRING__TYPE_I:     /* fall through */
  case FIO_CLI_BOOL__TYPE_I:       /* fall through */
  case FIO_CLI_INT__TYPE_I:        /* fall through */
  case FIO_CLI_PRINT__TYPE_I:      /* fall through */
  case FIO_CLI_PRINT_LINE__TYPE_I: /* fall through */
  case FIO_CLI_PRINT_HEADER__TYPE_I: /* fall through */ return pos[1];
  }
  return NULL;
}

FIO_SFUNC void fio___cli_print_line(char const *desc, char const *name) {
  char buf[1024];
  size_t pos = 0;
  while (name[0] == '.' || name[0] == '/')
    ++name;
  while (*desc) {
    if (desc[0] == 'N' && desc[1] == 'A' && desc[2] == 'M' && desc[3] == 'E') {
      buf[pos++] = 0;
      desc += 4;
      fprintf(stderr, "%s%s", buf, name);
      pos = 0;
    } else {
      buf[pos++] = *desc;
      ++desc;
      if (pos >= 980) {
        buf[pos++] = 0;
        fwrite(buf, pos, sizeof(*buf), stderr);
        pos = 0;
      }
    }
  }
  if (pos)
    fwrite(buf, pos, sizeof(*buf), stderr);
}

FIO_SFUNC void fio___cli_set_arg(fio___cli_cstr_s arg,
                                 char const *value,
                                 char const *line,
                                 fio_cli_parser_data_s *parser) {
  char const *type = NULL;
  /* handle unnamed argument */
  if (!line || !arg.len) {
    if (!value) {
      goto print_help;
    }
    if (!strcmp(value, "-?") || !strcasecmp(value, "-h") ||
        !strcasecmp(value, "-help") || !strcasecmp(value, "--help")) {
      goto print_help;
    }
    fio___cli_cstr_s n = {.len = (size_t)++parser->unnamed_count};
    fio___cli_hash_set(&fio___cli_values, n, value, NULL);
    if (parser->unnamed_max >= 0 &&
        parser->unnamed_count > parser->unnamed_max) {
      arg.len = 0;
      goto error;
    }
    FIO_LOG_DEBUG2("(CLI) set an unnamed argument: %s", value);
    FIO_ASSERT_DEBUG(fio___cli_hash_get(&fio___cli_values, n) == value,
                     "(CLI) set argument failed!");
    return;
  }

  /* validate data types */
  type = fio___cli_get_line_type(parser, line);
  switch ((size_t)type) {
  case FIO_CLI_BOOL__TYPE_I:
    if (value && value != parser->argv[parser->pos + 1]) {
      while (*value) {
        /* support grouped boolean flags with one `-`*/
        char bf[3] = {'-', *value, 0};
        ++value;

        fio___cli_cstr_s a = {.buf = bf, .len = 2};

        const char *l = fio___cli_hash_get(&fio___cli_aliases, a);
        if (!l) {
          if (bf[1] == ',')
            continue;
          value = arg.buf + arg.len;
          goto error;
        }
        const char *t = fio___cli_get_line_type(parser, l);
        if (t != (char *)FIO_CLI_BOOL__TYPE_I) {
          value = arg.buf + arg.len;
          goto error;
        }
        fio___cli_set_arg(a, parser->argv[parser->pos + 1], l, parser);
      }
    }
    value = "1";
    break;
  case FIO_CLI_INT__TYPE_I:
    if (value) {
      char const *tmp = value;
      fio_atol((char **)&tmp);
      if (*tmp) {
        goto error;
      }
    }
    /* fall through */
  case FIO_CLI_STRING__TYPE_I:
    if (!value)
      goto error;
    if (!value[0])
      goto finish;
    break;
  }

  /* add values using all aliases possible */
  {
    fio___cli_cstr_s n = {.buf = line};
    while (n.buf[0] == '-') {
      while (n.buf[n.len] && n.buf[n.len] != ' ' && n.buf[n.len] != ',') {
        ++n.len;
      }
      fio___cli_hash_set(&fio___cli_values, n, value, NULL);
      FIO_LOG_DEBUG2("(CLI) set argument %.*s = %s", (int)n.len, n.buf, value);
      FIO_ASSERT_DEBUG(fio___cli_hash_get(&fio___cli_values, n) == value,
                       "(CLI) set argument failed!");
      while (n.buf[n.len] && (n.buf[n.len] == ' ' || n.buf[n.len] == ',')) {
        ++n.len;
      }
      n.buf += n.len;
      n.len = 0;
    }
  }

finish:

  /* handle additional argv progress (if value is on separate argv) */
  if (value && parser->pos < parser->argc &&
      value == parser->argv[parser->pos + 1])
    ++parser->pos;
  return;

error: /* handle errors*/
  FIO_LOG_DEBUG2("(CLI) error detected, printing help and exiting.");
  fprintf(stderr,
          "\n\r\x1B[31mError:\x1B[0m invalid argument %.*s %s %s\n\n",
          (int)arg.len,
          arg.buf,
          arg.len ? "with value" : "",
          value ? (value[0] ? value : "(empty)") : "(null)");
print_help:
  if (parser->description) {
    fprintf(stderr, "\n");
    fio___cli_print_line(parser->description, parser->argv[0]);
    fprintf(stderr, "\n");
  } else {
    const char *name_tmp = parser->argv[0];
    while (name_tmp[0] == '.' || name_tmp[0] == '/')
      ++name_tmp;
    fprintf(stderr,
            "\nAvailable command-line options for \x1B[1m%s\x1B[0m:\n",
            name_tmp);
  }
  /* print out each line's arguments */
  char const **pos = parser->names;
  while (*pos) {
    switch ((intptr_t)*pos) {
    case FIO_CLI_STRING__TYPE_I:     /* fall through */
    case FIO_CLI_BOOL__TYPE_I:       /* fall through */
    case FIO_CLI_INT__TYPE_I:        /* fall through */
    case FIO_CLI_PRINT__TYPE_I:      /* fall through */
    case FIO_CLI_PRINT_LINE__TYPE_I: /* fall through */
    case FIO_CLI_PRINT_HEADER__TYPE_I: ++pos; continue;
    }
    type = (char *)FIO_CLI_STRING__TYPE_I;
    switch ((intptr_t)pos[1]) {
    case FIO_CLI_PRINT__TYPE_I:
      fprintf(stderr, "          \t   ");
      fio___cli_print_line(pos[0], parser->argv[0]);
      fprintf(stderr, "\n");
      pos += 2;
      continue;
    case FIO_CLI_PRINT_LINE__TYPE_I:
      fio___cli_print_line(pos[0], parser->argv[0]);
      fprintf(stderr, "\n");
      pos += 2;
      continue;
    case FIO_CLI_PRINT_HEADER__TYPE_I:
      fprintf(stderr, "\n\x1B[4m");
      fio___cli_print_line(pos[0], parser->argv[0]);
      fprintf(stderr, "\x1B[0m\n");
      pos += 2;
      continue;

    case FIO_CLI_STRING__TYPE_I: /* fall through */
    case FIO_CLI_BOOL__TYPE_I:   /* fall through */
    case FIO_CLI_INT__TYPE_I: /* fall through */ type = pos[1];
    }
    /* print line @ pos, starting with main argument name */
    int alias_count = 0;
    int first_len = 0;
    size_t tmp = 0;
    char const *const p = *pos;
    fio___cli_cstr_s def = fio___cli_map_line2default(p);
    while (p[tmp] == '-') {
      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {
        if (!alias_count)
          ++first_len;
        ++tmp;
      }
      ++alias_count;
      while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {
        ++tmp;
      }
    }
    if (def.len) {
      tmp = (size_t)((def.buf + def.len + 1) - p);
      tmp += (p[tmp] == ')'); /* in case of `")` */
      while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {
        ++tmp;
      }
    }
    switch ((size_t)type) {
    case FIO_CLI_STRING__TYPE_I:
      fprintf(stderr,
              " \x1B[1m%-10.*s\x1B[0m\x1B[2m\t\"\" \x1B[0m%s\n",
              first_len,
              p,
              p + tmp);
      break;
    case FIO_CLI_BOOL__TYPE_I:
      fprintf(stderr, " \x1B[1m%-10.*s\x1B[0m\t   %s\n", first_len, p, p + tmp);
      break;
    case FIO_CLI_INT__TYPE_I:
      fprintf(stderr,
              " \x1B[1m%-10.*s\x1B[0m\x1B[2m\t## \x1B[0m%s\n",
              first_len,
              p,
              p + tmp);
      break;
    }
    /* print alias information */
    tmp = first_len;
    while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {
      ++tmp;
    }
    while (p[tmp] == '-') {
      const size_t start = tmp;
      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {
        ++tmp;
      }
      int padding = first_len - (tmp - start);
      if (padding < 0)
        padding = 0;
      switch ((size_t)type) {
      case FIO_CLI_STRING__TYPE_I:
        fprintf(stderr,
                " \x1B[1m%-10.*s\x1B[0m\x1B[2m\t\"\" \x1B[0m%.*s\x1B[2msame as "
                "%.*s\x1B[0m\n",
                (int)(tmp - start),
                p + start,
                padding,
                "",
                first_len,
                p);
        break;
      case FIO_CLI_BOOL__TYPE_I:
        fprintf(stderr,
                " \x1B[1m%-10.*s\x1B[0m\t   %.*s\x1B[2msame as %.*s\x1B[0m\n",
                (int)(tmp - start),
                p + start,
                padding,
                "",
                first_len,
                p);
        break;
      case FIO_CLI_INT__TYPE_I:
        fprintf(stderr,
                " \x1B[1m%-10.*s\x1B[0m\x1B[2m\t## \x1B[0m%.*s\x1B[2msame as "
                "%.*s\x1B[0m\n",
                (int)(tmp - start),
                p + start,
                padding,
                "",
                first_len,
                p);
        break;
      }
    }
    /* print default information */
    if (def.len)
      fprintf(stderr,
              "           \t\x1B[2mdefault value: %.*s\x1B[0m\n",
              (int)def.len,
              def.buf);
    ++pos;
  }
  fprintf(stderr,
          "\nUse any of the following input formats:\n"
          "\t-arg <value>\t-arg=<value>\t-arg<value>\n"
          "\n"
          "Use \x1B[1m-h\x1B[0m , \x1B[1m-help\x1B[0m or "
          "\x1B[1m-?\x1B[0m "
          "to get this information again.\n"
          "\n");
  fio_cli_end();
  exit(0);
}

/* *****************************************************************************
CLI Initialization
***************************************************************************** */

void fio_cli_start___(void); /* sublime text marker */
SFUNC void fio_cli_start FIO_NOOP(int argc,
                                  char const *argv[],
                                  int unnamed_min,
                                  int unnamed_max,
                                  char const *description,
                                  char const **names) {
  if (unnamed_max >= 0 && unnamed_max < unnamed_min)
    unnamed_max = unnamed_min;
  fio_cli_parser_data_s parser = {
      .unnamed_min = unnamed_min,
      .unnamed_max = unnamed_max,
      .pos = 0,
      .argc = argc,
      .argv = argv,
      .description = description,
      .names = names,
  };

  if (fio___cli_hash_count(&fio___cli_values)) {
    fio_cli_end();
  }

  /* initialize the default value linked list */
  fio___cli_default_values = FIO_LIST_INIT(fio___cli_default_values);

  /* prepare aliases hash map */

  char const **line = names;
  while (*line) {
    switch ((intptr_t)*line) {
    case FIO_CLI_STRING__TYPE_I:     /* fall through */
    case FIO_CLI_BOOL__TYPE_I:       /* fall through */
    case FIO_CLI_INT__TYPE_I:        /* fall through */
    case FIO_CLI_PRINT__TYPE_I:      /* fall through */
    case FIO_CLI_PRINT_LINE__TYPE_I: /* fall through */
    case FIO_CLI_PRINT_HEADER__TYPE_I: /* fall through */ ++line; continue;
    }
    if (line[1] != (char *)FIO_CLI_PRINT__TYPE_I &&
        line[1] != (char *)FIO_CLI_PRINT_LINE__TYPE_I &&
        line[1] != (char *)FIO_CLI_PRINT_HEADER__TYPE_I)
      fio___cli_map_line2alias(*line);
    ++line;
  }

  /* parse existing arguments */

  while ((++parser.pos) < argc) {
    char const *value = NULL;
    fio___cli_cstr_s n = {.buf = argv[parser.pos],
                          .len = strlen(argv[parser.pos])};
    if (parser.pos + 1 < argc) {
      value = argv[parser.pos + 1];
    }
    const char *l = NULL;
    while (n.len && !(l = fio___cli_hash_get(&fio___cli_aliases, n))) {
      --n.len;
      value = n.buf + n.len;
    }
    if (n.len && value && value[0] == '=') {
      ++value;
    }
    // fprintf(stderr, "Setting %.*s to %s\n", (int)n.len, n.buf, value);
    fio___cli_set_arg(n, value, l, &parser);
  }

  /* Cleanup and save state for API */
  fio___cli_hash_destroy(&fio___cli_aliases);
  fio___cli_unnamed_count = parser.unnamed_count;
  /* test for required unnamed arguments */
  if (parser.unnamed_count < parser.unnamed_min)
    fio___cli_set_arg((fio___cli_cstr_s){.len = 0}, NULL, NULL, &parser);
}

/* *****************************************************************************
CLI Destruction
***************************************************************************** */

SFUNC void __attribute__((destructor)) fio_cli_end(void) {
  fio___cli_hash_destroy(&fio___cli_values);
  fio___cli_hash_destroy(&fio___cli_aliases);
  fio___cli_unnamed_count = 0;
  if (fio___cli_default_values.next) {
    while (fio___cli_default_values.next != &fio___cli_default_values) {
      fio___cli_def_str_s *node;
      FIO_LIST_POP(fio___cli_def_str_s, node, node, &fio___cli_default_values);
      FIO_MEM_FREE_(node, sizeof(*node) + node->len + 1);
    }
  }
}
/* *****************************************************************************
CLI Data Access API
***************************************************************************** */

/** Returns the argument's value as a NUL terminated C String. */
SFUNC char const *fio_cli_get(char const *name) {
  if (!name)
    return NULL;
  fio___cli_cstr_s n = {.buf = name, .len = strlen(name)};
  if (!fio___cli_hash_count(&fio___cli_values)) {
    return NULL;
  }
  char const *val = fio___cli_hash_get(&fio___cli_values, n);
  return val;
}

/** Returns the argument's value as an integer. */
SFUNC int fio_cli_get_i(char const *name) {
  char const *val = fio_cli_get(name);
  return fio_atol((char **)&val);
}

/** Returns the number of unrecognized argument. */
SFUNC unsigned int fio_cli_unnamed_count(void) {
  return (unsigned int)fio___cli_unnamed_count;
}

/** Returns the unrecognized argument using a 0 based `index`. */
SFUNC char const *fio_cli_unnamed(unsigned int index) {
  if (!fio___cli_hash_count(&fio___cli_values) || !fio___cli_unnamed_count) {
    return NULL;
  }
  fio___cli_cstr_s n = {.buf = NULL, .len = index + 1};
  return fio___cli_hash_get(&fio___cli_values, n);
}

/**
 * Sets the argument's value as a NUL terminated C String (no copy!).
 *
 * Note: this does NOT copy the C strings to memory. Memory should be kept
 * alive until `fio_cli_end` is called.
 */
SFUNC void fio_cli_set(char const *name, char const *value) {
  fio___cli_cstr_s n = (fio___cli_cstr_s){.buf = name, .len = strlen(name)};
  fio___cli_hash_set(&fio___cli_values, n, value, NULL);
}

/** Sets an unrecognized argument at a 0 based `index`. */
SFUNC void fio_cli_unnamed_set(unsigned int index, char const *value) {
  fio___cli_cstr_s n = {.buf = NULL, .len = index + 1};
  fio___cli_hash_set(&fio___cli_values, n, value, NULL);
  if (fio___cli_unnamed_count < n.len)
    fio___cli_unnamed_count = n.len;
}

/* *****************************************************************************
CLI - test
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, cli)(void) {
  const char *argv[] = {
      "appname",
      "-i11",
      "-i2=2",
      "-i3",
      "3",
      "-t,u",
      "-s",
      "test",
      "unnamed",
  };
  const int argc = sizeof(argv) / sizeof(argv[0]);
  fprintf(stderr, "* Testing CLI helpers.\n");
  { /* avoid macro for C++ */
    const char *arguments[] = {
        FIO_CLI_INT("-integer1 -i1 first integer"),
        FIO_CLI_INT("-integer2 -i2 second integer"),
        FIO_CLI_INT("-integer3 -i3 third integer"),
        FIO_CLI_INT("-integer4 -i4 (4) fourth integer"),
        FIO_CLI_INT("-integer5 -i5 (\"5\") fifth integer"),
        FIO_CLI_BOOL("-boolean -t boolean"),
        FIO_CLI_BOOL("-boolean2 -u boolean"),
        FIO_CLI_BOOL("-boolean_false -f boolean"),
        FIO_CLI_STRING("-str -s a string"),
        FIO_CLI_PRINT_HEADER("Printing stuff"),
        FIO_CLI_PRINT_LINE("does nothing, but shouldn't crash either"),
        FIO_CLI_PRINT("does nothing, but shouldn't crash either"),
        NULL,
    };
    fio_cli_start FIO_NOOP(argc, argv, 0, -1, NULL, arguments);
  }
  FIO_ASSERT(fio_cli_get_i("-i2") == 2, "CLI second integer error.");
  FIO_ASSERT(fio_cli_get_i("-i3") == 3, "CLI third integer error.");
  FIO_ASSERT(fio_cli_get_i("-i4") == 4,
             "CLI fourth integer error (%s).",
             fio_cli_get("-i4"));
  FIO_ASSERT(fio_cli_get_i("-i5") == 5,
             "CLI fifth integer error (%s).",
             fio_cli_get("-i5"));
  FIO_ASSERT(fio_cli_get_i("-i1") == 1, "CLI first integer error.");
  FIO_ASSERT(fio_cli_get_i("-i2") == fio_cli_get_i("-integer2"),
             "CLI second integer error.");
  FIO_ASSERT(fio_cli_get_i("-i3") == fio_cli_get_i("-integer3"),
             "CLI third integer error.");
  FIO_ASSERT(fio_cli_get_i("-i1") == fio_cli_get_i("-integer1"),
             "CLI first integer error.");
  FIO_ASSERT(fio_cli_get_i("-t") == 1, "CLI boolean true error.");
  FIO_ASSERT(fio_cli_get_i("-u") == 1, "CLI boolean 2 true error.");
  FIO_ASSERT(fio_cli_get_i("-f") == 0, "CLI boolean false error.");
  FIO_ASSERT(!strcmp(fio_cli_get("-s"), "test"), "CLI string error.");
  FIO_ASSERT(fio_cli_unnamed_count() == 1, "CLI unnamed count error.");
  FIO_ASSERT(!strcmp(fio_cli_unnamed(0), "unnamed"), "CLI unnamed error.");
  fio_cli_set("-manual", "okay");
  FIO_ASSERT(!strcmp(fio_cli_get("-manual"), "okay"), "CLI set/get error.");
  fio_cli_end();
  FIO_ASSERT(fio_cli_get_i("-i1") == 0, "CLI cleanup error.");
}
#endif /* FIO_TEST_CSTL */

/* *****************************************************************************
CLI - cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE*/
#endif /* FIO_CLI */
#undef FIO_CLI
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_POLL       /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                            POSIX Portable Polling



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_POLL) && !defined(H___FIO_POLL___H) && !defined(FIO_STL_KEEP__)

#ifndef FIO_POLL_POSSIBLE_FLAGS
/** The user flags IO events recognize */
#define FIO_POLL_POSSIBLE_FLAGS (POLLIN | POLLOUT | POLLPRI)
#endif

#ifndef FIO_POLL_MAX_EVENTS
/** relevant only for epoll and kqueue - maximum number of events per review */
#define FIO_POLL_MAX_EVENTS FIO_QUEUE_TASKS_PER_ALLOC
#endif

/* *****************************************************************************
Possible polling engine (system call) selection
***************************************************************************** */

#ifndef FIO_POLL_ENGINE_POLL
/** define `FIO_POLL_ENGINE` as `FIO_POLL_ENGINE_POLL` to use `poll` */
#define FIO_POLL_ENGINE_POLL 1
#endif
#ifndef FIO_POLL_ENGINE_EPOLL
/** define `FIO_POLL_ENGINE` as `FIO_POLL_ENGINE_EPOLL` to use `epoll` */
#define FIO_POLL_ENGINE_EPOLL 2
#endif
#ifndef FIO_POLL_ENGINE_KQUEUE
/** define `FIO_POLL_ENGINE` as `FIO_POLL_ENGINE_KQUEUE` to use `kqueue` */
#define FIO_POLL_ENGINE_KQUEUE 3
#endif

/* if `FIO_POLL_ENGINE` wasn't define, detect automatically. */
#if !defined(FIO_POLL_ENGINE)
#if defined(HAVE_EPOLL) || __has_include("sys/epoll.h")
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_EPOLL
#elif (defined(HAVE_KQUEUE) || __has_include("sys/event.h"))
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_KQUEUE
#else
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_POLL
#endif
#endif /* FIO_POLL_ENGINE */

#if FIO_POLL_ENGINE == FIO_POLL_ENGINE_POLL
#ifndef FIO_POLL_ENGINE_STR
#define FIO_POLL_ENGINE_STR "poll"
#endif
#elif FIO_POLL_ENGINE == FIO_POLL_ENGINE_EPOLL
#ifndef FIO_POLL_ENGINE_STR
#define FIO_POLL_ENGINE_STR "epoll"
#endif
#elif FIO_POLL_ENGINE == FIO_POLL_ENGINE_KQUEUE
#ifndef FIO_POLL_ENGINE_STR
#define FIO_POLL_ENGINE_STR "kqueue"
#endif
#endif
/* *****************************************************************************
Polling API
***************************************************************************** */

/** the `fio_poll_s` type should be considered opaque. */
typedef struct fio_poll_s fio_poll_s;

typedef struct {
  /** callback for when data is availabl in the incoming buffer. */
  void (*on_data)(void *udata);
  /** callback for when the outgoing buffer allows a call to `write`. */
  void (*on_ready)(void *udata);
  /** callback for closed connections and / or connections with errors. */
  void (*on_close)(void *udata);
} fio_poll_settings_s;

/** Initializes the polling object, allocating its resources. */
FIO_IFUNC void fio_poll_init(fio_poll_s *p, fio_poll_settings_s);
/** Initializes the polling object, allocating its resources. */
#define fio_poll_init(p, ...)                                                  \
  fio_poll_init((p), (fio_poll_settings_s){__VA_ARGS__})

/** Destroys the polling object, freeing its resources. */
FIO_IFUNC void fio_poll_destroy(fio_poll_s *p);

/** returns the system call used for polling as a constant string. */
FIO_IFUNC const char *fio_poll_engine(void);

/**
 * Adds a file descriptor to be monitored, adds events to be monitored or
 * updates the monitored file's `udata`.
 *
 * Possible flags are: `POLLIN` and `POLLOUT`. Other flags may be set but might
 * be ignored.
 *
 * Monitoring mode is always one-shot. If an event if fired, it is removed from
 * the monitoring state.
 *
 * Returns -1 on error.
 */
SFUNC int fio_poll_monitor(fio_poll_s *p,
                           int fd,
                           void *udata,
                           unsigned short flags);

/**
 * Reviews if any of the monitored file descriptors has any events.
 *
 * `timeout` is in milliseconds.
 *
 * Returns the number of events called.
 *
 * Polling is thread safe, but has different effects on different threads.
 *
 * Adding a new file descriptor from one thread while polling in a different
 * thread will not poll that IO until `fio_poll_review` is called again.
 */
SFUNC int fio_poll_review(fio_poll_s *p, size_t timeout);

/** Stops monitoring the specified file descriptor (if monitoring). */
SFUNC int fio_poll_forget(fio_poll_s *p, int fd);

/* *****************************************************************************
Implementation Helpers
***************************************************************************** */

/** returns the system call used for polling as a constant string. */
FIO_IFUNC const char *fio_poll_engine(void) { return FIO_POLL_ENGINE_STR; }

/* validate settings */
#define FIO_POLL_VALIDATE(settings_dest)                                       \
  if (!(settings_dest).on_data)                                                \
    (settings_dest).on_data = fio___poll_ev_mock;                              \
  if (!(settings_dest).on_ready)                                               \
    (settings_dest).on_ready = fio___poll_ev_mock;                             \
  if (!(settings_dest).on_close)                                               \
    (settings_dest).on_close = fio___poll_ev_mock;

SFUNC void fio___poll_ev_mock(void *udata);

#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)
/* mock event */
SFUNC void fio___poll_ev_mock(void *udata) { (void)udata; }
#endif /* defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN) */
/* *****************************************************************************
Cleanup
***************************************************************************** */
#endif /* FIO_POLL */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_EPOLL   /* Dev */
#define FIO___DEV___    /* Development inclusion - ignore line */
#define FIO_POLL        /* Development inclusion - ignore line */
#include "./include.h"  /* Development inclusion - ignore line */
#endif                  /* Development inclusion - ignore line */
/* ************************************************************************* */
#if defined(FIO_POLL) &&                                                       \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)) &&                  \
    FIO_POLL_ENGINE == FIO_POLL_ENGINE_EPOLL &&                                \
    !defined(H___FIO_POLL_EGN___H) && !defined(H___FIO_POLL___H) &&            \
    !defined(FIO_STL_KEEP__)
#define H___FIO_POLL_EGN___H
/* *****************************************************************************




                        POSIX Portable Polling with `epoll`



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#include <sys/epoll.h>

/* *****************************************************************************
Polling API
***************************************************************************** */

/** the `fio_poll_s` type should be considered opaque. */
struct fio_poll_s {
  fio_poll_settings_s settings;
  struct pollfd fds[2];
  int fd[2];
};

FIO_SFUNC void fio___epoll_after_fork(void *p_) {
  fio_poll_s *p = (fio_poll_s *)p_;
  fio_poll_destroy(p);
  fio_poll_init FIO_NOOP(p, p->settings);
}

/** Initializes the polling object, allocating its resources. */
FIO_IFUNC void fio_poll_init FIO_NOOP(fio_poll_s *p, fio_poll_settings_s args) {
  *p = (fio_poll_s){
      .settings = args,
      .fds =
          {
              {.fd = epoll_create1(0), .events = (POLLIN | POLLOUT)},
              {.fd = epoll_create1(0), .events = (POLLIN | POLLOUT)},
          },
  };
  FIO_POLL_VALIDATE(p->settings);
  fio_state_callback_add(FIO_CALL_IN_CHILD, fio___epoll_after_fork, p);
}

/** Destroys the polling object, freeing its resources. */
FIO_IFUNC void fio_poll_destroy(fio_poll_s *p) {
  for (int i = 0; i < 2; ++i) {
    if (p->fds[i].fd != -1)
      close(p->fds[i].fd);
    p->fds[i].fd = -1;
  }
  fio_state_callback_remove(FIO_CALL_IN_CHILD, fio___epoll_after_fork, p);
}

/* *****************************************************************************
Poll Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

FIO_IFUNC int fio___epoll_add2(int fd,
                               void *udata,
                               uint32_t events,
                               int ep_fd) {
  int ret = 0;
  struct epoll_event chevent;
  do {
    errno = 0;
    chevent = (struct epoll_event){
        .events = events,
        .data.ptr = udata,
    };
    ret = epoll_ctl(ep_fd, EPOLL_CTL_MOD, fd, &chevent);
    if (ret == -1 && errno == ENOENT) {
      errno = 0;
      chevent = (struct epoll_event){
          .events = events,
          .data.ptr = udata,
      };
      ret = epoll_ctl(ep_fd, EPOLL_CTL_ADD, fd, &chevent);
    }
  } while (errno == EINTR);

  return ret;
}

/**
 * Adds a file descriptor to be monitored, adds events to be monitored or
 * updates the monitored file's `udata`.
 *
 * Possible flags are: `POLLIN` and `POLLOUT`. Other flags may be set but might
 * be ignored.
 *
 * Monitoring mode is always one-shot. If an event if fired, it is removed from
 * the monitoring state.
 *
 * Returns -1 on error.
 */
SFUNC int fio_poll_monitor(fio_poll_s *p,
                           int fd,
                           void *udata,
                           unsigned short flags) {
  int r = 0;
  if ((flags & POLLOUT))
    r |= fio___epoll_add2(fd,
                          udata,
                          (EPOLLOUT | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),
                          p->fds[0].fd);
  if ((flags & POLLIN))
    r |= fio___epoll_add2(fd,
                          udata,
                          (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),
                          p->fds[1].fd);
  return r;
}

/**
 * Stops monitoring the specified file descriptor, returning its udata (if any).
 */
SFUNC int fio_poll_forget(fio_poll_s *p, int fd) {
  int r = 0;
  struct epoll_event chevent = {.events = (EPOLLOUT | EPOLLIN)};
  r |= epoll_ctl(p->fds[0].fd, EPOLL_CTL_DEL, fd, &chevent);
  r |= epoll_ctl(p->fds[1].fd, EPOLL_CTL_DEL, fd, &chevent);
  return r;
}

/**
 * Reviews if any of the monitored file descriptors has any events.
 *
 * `timeout` is in milliseconds.
 *
 * Returns the number of events called.
 *
 * Polling is thread safe, but has different effects on different threads.
 *
 * Adding a new file descriptor from one thread while polling in a different
 * thread will not poll that IO until `fio_poll_review` is called again.
 */
SFUNC int fio_poll_review(fio_poll_s *p, size_t timeout) {
  int total = 0;
  struct epoll_event events[FIO_POLL_MAX_EVENTS];
  /* wait for events and handle them */
  int internal_count = poll(p->fds, 2, timeout);
  if (internal_count <= 0)
    return total;
  int active_count = epoll_wait(p->fds[0].fd, events, FIO_POLL_MAX_EVENTS, 0);
  if (active_count > 0) {
    for (int i = 0; i < active_count; i++) {
      // errors are handled as disconnections (on_close) in the EPOLLIN queue
      // if no error, try an active event(s)
      if (events[i].events & EPOLLOUT)
        p->settings.on_ready(events[i].data.ptr);
    } // end for loop
    total += active_count;
  }
  active_count = epoll_wait(p->fds[1].fd, events, FIO_POLL_MAX_EVENTS, 0);
  if (active_count > 0) {
    for (int i = 0; i < active_count; i++) {
      // errors are handled as disconnections (on_close), but only once...
      if (events[i].events & (~(EPOLLIN | EPOLLOUT)))
        p->settings.on_close(events[i].data.ptr);
      // no error, then it's an active event(s)
      else if (events[i].events & EPOLLIN)
        p->settings.on_data(events[i].data.ptr);
    } // end for loop
    total += active_count;
  }
  return total;
}

/* *****************************************************************************
Poll Monitoring Testing?
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, poll)(void) {
  fprintf(stderr,
          "* SKIPPED testing file descriptor polling (engine: epoll).\n");
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_POLL_ENGINE == FIO_POLL_ENGINE_EPOLL */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_KQUEUE  /* Dev */
#define FIO___DEV___    /* Development inclusion - ignore line */
#define FIO_POLL        /* Development inclusion - ignore line */
#include "./include.h"  /* Development inclusion - ignore line */
#endif                  /* Development inclusion - ignore line */
/* ************************************************************************* */
#if defined(FIO_POLL) &&                                                       \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)) &&                  \
    FIO_POLL_ENGINE == FIO_POLL_ENGINE_KQUEUE &&                               \
    !defined(H___FIO_POLL_EGN___H) && !defined(H___FIO_POLL___H) &&            \
    !defined(FIO_STL_KEEP__)
#define H___FIO_POLL_EGN___H
/* *****************************************************************************




                        POSIX Portable Polling with `kqueue`



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#include <sys/event.h>
/* *****************************************************************************
Polling API
***************************************************************************** */

/** the `fio_poll_s` type should be considered opaque. */
struct fio_poll_s {
  fio_poll_settings_s settings;
  int fd;
};

FIO_SFUNC void fio___kqueue_after_fork(void *p_) {
  fio_poll_s *p = (fio_poll_s *)p_;
  fio_poll_destroy(p);
  fio_poll_init FIO_NOOP(p, p->settings);
}

/** Initializes the polling object, allocating its resources. */
FIO_IFUNC void fio_poll_init FIO_NOOP(fio_poll_s *p, fio_poll_settings_s args) {
  *p = (fio_poll_s){
      .settings = args,
      .fd = kqueue(),
  };
  if (p->fd == -1) {
    FIO_LOG_FATAL("couldn't open kqueue.\n");
    exit(errno);
  }
  FIO_POLL_VALIDATE(p->settings);
  fio_state_callback_add(FIO_CALL_IN_CHILD, fio___kqueue_after_fork, p);
}

/** Destroys the polling object, freeing its resources. */
FIO_IFUNC void fio_poll_destroy(fio_poll_s *p) {
  if (p->fd != -1)
    close(p->fd);
  p->fd = -1;
  fio_state_callback_remove(FIO_CALL_IN_CHILD, fio___kqueue_after_fork, p);
}

/* *****************************************************************************
Poll Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/**
 * Adds a file descriptor to be monitored, adds events to be monitored or
 * updates the monitored file's `udata`.
 *
 * Possible flags are: `POLLIN` and `POLLOUT`. Other flags may be set but might
 * be ignored.
 *
 * Monitoring mode is always one-shot. If an event if fired, it is removed from
 * the monitoring state.
 *
 * Returns -1 on error.
 */
SFUNC int fio_poll_monitor(fio_poll_s *p,
                           int fd,
                           void *udata,
                           unsigned short flags) {
  int r = -1;
  struct kevent chevent[2];
  int i = 0;
  if ((flags & POLLIN)) {
    EV_SET(chevent,
           fd,
           EVFILT_READ,
           EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,
           0,
           0,
           udata);
    ++i;
  }
  if ((flags & POLLOUT)) {
    EV_SET(chevent + i,
           fd,
           EVFILT_WRITE,
           EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,
           0,
           0,
           udata);
    ++i;
  }
  do {
    errno = 0;
  } while ((r = kevent(p->fd, chevent, i, NULL, 0, NULL)) == -1 &&
           errno == EINTR);
  return r;
}

/**
 * Reviews if any of the monitored file descriptors has any events.
 *
 * `timeout` is in milliseconds.
 *
 * Returns the number of events called.
 *
 * Polling is thread safe, but has different effects on different threads.
 *
 * Adding a new file descriptor from one thread while polling in a different
 * thread will not poll that IO until `fio_poll_review` is called again.
 */
SFUNC int fio_poll_review(fio_poll_s *p, size_t timeout_) {
  if (p->fd < 0)
    return -1;
  struct kevent events[FIO_POLL_MAX_EVENTS] = {{0}};

  const struct timespec timeout = {
      .tv_sec = (time_t)(timeout_ / 1024),
      .tv_nsec = (suseconds_t)((timeout_ & (1023UL)) * 1000000)};
  /* wait for events and handle them */
  int active_count =
      kevent(p->fd, NULL, 0, events, FIO_POLL_MAX_EVENTS, &timeout);

  if (active_count > 0) {
    for (int i = 0; i < active_count; i++) {
      // test for event(s) type
      if (events[i].filter == EVFILT_WRITE) {
        p->settings.on_ready(events[i].udata);
      } else if (events[i].filter == EVFILT_READ) {
        p->settings.on_data(events[i].udata);
      }
      if (events[i].flags & (EV_EOF | EV_ERROR)) {
        p->settings.on_close(events[i].udata);
      }
    }
  } else if (active_count < 0) {
    if (errno == EINTR)
      return 0;
    return -1;
  }
  return active_count;
}

/** Stops monitoring the specified file descriptor (if monitoring). */
SFUNC int fio_poll_forget(fio_poll_s *p, int fd) {
  int r = 0;
  if (p->fd == -1)
    return (r = -1);
  struct kevent chevent[2];
  EV_SET(chevent, fd, EVFILT_READ, EV_DELETE, 0, 0, NULL);
  EV_SET(chevent + 1, fd, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
  do {
    errno = 0;
    r = kevent(p->fd, chevent, 2, NULL, 0, NULL);
  } while (errno == EINTR);
  return r;
}

/* *****************************************************************************
Poll Monitoring Testing?
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, poll)(void) {
  fprintf(stderr,
          "* SKIPPED testing file descriptor polling (engine: kqueue).\n");
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Cleanup
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_POLL_ENGINE == FIO_POLL_ENGINE_KQUEUE */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO_POLL_ENGINE FIO_POLL_ENGINE_POLL    /* Dev */
#define FIO___DEV___    /* Development inclusion - ignore line */
#define FIO_POLL        /* Development inclusion - ignore line */
#include "./include.h"  /* Development inclusion - ignore line */
#endif                  /* Development inclusion - ignore line */
/* ************************************************************************* */
#if defined(FIO_POLL) &&                                                       \
    (defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)) &&                  \
    FIO_POLL_ENGINE == FIO_POLL_ENGINE_POLL &&                                 \
    !defined(H___FIO_POLL_EGN___H) && !defined(H___FIO_POLL___H) &&            \
    !defined(FIO_STL_KEEP__)
#define H___FIO_POLL_EGN___H
/* *****************************************************************************



                        POSIX Portable Polling with `poll`


Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#ifdef POLLRDHUP
#define FIO_POLL_EX_FLAGS POLLRDHUP
#else
#define FIO_POLL_EX_FLAGS 0
#endif

typedef struct {
  void *udata;
  int fd;
  unsigned short flags;
} fio___poll_i_s;

#define FIO___POLL_IMAP_CMP(a, b) ((a)->fd == (b)->fd)
#define FIO___POLL_IMAP_VALID(o)  (1)
#define FIO___POLL_IMAP_HASH(o)   (fio_risky_ptr((void *)((uintptr_t)((o)->fd))))
FIO_TYPEDEF_IMAP_ARRAY(fio___poll_map,
                       fio___poll_i_s,
                       uint32_t,
                       FIO___POLL_IMAP_HASH,
                       FIO___POLL_IMAP_CMP,
                       FIO___POLL_IMAP_VALID)
#undef FIO___POLL_IMAP_CMP
#undef FIO___POLL_IMAP_VALID
#undef FIO___POLL_IMAP_HASH

struct fio_poll_s {
  fio_poll_settings_s settings;
  fio___poll_map_s map;
  FIO___LOCK_TYPE lock;
};

/* *****************************************************************************
Poll Monitoring Implementation - inline static functions
***************************************************************************** */

/** Initializes the polling object, allocating its resources. */
FIO_IFUNC void fio_poll_init FIO_NOOP(fio_poll_s *p, fio_poll_settings_s args) {
  if (p) {
    *p = (fio_poll_s){
        .settings = args,
        .map = {0},
        .lock = FIO___LOCK_INIT,
    };
    FIO_POLL_VALIDATE(p->settings);
  }
}

/** Destroys the polling object, freeing its resources. */
FIO_IFUNC void fio_poll_destroy(fio_poll_s *p) {
  if (!p)
    return;
  fio___poll_map_destroy(&p->map);
  FIO___LOCK_DESTROY(p->lock);
}

/* *****************************************************************************
Poll Monitoring Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* handle events, return a mask for possible remaining flags. */
FIO_IFUNC unsigned short fio___poll_handle_events(fio_poll_s *p,
                                                  void *udata,
                                                  unsigned short flags) {
  if ((flags & POLLOUT))
    p->settings.on_ready(udata);
  if ((flags & (POLLIN | POLLPRI)))
    p->settings.on_data(udata);
  if ((flags & (POLLHUP | POLLERR | POLLNVAL | FIO_POLL_EX_FLAGS))) {
    p->settings.on_close(udata);
    return 0;
  }
  return ~flags;
}

/**
 * Adds a file descriptor to be monitored, adds events to be monitored or
 * updates the monitored file's `udata`.
 *
 * Possible flags are: `POLLIN` and `POLLOUT`. Other flags may be set but might
 * be ignored.
 *
 * Monitoring mode is always one-shot. If an event if fired, it is removed from
 * the monitoring state.
 *
 * Returns -1 on error.
 */
SFUNC int fio_poll_monitor(fio_poll_s *p,
                           int fd,
                           void *udata,
                           unsigned short flags) {
  int r = -1;
  if (!p || fd == -1)
    return r;
  r = 0;
  flags &= FIO_POLL_POSSIBLE_FLAGS;
  flags |= FIO_POLL_EX_FLAGS;
  fio___poll_i_s i = {.udata = udata, .fd = fd, .flags = flags};
  FIO___LOCK_LOCK(p->lock);
  fio___poll_i_s *ptr = fio___poll_map_set(&p->map, i, 0);
  ptr->flags |= flags;
  FIO___LOCK_UNLOCK(p->lock);
  return r;
}

/**
 * Reviews if any of the monitored file descriptors has any events.
 *
 * `timeout` is in milliseconds.
 *
 * Returns the number of events called.
 *
 * Polling is thread safe, but has different effects on different threads.
 *
 * Adding a new file descriptor from one thread while polling in a different
 * thread will not poll that IO until `fio_poll_review` is called again.
 */
SFUNC int fio_poll_review(fio_poll_s *p, size_t timeout) {
  int events = -1;
  int handled = -1;
  if (!p || !(p->map.count)) {
    if (timeout) {
      FIO_THREAD_WAIT((timeout * 1000000));
    }
    return 0;
  }
  /* handle events in a copy, allowing events / threads to mutate it */
  FIO___LOCK_LOCK(p->lock);
  fio_poll_s cpy = *p;
  p->map = (fio___poll_map_s){0};
  FIO___LOCK_UNLOCK(p->lock);

  const size_t max = cpy.map.count;
  const unsigned short flag_mask = FIO_POLL_POSSIBLE_FLAGS | FIO_POLL_EX_FLAGS;

  int w = 0, r = 0, i = 0;
  struct pollfd *pfd = (struct pollfd *)FIO_MEM_REALLOC_(
      NULL,
      0,
      ((max * sizeof(void *)) + (max * sizeof(struct pollfd))),
      0);
  void **uary = (void **)(pfd + max);

  FIO_IMAP_EACH(fio___poll_map, (&cpy.map), pos) {
    if (!(cpy.map.ary[pos].flags & flag_mask))
      continue;
    pfd[r] = (struct pollfd){.fd = cpy.map.ary[pos].fd,
                             .events = (short)cpy.map.ary[pos].flags};
    uary[r] = cpy.map.ary[pos].udata;
    ++r;
  }

#if FIO_OS_WIN
  events = WSAPoll(pfd, r, (int)timeout);
#else
  events = poll(pfd, r, (int)timeout);
#endif

  if (events > 0) {
    /* handle events and remove consumed entries */
    for (i = 0; i < r && handled < events; ++i) {
      if (pfd[i].revents) {
        ++handled;
        pfd[i].events &=
            fio___poll_handle_events(&cpy, uary[i], pfd[i].revents);
      }
      if ((pfd[i].events & (~(FIO_POLL_EX_FLAGS)))) {
        if (i != w) {
          pfd[w] = pfd[i];
          uary[w] = uary[i];
        }
        ++w;
      }
    }
    if (i < r && i != w) {
      FIO_MEMMOVE(pfd + w, pfd + i, ((r - i) * sizeof(*pfd)));
      FIO_MEMMOVE(uary + w, uary + i, ((r - i) * sizeof(*uary)));
    }
  }
  w += r - i;
  i = 0;

  FIO___LOCK_LOCK(p->lock);
  if (!p->map.count && events <= 0) {
    p->map = cpy.map;
    i = 1;
    goto finish;
  }
  if (w) {
    fio___poll_map_reserve(&p->map, w + p->map.count);
    for (i = 0; i < w; ++i) {
      fio___poll_i_s *existing =
          fio___poll_map_get(&p->map, (fio___poll_i_s){.fd = pfd[i].fd});
      if (existing) {
        existing->flags |= existing->flags ? pfd[i].events : 0;
        continue;
      }
      fio___poll_map_set(&p->map,
                         (fio___poll_i_s){
                             .fd = pfd[i].fd,
                             .flags = (unsigned short)pfd[i].events,
                             .udata = uary[i],
                         },
                         1);
    }
  }
  i = 0;

finish:
  FIO___LOCK_UNLOCK(p->lock);
  FIO_MEM_FREE(pfd, ((max * sizeof(void *)) + (max * sizeof(struct pollfd))));
  if (!i)
    fio___poll_map_destroy(&cpy.map);
  return events;
}

/** Stops monitoring the specified file descriptor, returning -1 on error. */
SFUNC int fio_poll_forget(fio_poll_s *p, int fd) {
  int r = 0;
  fio___poll_i_s i = {.fd = fd};
  FIO___LOCK_LOCK(p->lock);
  fio___poll_i_s *ptr = fio___poll_map_set(&p->map, i, 0);
  ptr->flags = 0;
  FIO___LOCK_UNLOCK(p->lock);
  return r;
}

/** Closes all sockets, calling the `on_close`. */
SFUNC void fio_poll_close_all(fio_poll_s *p) {
  FIO___LOCK_LOCK(p->lock);
  fio_poll_s cpy = *p;
  p->map = (fio___poll_map_s){0};
  FIO___LOCK_UNLOCK(p->lock);
  const unsigned short flag_mask = FIO_POLL_POSSIBLE_FLAGS | FIO_POLL_EX_FLAGS;
  FIO_IMAP_EACH(fio___poll_map, (&cpy.map), pos) {
    if ((cpy.map.ary[pos].flags & flag_mask)) {
      cpy.settings.on_close(cpy.map.ary[pos].udata);
      fio_sock_close(cpy.map.ary[pos].fd);
    }
  }
  fio___poll_map_destroy(&cpy.map);
}
/* *****************************************************************************
Poll Monitoring Testing?
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, poll)(void) {
  fprintf(
      stderr,
      "* Testing file descriptor monitoring (poll setup / cleanup only).\n");
  fio_poll_s p;
  fio_poll_init(&p, NULL);
  short events[4] = {POLLOUT, POLLIN, POLLOUT | POLLIN, POLLOUT | POLLIN};
  for (int i = 128; i--;) {
    FIO_ASSERT(!fio_poll_monitor(&p, i, (void *)(uintptr_t)i, events[(i & 3)]),
               "fio_poll_monitor failed for fd %d",
               i);
  }
  for (int i = 128; i--;) {
    if ((i & 3) == 3) {
      FIO_ASSERT(!fio_poll_forget(&p, i), "fio_poll_forget failed at %d", i);
      FIO_ASSERT(fio_poll_forget(&p, i),
                 "fio_poll_forget didn't forget previous %d",
                 i);
    }
  }
  fio_poll_destroy(&p);
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Cleanup
***************************************************************************** */
#undef FIO_POLL_EX_FLAGS
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_POLL_ENGINE == FIO_POLL_ENGINE_POLL */

#if defined(FIO_POLL) && !defined(H___FIO_POLL___H) && !defined(FIO_STL_KEEP__)
#define H___FIO_POLL___H
#undef FIO_POLL
#endif /* FIO_POLL */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_SERVER     /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




            A Simple Server - Evented, Reactor based, Single-Threaded



Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_SERVER) && !defined(FIO_STL_KEEP__) &&                         \
    !defined(H___FIO_SERVER___H)
#define H___FIO_SERVER___H
/* *****************************************************************************
Server Settings

At this point, define any MACROs and customizable settings available to the
developer.
***************************************************************************** */

#ifndef FIO_SRV_BUFFER_PER_WRITE
/** Control the size of the on-stack buffer used for `write` events. */
#define FIO_SRV_BUFFER_PER_WRITE 65536U
#endif

#ifndef FIO_SRV_THROTTLE_LIMIT
/** IO will be throttled (no `on_data` events) if outgoing buffer is large. */
#define FIO_SRV_THROTTLE_LIMIT 2097152U
#endif

#ifndef FIO_SRV_TIMEOUT_MAX
/** Controls the maximum and default timeout in milliseconds. */
#define FIO_SRV_TIMEOUT_MAX 300000
#endif

#ifndef FIO_SRV_SHUTDOWN_TIMEOUT
/* Sets the hard timeout (in milliseconds) for the server's shutdown loop. */
#define FIO_SRV_SHUTDOWN_TIMEOUT 10000
#endif

/* *****************************************************************************
IO Types
***************************************************************************** */

/** The main protocol object type. See `struct fio_protocol_s`. */
typedef struct fio_protocol_s fio_protocol_s;

/** The main IO object type. Should be treated as an opaque pointer. */
typedef struct fio_s fio_s;

/* *****************************************************************************
Starting / Stopping the Server
***************************************************************************** */

/** Stopping the server. */
SFUNC void fio_srv_stop(void);

/** Starts the server, using optional `workers` processes. This will BLOCK! */
SFUNC void fio_srv_start(int workers);

/** Returns true if server running and 0 if server stopped or shutting down. */
SFUNC int fio_srv_is_running();

/** Returns true if the current process is the server's master process. */
SFUNC int fio_srv_is_master();

/** Returns true if the current process is a server's worker process. */
SFUNC int fio_srv_is_worker();

/** Returns the number or workers the server will actually run. */
SFUNC uint16_t fio_srv_workers(int workers_requested);

/* *****************************************************************************
Listening to Incoming Connections
***************************************************************************** */

/** Arguments for the fio_listen function */
struct fio_listen_args {
  /** The binding address in URL format. Defaults to: tcp://0.0.0.0:3000 */
  const char *url;
  /**
   * Called whenever a new connection is accepted (required).
   *
   * Should either call `fio_attach` or close the connection.
   */
  void (*on_open)(int fd, void *udata);
  /**
   * Called when the server is done, usable for cleanup.
   *
   * This will be called separately for every process before exiting.
   */
  void (*on_finish)(void *udata);
  /** Opaque user data. */
  void *udata;
  /**
   * Selects a queue that will be used to schedule a pre-accept task.
   * May be used to test user thread stress levels before accepting connections.
   */
  fio_queue_s *queue_for_accept;
  /** If the server is forked - listen on the root process or the workers? */
  uint8_t on_root;
};

/**
 * Sets up a network service on a listening socket.
 *
 * Returns 0 on success or -1 on error.
 *
 * See the `fio_listen` Macro for details.
 */
SFUNC int fio_listen(struct fio_listen_args args);
#define fio_listen(...) fio_listen((struct fio_listen_args){__VA_ARGS__})

/* *****************************************************************************
Connecting as a Client
***************************************************************************** */

/** Connects to a specific URL, returning 0 on success and -1 on error. */
FIO_IFUNC int fio_connect(const char *url,
                          fio_protocol_s *protocol,
                          void *udata,
                          void *tls);

/* *****************************************************************************
IO Operations
***************************************************************************** */

/**
 * Attaches the socket in `fd` to the facio.io engine (reactor).
 *
 * * `fd` should point to a valid socket.
 *
 * * `protocol` may be the existing protocol or NULL (for partial hijack).
 *
 * * `udata` is opaque user data and may be any value, including NULL.
 *
 * * `tls` is a context for Transport Layer (Security) and can be used to
 *   redirect read/write operations, as set by the protocol.
 *
 * Returns NULL on error. the `fio_s` pointer must NOT be used except within
 * proper callbacks.
 */
SFUNC fio_s *fio_attach_fd(int fd,
                           fio_protocol_s *protocol,
                           void *udata,
                           void *tls);

/** Sets a new protocol object. `NULL` is a valid "only-write" protocol. */
SFUNC fio_protocol_s *fio_protocol_set(fio_s *io, fio_protocol_s *protocol);

/**
 * Returns a pointer to the current protocol object.
 *
 * If `protocol` wasn't properly set, the pointer might be invalid.
 */
SFUNC fio_protocol_s *fio_protocol_get(fio_s *io);

/** Associates a new `udata` pointer with the IO, returning the old `udata` */
FIO_IFUNC void *fio_udata_set(fio_s *io, void *udata);

/** Returns the `udata` pointer associated with the IO. */
FIO_IFUNC void *fio_udata_get(fio_s *io);

/** Associates a new `tls` pointer with the IO, returning the old `tls` */
FIO_IFUNC void *fio_tls_set(fio_s *io, void *tls);

/** Returns the `tls` pointer associated with the IO. */
FIO_IFUNC void *fio_tls_get(fio_s *io);

/** Returns the socket file descriptor (fd) associated with the IO. */
SFUNC int fio_fd_get(fio_s *io);

/* Resets a socket's timeout counter. */
SFUNC void fio_touch(fio_s *io);

/**
 * Reads data to the buffer, if any data exists. Returns the number of bytes
 * read.
 *
 * NOTE: zero (`0`) is a valid return value meaning no data was available.
 */
SFUNC size_t fio_read(fio_s *io, void *buf, size_t len);

typedef struct {
  /** The buffer with the data to send (if no file descriptor) */
  void *buf;
  /** The file descriptor to send (if no buffer) */
  intptr_t fd;
  /** The length of the data to be sent. On files, 0 = the whole file. */
  size_t len;
  /** The length of the data to be sent. On files, 0 = the whole file. */
  size_t offset;
  /**
   * If this is a buffer, the de-allocation function used to free it.
   *
   * If NULL, the buffer will NOT be de-allocated.
   */
  void (*dealloc)(void *);
  /** If non-zero, makes a copy of the buffer or keeps a file open. */
  uint8_t copy;
} fio_write_args_s;

/**
 * Writes data to the outgoing buffer and schedules the buffer to be sent.
 */
SFUNC void fio_write2(fio_s *io, fio_write_args_s args);
#define fio_write2(io, ...) fio_write2(io, (fio_write_args_s){__VA_ARGS__})

/** Helper macro for a common fio_write2 (copies the buffer). */
#define fio_write(io, buf_, len_)                                              \
  fio_write2(io, .buf = (buf_), .len = (len_), .copy = 1)

/**
 * Sends data from a file as if it were a single atomic packet (sends up to
 * length bytes or until EOF is reached).
 *
 * Once the file was sent, the `source_fd` will be closed using `close`.
 *
 * The file will be buffered to the socket chunk by chunk, so that memory
 * consumption is capped.
 *
 * `offset` dictates the starting point for the data to be sent and length sets
 * the maximum amount of data to be sent.
 *
 * Closes the file on error.
 */
#define fio_sendfile(io, source_fd, offset_, bytes)                            \
  fio_write2((io),                                                             \
             .fd = (source_fd),                                                \
             .offset = (size_t)(offset_),                                      \
             .len = (bytes))

/** Marks the IO for closure as soon as scheduled data was sent. */
SFUNC void fio_close(fio_s *io);

/** Marks the IO for immediate closure. */
SFUNC void fio_close_now(fio_s *io);

/**
 * Increases a IO's reference count, so it won't be automatically destroyed
 * when all tasks have completed.
 *
 * Use this function in order to use the IO outside of a scheduled task.
 *
 * This function is thread-safe.
 */
SFUNC fio_s *fio_dup(fio_s *io);

/**
 * Decreases a IO's reference count, so it could be automatically destroyed
 * when all other tasks have completed.
 *
 * Use this function once finished with a IO that was `dup`-ed.
 *
 * This function is thread-safe.
 */
SFUNC void fio_undup(fio_s *io);

/** Suspends future "on_data" events for the IO. */
SFUNC void fio_suspend(fio_s *io);

/** Listens for future "on_data" events related to the IO. */
SFUNC void fio_unsuspend(fio_s *io);

/** Returns 1 if the IO handle was suspended. */
SFUNC int fio_is_suspended(fio_s *io);

/* *****************************************************************************
Task Scheduling
***************************************************************************** */

/** Schedules a task for delayed execution. This function is thread-safe. */
SFUNC void fio_defer(void (*task)(void *, void *), void *udata1, void *udata2);

/** Schedules a timer bound task, see `fio_timer_schedule`. */
SFUNC void fio_run_every(fio_timer_schedule_args_s args);
/**
 * Schedules a timer bound task, see `fio_timer_schedule`.
 *
 * Possible "named arguments" (fio_timer_schedule_args_s members) include:
 *
 * * The timer function. If it returns a non-zero value, the timer stops:
 *        int (*fn)(void *, void *)
 * * Opaque user data:
 *        void *udata1
 * * Opaque user data:
 *        void *udata2
 * * Called when the timer is done (finished):
 *        void (*on_finish)(void *, void *)
 * * Timer interval, in milliseconds:
 *        uint32_t every
 * * The number of times the timer should be performed. -1 == infinity:
 *        int32_t repetitions
 */
#define fio_run_every(...)                                                     \
  fio_run_every((fio_timer_schedule_args_s){__VA_ARGS__})

/** Returns the last millisecond when the server reviewed pending IO events. */
SFUNC int64_t fio_last_tick(void);

/**************************************************************************/ /**
The Protocol
============

The Protocol struct defines the callbacks used for a family of connections and
sets their behavior. The Protocol struct is part of facil.io's core design.

Protocols are usually global objects and the same protocol can be assigned to
multiple IO handles.

All the callbacks receive a IO handle, which is used instead of the system's
file descriptor and protects callbacks and IO operations from sending data to
incorrect clients (possible `fd` "recycling").
*/
struct fio_protocol_s {
  /**
   * Reserved / private data - used by facil.io internally.
   * MUST be initialized to zero.
   */
  struct {
    /* A linked list of currently attached IOs (ordered) - do NOT alter. */
    FIO_LIST_HEAD ios;
    /* A linked list of other protocols used by IO core - do NOT alter. */
    FIO_LIST_NODE protocols;
    /* internal flags - do NOT alter after initial initialization to zero. */
    uintptr_t flags;
  } reserved;
  /** Called when an IO is attached to a protocol. */
  void (*on_attach)(fio_s *io);
  /** Called when a data is available. */
  void (*on_data)(fio_s *io);
  /** called once all pending `fio_write` calls are finished. */
  void (*on_ready)(fio_s *io);
  /** Called after the connection was closed, and pending tasks completed. */
  void (*on_close)(void *udata);
  /**
   * Called when the server is shutting down, immediately before closing the
   * connection.
   *
   * After the `on_shutdown` callback returns, the socket is marked for closure.
   *
   * Once the socket was marked for closure, facil.io will allow a limited
   * amount of time for data to be sent, after which the socket might be closed
   * even if the client did not consume all buffered data.
   */
  void (*on_shutdown)(fio_s *io);
  /** Called when a connection's timeout was reached */
  void (*on_timeout)(fio_s *io);
  /**
   * Defines Transport Layer callbacks that facil.io will treat as non-blocking
   * system calls.
   */
  struct fio_io_functions {
    /** called once the IO was attached and the TLS object was set. */
    void (*start)(fio_s *io);
    /** Called to perform a non-blocking `read`, same as the system call. */
    ssize_t (*read)(int fd, void *buf, size_t len, void *tls);
    /** Called to perform a non-blocking `write`, same as the system call. */
    ssize_t (*write)(int fd, const void *buf, size_t len, void *tls);
    /** Sends any unsent internal data. Returns 0 only if all data was sent. */
    int (*flush)(int fd, void *tls);
    /** Decreases a fio_tls_s object's reference count, or frees the object. */
    void (*free)(void *tls);
  } io_functions;
  /**
   * The timeout value in seconds for all connections using this protocol.
   *
   * Limited to FIO_SRV_TIMEOUT_MAX seconds. Zero (0) == FIO_SRV_TIMEOUT_MAX
   */
  uint32_t timeout;
};

/** Performs a task for each IO in the stated protocol. */
FIO_SFUNC size_t fio_protocol_each(fio_protocol_s *protocol,
                                   void (*task)(fio_s *, void *udata2),
                                   void *udata2);

/* *****************************************************************************
Connection Object Links / Environment
***************************************************************************** */

/** Named arguments for the `fio_env_set` function. */
typedef struct {
  /** A numerical type filter. Defaults to 0. Negative values are reserved. */
  intptr_t type;
  /** The name for the link. The name and type uniquely identify the object. */
  fio_buf_info_s name;
  /** The object being linked to the connection. */
  void *udata;
  /** A callback that will be called once the connection is closed. */
  void (*on_close)(void *data);
  /** Set to true (1) if the name string's life lives as long as the `env` . */
  uint8_t const_name;
} fio_env_set_args_s;

/** Named arguments for the `fio_env_unset` function. */
typedef struct {
  /** A numerical type filter. Should be the same as used with `fio_env_set` */
  intptr_t type;
  /** The name of the object. Should be the same as used with `fio_env_set` */
  fio_buf_info_s name;
} fio_env_unset_args_s;

/**
 * Links an object to a connection's lifetime / environment.
 *
 * The `on_close` callback will be called once the connection has died.
 *
 * If the `io` is NULL, the value will be set for the global environment.
 */
SFUNC void fio_env_set(fio_s *io, fio_env_set_args_s);

/**
 * Links an object to a connection's lifetime, calling the `on_close` callback
 * once the connection has died.
 *
 * If the `io` is NULL, the value will be set for the global environment, in
 * which case the `on_close` callback will only be called once the process
 * exits.
 *
 * This is a helper MACRO that allows the function to be called using named
 * arguments.
 */
#define fio_env_set(io, ...) fio_env_set(io, (fio_env_set_args_s){__VA_ARGS__})

/**
 * Un-links an object from the connection's lifetime, so it's `on_close`
 * callback will NOT be called.
 *
 * Returns 0 on success and -1 if the object couldn't be found.
 */
SFUNC int fio_env_unset(fio_s *io, fio_env_unset_args_s);

/**
 * Un-links an object from the connection's lifetime, so it's `on_close`
 * callback will NOT be called.
 *
 * Returns 0 on success and -1 if the object couldn't be found.
 *
 * This is a helper MACRO that allows the function to be called using named
 * arguments.
 */
#define fio_env_unset(io, ...)                                                 \
  fio_env_unset(io, (fio_env_unset_args_s){__VA_ARGS__})

/**
 * Removes an object from the connection's lifetime / environment, calling it's
 * `on_close` callback as if the connection was closed.
 */
SFUNC int fio_env_remove(fio_s *io, fio_env_unset_args_s);

/**
 * Removes an object from the connection's lifetime / environment, calling it's
 * `on_close` callback as if the connection was closed.
 *
 * This is a helper MACRO that allows the function to be called using named
 * arguments.
 */
#define fio_env_remove(io, ...)                                                \
  fio_env_remove(io, (fio_env_unset_args_s){__VA_ARGS__})

/* *****************************************************************************
Simple Server Implementation - inlined static functions
***************************************************************************** */

/** Defines a get / set function for the property. */
#define FIO_SERVER_GETSET_FUNC(property, index)                                \
  FIO_IFUNC void *fio_##property##_set(fio_s *io, void *property) {            \
    void *old = ((void **)io)[index];                                          \
    ((void **)io)[index] = property;                                           \
    return old;                                                                \
  }                                                                            \
  FIO_IFUNC void *fio_##property##_get(fio_s *io) {                            \
    return ((void **)io)[index];                                               \
  }
FIO_SERVER_GETSET_FUNC(udata, 0)
FIO_SERVER_GETSET_FUNC(tls, 1)

/** Connects to a specific URL, returning 0 on success and -1 on error. */
FIO_IFUNC int fio_connect(const char *url,
                          fio_protocol_s *protocol,
                          void *udata,
                          void *tls) {
  int fd = fio_sock_open2(url, FIO_SOCK_CLIENT);
  if (fd == -1)
    return -1;
  return (0 - !fio_attach_fd(fd, protocol, udata, tls));
}

/* *****************************************************************************



          Simple Server Implementation - possibly externed functions.


REMEMBER: memory allocations: FIO_MEM_REALLOC_ / FIO_MEM_FREE_
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Protocol validation
***************************************************************************** */

static void srv_on_ev_mock_sus(fio_s *io) { fio_suspend(io); }
static void srv_on_ev_mock(fio_s *io) { (void)(io); }
static void srv_on_close_mock(void *ptr) { (void)ptr; }
static void srv_on_ev_on_timeout(fio_s *io) { fio_close_now(io); }
static void fio___srv_on_timeout_never(fio_s *io) { fio_touch(io); }

/* Called to perform a non-blocking `read`, same as the system call. */
static ssize_t io_func_default_read(int fd, void *buf, size_t len, void *tls) {
  (void)tls;
  return fio_sock_read(fd, buf, len);
}
/** Called to perform a non-blocking `write`, same as the system call. */
static ssize_t io_func_default_write(int fd,
                                     const void *buf,
                                     size_t len,
                                     void *tls) {
  (void)tls;
  return fio_sock_write(fd, buf, len);
}
/** Sends any unsent internal data. Returns 0 only if all data was sent. */
static int io_func_default_flush(int fd, void *tls) {
  return 0;
  (void)fd;
  (void)tls;
}
static void io_func_default_free(void *tls) { (void)tls; }

FIO_SFUNC void fio___srv_init_protocol(fio_protocol_s *pr) {
  pr->reserved.protocols = FIO_LIST_INIT(pr->reserved.protocols);
  pr->reserved.ios = FIO_LIST_INIT(pr->reserved.ios);
  if (!pr->on_attach)
    pr->on_attach = srv_on_ev_mock;
  if (!pr->on_data)
    pr->on_data = srv_on_ev_mock_sus;
  if (!pr->on_ready)
    pr->on_ready = srv_on_ev_mock;
  if (!pr->on_close)
    pr->on_close = srv_on_close_mock;
  if (!pr->on_shutdown)
    pr->on_shutdown = srv_on_ev_mock;
  if (!pr->on_timeout)
    pr->on_timeout = srv_on_ev_on_timeout;
  if (!pr->io_functions.start)
    pr->io_functions.start = srv_on_ev_mock;
  if (!pr->io_functions.read)
    pr->io_functions.read = io_func_default_read;
  if (!pr->io_functions.write)
    pr->io_functions.write = io_func_default_write;
  if (!pr->io_functions.flush)
    pr->io_functions.flush = io_func_default_flush;
  if (!pr->io_functions.free)
    pr->io_functions.free = io_func_default_free;
}

/* the MOCK_PROTOCOL is used to manage hijacked / zombie connections. */
static fio_protocol_s MOCK_PROTOCOL;

FIO_IFUNC void fio___srv_init_protocol_test(fio_protocol_s *pr) {
  if (!fio_atomic_or(&pr->reserved.flags, 1))
    fio___srv_init_protocol(pr);
}

/* *****************************************************************************
Server / IO environment support (`env`)
***************************************************************************** */

/** An object that can be linked to any facil.io connection (fio_s). */
typedef struct {
  void (*on_close)(void *data);
  void *udata;
} fio___srv_env_obj_s;

/* unordered `env` dictionary style map */
#define FIO_UMAP_NAME fio___srv_env
#define FIO_MAP_KEY_KSTR
#define FIO_MAP_VALUE fio___srv_env_obj_s
#define FIO_MAP_VALUE_DESTROY(o)                                               \
  do {                                                                         \
    if ((o).on_close)                                                          \
      (o).on_close((o).udata);                                                 \
  } while (0)
#define FIO_MAP_DESTROY_AFTER_COPY 0

#define FIO_STL_KEEP__ 1
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

typedef struct {
  fio_thread_mutex_t lock;
  fio___srv_env_s env;
} fio___srv_env_safe_s;

#define FIO___SRV_ENV_SAFE_INIT                                                \
  { .lock = FIO_THREAD_MUTEX_INIT, .env = FIO_MAP_INIT }

FIO_IFUNC void fio___srv_env_safe_set(fio___srv_env_safe_s *e,
                                      char *key_,
                                      size_t len,
                                      intptr_t type_,
                                      fio___srv_env_obj_s val,
                                      uint8_t key_is_const) {
  fio_str_info_s key = FIO_STR_INFO3(key_, len, !key_is_const);
  const uint64_t hash = fio_risky_hash(key_, len, (uint64_t)(type_));
  fio_thread_mutex_lock(&e->lock);
  fio___srv_env_set(&e->env, hash, key, val, NULL);
  fio_thread_mutex_unlock(&e->lock);
}

FIO_IFUNC int fio___srv_env_safe_unset(fio___srv_env_safe_s *e,
                                       char *key_,
                                       size_t len,
                                       intptr_t type_) {
  int r;
  fio_str_info_s key = FIO_STR_INFO3(key_, len, 0);
  const uint64_t hash = fio_risky_hash(key_, len, (uint64_t)(type_));
  fio___srv_env_obj_s old;
  fio_thread_mutex_lock(&e->lock);
  r = fio___srv_env_remove(&e->env, hash, key, &old);
  fio_thread_mutex_unlock(&e->lock);
  return r;
}

FIO_IFUNC int fio___srv_env_safe_remove(fio___srv_env_safe_s *e,
                                        char *key_,
                                        size_t len,
                                        intptr_t type_) {
  int r;
  fio_str_info_s key = FIO_STR_INFO3(key_, len, 0);
  const uint64_t hash = fio_risky_hash(key_, len, (uint64_t)(type_));
  fio_thread_mutex_lock(&e->lock);
  r = fio___srv_env_remove(&e->env, hash, key, NULL);
  fio_thread_mutex_unlock(&e->lock);
  return r;
}

FIO_IFUNC void fio___srv_env_safe_destroy(fio___srv_env_safe_s *e) {
  fio___srv_env_destroy(&e->env);
  fio_thread_mutex_destroy(&e->lock);
  *e = (fio___srv_env_safe_s)FIO___SRV_ENV_SAFE_INIT;
}

/* *****************************************************************************
IO Validity Map - Type
***************************************************************************** */
#ifndef FIO_VALIDITY_MAP_USE
#define FIO_VALIDITY_MAP_USE 0
#endif

#if FIO_VALIDITY_MAP_USE
#define FIO_UMAP_NAME         fio_validity_map
#define FIO_MAP_KEY           fio_s *
#define FIO_MAP_HASH_FN(o)    fio_risky_ptr(o)
#define FIO_MAP_KEY_CMP(a, b) ((a) == (b))
#ifndef FIO_VALIDATE_IO_MUTEX
/* mostly for debugging possible threading issues. */
#define FIO_VALIDATE_IO_MUTEX 0
#endif
#define FIO_STL_KEEP__ 1
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__
#else
typedef void *fio_validity_map_s;
#endif

/* *****************************************************************************
Global State
***************************************************************************** */

static void fio___srv_poll_on_data_schd(void *udata);
static void fio___srv_poll_on_ready_schd(void *udata);
static void fio___srv_poll_on_close_schd(void *udata);

static struct {
  FIO_LIST_HEAD protocols;
#if FIO_VALIDITY_MAP_USE
  fio_validity_map_s valid;
#if FIO_VALIDATE_IO_MUTEX
  fio_thread_mutex_t valid_lock;
#endif
#endif /* FIO_VALIDITY_MAP_USE */
  fio___srv_env_safe_s env;
  fio_poll_s poll_data;
  int64_t tick;
  pid_t root_pid;
  pid_t pid;
  fio_s *wakeup;
  int wakeup_fd;
  uint16_t workers;
  uint8_t is_worker;
  volatile uint8_t stop;
} fio___srvdata = {
#if FIO_VALIDATE_IO_MUTEX && FIO_VALIDITY_MAP_USE
    .valid_lock = FIO_THREAD_MUTEX_INIT,
#endif
    .env = FIO___SRV_ENV_SAFE_INIT,
    .tick = 0,
    .wakeup_fd = -1,
    .stop = 1,
};

/* *****************************************************************************
Wakeup Protocol
***************************************************************************** */

static void fio___srv_wakeup_cb(fio_s *io) {
  char buf[512];
  fio_sock_read(fio_fd_get(io), buf, 512);
  (void)(io);
  FIO_LOG_DEBUG2("(%d) fio___srv_wakeup called", fio___srvdata.pid);
}
static void fio___srv_wakeup_on_close(void *ignr_) {
  (void)ignr_;
  fio_sock_close(fio___srvdata.wakeup_fd);
  fio___srvdata.wakeup = NULL;
  fio___srvdata.wakeup_fd = -1;
  FIO_LOG_DEBUG2("(%d) fio___srv_wakeup destroyed", fio___srvdata.pid);
}

FIO_SFUNC void fio___srv_wakeup(void) {
  if (!fio___srvdata.wakeup)
    return;
  char buf[1] = {~0};
  ssize_t ignr = fio_sock_write(fio___srvdata.wakeup_fd, buf, 1);
  (void)ignr;
}

FIO_SFUNC fio_protocol_s FIO___SRV_WAKEUP_PROTOCOL = {
    .on_data = fio___srv_wakeup_cb,
    .on_close = fio___srv_wakeup_on_close,
    .on_timeout = fio___srv_on_timeout_never,
};

FIO_SFUNC void fio___srv_wakeup_init(void) {
  if (fio___srvdata.wakeup)
    return;
  int fds[2];
  if (pipe(fds)) {
    FIO_LOG_ERROR("(%d) couldn't open wakeup pipes, fio___srv_wakeup disabled.",
                  fio___srvdata.pid);
    return;
  }
  fio___srvdata.wakeup_fd = fds[1];
  fio___srvdata.wakeup = fio_attach_fd(fds[0],
                                       &FIO___SRV_WAKEUP_PROTOCOL,
                                       (void *)(uintptr_t)fds[1],
                                       NULL);
  FIO_LOG_DEBUG2("(%d) fio___srv_wakeup initialized", fio___srvdata.pid);
}

/* *****************************************************************************
Server Timers and Task Queues
***************************************************************************** */

static fio_timer_queue_s fio___srv_timer[1] = {FIO_TIMER_QUEUE_INIT};
static fio_queue_s fio___srv_tasks[1];

/** Returns the last millisecond when the server reviewed pending IO events. */
SFUNC int64_t fio_last_tick(void) { return fio___srvdata.tick; }

/** Schedules a task for delayed execution. This function is thread-safe. */
SFUNC void fio_defer(void (*task)(void *, void *), void *udata1, void *udata2) {
  fio_queue_push(fio___srv_tasks, task, udata1, udata2);
  fio___srv_wakeup();
}

/** Schedules a timer bound task, see `fio_timer_schedule` in the CSTL. */
SFUNC void fio_run_every FIO_NOOP(fio_timer_schedule_args_s args) {
  args.start_at += ((uint64_t)0 - !args.start_at) & fio___srvdata.tick;
  fio_timer_schedule FIO_NOOP(fio___srv_timer, args);
}

/* *****************************************************************************
IO Validity Map - Implementation
***************************************************************************** */
#if FIO_VALIDITY_MAP_USE

#if FIO_VALIDATE_IO_MUTEX
#define FIO_VALIDATE_LOCK()   fio_thread_mutex_lock(&fio___srvdata.valid_lock)
#define FIO_VALIDATE_UNLOCK() fio_thread_mutex_unlock(&fio___srvdata.valid_lock)
#define FIO_VALIDATE_LOCK_DESTROY()                                            \
  fio_thread_mutex_destroy(&fio___srvdata.valid_lock)
#else
#define FIO_VALIDATE_LOCK()
#define FIO_VALIDATE_UNLOCK()
#define FIO_VALIDATE_LOCK_DESTROY()
#endif

FIO_IFUNC int fio_is_valid(fio_s *io) {
  FIO_VALIDATE_LOCK();
  fio_s *r = fio_validity_map_get(&fio___srvdata.valid, fio_risky_ptr(io), io);
  FIO_VALIDATE_UNLOCK();
  return r == io;
}

FIO_IFUNC void fio_set_valid(fio_s *io) {
  FIO_VALIDATE_LOCK();
  fio_validity_map_set(&fio___srvdata.valid, fio_risky_ptr(io), io, NULL);
  FIO_VALIDATE_UNLOCK();
  FIO_ASSERT_DEBUG(fio_is_valid(io),
                   "(%d) IO validity set, but map reported as invalid!",
                   (int)fio___srvdata.pid);
  FIO_LOG_DEBUG2("(%d) IO %p is now valid", (int)fio___srvdata.pid, (void *)io);
}

FIO_IFUNC void fio_set_invalid(fio_s *io) {
  fio_s *old = NULL;
  FIO_LOG_DEBUG2("(%d) IO %p is no longer valid",
                 (int)fio___srvdata.pid,
                 (void *)io);
  FIO_VALIDATE_LOCK();
  fio_validity_map_remove(&fio___srvdata.valid, fio_risky_ptr(io), io, &old);
  FIO_VALIDATE_UNLOCK();
  FIO_ASSERT_DEBUG(!old || old == io,
                   "(%d) invalidity map corruption (%p != %p)!",
                   (int)fio___srvdata.pid,
                   io,
                   old);
  FIO_ASSERT_DEBUG(!fio_is_valid(io),
                   "(%d) IO validity removed, but map reported as valid!",
                   (int)fio___srvdata.pid);
}

FIO_IFUNC void fio_invalidate_all() {
  FIO_VALIDATE_LOCK();
  fio_validity_map_destroy(&fio___srvdata.valid);
  FIO_VALIDATE_UNLOCK();
  FIO_VALIDATE_LOCK_DESTROY();
}

/** Returns an approximate number of IO objects attached. */
SFUNC size_t fio_io_count(void) { /* TODO: remove? */
  return fio_validity_map_count(&fio___srvdata.valid);
}

#undef FIO_VALIDATE_LOCK
#undef FIO_VALIDATE_UNLOCK
#undef FIO_VALIDATE_LOCK_DESTROY
#else /* FIO_VALIDITY_MAP_USE */
#define fio_is_valid(io) 1
#define fio_set_valid(io)
#define fio_set_invalid(io)
#define fio_invalidate_all()
#endif /* FIO_VALIDITY_MAP_USE */
/* *****************************************************************************
IO objects
***************************************************************************** */

struct fio_s {
  void *udata;
  void *tls;
  fio_protocol_s *pr;
  FIO_LIST_NODE node;
  fio_stream_s stream;
  fio___srv_env_safe_s env;
  int64_t active;
  uint32_t state;
  int fd;
};

#define FIO_STATE_OPEN      ((uint32_t)1U)
#define FIO_STATE_SUSPENDED ((uint32_t)2U)
#define FIO_STATE_THROTTLED ((uint32_t)4U)
#define FIO_STATE_CLOSING   ((uint32_t)8U)

FIO_SFUNC void fio_s_init(fio_s *io) {
  *io = (fio_s){
      .pr = &MOCK_PROTOCOL,
      .node = FIO_LIST_INIT(io->node),
      .stream = FIO_STREAM_INIT(io->stream),
      .env = FIO___SRV_ENV_SAFE_INIT,
      .active = fio___srvdata.tick,
      .state = FIO_STATE_OPEN,
      .fd = -1,
  };
  FIO_LIST_PUSH(&io->pr->reserved.ios, &io->node);
  FIO_LIST_REMOVE(&MOCK_PROTOCOL.reserved.protocols);
  FIO_LIST_PUSH(&fio___srvdata.protocols, &MOCK_PROTOCOL.reserved.protocols);
  fio_set_valid(io);
}

FIO_SFUNC void fio_s_destroy(fio_s *io) {
  fio_set_invalid(io);
  FIO_LIST_REMOVE(&io->node);
  fio_sock_close(io->fd);
  fio_stream_destroy(&io->stream);
  fio_poll_forget(&fio___srvdata.poll_data, io->fd);
  FIO_LOG_DDEBUG2("detaching and destroying %p (fd %d)", (void *)io, io->fd);
  io->pr->on_close(io->udata);
  io->pr->io_functions.free(io->tls);
  fio___srv_env_safe_destroy(&io->env);
  if (FIO_LIST_IS_EMPTY(&io->pr->reserved.ios))
    FIO_LIST_REMOVE_RESET(&io->pr->reserved.protocols);
}
#define FIO_REF_NAME       fio
#define FIO_REF_INIT(o)    fio_s_init(&(o))
#define FIO_REF_DESTROY(o) fio_s_destroy(&(o))
#define FIO_STL_KEEP__     1
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

static void fio___protocol_set_task(void *io_, void *old_) {
  fio_s *io = (fio_s *)io_;
  fio_protocol_s *old = (fio_protocol_s *)old_;
  FIO_LIST_REMOVE(&io->node);
  if (FIO_LIST_IS_EMPTY(&old->reserved.ios))
    FIO_LIST_REMOVE_RESET(&old->reserved.protocols);
  FIO_LIST_PUSH(&io->pr->reserved.ios, &io->node);
  if (io->node.next == io->node.prev) /* list was empty before IO was added */
    FIO_LIST_PUSH(&fio___srvdata.protocols, &io->pr->reserved.protocols);
  fio_poll_monitor(&fio___srvdata.poll_data,
                   io->fd,
                   (void *)io,
                   POLLIN | POLLOUT);
  io->pr->on_attach(io);
  io->pr->io_functions.start(io);
}

/** Sets a new protocol object, returning the old protocol. */
SFUNC fio_protocol_s *fio_protocol_set(fio_s *io, fio_protocol_s *pr) {
  if (!pr)
    pr = &MOCK_PROTOCOL;
  fio___srv_init_protocol_test(pr);
  fio_protocol_s *old = io->pr;
  if (pr == old)
    return NULL;
  io->pr = pr;
  // fio_queue_push(fio___srv_tasks, fio___protocol_set_task, io, old);
  fio___protocol_set_task((void *)io, (void *)old);
  return old;
}

/** Returns a pointer to the current protocol object. */
SFUNC fio_protocol_s *fio_protocol_get(fio_s *io) { return io->pr; }

/* Attaches the socket in `fd` to the facio.io engine (reactor). */
SFUNC fio_s *fio_attach_fd(int fd,
                           fio_protocol_s *protocol,
                           void *udata,
                           void *tls) {
  fio_s *io = NULL;
  fio_protocol_s *old = NULL;
  if (!protocol)
    protocol = &MOCK_PROTOCOL;
  fio___srv_init_protocol_test(protocol);
  if (fd == -1)
    goto error;
  io = fio_new2();
  FIO_ASSERT_ALLOC(io);
  FIO_LOG_DDEBUG2("attaching fd %d to IO object %p", fd, (void *)io);
  fio_sock_set_non_block(fd);
  old = io->pr;
  io->fd = fd;
  io->pr = protocol;
  io->udata = udata;
  io->tls = tls;
  fio_queue_push(fio___srv_tasks, fio___protocol_set_task, io, old);
  return io;
error:
  protocol->on_close(udata);
  protocol->io_functions.free(tls);
  return NULL;
}

/**
 * Increases a IO's reference count, so it won't be automatically destroyed
 * when all tasks have completed.
 */
SFUNC fio_s *fio_dup(fio_s *io) { return fio_dup2(io); }

static void fio_undup_task(void *io, void *ignr_) {
  (void)ignr_;
  fio_free2((fio_s *)io);
}
/**
 * Decreases a IO's reference count, so it could be automatically destroyed
 * when all other tasks have completed.
 */
SFUNC void fio_undup(fio_s *io) {
  fio_queue_push(fio___srv_tasks, fio_undup_task, io);
  fio___srv_wakeup();
}

/** Performs a task for each IO in the stated protocol. */
FIO_SFUNC size_t fio_protocol_each(fio_protocol_s *protocol,
                                   void (*task)(fio_s *, void *),
                                   void *udata) {
  size_t count = 0;
  if (!protocol || !protocol->reserved.ios.next || !protocol->reserved.ios.prev)
    return count;
  FIO_LIST_EACH(fio_s, node, &protocol->reserved.ios, io) {
    if (!(io->state & FIO_STATE_OPEN))
      continue;
    task(io, udata);
    ++count;
  }
  return count;
}

/* *****************************************************************************
Connection Object Links / Environment
***************************************************************************** */

void fio_env_set___(void); /* IDE marker */
/**
 * Links an object to a connection's lifetime / environment.
 */
SFUNC void fio_env_set FIO_NOOP(fio_s *io, fio_env_set_args_s args) {
  fio___srv_env_obj_s val = {
      .udata = args.udata,
      .on_close = args.on_close,
  };
  fio___srv_env_safe_set((io ? &io->env : &fio___srvdata.env),
                         args.name.buf,
                         args.name.len,
                         args.type,
                         val,
                         args.const_name);
}

void fio_env_unset___(void); /* IDE marker */
/**
 * Un-links an object from the connection's lifetime, so it's `on_close`
 * callback will NOT be called.
 */
SFUNC int fio_env_unset FIO_NOOP(fio_s *io, fio_env_unset_args_s args) {
  return fio___srv_env_safe_unset((io ? &io->env : &fio___srvdata.env),
                                  args.name.buf,
                                  args.name.len,
                                  args.type);
}

/**
 * Removes an object from the connection's lifetime / environment, calling it's
 * `on_close` callback as if the connection was closed.
 */
SFUNC int fio_env_remove FIO_NOOP(fio_s *io, fio_env_unset_args_s args) {
  return fio___srv_env_safe_remove((io ? &io->env : &fio___srvdata.env),
                                   args.name.buf,
                                   args.name.len,
                                   args.type);
}

/* *****************************************************************************
Event handling
***************************************************************************** */

static void fio___srv_poll_on_data(void *io_, void *ignr_) {
  (void)ignr_;
  fio_s *io = (fio_s *)io_;
  if (io->state == FIO_STATE_OPEN) {
    /* this also tests for the suspended / throttled / closing flags */
    io->pr->on_data(io);
    if (io->state == FIO_STATE_OPEN) {
      fio_poll_monitor(&fio___srvdata.poll_data, io->fd, io, POLLIN);
    }
  } else if ((io->state & FIO_STATE_OPEN)) {
    fio_poll_monitor(&fio___srvdata.poll_data, io->fd, io, POLLOUT);
  }
  fio_free2(io);
  return;
}

static void fio___srv_poll_on_ready(void *io_, void *ignr_) {
  (void)ignr_;
  fio_s *io = (fio_s *)io_;
  if ((io->state & FIO_STATE_OPEN)) {
    char buf_mem[FIO_SRV_BUFFER_PER_WRITE];
    size_t total = 0;
    for (;;) {
      size_t len = FIO_SRV_BUFFER_PER_WRITE;
      char *buf = buf_mem;
      fio_stream_read(&io->stream, &buf, &len);
      if (!len)
        break;
      ssize_t r = io->pr->io_functions.write(io->fd, buf, len, io->tls);
      if (r > 0) {
        total += r;
        fio_stream_advance(&io->stream, len);
        continue;
      } else if ((r == -1) & ((errno == EWOULDBLOCK) | (errno == EAGAIN) |
                              (errno == EINTR))) {
        break;
      } else {
        fio_close_now(io);
        goto finish;
      }
    }
    if (total)
      fio_touch(io);
    if (!fio_stream_any(&io->stream) &&
        !io->pr->io_functions.flush(io->fd, io->tls)) {
      if ((io->state & FIO_STATE_CLOSING)) {
        fio_close_now(io);
      } else {
        if ((io->state & FIO_STATE_THROTTLED)) {
          fio_atomic_and(&io->state, ~FIO_STATE_THROTTLED);
          fio_poll_monitor(&fio___srvdata.poll_data, io->fd, io, POLLIN);
        }
        io->pr->on_ready(io);
      }
    } else if ((io->state & FIO_STATE_OPEN)) {
      if (fio_stream_length(&io->stream) >= FIO_SRV_THROTTLE_LIMIT) {
        if (!(io->state & FIO_STATE_THROTTLED))
          FIO_LOG_DDEBUG2("throttled IO %p (fd %d)", (void *)io, io->fd);
        fio_atomic_or(&io->state, FIO_STATE_THROTTLED);
      }
      fio_poll_monitor(&fio___srvdata.poll_data, io->fd, io, POLLOUT);
    }
  }
finish:
  fio_free2(io);
}

static void fio___srv_poll_on_close(void *io_, void *ignr_) {
  (void)ignr_;
  fio_s *io = (fio_s *)io_;
  fio_close_now(io);
  fio_free2(io);
}

static void fio___srv_poll_on_timeout(void *io_, void *ignr_) {
  (void)ignr_;
  fio_s *io = (fio_s *)io_;
  io->pr->on_timeout(io);
  fio_free2(io);
}

/* *****************************************************************************
Event scheduling
***************************************************************************** */

static void fio___srv_poll_on_data_schd(void *io) {
  if (!fio_is_valid(io))
    return;
  fio_queue_push(fio___srv_tasks,
                 fio___srv_poll_on_data,
                 fio_dup2((fio_s *)io));
}
static void fio___srv_poll_on_ready_schd(void *io) {
  if (!fio_is_valid(io))
    return;
  fio_queue_push(fio___srv_tasks,
                 fio___srv_poll_on_ready,
                 fio_dup2((fio_s *)io));
}
static void fio___srv_poll_on_close_schd(void *io) {
  if (!fio_is_valid(io))
    return;
  fio_queue_push(fio___srv_tasks,
                 fio___srv_poll_on_close,
                 fio_dup2((fio_s *)io));
}

/* *****************************************************************************
Timeout Review
***************************************************************************** */

/** Schedules the timeout event for any timed out IO object */
static int fio___srv_review_timeouts(void) {
  int c = 0;
  static time_t last_to_review = 0;
  /* test timeouts at whole second intervals */
  if (last_to_review + 1000 > fio___srvdata.tick)
    return c;
  last_to_review = fio___srvdata.tick;
  const int64_t now_milli = fio___srvdata.tick;

  FIO_LIST_EACH(fio_protocol_s,
                reserved.protocols,
                &fio___srvdata.protocols,
                pr) {
    FIO_ASSERT_DEBUG(pr->reserved.flags, "protocol object flags unmarked?!");
    if (!pr->timeout || pr->timeout > FIO_SRV_TIMEOUT_MAX)
      pr->timeout = FIO_SRV_TIMEOUT_MAX;
    int64_t limit = now_milli - ((int64_t)pr->timeout);
    FIO_LIST_EACH(fio_s, node, &pr->reserved.ios, io) {
      FIO_ASSERT_DEBUG(io->pr == pr, "IO protocol ownership error");
      if (io->active >= limit)
        break;
      FIO_LOG_DDEBUG2("scheduling timeout for %p (fd %d)", (void *)io, io->fd);
      fio_queue_push(fio___srv_tasks, fio___srv_poll_on_timeout, fio_dup2(io));
      ++c;
    }
  }
  return c;
}

/* *****************************************************************************
Reactor cycling
***************************************************************************** */
static void fio___srv_signal_handle(int sig, void *flg) {
  ((uint8_t *)flg)[0] = 1;
  (void)sig;
}

FIO_SFUNC void fio___srv_tick(int timeout) {
  static size_t performed_idle = 0;
  if (fio_poll_review(&fio___srvdata.poll_data, timeout) > 0) {
    performed_idle = 0;
  } else {
    if (!performed_idle)
      fio_state_callback_force(FIO_CALL_ON_IDLE);
    performed_idle = 1;
  }
  fio___srvdata.tick = fio_time_milli();
  fio_timer_push2queue(fio___srv_tasks, fio___srv_timer, fio___srvdata.tick);
  fio_queue_perform_all(fio___srv_tasks);
  if (fio___srv_review_timeouts())
    fio_queue_perform_all(fio___srv_tasks);
  fio_signal_review();
}

FIO_SFUNC void fio_srv_shutdown(void) {
  /* collect tick for shutdown start, to monitor for possible timeout */
  int64_t shutdown_start = fio___srvdata.tick = fio_time_milli();
  size_t connected = 0;
  /* first notify that shutdown is starting */
  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);
  /* preform on_shutdown callback for each connection and close */
  FIO_LIST_EACH(fio_protocol_s,
                reserved.protocols,
                &fio___srvdata.protocols,
                pr) {
    FIO_LIST_EACH(fio_s, node, &pr->reserved.ios, io) {
      pr->on_shutdown(io); /* TODO / FIX: move callback to task? */
      fio_close(io);       /* TODO / FIX: skip close on return value? */
      ++connected;
    }
  }
  FIO_LOG_DEBUG("Server shutting down with %zu connected clients", connected);
  /* cycle while connections exist. */
  while (shutdown_start + FIO_SRV_SHUTDOWN_TIMEOUT >= fio___srvdata.tick &&
         !FIO_LIST_IS_EMPTY(&fio___srvdata.protocols)) {
    fio___srv_tick(100);
  }
  /* in case of timeout, force close remaining connections. */
  connected = 0;
  FIO_LIST_EACH(fio_protocol_s,
                reserved.protocols,
                &fio___srvdata.protocols,
                pr) {
    FIO_LIST_EACH(fio_s, node, &pr->reserved.ios, io) {
      fio_close_now(io);
      ++connected;
    }
  }
  FIO_LOG_DEBUG("Server shutdown timed out with %zu clients", connected);
  /* perform remaining tasks. */
  fio_queue_perform_all(fio___srv_tasks);
}

FIO_SFUNC void fio___srv_work(int is_worker) {
  fio___srvdata.is_worker = is_worker;
  fio_queue_perform_all(fio___srv_tasks);
  if (is_worker) {
    fio_state_callback_force(FIO_CALL_ON_START);
  }
  fio___srv_wakeup_init();
  while (!fio___srvdata.stop) {
    fio___srv_tick(500);
  }
  fio_srv_shutdown();
  fio_state_callback_force(FIO_CALL_ON_FINISH);
  fio_queue_perform_all(fio___srv_tasks);
  fio___srvdata.workers = 0;
}

/* *****************************************************************************
Worker Forking
***************************************************************************** */
static void fio___srv_spawn_worker(void *ignr_1, void *ignr_2);

static void fio___srv_wait_for_worker(void *thr_) {
  fio_thread_t t = (fio_thread_t)thr_;
  fio_thread_join(&t);
}

/** Worker sentinel */
static void *fio___srv_worker_sentinel(void *pid_data) {
  pid_t pid = (pid_t)(uintptr_t)pid_data;
  int status = 0;
  (void)status;
  fio_thread_t thr = fio_thread_current();
  fio_state_callback_add(FIO_CALL_ON_FINISH,
                         fio___srv_wait_for_worker,
                         (void *)thr);
  if (waitpid(pid, &status, 0) != pid && !fio___srvdata.stop)
    FIO_LOG_ERROR("waitpid failed, worker re-spawning might fail.");
  if (!WIFEXITED(status) || WEXITSTATUS(status)) {
    FIO_LOG_WARNING("abnormal worker exit detected");
    fio_state_callback_force(FIO_CALL_ON_CHILD_CRUSH);
  }
  if (!fio___srvdata.stop) {
    FIO_ASSERT_DEBUG(
        0,
        "DEBUG mode prevents worker re-spawning, now crashing parent.");
    fio_state_callback_remove(FIO_CALL_ON_FINISH,
                              fio___srv_wait_for_worker,
                              (void *)thr);
    fio_thread_detach(&thr);
    fio_queue_push(fio___srv_tasks, fio___srv_spawn_worker, (void *)thr);
  }
  return NULL;
}

static void fio___srv_spawn_worker(void *ignr_1, void *ignr_2) {
  (void)ignr_1, (void)ignr_2;
  fio_thread_t t;

  if (fio___srvdata.root_pid != fio___srvdata.pid)
    return;

  fio_state_callback_force(FIO_CALL_BEFORE_FORK);
  /* do not allow master tasks to run in worker */
  fio_queue_perform_all(fio___srv_tasks);
  /* perform actual fork */
  pid_t pid = fio_thread_fork();
  FIO_ASSERT(pid != (pid_t)-1, "system call `fork` failed.");
  if (!pid)
    goto is_worker_process;
  fio_state_callback_force(FIO_CALL_AFTER_FORK);
  fio_state_callback_force(FIO_CALL_IN_MASTER);
  if (fio_thread_create(&t,
                        fio___srv_worker_sentinel,
                        (void *)(uintptr_t)pid)) {
    FIO_LOG_FATAL(
        "sentinel thread creation failed, no worker will be spawned.");
    fio_srv_stop();
  }
  return;

is_worker_process:
  fio___srvdata.pid = getpid();
  fio___srvdata.is_worker = 1;
  FIO_LOG_INFO("(%d) worker starting up.", (int)fio___srvdata.pid);
  fio_state_callback_force(FIO_CALL_AFTER_FORK);
  fio_state_callback_force(FIO_CALL_IN_CHILD);
  fio___srv_work(1);
  FIO_LOG_INFO("(%d) worker exiting.", (int)fio___srvdata.pid);
  exit(0);
}

/* *****************************************************************************
Starting the Server
***************************************************************************** */

/* Stopping the server. */
SFUNC void fio_srv_stop(void) { fio___srvdata.stop = 1; }

/* Returns true if server running and 0 if server stopped or shutting down. */
SFUNC int fio_srv_is_running() { return !fio___srvdata.stop; }

/* Returns true if the current process is the server's master process. */
SFUNC int fio_srv_is_master() {
  return fio___srvdata.root_pid == fio___srvdata.pid;
}

/* Returns true if the current process is a server's worker process. */
SFUNC int fio_srv_is_worker() { return fio___srvdata.is_worker; }

/* Returns the number or workers the server will actually run. */
SFUNC uint16_t fio_srv_workers(int workers) {
  if (workers < 0) {
    int cores = -1;
#ifdef _SC_NPROCESSORS_ONLN
    cores = sysconf(_SC_NPROCESSORS_ONLN);
#endif /* _SC_NPROCESSORS_ONLN */
    if (cores == -1) {
      cores = 8;
      FIO_LOG_WARNING("fio_srv_start called with negative value for worker "
                      "count, but auto-detect failed, assuming %d CPU cores",
                      cores);
    }
    workers = cores / (0 - workers);
    workers += !workers;
  }
  return workers;
}

/* Starts the server, using optional `workers` processes. This will BLOCK! */
SFUNC void fio_srv_start(int workers) {
  fio___srvdata.stop = 0;
  fio___srvdata.workers = fio_srv_workers(workers);
  workers = (int)fio___srvdata.workers;
  fio___srvdata.is_worker = !workers;
  fio_sock_maximize_limits();
  fio_state_callback_force(FIO_CALL_PRE_START);
  fio_queue_perform_all(fio___srv_tasks);
  fio_signal_monitor(SIGINT,
                     fio___srv_signal_handle,
                     (void *)&fio___srvdata.stop);
  fio_signal_monitor(SIGTERM,
                     fio___srv_signal_handle,
                     (void *)&fio___srvdata.stop);
#ifdef SIGPIPE
  fio_signal_monitor(SIGPIPE, NULL, NULL);
#endif
  fio___srvdata.tick = fio_time_milli();
  if (workers)
    FIO_LOG_DEBUG("starting facil.io server using %d workers.", workers);
  else
    FIO_LOG_DEBUG("starting facil.io server in single process mode.");
  for (int i = 0; i < workers; ++i) {
    fio___srv_spawn_worker(NULL, NULL);
  }
  fio___srv_work(!workers);
  fio_signal_forget(SIGINT);
  fio_signal_forget(SIGTERM);
#ifdef SIGPIPE
  fio_signal_forget(SIGPIPE);
#endif
  fio_queue_perform_all(fio___srv_tasks);
}

/* *****************************************************************************
IO API
***************************************************************************** */

/** Returns the socket file descriptor (fd) associated with the IO. */
SFUNC int fio_fd_get(fio_s *io) { return io->fd; }

FIO_SFUNC void fio_touch___task(void *io_, void *ignr_) {
  (void)ignr_;
  fio_s *io = (fio_s *)io_;
  io->active = fio___srvdata.tick;
  FIO_LIST_REMOVE(&io->node);
  FIO_LIST_PUSH(&io->pr->reserved.ios, &io->node);
  fio_free2(io);
}

/* Resets a socket's timeout counter. */
SFUNC void fio_touch(fio_s *io) {
  fio_queue_push_urgent(fio___srv_tasks, fio_touch___task, fio_dup(io));
}

/**
 * Reads data to the buffer, if any data exists. Returns the number of bytes
 * read.
 *
 * NOTE: zero (`0`) is a valid return value meaning no data was available.
 */
SFUNC size_t fio_read(fio_s *io, void *buf, size_t len) {
  ssize_t r = io->pr->io_functions.read(io->fd, buf, len, io->tls);
  if (r > 0) {
    fio_touch(io);
    return r;
  }
  if ((!len) | ((r == -1) & ((errno == EAGAIN) | (errno == EWOULDBLOCK) |
                             (errno == EINTR))))
    return 0;
  fio_close(io);
  return 0;
}

FIO_SFUNC void fio_write2___task(void *io_, void *packet_) {
  fio_s *io = (fio_s *)io_;
  fio_stream_packet_s *packet = (fio_stream_packet_s *)packet_;
  if (!(io->state & FIO_STATE_OPEN))
    goto io_error;
  fio_stream_add(&io->stream, packet);
  fio_queue_push(fio___srv_tasks,
                 fio___srv_poll_on_ready,
                 io); /* no dup/undup, already done.*/
  return;
io_error:
  fio_stream_pack_free(packet);
  fio_free2(io); /* undup the IO object since it isn't moved to on_ready */
}

void fio_write2___(void); /* IDE marker*/
/**
 * Writes data to the outgoing buffer and schedules the buffer to be sent.
 */
SFUNC void fio_write2 FIO_NOOP(fio_s *io, fio_write_args_s args) {
  fio_stream_packet_s *packet = NULL;
  if (!io)
    goto io_error_null;
  if (args.buf) {
    packet = fio_stream_pack_data(args.buf,
                                  args.len,
                                  args.offset,
                                  args.copy,
                                  args.dealloc);
  } else if (args.fd != -1) {
    packet = fio_stream_pack_fd(args.fd, args.len, args.offset, args.copy);
  }
  if (!packet)
    goto error;
  if (io && (io->state & FIO_STATE_CLOSING))
    goto write_called_after_close;
  fio_queue_push(fio___srv_tasks, fio_write2___task, fio_dup2(io), packet);
  return;
error: /* note: `dealloc` is called by the `fio_stream` API error handler. */
  FIO_LOG_ERROR("couldn't create %zu bytes long user-packet for IO %p (%d)",
                args.len,
                (void *)io,
                (io ? io->fd : -1));
  return;
write_called_after_close:
  FIO_LOG_WARNING("`write` called after `close` was called for IO.");
  fio_stream_pack_free(packet);
  return;
io_error_null:
  FIO_LOG_ERROR("(%d) `fio_write2` called for invalid IO (NULL)",
                fio___srvdata.pid);
  if (args.dealloc)
    args.dealloc(args.buf);
}

/** Marks the IO for closure as soon as scheduled data was sent. */
SFUNC void fio_close(fio_s *io) {
  if (io && (io->state & FIO_STATE_OPEN) &&
      !(fio_atomic_or(&io->state, FIO_STATE_CLOSING) & FIO_STATE_CLOSING)) {
    FIO_LOG_DDEBUG2("scheduling IO %p (fd %d) for closure", (void *)io, io->fd);
    fio_queue_push(fio___srv_tasks,
                   fio___srv_poll_on_ready,
                   fio_dup2((fio_s *)io));
  }
}

/** Marks the IO for immediate closure. */
SFUNC void fio_close_now(fio_s *io) {
  fio_atomic_or(&io->state, FIO_STATE_CLOSING);
  if ((fio_atomic_and(&io->state, ~FIO_STATE_OPEN) & FIO_STATE_OPEN))
    fio_free2(io);
}

/** Suspends future "on_data" events for the IO. */
SFUNC void fio_suspend(fio_s *io) { io->state |= FIO_STATE_SUSPENDED; }

/** Listens for future "on_data" events related to the IO. */
SFUNC void fio_unsuspend(fio_s *io) {
  if ((fio_atomic_and(&io->state, ~FIO_STATE_SUSPENDED) & FIO_STATE_SUSPENDED))
    fio_poll_monitor(&fio___srvdata.poll_data, io->fd, (void *)io, POLLIN);
}

/** Returns 1 if the IO handle was suspended. */
SFUNC int fio_is_suspended(fio_s *io) {
  return (io->state & FIO_STATE_SUSPENDED);
}

/* *****************************************************************************
Listening
***************************************************************************** */

static void fio___srv_listen_on_data_task(void *io_, void *ignr_) {
  (void)ignr_;
  fio_s *io = (fio_s *)io_;
  int fd;
  struct fio_listen_args *l = (struct fio_listen_args *)(io->udata);
  while ((fd = accept(fio_fd_get(io), NULL, NULL)) != -1) {
    l->on_open(fd, l->udata);
  }
  fio_free2(io);
}
static void fio___srv_listen_on_data_task_reschd(void *io_, void *ignr_) {
  fio_queue_push(fio___srv_tasks, fio___srv_listen_on_data_task, io_, ignr_);
}

static void fio___srv_listen_on_data(fio_s *io) {
  int fd;
  struct fio_listen_args *l = (struct fio_listen_args *)(io->udata);
  if (l->queue_for_accept) {
    fio_queue_push(l->queue_for_accept,
                   fio___srv_listen_on_data_task_reschd,
                   fio_dup2(io));
    return;
  }
  while ((fd = accept(fio_fd_get(io), NULL, NULL)) != -1) {
    l->on_open(fd, l->udata);
  }
}
static void fio___srv_listen_on_close(void *settings_) {
  struct fio_listen_args *s = (struct fio_listen_args *)settings_;
  if (s->on_finish)
    s->on_finish(s->udata);
  if ((!s->on_root && fio_srv_is_worker()) ||
      (s->on_root && fio_srv_is_master()))
    FIO_LOG_INFO("(%d) stopped listening on %s", fio___srvdata.pid, s->url);
}

FIO_SFUNC void fio___srv_listen_cleanup_task(void *udata) {
  struct fio_listen_args *l = (struct fio_listen_args *)udata;
  int *pfd = (int *)(l + 1);
  fio_sock_close(*pfd);
#ifdef AF_UNIX
  /* delete the unix socket file, if any. */
  fio_url_s u = fio_url_parse(l->url, strlen(l->url));
  if (fio_srv_is_master() && !u.host.buf && !u.port.buf && u.path.buf) {
    unlink(u.path.buf);
  }
#endif
  fio_state_callback_remove(FIO_CALL_AT_EXIT,
                            fio___srv_listen_cleanup_task,
                            udata);
  FIO_MEM_FREE_(l, sizeof(*l) + sizeof(int) + strlen(l->url) + 1);
}

static fio_protocol_s FIO___LISTEN_PROTOCOL = {
    .on_data = fio___srv_listen_on_data,
    .on_close = fio___srv_listen_on_close,
    .on_timeout = fio___srv_on_timeout_never,
};

FIO_SFUNC void fio___srv_listen_attach_task(void *udata) {
  struct fio_listen_args *l = (struct fio_listen_args *)udata;
  int *pfd = (int *)(l + 1);
  int fd = fio_sock_dup(*pfd);
  FIO_ASSERT(fd != -1, "listening socket failed to `dup`");
  FIO_LOG_DEBUG2("(%d) Called dup(%d) to attach %d as a listening socket.",
                 (int)fio___srvdata.pid,
                 *pfd,
                 fd);
  fio_attach_fd(fd, &FIO___LISTEN_PROTOCOL, l, NULL);
  FIO_LOG_INFO("(%d) started listening on %s", fio___srvdata.pid, l->url);
}

FIO_SFUNC void fio___srv_listen_attach_task_deferred(void *udata, void *ignr_) {
  (void)ignr_;
  fio___srv_listen_attach_task(udata);
}

void fio_listen___(void); /* IDE Marker */
SFUNC int fio_listen FIO_NOOP(struct fio_listen_args args) {
  static int64_t port = 0;
  size_t len = args.url ? strlen(args.url) + 1 : 0;
  struct fio_listen_args *cpy = NULL;
  fio_str_info_s adr, tmp;
  int *fd_store;
  int fd;
  if (!args.on_open) {
    FIO_LOG_ERROR("fio_listen missing `on_open` callback.");
    goto other_error;
  }
  len += (!len) << 6;
  cpy = (struct fio_listen_args *)
      FIO_MEM_REALLOC_(NULL, 0, (sizeof(*cpy) + sizeof(int) + len), 0);
  FIO_ASSERT_ALLOC(cpy);
  *cpy = args;
  cpy->url = (char *)(cpy + 1) + sizeof(int);
  fd_store = (int *)(cpy + 1);
  if (args.url) {
    FIO_MEMCPY((void *)(cpy->url), args.url, len);
  } else {
    if (!port) {
      char *port_env = getenv("PORT");
      if (port_env)
        port = fio_atol10(&port_env);
      if (!port | ((uint64_t)port > 65535))
        port = 3000;
    }
    tmp = FIO_STR_INFO3((char *)cpy->url, 0, len);
    if (!(adr.buf = getenv("ADDRESS")) || (adr.len = strlen(adr.buf)) > 58) {
      adr = FIO_STR_INFO2((char *)"0.0.0.0:", 8);
    }
    fio_string_write2(&tmp,
                      NULL,
                      FIO_STRING_WRITE_STR2(adr.buf, adr.len),
                      FIO_STRING_WRITE_UNUM(port));
    ++port;
  }
  fd = fio_sock_open2(cpy->url, FIO_SOCK_SERVER | FIO_SOCK_TCP);
  if (fd == -1)
    goto fd_error;
  *fd_store = fd;
  if (fio_srv_is_running()) {
    fio_defer(fio___srv_listen_attach_task_deferred, cpy, NULL);
  } else {
    fio_state_callback_add(
        (args.on_root ? FIO_CALL_PRE_START : FIO_CALL_ON_START),
        fio___srv_listen_attach_task,
        (void *)cpy);
  }
  fio_state_callback_add(FIO_CALL_AT_EXIT, fio___srv_listen_cleanup_task, cpy);
  return 0;
fd_error:
  FIO_MEM_FREE_(cpy, (sizeof(*cpy) + len));
other_error:
  if (args.on_finish)
    args.on_finish(args.udata);
  return -1;
}

/* *****************************************************************************
Managing data after a fork
***************************************************************************** */
FIO_SFUNC void fio___srv_after_fork(void *ignr_) {
  (void)ignr_;
  fio___srvdata.pid = getpid();
  fio_queue_perform_all(fio___srv_tasks);
  FIO_LIST_EACH(fio_protocol_s,
                reserved.protocols,
                &fio___srvdata.protocols,
                pr) {
    FIO_LIST_EACH(fio_s, node, &pr->reserved.ios, io) { fio_close_now(io); }
  }
  fio_queue_perform_all(fio___srv_tasks);
  fio_invalidate_all();
  fio_queue_perform_all(fio___srv_tasks);
  fio_queue_destroy(fio___srv_tasks);
}

FIO_SFUNC void fio___srv_cleanup_at_exit(void *ignr_) {
  fio___srv_after_fork(ignr_);
  fio_poll_destroy(&fio___srvdata.poll_data);
  fio___srv_env_safe_destroy(&fio___srvdata.env);
}

/* *****************************************************************************
Initializing Server State
***************************************************************************** */
FIO_CONSTRUCTOR(fio___srv) {
  fio_queue_init(fio___srv_tasks);
  fio_poll_init(&fio___srvdata.poll_data,
                .on_data = fio___srv_poll_on_data_schd,
                .on_ready = fio___srv_poll_on_ready_schd,
                .on_close = fio___srv_poll_on_close_schd);
  fio___srv_init_protocol_test(&MOCK_PROTOCOL);
  fio___srv_init_protocol_test(&FIO___LISTEN_PROTOCOL);
  fio___srvdata.protocols = FIO_LIST_INIT(fio___srvdata.protocols);
  fio___srvdata.tick = fio_time_milli();
  fio___srvdata.root_pid = fio___srvdata.pid = getpid();
  fio_state_callback_add(FIO_CALL_IN_CHILD, fio___srv_after_fork, NULL);
  fio_state_callback_add(FIO_CALL_AT_EXIT, fio___srv_cleanup_at_exit, NULL);
}

/* *****************************************************************************
Done with Server code
***************************************************************************** */
#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_SERVER */
/* *****************************************************************************
Simple Server Testing
***************************************************************************** */
#if defined(FIO_TEST_CSTL) && defined(FIO_SERVER) &&                           \
    !defined(FIO_STL_KEEP__) && !defined(FIO_FIO_TEST_SERVER_ONLY_ONCE) &&     \
    (!defined(FIO_EXTERN) || defined(FIO_EXTERN_COMPLETE))
#define FIO_FIO_TEST_SERVER_ONLY_ONCE 1
/* *****************************************************************************
Test IO ENV support
***************************************************************************** */

/* State callback test task */
FIO_SFUNC void FIO_NAME_TEST(FIO_NAME_TEST(stl, server),
                             env_on_close)(void *udata) {
  size_t *p = (size_t *)udata;
  ++p[0];
}

/* State callback tests */
FIO_SFUNC void FIO_NAME_TEST(FIO_NAME_TEST(stl, server), env)(void) {
  fprintf(stderr, "   * Testing fio_env.\n");
  size_t a = 0, b = 0, c = 0;
  fio___srv_env_safe_s env = FIO___SRV_ENV_SAFE_INIT;
  fio___srv_env_safe_set(
      &env,
      (char *)"a_key",
      5,
      1,
      (fio___srv_env_obj_s){
          .udata = &a,
          .on_close = FIO_NAME_TEST(FIO_NAME_TEST(stl, server), env_on_close)},
      1);
  fio___srv_env_safe_set(
      &env,
      (char *)"a_key",
      5,
      2,
      (fio___srv_env_obj_s){
          .udata = &a,
          .on_close = FIO_NAME_TEST(FIO_NAME_TEST(stl, server), env_on_close)},
      2);
  fio___srv_env_safe_set(
      &env,
      (char *)"a_key",
      5,
      3,
      (fio___srv_env_obj_s){
          .udata = &a,
          .on_close = FIO_NAME_TEST(FIO_NAME_TEST(stl, server), env_on_close)},
      1);
  fio___srv_env_safe_set(
      &env,
      (char *)"b_key",
      5,
      1,
      (fio___srv_env_obj_s){
          .udata = &b,
          .on_close = FIO_NAME_TEST(FIO_NAME_TEST(stl, server), env_on_close)},
      1);
  fio___srv_env_safe_set(
      &env,
      (char *)"c_key",
      5,
      1,
      (fio___srv_env_obj_s){
          .udata = &c,
          .on_close = FIO_NAME_TEST(FIO_NAME_TEST(stl, server), env_on_close)},
      1);
  fio___srv_env_safe_unset(&env, (char *)"a_key", 5, 3);
  FIO_ASSERT(!a,
             "unset should have removed an object without calling callback.");
  fio___srv_env_safe_remove(&env, (char *)"a_key", 5, 3);
  FIO_ASSERT(!a, "remove after unset should have no side-effects.");
  fio___srv_env_safe_remove(&env, (char *)"a_key", 5, 2);
  FIO_ASSERT(a == 1, "remove should call callbacks.");
  fio___srv_env_safe_destroy(&env);
  FIO_ASSERT(a == 2 && b == 1 && c == 1, "destroy should call callbacks.");
}

/* *****************************************************************************
Test summery
***************************************************************************** */

FIO_SFUNC void FIO_NAME_TEST(stl, server)(void) {
  fprintf(stderr, "* Testing fio_srv units (TODO).\n");
  FIO_NAME_TEST(FIO_NAME_TEST(stl, server), env)();
}

/* *****************************************************************************
Simple Server Cleanup
***************************************************************************** */
#undef FIO_SERVER
#endif /* FIO_TEST_CSTL */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_PUBSUB     /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************




                Pub/Sub Services for IPC / Server applications




Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_PUBSUB) && !defined(H___FIO_PUBSUB___H) &&                     \
    !defined(FIO_STL_KEEP__)
#define H___FIO_PUBSUB___H

/* *****************************************************************************
Pub/Sub - message format
***************************************************************************** */

/** Message structure, as received by the `on_message` subscription callback. */
typedef struct fio_msg_s {
  /** A connection (if any) to which the subscription belongs. */
  fio_s *io;
  /**
   * A channel name, allowing for pub/sub patterns.
   *
   * NOTE: the channel and message strings should be considered immutable.
   */
  fio_str_info_s channel;
  /**
   * The actual message.
   *
   * NOTE: the channel and message strings should be considered immutable.
   **/
  fio_str_info_s message;
  /** The `udata` argument associated with the subscription. */
  void *udata;
  /** Channel name namespace. Negative values are reserved. */
  int16_t filter;
  /** flag indicating if the message is JSON data or binary/text. */
  uint8_t is_json;
} fio_msg_s;

/* *****************************************************************************
Pub/Sub - Subscribe / Unsubscribe
***************************************************************************** */

/** Possible arguments for the fio_subscribe method. */
typedef struct {
  /**
   * The subscription owner - if none, the subscription is owned by the system.
   *
   * Note:
   *
   * Both the system and the `io` objects each manage channel listing
   * which allows only a single subscription to the same channel.
   *
   * This means a single subscription per channel per IO and a single
   * subscription per channel for the global system unless managing the
   * subscription handle manually.
   */
  fio_s *io;
  /**
   * A named `channel` to which the message was sent.
   *
   * Subscriptions require a match by both channel name and namespace filter.
   */
  fio_buf_info_s channel;
  /**
   * The callback to be called for each message forwarded to the subscription.
   */
  void (*on_message)(fio_msg_s *msg);
  /** An optional callback for when a subscription is canceled. */
  void (*on_unsubscribe)(void *udata);
  /** The opaque udata value is ignored and made available to the callbacks. */
  void *udata;
  /**
   * OPTIONAL: subscription handle return value - should be NULL when using
   * automatic memory management with the IO or global environment.
   *
   * When set, the `io` pointer will be ignored and the subscription object
   * handle will be written to the `subscription_handle_ptr` which MUST be
   * used when unsubscribing.
   *
   * NOTE: this could cause subscriptions and memory leaks unless properly
   * handled.
   */
  uintptr_t *subscription_handle_ptr;
  /**
   * A numerical namespace `filter` subscribers need to match.
   *
   * Negative values are reserved for facil.io framework extensions.
   *
   * Filer channels are bound to the processes and workers, they are NOT
   * forwarded to engines and can be used for inter process communication (IPC).
   */
  int16_t filter;
  /** If set, pattern matching will be used (name is a pattern). */
  uint8_t is_pattern;
  /** If set, subscription will be limited to the root / master process. */
  uint8_t master_only;
} subscribe_args_s;

/**
 * Subscribes to a channel / filter pair.
 *
 * The on_unsubscribe callback will be called on failure.
 */
SFUNC void fio_subscribe(subscribe_args_s args);

/**
 * Subscribes to a channel / filter pair.
 *
 * See `subscribe_args_s` for details.
 */
#define fio_subscribe(...) fio_subscribe((subscribe_args_s){__VA_ARGS__})

/**
 * Cancels an existing subscriptions.
 *
 * Accepts the same arguments as `fio_subscribe`, except the `udata` and
 * callback details are ignored (no need to provide `udata` or callback
 * details).
 *
 * If a `subscription_handle_ptr` was provided it should contain the value of
 * the subscription handle returned.
 *
 * Returns -1 if the subscription could not be found. Otherwise returns 0.
 */
SFUNC int fio_unsubscribe(subscribe_args_s args);

/**
 * Cancels an existing subscriptions.
 *
 * Accepts the same arguments as `fio_subscribe`, except the `udata` and
 * callback details are ignored (no need to provide `udata` or callback
 * details).
 *
 * Returns -1 if the subscription could not be found. Otherwise returns 0.
 */
#define fio_unsubscribe(...) fio_unsubscribe((subscribe_args_s){__VA_ARGS__})

/* *****************************************************************************
Pub/Sub - Publish
***************************************************************************** */

/** A pub/sub engine data structure. See details later on. */
typedef struct fio_pubsub_engine_s fio_pubsub_engine_s;

/** Publishing and on_message callback arguments. */
typedef struct fio_publish_args_s {
  /** The pub/sub engine that should be used to forward this message. */
  fio_pubsub_engine_s const *engine;
  /** If `from` is specified, it will be skipped (won't receive message). */
  fio_s *from;
  /** The target named channel. */
  fio_buf_info_s channel;
  /** The message body / content. */
  fio_buf_info_s message;
  /** A numeral namespace for channel names. Negative values are reserved. */
  int16_t filter;
  /** A flag indicating if the message is JSON data or not. */
  uint8_t is_json;
} fio_publish_args_s;

/**
 * Publishes a message to the relevant subscribers (if any).
 *
 * By default the message is sent using the `FIO_PUBSUB_DEFAULT` engine (set by
 * default to `FIO_PUBSUB_LOCAL` which publishes to all processes, including the
 * calling process).
 *
 * To limit the message only to other processes (exclude the calling process),
 * use the `FIO_PUBSUB_SIBLINGS` engine.
 *
 * To limit the message only to the calling process, use the
 * `FIO_PUBSUB_PROCESS` engine.
 *
 * To limit the message only to the root process, use the `FIO_PUBSUB_ROOT`
 * engine.
 */
SFUNC void fio_publish(fio_publish_args_s args);
/**
 * Publishes a message to the relevant subscribers (if any).
 *
 * By default the message is sent using the `FIO_PUBSUB_DEFAULT` engine (set by
 * default to `FIO_PUBSUB_LOCAL` which publishes to all processes, including the
 * calling process).
 *
 * To limit the message only to other processes (exclude the calling process),
 * use the `FIO_PUBSUB_SIBLINGS` engine.
 *
 * To limit the message only to the calling process, use the
 * `FIO_PUBSUB_PROCESS` engine.
 *
 * To limit the message only to the root process, use the `FIO_PUBSUB_ROOT`
 * engine.
 */
#define fio_publish(...) fio_publish((fio_publish_args_s){__VA_ARGS__})
/** for backwards compatibility */
#define pubsub_publish fio_publish

/**
 * Defers the current callback, so it will be called again for the message.
 *
 * After calling this function, the `msg` object must NOT be accessed again.
 */
SFUNC void fio_message_defer(fio_msg_s *msg);

/* *****************************************************************************
Pub/Sub - defaults and builtin pub/sub engines
***************************************************************************** */

typedef enum {
  /** Flag bits for internal usage (letter exchange network format). */
  FIO___PUBSUB_PROCESS = 1,
  FIO___PUBSUB_ROOT = 2,
  FIO___PUBSUB_SIBLINGS = 4,
  FIO___PUBSUB_WORKERS = (4 | 1),
  FIO___PUBSUB_LOCAL = (4 | 2 | 1),
  FIO___PUBSUB_REMOTE = 8,
  FIO___PUBSUB_CLUSTER = (8 | 4 | 2 | 1),
  FIO___PUBSUB_SUB = 16,
  FIO___PUBSUB_UNSUB = 32,
  FIO___PUBSUB_JSON = 128,
} fio___letter_flag_bits_e;

/** Used to publish the message exclusively to the root / master process. */
#define FIO_PUBSUB_ROOT ((fio_pubsub_engine_s *)FIO___PUBSUB_ROOT)
/** Used to publish the message only within the current process. */
#define FIO_PUBSUB_PROCESS ((fio_pubsub_engine_s *)FIO___PUBSUB_PROCESS)
/** Used to publish the message except within the current process. */
#define FIO_PUBSUB_SIBLINGS ((fio_pubsub_engine_s *)FIO___PUBSUB_SIBLINGS)
/** Used to publish the message for this process, its siblings and root. */
#define FIO_PUBSUB_LOCAL ((fio_pubsub_engine_s *)FIO___PUBSUB_LOCAL)
/** Used to publish the message to any possible publishers. */
#define FIO_PUBSUB_CLUSTER ((fio_pubsub_engine_s *)FIO___PUBSUB_CLUSTER)

#if defined(FIO_EXTERN) /* static definitions can't be easily repeated. */
/** The default engine (settable). Initial default is FIO_PUBSUB_CLUSTER. */
SFUNC const fio_pubsub_engine_s *FIO_PUBSUB_DEFAULT;

/**
 * The pattern matching callback used for pattern matching.
 *
 * Returns 1 on a match or 0 if the string does not match the pattern.
 *
 * By default, the value is set to `fio_glob_match` (see facil.io's C STL).
 */
SFUNC uint8_t (*FIO_PUBSUB_PATTERN_MATCH)(fio_str_info_s pattern,
                                          fio_str_info_s channel);
#endif
/* *****************************************************************************
 * Message metadata (advance usage API)
 **************************************************************************** */

/**
 * The number of different metadata callbacks that can be attached.
 *
 * Effects performance.
 *
 * The default value should be enough for the following metadata objects:
 * - WebSocket server headers.
 * - WebSocket client (header + masked message copy).
 * - EventSource (SSE) encoded named channel and message.
 */
#ifndef FIO_PUBSUB_METADATA_LIMIT
#define FIO_PUBSUB_METADATA_LIMIT 4
#endif

/** Pub/Sub Metadata callback type. */
typedef void *(*fio_msg_metadata_fn)(fio_str_info_s ch,
                                     fio_str_info_s msg,
                                     int16_t filter,
                                     uint8_t is_json);

/**
 * It's possible to attach metadata to facil.io pub/sub messages before they are
 * published.
 *
 * This allows, for example, messages to be encoded as network packets for
 * outgoing protocols (i.e., encoding for WebSocket transmissions), improving
 * performance in large network based broadcasting.
 *
 * Up to `FIO_PUBSUB_METADATA_LIMIT` metadata callbacks can be attached.
 *
 * The callback should return a `void *` pointer.
 *
 * To remove a callback, call `fio_message_metadata_remove` with the returned
 * value.
 *
 * The cluster messaging system allows some messages to be flagged as JSON and
 * this flag is available to the metadata callback.
 *
 * Returns zero (0) on success or -1 on failure.
 *
 * Multiple `fio_message_metadata_add` calls increase a reference count and
 * should be matched by the same number of `fio_message_metadata_remove`.
 */
SFUNC int fio_message_metadata_add(fio_msg_metadata_fn metadata_func,
                                   void (*cleanup)(void *));

/**
 * Removed the metadata callback.
 *
 * Removal might be delayed if live metatdata exists.
 */
SFUNC void fio_message_metadata_remove(fio_msg_metadata_fn metadata_func);

/** Finds the message's metadata, returning the data or NULL. */
SFUNC void *fio_message_metadata(fio_msg_s *msg,
                                 fio_msg_metadata_fn metadata_func);

/* *****************************************************************************
 * Cluster / Pub/Sub Middleware and Extensions ("Engines")
 **************************************************************************** */

/**
 * facil.io can be linked with external Pub/Sub services using "engines".
 *
 * Engines MUST provide the listed function pointers and should be attached
 * using the `fio_pubsub_attach` function.
 *
 * Engines that were connected / attached using `fio_pubsub_attach` MUST
 * disconnect / detach, before being destroyed, by using the `fio_pubsub_detach`
 * function.
 *
 * When an engine received a message to publish, it should call the
 * `fio_publish` function with the engine to which the message is forwarded.
 * i.e.:
 *
 *       fio_publish(
 *           .engine = FIO_PUBSUB_LOCAL,
 *           .channel = channel_name,
 *           .message = msg_body);
 *
 * IMPORTANT: The callbacks will be called by the main IO thread, so they should
 * never block. Long tasks should copy the data and scheduling an external task
 * (i.e., using `fio_defer`).
 */
struct fio_pubsub_engine_s {
  /** For internal facil.io use - initialize to zero(!) before calling `attach`
   */
  struct {
    FIO_LIST_NODE node;
  } internal_use_;
  /** Called after the engine was detached, may be used for cleanup. */
  void (*detached)(const fio_pubsub_engine_s *eng);
  /** Subscribes to a channel. Called ONLY in the Root (master) process. */
  void (*subscribe)(const fio_pubsub_engine_s *eng,
                    fio_buf_info_s channel,
                    int16_t filter);
  /** Subscribes to a pattern. Called ONLY in the Root (master) process. */
  void (*psubscribe)(const fio_pubsub_engine_s *eng,
                     fio_buf_info_s channel,
                     int16_t filter);
  /** Unsubscribes to a channel. Called ONLY in the Root (master) process. */
  void (*unsubscribe)(const fio_pubsub_engine_s *eng,
                      fio_buf_info_s channel,
                      int16_t filter);
  /** Unsubscribe to a pattern. Called ONLY in the Root (master) process. */
  void (*punsubscribe)(const fio_pubsub_engine_s *eng,
                       fio_buf_info_s channel,
                       int16_t filter);
  /** Publishes a message through the engine. Called by any worker / thread. */
  void (*publish)(const fio_pubsub_engine_s *eng,
                  fio_buf_info_s channel,
                  fio_buf_info_s msg,
                  int16_t filter,
                  uint8_t is_json);
};

/**
 * Attaches an engine, so it's callback can be called by facil.io.
 *
 * The `(p)subscribe` callback will be called for every existing channel.
 *
 * This can be called multiple times resulting in re-running the `(p)subscribe`
 * callbacks.
 *
 * NOTE: the root (master) process will call `subscribe` for any channel in any
 * process, while all the other processes will call `subscribe` only for their
 * own channels. This allows engines to use the root (master) process as an
 * exclusive subscription process and publish to `FIO_PUBSUB_LOCAL`.
 */
SFUNC void fio_pubsub_attach(fio_pubsub_engine_s *engine);

/** Schedules an engine for Detachment, so it could be safely destroyed. */
SFUNC void fio_pubsub_detach(fio_pubsub_engine_s *engine);

/* *****************************************************************************



Pub/Sub Implementation



The implementation has a big number of interconnected modules:
- Letters and their network exchange protocols (`fio_letter_s`)
- Distribution Channels (`fio_channel_s` and `FIO_POSTOFFICE`)
- Subscriptions (`fio_subscription_s`)
- External Distribution Engines (`fio_pubsub_engine_s`)
- Letter Metadata Management.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Pub/Sub - defaults and builtin pub/sub engines
***************************************************************************** */

/** The default engine (settable). Initial default is FIO_PUBSUB_CLUSTER. */
SFUNC const fio_pubsub_engine_s *FIO_PUBSUB_DEFAULT = FIO_PUBSUB_CLUSTER;

/**
 * The pattern matching callback used for pattern matching.
 *
 * Returns 1 on a match or 0 if the string does not match the pattern.
 *
 * By default, the value is set to `fio_glob_match` (see facil.io's C STL).
 */
SFUNC uint8_t (*FIO_PUBSUB_PATTERN_MATCH)(fio_str_info_s,
                                          fio_str_info_s) = fio_glob_match;

/* a mock callback for subscriptions */
FIO_SFUNC void fio_subscription___mock_cb(fio_msg_s *msg) { (void)msg; }
/* a default callback for IO subscriptions - sends message data. */
FIO_SFUNC void fio_subscription___send_cb(fio_msg_s *msg);

/* *****************************************************************************
 * Pub / Sub types, for internal use
 **************************************************************************** */

/** The Letter: contains the data to be distributed to subscribers. */
typedef struct fio_letter_s {
  void *from;
  uint8_t metadata_is_initialized; /* to compact this we need to change all? */
  void *metadata[FIO_PUBSUB_METADATA_LIMIT];
  char buf[];
} fio_letter_s;

/**
 * Reference counting: `fio_letter_dup(letter)` / `fio_letter_free(letter)`
 */
FIO_SFUNC void fio_letter_on_destroy(fio_letter_s *letter);
#define FIO_REF_NAME             fio_letter
#define FIO_REF_FLEX_TYPE        char
#define FIO_REF_DESTROY(obj)     fio_letter_on_destroy(&(obj))
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_STL_KEEP__           1
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

/** The Distribution Channel: manages subscriptions to named channels. */
typedef struct fio_channel_s {
  FIO_LIST_HEAD subscriptions;
  uint32_t name_len;
  int16_t filter;
  uint8_t is_pattern;
  char name[];
} fio_channel_s;

/**
 * Reference counting: `fio_channel_dup(ch)` / `fio_channel_free(ch)`
 */
#define FIO_REF_NAME             fio_channel
#define FIO_REF_FLEX_TYPE        char
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_STL_KEEP__           1
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

/** The Subscription: contains subscriber data. */
typedef struct fio_subscription_s {
  FIO_LIST_NODE node;
  fio_s *io;
  fio_channel_s *channel;
  void (*on_message)(fio_msg_s *msg);
  void (*on_unsubscribe)(void *udata);
  void *udata;
} fio_subscription_s;

/**
 * Reference counting: `fio_subscription_dup(sb)` / `fio_subscription_free(sb)`
 */
FIO_SFUNC void fio_subscription_on_destroy(fio_subscription_s *sub);
#define FIO_REF_NAME             fio_subscription
#define FIO_REF_DESTROY(obj)     fio_subscription_on_destroy(&(obj))
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_STL_KEEP__           1
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

/** The Channel Map: maps named channels. */
FIO_SFUNC void fio_channel_on_create(fio_channel_s *ch);
FIO_SFUNC void fio_channel_on_destroy(fio_channel_s *ch);
FIO_IFUNC int fio_channel___cmp(fio_channel_s *a, fio_channel_s *b) {
  /* when letter publishing, the channel name is stored in subscriptions.next */
  return a->filter == b->filter && a->name_len == b->name_len &&
         (!a->name_len ||
          !FIO_MEMCMP(
              a->name,
              (b->subscriptions.prev ? b->name : (char *)b->subscriptions.next),
              a->name_len));
}
FIO_IFUNC uint64_t fio_channel___hash(char *buf, size_t len, int16_t filter) {
  return fio_risky_hash(buf, len, (((size_t)filter << 17) | (size_t)filter));
}
#define FIO_MAP_NAME fio_channel_map
#define FIO_MAP_KEY  fio_channel_s *
#define FIO_MAP_KEY_COPY(dest, src)                                            \
  do {                                                                         \
    (dest) = (src);                                                            \
    fio_channel_on_create((src));                                              \
  } while (0);
#define FIO_MAP_KEY_CMP(a, b) fio_channel___cmp((a), (b))
#define FIO_MAP_KEY_DESTROY(key)                                               \
  do {                                                                         \
    fio_channel_on_destroy(key);                                               \
    fio_channel_free((key));                                                   \
  } while (0)
#define FIO_MAP_KEY_DISCARD(key) fio_channel_free((key))
#define FIO_STL_KEEP__           1
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

/* *****************************************************************************



                          The Letter Object &
Protocol



The Letter Object & Protocol is the internal
message exchange protocol and format used by the
pub/sub service and API. Access is given for
zero-copy uses.

The letter exchange protocol imposes the
following limitations on message exchange:

* Channel Names are limited to 2^16 bytes (65,536
bytes).

* Message payload is limited to 2^24 bytes
(16,777,216 bytes == about 16Mb).

* Totally Empty messages are ignored.

Letter network format in bytes (16 byte header +
2 NUL bytes): | [ 0-7 ] 8 bytes - Message ID | |
[ 8-9 ] 2 Bytes - numerical Filter | | [10-11] 2
bytes - little endian channel length        | |
[12-14] 3 bytes - little endian message length |
| [ 15 ]  1 Bytes - flags | | X bytes - (channel
length + 1 NUL terminator)         | | Y bytes -
(message length + 1 NUL terminator)         |
Total overhead: 18 bytes (16 byte header + 2 NUL
terminators)

***************************************************************************** */

/* *****************************************************************************
Letter Type API & Callbacks
***************************************************************************** */

/** Allocates a new letter wrapper to be filled
 * from an existing buffer. */
FIO_IFUNC fio_letter_s *fio_letter_new_read(const char *head);
/* allocates a new, fully composed, letter. */
FIO_IFUNC fio_letter_s *fio_letter_new_compose(fio_buf_info_s channel,
                                               fio_buf_info_s message,
                                               int16_t filter,
                                               uint8_t flags);
/** initializes a letter's metadata. */
FIO_SFUNC void fio_letter_initialize_metadata(fio_letter_s *l);
/** Returns a letter's message length (if any) */
FIO_IFUNC size_t fio_letter_message_len(fio_letter_s *l);
/** Returns a letter's channel length (if any) */
FIO_IFUNC size_t fio_letter_channel_len(fio_letter_s *l);
/** Returns a letter's channel. */
FIO_IFUNC fio_str_info_s fio_letter_channel(fio_letter_s *l);
/** Returns a letter's message. */
FIO_IFUNC fio_str_info_s fio_letter_message(fio_letter_s *l);
/** Returns a letter's numerical filter. */
FIO_IFUNC int16_t fio_letter_filter(fio_letter_s *l);
/** Returns the letter's flags (8 bits allowing
 * for 8 distinct flags). */
FIO_IFUNC uint8_t fio_letter_flags(fio_letter_s *l);
/** Returns a letter's ID (8 bytes random number)
 */
FIO_IFUNC uint64_t fio_letter_id(fio_letter_s *l);
/* returns the letter object associated with the
 * public message object. */
FIO_IFUNC fio_letter_s *fio_msg2letter(fio_msg_s *msg);

#define FIO___LETTER_HEADER_LENGTH 16 /* without NUL terminators */
#define FIO___LETTER_MINIMAL_LEN   (FIO___LETTER_HEADER_LENGTH + 2) /* 2xNUL */

/* *****************************************************************************
Letter Protocol API & Callbacks
***************************************************************************** */

/** Callback called by the letter protocol when a
 * letter arrives @ master. */
FIO_SFUNC void fio___letter_on_recieved_root(fio_letter_s *letter);
/** Callback called by the letter protocol when a
 * letter arrives @ child. */
FIO_SFUNC void fio___letter_on_recieved_child(fio_letter_s *letter);
/** Starts listening to IPC connections on a
 * local socket. */
FIO_IFUNC void fio___pubsub_ipc_listen(void *ignr_);

/** Write a letter to a specific IO object */
FIO_IFUNC void fio_letter_write(fio_s *io, fio_letter_s *l);
/** Returns a letter's total network length */
FIO_IFUNC size_t fio_letter_len(fio_letter_s *l);

/** Listen to remote letter exchange clients
 * (cluster letter exchange). */
FIO_IFUNC int fio_letter_remote_listen(const char *url, uint64_t app_key[2]);
/** Connect to remote letter exchange server
 * (cluster letter exchange). */
FIO_IFUNC int fio_letter_remote_connect(const char *url, uint64_t app_key[2]);

/* *****************************************************************************
Channel Delivery API & Callbacks
***************************************************************************** */

/** Distributes letters to the channel's
 * subscribers. */
FIO_SFUNC void fio___channel_deliver_task(void *ch_, void *l_);

/** Distributes letters to the distribution
 * channels. */
FIO_IFUNC void fio___channel_deliver(fio_letter_s *letter);

#ifndef FIO_POSTOFFICE_THREAD_LOCK
/** Controls if the channel subscribe API is
 * published or not. */
#define FIO_POSTOFFICE_THREAD_LOCK 0
#endif

/* *****************************************************************************
Subscription Type API
***************************************************************************** */

/* unsubscribes and defers the callback. */
FIO_IFUNC void fio___subscription_unsubscribe(fio_subscription_s *s);

/* *****************************************************************************
Subscription Management Tasks
***************************************************************************** */

/* The task to subscribe to a channel (called by
 * `fio_defer`). */
FIO_SFUNC void fio___subscribe_task(void *ch_, void *sub_);

/** Unsubscribes a node and destroys the channel
 * if no more subscribers. */
FIO_IFUNC void fio___unsubscribe_task(void *ch_, void *sub_);

/** Delivers a letter to a subscription */
FIO_IFUNC void fio___subscription_on_message_task(void *s, void *l);

/** publishes a letter to the expecting processes
 * by letter flags. */
FIO_SFUNC void fio___publish_letter_task(void *l_, void *ignr_);

/* *****************************************************************************
Postoffice State
***************************************************************************** */
#ifndef FIO___IPC_LEN
#define FIO___IPC_LEN 256
#endif

/* master only subscription map */
#if 0
#define FIO___PUBSUB_MASTER_MAP_HASH(s)                                        \
  fio_channel___hash((s[0]->channel->subscriptions.prev                        \
                          ? s[0]->channel->name                                \
                          : (char *)s[0]->channel->subscriptions.next),        \
                     s[0]->channel->name_len,                                  \
                     s[0]->channel->filter)
#define FIO___PUBSUB_MASTER_MAP_CMP(a, b)                                      \
  fio_channel___cmp(a[0]->channel, b[0]->channel)
FIO_TYPEDEF_IMAP_ARRAY(fio___postoffice_msmap,
                       fio_subscription_s *,
                       uint32_t,
                       FIO___PUBSUB_MASTER_MAP_HASH,
                       FIO___PUBSUB_MASTER_MAP_CMP,
                       FIO_IMAP_ALWAYS_VALID)
#undef FIO___PUBSUB_MASTER_MAP_HASH
#undef FIO___PUBSUB_MASTER_MAP_CMP
#else
#define FIO_MAP_KEY_KSTR
#define FIO_MAP_NAME             fio___postoffice_msmap
#define FIO_MAP_VALUE            fio_subscription_s *
#define FIO_MAP_VALUE_DESTROY(s) fio___subscription_unsubscribe(s)
#define FIO_STL_KEEP__
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__
#endif

static struct FIO_POSTOFFICE {
#if FIO_POSTOFFICE_THREAD_LOCK
  FIO___LOCK_TYPE lock;
#endif
  fio_channel_map_s channels;
  fio_channel_map_s patterns;
  FIO_LIST_NODE engines;
  fio_protocol_s *siblings_protocol;
  fio___postoffice_msmap_s master_subscriptions;
  uint8_t publish_filter;
  uint8_t local_send_filter;
  uint8_t remote_send_filter;
  char ipc_url[FIO___IPC_LEN];
} FIO_POSTOFFICE = {
#if FIO_POSTOFFICE_THREAD_LOCK
    .lock = FIO___LOCK_INIT,
#endif
    .channels = FIO_MAP_INIT,
    .patterns = FIO_MAP_INIT,
    .publish_filter = (FIO___PUBSUB_PROCESS | FIO___PUBSUB_ROOT),
    .local_send_filter = (FIO___PUBSUB_SIBLINGS),
    .remote_send_filter = FIO___PUBSUB_REMOTE,
};

/** Callback called when entering a child
 * processes. */
FIO_SFUNC void fio___postoffice_on_enter_child(void *ignr_);
/* *****************************************************************************



                          Letter Metadata
Implementation



***************************************************************************** */

FIO_SFUNC struct {
  fio_msg_metadata_fn build;
  void (*cleanup)(void *);
  size_t ref;
} FIO_PUBSUB_METADATA[FIO_PUBSUB_METADATA_LIMIT];

/* Returns zero (0) on success or -1 on failure.
 */
SFUNC int fio_message_metadata_add(fio_msg_metadata_fn metadata_func,
                                   void (*cleanup)(void *)) {
  for (size_t i = 0; i < FIO_PUBSUB_METADATA_LIMIT; ++i) { /* test existing */
    if (fio_atomic_add(&FIO_PUBSUB_METADATA[i].ref, 1) &&
        metadata_func == FIO_PUBSUB_METADATA[i].build)
      return 0;
    fio_atomic_sub(&FIO_PUBSUB_METADATA[i].ref, 1);
  }
  for (size_t i = 0; i < FIO_PUBSUB_METADATA_LIMIT;
       ++i) { /* insert if available */
    if (fio_atomic_add(&FIO_PUBSUB_METADATA[i].ref, 1)) {
      fio_atomic_sub(&FIO_PUBSUB_METADATA[i].ref, 1);
      continue;
    }
    FIO_PUBSUB_METADATA[i].build = metadata_func;
    FIO_PUBSUB_METADATA[i].cleanup = cleanup;
    return 0;
  }
  return -1;
}

/**
 * Removed the metadata callback.
 *
 * Removal might be delayed if live metatdata
 * exists.
 */
SFUNC void fio_message_metadata_remove(fio_msg_metadata_fn metadata_func) {
  for (size_t i = 0; i < FIO_PUBSUB_METADATA_LIMIT; ++i) { /* test existing */
    if (fio_atomic_add(&FIO_PUBSUB_METADATA[i].ref, 1) &&
        metadata_func == FIO_PUBSUB_METADATA[i].build) {
      fio_atomic_sub(&FIO_PUBSUB_METADATA[i].ref, 1);
    }
    fio_atomic_sub(&FIO_PUBSUB_METADATA[i].ref, 1);
  }
}

/** Finds the message's metadata, returning the
 * data or NULL. */
SFUNC void *fio_message_metadata(fio_msg_s *msg,
                                 fio_msg_metadata_fn metadata_func) {
  for (size_t i = 0; i < FIO_PUBSUB_METADATA_LIMIT; ++i) { /* test existing */
    if (FIO_PUBSUB_METADATA[i].ref &&
        metadata_func == FIO_PUBSUB_METADATA[i].build) {
      return fio_msg2letter(msg)->metadata[i];
    }
  }
  return NULL;
}

/** Callback called when a letter is destroyed
 * (reference counting). */
FIO_SFUNC void fio_letter_on_destroy(fio_letter_s *l) {
  if (!l->metadata_is_initialized)
    return;
  for (size_t i = 0; i < FIO_PUBSUB_METADATA_LIMIT; ++i) {
    if (fio_atomic_add(&FIO_PUBSUB_METADATA[i].ref, 1)) {
      FIO_PUBSUB_METADATA[i].cleanup(l->metadata[i]);
      fio_atomic_sub(&FIO_PUBSUB_METADATA[i].ref, 1);
    }
    fio_atomic_sub(&FIO_PUBSUB_METADATA[i].ref, 1);
  }
}

/** Callback called when a letter is destroyed
 * (reference counting). */
FIO_SFUNC void fio_letter_initialize_metadata(fio_letter_s *l) {
  if (fio_atomic_or(&l->metadata_is_initialized, 1)) {
    return;
  }
  for (size_t i = 0; i < FIO_PUBSUB_METADATA_LIMIT; ++i) {
    if (fio_atomic_add(&FIO_PUBSUB_METADATA[i].ref, 1)) {
      l->metadata[i] = FIO_PUBSUB_METADATA[i].build(
          fio_letter_channel(l),
          fio_letter_message(l),
          fio_letter_filter(l),
          ((fio_letter_flags(l) & FIO___PUBSUB_JSON) == FIO___PUBSUB_JSON));
      continue;
    }
    fio_atomic_sub(&FIO_PUBSUB_METADATA[i].ref, 1);
  }
}

/* *****************************************************************************



                    Letter / Message Object
Implementation



***************************************************************************** */

/* allocates a new letter wrapper to be filled
 * from an existing buffer. */
FIO_IFUNC fio_letter_s *fio_letter_new_read(const char *head) {
  fio_letter_s *l = NULL;
  uint32_t channel_len = fio_buf2u16_little(head + 10);
  uint32_t message_len = fio_buf2u32_little(head + 12) & 0x00FFFFFFUL;
  size_t len = FIO___LETTER_MINIMAL_LEN + channel_len + message_len;
  l = fio_letter_new(len);
  FIO_ASSERT_ALLOC(l);
  return l;
}

/* allocates a new, fully composed, letter. */
FIO_IFUNC fio_letter_s *fio_letter_new_compose(fio_buf_info_s channel,
                                               fio_buf_info_s message,
                                               int16_t filter,
                                               uint8_t flags) {
  fio_letter_s *l = NULL;
  if (!(channel.len | message.len | (uint32_t)filter | (uint32_t)flags))
    return l;
  size_t len = FIO___LETTER_MINIMAL_LEN + channel.len + message.len;
  uint64_t message_id = fio_rand64();
  union {
    uint8_t *u8;
    uint16_t *u16;
    uint32_t *u32;
    uint64_t *u64;
  } u;
  if ((channel.len > 0xFFFFULL) | (message.len > 0xFFFFFFULL))
    goto len_error;

  l = fio_letter_new(len);
  FIO_ASSERT_ALLOC(l);

  u.u8 = (uint8_t *)l->buf;
  u.u64[0] = message_id;
  u.u16[4] = fio_ltole16(filter);
  u.u16[5] = fio_ltole16(channel.len);
  u.u32[3] = fio_ltole32((message.len | (((uint32_t)flags) << 24)));
  if (channel.len && channel.buf) {
    FIO_MEMCPY(l->buf + FIO___LETTER_HEADER_LENGTH, channel.buf, channel.len);
  }
  l->buf[FIO___LETTER_HEADER_LENGTH + channel.len] = 0;
  if (message.len && message.buf) {
    FIO_MEMCPY(l->buf + FIO___LETTER_HEADER_LENGTH + 1 + channel.len,
               message.buf,
               message.len);
  }
  l->buf[(FIO___LETTER_HEADER_LENGTH + 1) + channel.len + message.len] = 0;
  return l;

len_error:
  FIO_LOG_ERROR("(pubsub) payload too big - exceeds the "
                "16Mb limit!\n\t"
                "Channel name length: %u bytes\n\t"
                "Message data length: %u bytes",
                (unsigned int)channel.len,
                (unsigned int)message.len);
  return l;
}

/* returns a letter's message length (if any) */
FIO_IFUNC size_t fio_letter_message_len(fio_letter_s *l) {
  return (size_t)(0x00FFFFFFULL & fio_buf2u32_little(l->buf + 12));
}

/* returns a letter's channel length (if any) */
FIO_IFUNC size_t fio_letter_channel_len(fio_letter_s *l) {
  return (size_t)(fio_buf2u16_little(l->buf + 10));
}

/* returns a letter's channel. */
FIO_IFUNC fio_str_info_s fio_letter_channel(fio_letter_s *l) {
  return (fio_str_info_s){.buf = (l->buf + FIO___LETTER_HEADER_LENGTH),
                          .len = fio_letter_channel_len(l)};
}

/* returns a letter's message. */
FIO_IFUNC fio_str_info_s fio_letter_message(fio_letter_s *l) {
  return (fio_str_info_s){.buf = (l->buf + FIO___LETTER_HEADER_LENGTH + 1 +
                                  fio_letter_channel_len(l)),
                          .len = fio_letter_message_len(l)};
}

/* returns a letter's numerical filter. */
FIO_IFUNC int16_t fio_letter_filter(fio_letter_s *l) {
  return (int16_t)fio_ltole16(*(uint16_t *)(l->buf + 8));
}

/* returns the letter's flags (8 bits allowing
 * for 8 distinct flags). */
FIO_IFUNC uint8_t fio_letter_flags(fio_letter_s *l) {
  return (uint8_t)(l->buf[15]);
}

/* returns a letter's ID (8 bytes random number)
 */
FIO_IFUNC uint64_t fio_letter_id(fio_letter_s *l) {
  return fio_buf2u32_local(l->buf);
}

/* returns a letter's length */
FIO_IFUNC size_t fio_letter_len(fio_letter_s *l) {
  return FIO___LETTER_HEADER_LENGTH + 2 + fio_letter_message_len(l) +
         fio_letter_channel_len(l);
}

/* *****************************************************************************



                  Letter Exchange Protocol
(Networking / IPC)



***************************************************************************** */

/* *****************************************************************************
Letter Sending
***************************************************************************** */

/* write a letter to an IO object */
FIO_IFUNC void fio_letter_write(fio_s *io, fio_letter_s *l) {
  if ((void *)io == l->from)
    return;
  fio_write2(io,
             .buf = (char *)fio_letter_dup(l),
             .offset = (uintptr_t)(((fio_letter_s *)0)->buf),
             .len = fio_letter_len(l),
             .dealloc = (void (*)(void *))fio_letter_free);
}

/* a default callback for IO subscriptions -
 * sends message data. */
FIO_SFUNC void fio_subscription___send_cb(fio_msg_s *msg) {
  if (!msg->message.len)
    return;
  fio_letter_s *l = fio_msg2letter(msg);
  fio_write2(msg->io,
             .buf = fio_letter_dup(l),
             .len = fio_letter_message_len(l),
             .offset = sizeof(*l) + (FIO___LETTER_HEADER_LENGTH + 1 +
                                     fio_letter_channel_len(l)),
             .dealloc = (void (*)(void *))fio_letter_free);
}

/* *****************************************************************************
Letter Reading and Parsing
***************************************************************************** */

/* a letter parser object */
typedef struct {
  fio_letter_s *letter;
  size_t pos;
  char buf[FIO___LETTER_MINIMAL_LEN]; /* minimal
                                         message
                                         length */
} fio_letter_parser_s;

/* a new letter parser */
FIO_IFUNC fio_letter_parser_s *fio_letter_parser_new(void) {
  fio_letter_parser_s *p =
      (fio_letter_parser_s *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*p), 0);
  FIO_ASSERT_ALLOC(p);
  p->letter = NULL;
  p->pos = 0;
  return p;
}

/* free a letter parser */
FIO_IFUNC void fio_letter_parser_free(fio_letter_parser_s *p) {
  if (!p)
    return;
  fio_letter_free(p->letter);
  FIO_MEM_FREE_(p, sizeof(*p));
}

/* forwards letters to callback, returns 0.
 * Returns -1 on error. */
FIO_IFUNC int fio___letter_read(fio_s *io, void (*callback)(fio_letter_s *)) {
  fio_letter_parser_s *parser = (fio_letter_parser_s *)fio_udata_get(io);
  for (;;) {
    ssize_t r;
    if (parser->letter) {
      fio_letter_s *const letter = parser->letter;
      const size_t to_read = fio_letter_len(parser->letter);
      while (parser->pos < to_read) {
        r = fio_read(io, letter->buf + parser->pos, to_read - parser->pos);
        if (r <= 0)
          return 0;
        parser->pos += r;
      }
      callback(letter);
      fio_letter_free(letter);
      parser->letter = NULL;
      parser->pos = 0;
    }
  read_header:
    r = fio_read(io,
                 parser->buf + parser->pos,
                 FIO___LETTER_MINIMAL_LEN - parser->pos);
    if (r <= 0)
      return 0;
    parser->pos += r;
    if (parser->pos < FIO___LETTER_HEADER_LENGTH)
      return 0;
    union {
      uint8_t *u8;
      uint32_t *u32;
      uint64_t *u64;
    } u = {.u8 = (uint8_t *)parser->buf};
    if ((u.u64[0] | u.u64[1])) {
      parser->letter = fio_letter_new_read(parser->buf);
      if (!parser->letter)
        goto error;
      parser->letter->from = (void *)io;
      FIO_MEMCPY(parser->letter->buf, parser->buf, parser->pos);
      continue;
    }
    parser->pos = 0; /* skip PING: all zero header */
    goto read_header;
  }

error:
  fio_close(io);
  return -1;
}

/* *****************************************************************************
Remote Letter Processing - validate unique
delivery.
***************************************************************************** */

#define FIO_OMAP_NAME  fio___letter_map
#define FIO_MAP_KEY    uint64_t
#define FIO_MAP_LRU    (1ULL << 16)
#define FIO_STL_KEEP__ 1
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

FIO_SFUNC struct {
  fio___letter_map_s map;
} fio___letter_validation = {
    .map = FIO_MAP_INIT,
};

FIO_SFUNC void fio___on_letter_remote(fio_letter_s *l) {
  const uint64_t hash = fio_risky_hash(l->buf, fio_letter_len(l), 0);
  const uint64_t letter_id = fio_letter_id(l);
  if (letter_id ==
      fio___letter_map_get(&fio___letter_validation.map, hash, letter_id))
    return;
  fio___letter_map_set(&fio___letter_validation.map, hash, letter_id);
  fio___letter_on_recieved_root(l);
}

/* *****************************************************************************
Letter Protocol Callbacks
***************************************************************************** */

FIO_SFUNC void fio___letter_on_recieved_root(fio_letter_s *l) {
  fio_defer(fio___publish_letter_task, fio_letter_dup(l), NULL);
  (void)l;
}

FIO_SFUNC void fio___letter_on_recieved_child(fio_letter_s *l) {
  fio___channel_deliver(l);
  (void)l;
}

FIO_SFUNC void fio___letter_on_attach(fio_s *io) {
  fio_letter_parser_s *p = fio_letter_parser_new();
  if (!p) {
    fio_close(io);
    return;
  }
  fio_udata_set(io, p);
}

FIO_SFUNC void fio___letter_on_data_ipc_master(fio_s *io) {
  fio___letter_read(io, fio___letter_on_recieved_root);
}
FIO_SFUNC void fio___letter_on_data_ipc_child(fio_s *io) {
  fio___letter_read(io, fio___letter_on_recieved_child);
}
FIO_SFUNC void fio___letter_on_close(void *p) {
  fio_letter_parser_free((fio_letter_parser_s *)p);
}
FIO_SFUNC void fio___letter_on_timeout(fio_s *io) {
  static const char ping_buf[FIO___LETTER_MINIMAL_LEN] = {0};
  fio_write2(io, .buf = (char *)ping_buf, .len = FIO___LETTER_MINIMAL_LEN);
}

FIO_SFUNC void fio___letter_on_data_remote(fio_s *io) {
  fio___letter_read(io, fio___on_letter_remote);
}

/* TODO: app-key + ed25519 per-connection key
 * exchange + ChaCha/Poly */
static fio_protocol_s FIO_LETTER_PROTOCOL_REMOTE = {
    .on_attach = fio___letter_on_attach,
    .on_data = fio___letter_on_data_remote,
    .on_close = fio___letter_on_close,
    .on_timeout = fio___letter_on_timeout,
};
static fio_protocol_s FIO_LETTER_PROTOCOL_IPC_MASTER = {
    .on_attach = fio___letter_on_attach,
    .on_data = fio___letter_on_data_ipc_master,
    .on_close = fio___letter_on_close,
    .on_timeout = fio___letter_on_timeout,
};
static fio_protocol_s FIO_LETTER_PROTOCOL_IPC_CHILD = {
    .on_attach = fio___letter_on_attach,
    .on_data = fio___letter_on_data_ipc_child,
    .on_close = fio___letter_on_close,
    .on_timeout = fio___letter_on_timeout,
};

/* *****************************************************************************
Letter Listening to Local Connections (IPC)
***************************************************************************** */

FIO_SFUNC void fio_letter_local_ipc_on_open(int fd, void *udata) {
  fio_attach_fd(fd, (fio_protocol_s *)udata, NULL, NULL);
}

/** Starts listening to IPC connections on a local socket. */
FIO_IFUNC void fio___pubsub_ipc_listen(void *ignr_) {
  (void)ignr_;
  if (fio_srv_is_worker()) {
    FIO_LOG_DEBUG("(pub/sub) IPC socket skipped "
                  "- no workers are spawned.");
    return;
  }
  FIO_ASSERT(!fio_listen(.url = FIO_POSTOFFICE.ipc_url,
                         .on_open = fio_letter_local_ipc_on_open,
                         .udata = (void *)&FIO_LETTER_PROTOCOL_IPC_MASTER,
                         .on_root = 1),
             "(pub/sub) couldn't open a socket for "
             "IPC.");
}

/* *****************************************************************************
Letter Listening to Remote Connections - TODO!
***************************************************************************** */

/** Listen to remote letter exchange clients
 * (cluster letter exchange). */
FIO_IFUNC int fio_letter_remote_listen(const char *url, uint64_t app_key[2]) {
  (void)url; /* TODO!  */
  (void)app_key;
  return 0;
}
/** Connect to remote letter exchange server
 * (cluster letter exchange). */
FIO_IFUNC int fio_letter_remote_connect(const char *url, uint64_t app_key[2]) {
  (void)url; /* TODO! */
  (void)app_key;
  return 0;
}

/* *****************************************************************************



                        Channel Delivery API & Callbacks



***************************************************************************** */

FIO_IFUNC fio_channel_s *fio_channel_new_named(fio_buf_info_s name,
                                               int16_t filter,
                                               uint8_t is_pattern) {
  fio_channel_s *ch = NULL;
  if (!name.buf)
    name.len = 0;
  if (name.len > 0xFFFFUL)
    return ch;
  ch = fio_channel_new(name.len + 1);
  FIO_ASSERT_ALLOC(ch);
  *ch = (fio_channel_s){
      .subscriptions = FIO_LIST_INIT(ch->subscriptions),
      .name_len = (uint32_t)name.len,
      .filter = filter,
      .is_pattern = !!is_pattern, /* MUST be 1 or 0 */
  };
  if (name.len) {
    FIO_MEMCPY(ch->name, name.buf, name.len);
  }
  ch->name[name.len] = 0;
  return ch;
}

/** To be used in the fio_letter_on_composed
 * callback to distribute letters. */
FIO_IFUNC void fio___channel_deliver(fio_letter_s *l) {
  fio_letter_initialize_metadata(l); /* lazy metadata initialization */
  const fio_str_info_s ch_name = fio_letter_channel(l);
  const int16_t filter = fio_letter_filter(l);
  fio_channel_s cpy = {
      .name_len = (uint32_t)ch_name.len,
      .filter = filter,
      .subscriptions.next = (FIO_LIST_NODE *)ch_name.buf,
  };
  const uint64_t hash = fio_channel___hash(ch_name.buf, ch_name.len, filter);

#if FIO_POSTOFFICE_THREAD_LOCK
  FIO___LOCK_LOCK(FIO_POSTOFFICE.lock);
#endif
  fio_channel_s *ch = fio_channel_map_get(&FIO_POSTOFFICE.channels, hash, &cpy);
  /* TODO: use NULL channel as catch all? */
  // if (!ch) {
  //   cpy.name_len = 0;
  //   ch =
  //   fio_channel_map_get(&FIO_POSTOFFICE.channels,
  //                            fio_channel___hash(NULL,
  //                            0, filter),
  //                            &cpy);
  // }
  if (ch)
    fio_defer(fio___channel_deliver_task,
              fio_channel_dup(ch),
              fio_letter_dup(l));
  FIO_MAP_EACH(fio_channel_map, &FIO_POSTOFFICE.patterns, i) {
    if (i.key && i.key->filter == filter &&
        FIO_PUBSUB_PATTERN_MATCH(FIO_STR_INFO2(i.key->name, i.key->name_len),
                                 ch_name))
      fio_defer(fio___channel_deliver_task,
                fio_channel_dup(i.key),
                fio_letter_dup(l));
  }
#if FIO_POSTOFFICE_THREAD_LOCK
  FIO___LOCK_UNLOCK(FIO_POSTOFFICE.lock);
#endif
}

/* *****************************************************************************



                          Subscription / Management Tasks



***************************************************************************** */

/* calls the on_unsubscribe callback. */
FIO_SFUNC void fio___subscription_on_destroy__task(void *fnp, void *udata) {
  union {
    void *p;
    void (*fn)(void *udata);
  } u = {.p = fnp};
  u.fn(udata);
}

FIO_SFUNC void fio_subscription_on_destroy(fio_subscription_s *s) {
  if (s->on_unsubscribe) {
    union {
      void *p;
      void (*fn)(void *udata);
    } u = {.fn = s->on_unsubscribe};
    fio_defer(fio___subscription_on_destroy__task, u.p, s->udata);
  }
}

/**
 * Reference counting: `fio_channel_dup(letter)`
 * / `fio_channel_free(letter)`
 */

FIO_SFUNC void fio___subscribe_task(void *ch_, void *sub_) {
  fio_channel_s *ch = (fio_channel_s *)ch_;
  fio_subscription_s *sub = (fio_subscription_s *)sub_;

#if FIO_POSTOFFICE_THREAD_LOCK
  FIO___LOCK_LOCK(FIO_POSTOFFICE.lock);
#endif

  fio_channel_map_s *map = &FIO_POSTOFFICE.channels + ch->is_pattern;
  const uint64_t hash = fio_channel___hash(ch->name, ch->name_len, ch->filter);
  ch = fio_channel_map_set_if_missing(map, hash, ch);
  if (!ch)
    goto unknown_error;
  sub->channel = fio_channel_dup(ch);
  FIO_LIST_PUSH(&ch->subscriptions, &sub->node);

#if FIO_POSTOFFICE_THREAD_LOCK
  FIO___LOCK_UNLOCK(FIO_POSTOFFICE.lock);
#endif
  return;

unknown_error:
  FIO_LOG_FATAL("%d (pubsub) channel couldn't "
                "be added to map!",
                fio___srvdata.pid);
#if FIO_POSTOFFICE_THREAD_LOCK
  FIO___LOCK_UNLOCK(FIO_POSTOFFICE.lock);
#endif
}

/** Unsubscribes a node and destroys the channel
 * if no more subscribers. */
FIO_IFUNC void fio___unsubscribe_task(void *ch_, void *sub_) {
  fio_channel_s *ch = (fio_channel_s *)ch_;
  fio_subscription_s *sub = (fio_subscription_s *)sub_;
  fio_channel_map_s *map;
  if (!ch)
    goto no_channel;

#if FIO_POSTOFFICE_THREAD_LOCK
  FIO___LOCK_LOCK(FIO_POSTOFFICE.lock);
#endif

  FIO_LIST_REMOVE(&sub->node);
  if (FIO_LIST_IS_EMPTY(&ch->subscriptions)) {
    map = &FIO_POSTOFFICE.channels + ch->is_pattern;
    fio_channel_map_remove(
        map,
        fio_channel___hash(ch->name, ch->name_len, ch->filter),
        ch,
        NULL);
    if (!fio_channel_map_count(map))
      fio_channel_map_destroy(map);
  }

#if FIO_POSTOFFICE_THREAD_LOCK
  FIO___LOCK_UNLOCK(FIO_POSTOFFICE.lock);
#endif

  fio_channel_free(ch);
no_channel:
  fio_subscription_free(sub);
  return;
}

/* *****************************************************************************



                            Subscription Type API



***************************************************************************** */

/** Defers the on_unsubscribe callback. */
FIO_IFUNC void fio___subscription_unsubscribe(fio_subscription_s *s) {
  if (!s)
    return;
  s->on_message = fio_subscription___mock_cb;
  fio_defer(fio___unsubscribe_task, (void *)(s->channel), (void *)s);
}

FIO_IFUNC void fio___subscription_on_message_task(void *s_, void *l_) {
  fio_subscription_s *s = (fio_subscription_s *)s_;
  fio_letter_s *l = (fio_letter_s *)l_;
  struct {
    fio_msg_s msg;
    fio_letter_s *l;
    uintptr_t flag;
  } m = {
      .msg =
          {
              .io = s->io,
              .channel = fio_letter_channel(l),
              .message = fio_letter_message(l),
              .udata = s->udata,
              .filter = fio_letter_filter(l),
              .is_json = !!(fio_letter_flags(l) & FIO___PUBSUB_JSON),
          },
      .l = l,
  };
  s->on_message(&m.msg);
  s->udata = m.msg.udata;
  if (m.flag)
    goto reschedule;
  fio_subscription_free(s);
  fio_letter_free(l);
  return;
reschedule:
  fio_defer(fio___subscription_on_message_task, s_, l_);
}

/* returns the letter object associated with the
 * message. */
FIO_IFUNC fio_letter_s *fio_msg2letter(fio_msg_s *msg) {
  return *(fio_letter_s **)(msg + 1);
}

/** Defers the current callback, so it will be
 * called again for the message. */
SFUNC void fio_message_defer(fio_msg_s *msg) {
  ((uintptr_t *)(msg + 1))[1] = 1;
}

/* delivers a letter to all of a channel's
 * subscribers */
FIO_SFUNC void fio___channel_deliver_task(void *ch_, void *l_) {
  fio_channel_s *ch = (fio_channel_s *)ch_;
  fio_letter_s *l = (fio_letter_s *)l_;
  if (l->from) {
    FIO_LIST_EACH(fio_subscription_s, node, &ch->subscriptions, s) {
      if (l->from != s->io)
        fio_defer((void (*)(void *, void *))fio___subscription_on_message_task,
                  fio_subscription_dup(s),
                  fio_letter_dup(l));
    }
  } else {
    FIO_LIST_EACH(fio_subscription_s, node, &ch->subscriptions, s) {
      fio_defer((void (*)(void *, void *))fio___subscription_on_message_task,
                fio_subscription_dup(s),
                fio_letter_dup(l));
    }
  }
  fio_letter_free(l);
  fio_channel_free(ch);
}

/* *****************************************************************************



                      Public Subscribe / Unsubscribe API



***************************************************************************** */

/** Subscribes to a named channel in the
 * numerical filter's namespace. */
void fio_subscribe___(void); /* sublimetext marker */
SFUNC void fio_subscribe FIO_NOOP(subscribe_args_s args) {
  fio_subscription_s *s = fio_subscription_new();
  if (!s)
    goto sub_error;
  *s = (fio_subscription_s){
      .io = args.io,
      .on_message = (args.on_message ? args.on_message
                                     : (args.io ? fio_subscription___send_cb
                                                : fio_subscription___mock_cb)),
      .on_unsubscribe = args.on_unsubscribe,
      .udata = args.udata,
  };
  s->channel =
      fio_channel_new_named(args.channel, args.filter, args.is_pattern);
  if (!s->channel)
    goto channel_error;
  fio_defer(fio___subscribe_task, (void *)s->channel, (void *)s);

  if (args.master_only && !args.io)
    goto is_master_only;
  if (!args.subscription_handle_ptr) {
    fio_env_set(args.io,
                .type = (intptr_t)(0LL - (((2ULL | (!!args.is_pattern)) << 16) |
                                          (uint16_t)args.filter)),
                .name = args.channel,
                .on_close = (void (*)(void *))fio___subscription_unsubscribe,
                .udata = s);
    return;
  }
  *args.subscription_handle_ptr = (uintptr_t)s;
  return;

is_master_only:
  if (fio_srv_is_master()) {
    fio___postoffice_msmap_set(
        &FIO_POSTOFFICE.master_subscriptions,
        fio_channel___hash(args.channel.buf, args.channel.len, args.filter),
        FIO_STR_INFO3(args.channel.buf, args.channel.len, (size_t)-1),
        s,
        NULL);
  } else {
    fio_channel_free(s->channel);
    fio_subscription_free(s);
    FIO_LOG_WARNING(
        "(%d) master-only subscription attempt on a non-master process: %.*s",
        fio___srvdata.pid,
        (int)args.channel.len,
        args.channel.buf);
  }
  return;

channel_error:
  FIO_LOG_ERROR("(%d) (pubsub) channel cannot be "
                "created?\n\t%zu bytes long\n\t%.*s",
                fio___srvdata.pid,
                args.channel.len,
                (int)args.channel.len,
                args.channel.buf);
  fio_subscription_free(s);
  return;

sub_error:
  FIO_LOG_ERROR("failed to allocate a new subscription");
  if (args.on_unsubscribe) {
    union {
      void *p;
      void (*fn)(void *udata);
    } u = {.fn = args.on_unsubscribe};
    fio_defer(fio___subscription_on_destroy__task, u.p, args.udata);
  }
  return;
}

/** Cancels an existing subscriptions. */
void fio_unsubscribe___(void); /* sublimetext marker */
int fio_unsubscribe FIO_NOOP(subscribe_args_s args) {
  if (args.master_only && !args.io)
    goto is_master_only;
  if (!args.subscription_handle_ptr) {
    return fio_env_remove(
        args.io,
        .type = (intptr_t)(0LL - (((2ULL | (!!args.is_pattern)) << 16) |
                                  (uint16_t)args.filter)),
        .name = args.channel);
  }
  fio___subscription_unsubscribe(
      *(fio_subscription_s **)args.subscription_handle_ptr);
  return 0;

is_master_only:
  return fio___postoffice_msmap_remove(
      &FIO_POSTOFFICE.master_subscriptions,
      fio_channel___hash(args.channel.buf, args.channel.len, args.filter),
      FIO_STR_INFO3(args.channel.buf, args.channel.len, (size_t)-1),
      NULL);
}

/* *****************************************************************************
Pub/Sub - Publish
***************************************************************************** */

FIO_SFUNC void fio___publish_letter_task(void *l_, void *ignr_) {
  (void)ignr_;
  fio_letter_s *l = (fio_letter_s *)l_;
  if ((fio_letter_flags(l) & FIO_POSTOFFICE.publish_filter))
    fio___channel_deliver(l);
  if ((fio_letter_flags(l) & FIO_POSTOFFICE.local_send_filter)) {
    fio_protocol_each(FIO_POSTOFFICE.siblings_protocol,
                      (void (*)(fio_s *, void *))fio_letter_write,
                      l_);
  }
  if ((fio_letter_flags(l) & FIO_POSTOFFICE.remote_send_filter)) {
    /* deliver to remote connections... all of
     * them? yes, we are the source. */
    fio_protocol_each(&FIO_LETTER_PROTOCOL_REMOTE,
                      (void (*)(fio_s *, void *))fio_letter_write,
                      l_);
  }
  fio_letter_free(l);
}

/** Publishes a message to the relevant
 * subscribers (if any). */
void fio_publish___(void); /* SublimeText marker*/
void fio_publish FIO_NOOP(fio_publish_args_s args) {
  fio_letter_s *l;
  if (!args.engine)
    args.engine = FIO_PUBSUB_DEFAULT;
  if ((uintptr_t)(args.engine) > 0XFF) {
    if (!args.filter)
      goto external_engine;
    args.engine = FIO_PUBSUB_LOCAL;
  }
  if (!args.engine)
    args.engine = FIO_PUBSUB_DEFAULT = FIO_PUBSUB_CLUSTER;
  l = fio_letter_new_compose(
      args.channel,
      args.message,
      (int16_t)args.filter,
      (uint8_t)((uintptr_t)args.engine |
                ((0x100U - args.is_json) & FIO___PUBSUB_JSON)));
  l->from = args.from;
  fio_queue_push(fio___srv_tasks, fio___publish_letter_task, l);
  return;
external_engine:
  args.engine->publish(args.engine,
                       args.channel,
                       args.message,
                       args.filter,
                       args.is_json);
}

/* *****************************************************************************



                      Post Office State Management



***************************************************************************** */

FIO_CONSTRUCTOR(fio_postoffice_init) {
  FIO_POSTOFFICE.engines = FIO_LIST_INIT(FIO_POSTOFFICE.engines);
  FIO_POSTOFFICE.siblings_protocol = &FIO_LETTER_PROTOCOL_IPC_MASTER;
  fio_str_info_s url = FIO_STR_INFO3(FIO_POSTOFFICE.ipc_url, 0, FIO___IPC_LEN);
  fio_string_write2(&url,
                    NULL,
                    FIO_STRING_WRITE_STR1((char *)"priv://facil_io_tmp_"),
                    FIO_STRING_WRITE_HEX(fio_rand64()),
                    FIO_STRING_WRITE_STR1((char *)".sock"));
  fio_state_callback_add(FIO_CALL_PRE_START, fio___pubsub_ipc_listen, NULL);
  fio_state_callback_add(FIO_CALL_IN_CHILD,
                         fio___postoffice_on_enter_child,
                         NULL);
  fio_state_callback_add(FIO_CALL_AT_EXIT,
                         (void (*)(void *))fio___letter_map_destroy,
                         (void *)(&fio___letter_validation.map));
  fio_state_callback_add(FIO_CALL_AT_EXIT,
                         (void (*)(void *))fio___postoffice_msmap_destroy,
                         (void *)(&FIO_POSTOFFICE.master_subscriptions));
  fio_state_callback_add(FIO_CALL_IN_CHILD,
                         (void (*)(void *))fio___postoffice_msmap_destroy,
                         (void *)(&FIO_POSTOFFICE.master_subscriptions));
}

/** Callback called by the letter protocol
 * entering a child processes. */
FIO_SFUNC void fio___postoffice_on_enter_child(void *ignr_) {
  (void)ignr_;
  FIO_POSTOFFICE.publish_filter = FIO___PUBSUB_PROCESS;
  FIO_POSTOFFICE.local_send_filter =
      (FIO___PUBSUB_SIBLINGS | FIO___PUBSUB_ROOT);
  FIO_POSTOFFICE.remote_send_filter = 0;
  FIO_POSTOFFICE.siblings_protocol = &FIO_LETTER_PROTOCOL_IPC_CHILD;
  if (fio_connect(FIO_POSTOFFICE.ipc_url,
                  &FIO_LETTER_PROTOCOL_IPC_CHILD,
                  NULL,
                  NULL)) {
    FIO_LOG_FATAL("(%d) couldn't connect to pub/sub socket @ %s",
                  fio___srvdata.pid,
                  FIO_POSTOFFICE.ipc_url);
    kill(fio___srvdata.root_pid, SIGINT);
    FIO_ASSERT(0, "fatal error encountered");
  }
  /* TODO! clear master-only subscriptions */
}

/* *****************************************************************************



                    Letter Engine Support Implementation



***************************************************************************** */

static void fio_pubsub_mock_detached(const fio_pubsub_engine_s *eng) {
  (void)eng;
}
static void fio_pubsub_mock_sub_unsub(const fio_pubsub_engine_s *eng,
                                      fio_buf_info_s channel,
                                      int16_t filter) {
  (void)eng;
  (void)channel;
  (void)filter;
}
static void fio_pubsub_mock_publish(const fio_pubsub_engine_s *eng,
                                    fio_buf_info_s channel,
                                    fio_buf_info_s msg,
                                    int16_t filter,
                                    uint8_t is_json) {
  (void)eng;
  (void)channel;
  (void)msg;
  (void)filter;
  (void)is_json;
}

/** Callback for when a channel is created. */
FIO_IFUNC void fio_channel_on_create(fio_channel_s *ch) {
  fio_buf_info_s name = FIO_BUF_INFO2(ch->name, ch->name_len);
  FIO_LOG_DEBUG2("%d (pubsub) channel created (filter %d, "
                 "length %zu bytes): %s",
                 fio___srvdata.pid,
                 (int)ch->filter,
                 (size_t)ch->name_len,
                 name.buf);
  FIO_LIST_EACH(fio_pubsub_engine_s,
                internal_use_.node,
                &FIO_POSTOFFICE.engines,
                e) {
    (&e->subscribe + ch->is_pattern)[0](e, name, ch->filter);
  }
}
/** Callback for when a channel is destroy. */
FIO_IFUNC void fio_channel_on_destroy(fio_channel_s *ch) {
  fio_buf_info_s name = FIO_BUF_INFO2(ch->name, ch->name_len);
  FIO_LIST_EACH(fio_pubsub_engine_s,
                internal_use_.node,
                &FIO_POSTOFFICE.engines,
                e) {
    (&e->unsubscribe + ch->is_pattern)[0](e, name, ch->filter);
  }
  FIO_LOG_DEBUG2("%d (pubsub) channel destroyed (filter "
                 "%d, length %zu bytes): %s",
                 fio___srvdata.pid,
                 (int)ch->filter,
                 (size_t)ch->name_len,
                 name.buf);
}

static void fio_pubsub_attach___task(void *engine_, void *ignr_) {
  (void)ignr_;
  fio_pubsub_engine_s *engine = (fio_pubsub_engine_s *)engine_;
  if (!engine->detached)
    engine->detached = fio_pubsub_mock_detached;
  if (!engine->subscribe)
    engine->subscribe = fio_pubsub_mock_sub_unsub;
  if (!engine->unsubscribe)
    engine->unsubscribe = fio_pubsub_mock_sub_unsub;
  if (!engine->psubscribe)
    engine->psubscribe = fio_pubsub_mock_sub_unsub;
  if (!engine->punsubscribe)
    engine->punsubscribe = fio_pubsub_mock_sub_unsub;
  if (!engine->publish)
    engine->publish = fio_pubsub_mock_publish;
  if (!engine->internal_use_.node.next) {
    FIO_LIST_PUSH(&FIO_POSTOFFICE.engines, &engine->internal_use_.node);
  }
  FIO_MAP_EACH(fio_channel_map, &FIO_POSTOFFICE.channels, i) {
    engine->subscribe(engine,
                      FIO_BUF_INFO2(i.key->name, i.key->name_len),
                      i.key->filter);
  }
  FIO_MAP_EACH(fio_channel_map, &FIO_POSTOFFICE.patterns, i) {
    engine->psubscribe(engine,
                       FIO_BUF_INFO2(i.key->name, i.key->name_len),
                       i.key->filter);
  }
}

/** Attaches an engine, so it's callback can be
 * called by facil.io. */
SFUNC void fio_pubsub_attach(fio_pubsub_engine_s *engine) {
  if (!engine)
    return;
  fio_defer(fio_pubsub_attach___task, engine, NULL);
}

FIO_SFUNC void fio_pubsub_detach___task(void *engine, void *ignr_) {
  (void)ignr_;
  fio_pubsub_engine_s *e = (fio_pubsub_engine_s *)engine;
  if (e->internal_use_.node.next) {
    FIO_LIST_REMOVE(&e->internal_use_.node);
    e->internal_use_.node.next = e->internal_use_.node.prev = NULL;
  }
  e->detached(e);
}

/** Schedules an engine for Detachment, so it
 * could be safely destroyed. */
SFUNC void fio_pubsub_detach(fio_pubsub_engine_s *engine) {
  fio_defer(fio_pubsub_detach___task, engine, NULL);
}

/* *****************************************************************************
Pub/Sub Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL

/* *****************************************************************************
Letter Testing
***************************************************************************** */
FIO_SFUNC void FIO_NAME_TEST(stl, letter)(void) {
  fprintf(stderr,
          "* Testing letter format (pub/sub "
          "message exchange)\n");
  struct test_info {
    char *channel;
    char *msg;
    int16_t filter;
    uint8_t flags;
  } test_info[] = {
      {(char *)"My Channel", (char *)"My channel Message", 0, 0},
      {NULL, (char *)"My filter Message", 1, 255},
      {(char *)"My Channel and Filter",
       (char *)"My channel -filter Message",
       257,
       4},
      {(char *)"My Channel and negative Filter",
       (char *)"My channel - filter Message",
       -3,
       8},
      {0},
  };
  for (int i = 0;
       test_info[i].msg || test_info[i].channel || test_info[i].filter;
       ++i) {
    fio_letter_s *l = fio_letter_new_compose(
        FIO_BUF_INFO2(
            test_info[i].channel,
            (test_info[i].channel ? strlen(test_info[i].channel) : 0)),
        FIO_BUF_INFO2(test_info[i].msg,
                      (test_info[i].msg ? strlen(test_info[i].msg) : 0)),
        test_info[i].filter,
        test_info[i].flags);
    FIO_ASSERT(fio_letter_filter(l) == test_info[i].filter,
               "letter filter identity error");
    FIO_ASSERT(fio_letter_flags(l) == test_info[i].flags,
               "letter flag identity error");
    if (test_info[i].msg) {
      FIO_ASSERT(fio_letter_message_len(l) == strlen(test_info[i].msg),
                 "letter message length error");
      FIO_ASSERT(!memcmp(fio_letter_message(l).buf,
                         test_info[i].msg,
                         fio_letter_message_len(l)),
                 "message identity error (%s != %.*s)",
                 test_info[i].msg,
                 (int)fio_letter_message_len(l),
                 fio_letter_message(l).buf);
    } else {
      FIO_ASSERT(!fio_letter_message_len(l),
                 "letter message length error %d != 0",
                 fio_letter_message_len(l));
    }
    if (test_info[i].channel) {
      FIO_ASSERT(fio_letter_channel_len(l) == strlen(test_info[i].channel),
                 "letter channel length error");
      FIO_ASSERT(fio_letter_channel(l).buf &&
                     !memcmp(fio_letter_channel(l).buf,
                             test_info[i].channel,
                             fio_letter_channel_len(l)),
                 "channel identity error (%s != %.*s)",
                 test_info[i].channel,
                 (int)fio_letter_channel_len(l),
                 fio_letter_channel(l).buf);
    } else {
      FIO_ASSERT(!fio_letter_channel_len(l), "letter channel length error");
    }

    fio_letter_free(l);
  }
}

FIO_SFUNC void FIO_NAME_TEST(stl, pubsub_on_message)(fio_msg_s *msg) {
  ((int *)(msg->udata))[0] += 1;
}
FIO_SFUNC void FIO_NAME_TEST(stl, pubsub_on_unsubscribe)(void *udata) {
  ((int *)(udata))[0] -= 1;
}

FIO_SFUNC void FIO_NAME_TEST(stl, pubsub_roundtrip)(void) {
  fprintf(stderr, "* Testing pub/sub round-trip.\n");
  uintptr_t sub_handle = 0;
  int state = 0, expected = 0, delta = 0;
  fio_buf_info_s test_channel = FIO_BUF_INFO1((char *)"pubsub_test_channel");
  subscribe_args_s sub[] = {
      {
          .channel = test_channel,
          .on_message = FIO_NAME_TEST(stl, pubsub_on_message),
          .on_unsubscribe = FIO_NAME_TEST(stl, pubsub_on_unsubscribe),
          .filter = -127,
          .udata = &state,
      },
      {
          .channel = test_channel,
          .on_message = FIO_NAME_TEST(stl, pubsub_on_message),
          .on_unsubscribe = FIO_NAME_TEST(stl, pubsub_on_unsubscribe),
          .subscription_handle_ptr = &sub_handle,
          .udata = &state,
          .filter = -127,
      },
      {
          .channel = FIO_BUF_INFO1((char *)"pubsub_*"),
          .on_message = FIO_NAME_TEST(stl, pubsub_on_message),
          .on_unsubscribe = FIO_NAME_TEST(stl, pubsub_on_unsubscribe),
          .filter = -127,
          .udata = &state,
          .is_pattern = 1,
      },
  };
  const int sub_count = (sizeof(sub) / sizeof(sub[0]));
#define FIO___PUBLISH2TEST()                                                   \
  fio_publish(.channel = test_channel,                                         \
              .filter = -127,                                                  \
              .engine = FIO_PUBSUB_CLUSTER);                                   \
  expected += delta;                                                           \
  fio_queue_perform_all(fio___srv_tasks);
  for (int i = 0; i < sub_count; ++i) {
    fio_subscribe FIO_NOOP(sub[i]);
    ++delta;
    FIO_ASSERT(state == expected,
               "subscribe shouldn't have "
               "affected state");
    FIO___PUBLISH2TEST();
    FIO_ASSERT(state == expected, "pub/sub test state incorrect (1-%d)", i);
    FIO___PUBLISH2TEST();
    FIO_ASSERT(state == expected, "pub/sub test state incorrect (2-%d)", i);
  }
  for (int i = 0; i < sub_count; ++i) {
    fio_unsubscribe FIO_NOOP(sub[i]);
    --delta;
    --expected;
    fio_queue_perform_all(fio___srv_tasks);
    FIO_ASSERT(state == expected, "unsubscribe should call callback");
    FIO___PUBLISH2TEST();
    FIO_ASSERT(state == expected, "pub/sub test state incorrect (3-%d)", i);
    FIO___PUBLISH2TEST();
    FIO_ASSERT(state == expected, "pub/sub test state incorrect (4-%d)", i);
  }
#undef FIO___PUBLISH2TEST
}
FIO_SFUNC void FIO_NAME_TEST(stl, pubsub)(void) {
  FIO_NAME_TEST(stl, letter)();
  FIO_NAME_TEST(stl, pubsub_roundtrip)();
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Pub/Sub Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_PUBSUB
#endif /* FIO_PUBSUB */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___    /* Development inclusion - ignore line */
#define FIO_HTTP_HANDLE /* Development inclusion - ignore line */
#define FIO_STR         /* Development inclusion - ignore line */
#include "./include.h"  /* Development inclusion - ignore line */
#endif                  /* Development inclusion - ignore line */
/* *****************************************************************************




                      An HTTP connection Handle helper




Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_HTTP_HANDLE) && !defined(FIO_STL_KEEP__) &&                    \
    !defined(H___FIO_HTTP_HANDLE___H)
#define H___FIO_HTTP_HANDLE___H

/* *****************************************************************************
HTTP Handle Settings
***************************************************************************** */
#ifndef FIO_HTTP_EXACT_LOGGING
/**
 * By default, facil.io logs the HTTP request cycle using a fuzzy starting and
 * ending point for the time stamp.
 *
 * The fuzzy timestamp includes delays that aren't related to the HTTP request
 * and may ignore time passed due to timestamp caching.
 *
 * On the other hand, `FIO_HTTP_EXACT_LOGGING` collects exact time stamps to
 * measure the time it took to process the HTTP request (excluding time spent
 * reading / writing the data from the network).
 *
 * Due to the preference to err on the side of higher performance, fuzzy
 * time-stamping is the default.
 */
#define FIO_HTTP_EXACT_LOGGING 0
#endif

#ifndef FIO_HTTP_BODY_RAM_LIMIT
/**
 * The HTTP handle automatically switches between RAM storage and file storage
 * once the HTTP body (payload) reaches a certain size. This control this point
 * of transition
 */
#define FIO_HTTP_BODY_RAM_LIMIT (1 << 17)
#endif

/* *****************************************************************************
HTTP Handle Type
***************************************************************************** */

/** Named arguments for the http_write function. */
typedef struct fio_http_s fio_http_s;

/**
 * The HTTP Controller points to all the callbacks required by the HTTP Handler.
 *
 * This allows the HTTP Handler to be somewhat protocol agnostic.
 */
typedef struct fio_http_controller_s fio_http_controller_s;

/* *****************************************************************************
Constructor / Destructor
***************************************************************************** */

/** Create a new fio_http_s handle. */
SFUNC fio_http_s *fio_http_new(void);

/** Reduces an fio_http_s handle's reference count or frees it. */
SFUNC void fio_http_free(fio_http_s *);

/** Increases an fio_http_s handle's reference count. */
SFUNC fio_http_s *fio_http_dup(fio_http_s *);

/* *****************************************************************************
Opaque User and Controller Data
***************************************************************************** */

/** Gets the opaque user pointer associated with the HTTP handle. */
FIO_IFUNC void *fio_http_udata_get(fio_http_s *);

/** Sets the opaque user pointer associated with the HTTP handle. */
FIO_IFUNC void *fio_http_udata_set(fio_http_s *, void *);

/** Gets the HTTP Controller associated with the HTTP handle. */
FIO_IFUNC fio_http_controller_s *fio_http_controller_get(fio_http_s *h);

/** Gets the HTTP Controller associated with the HTTP handle. */
FIO_IFUNC fio_http_controller_s *fio_http_controller_set(
    fio_http_s *h,
    fio_http_controller_s *controller);

/** Returns the existing controller data (`void *` pointer). */
FIO_IFUNC void *fio_http_cdata_get(fio_http_s *h);

/** Sets a new controller data (`void *` pointer). */
FIO_IFUNC void *fio_http_cdata_set(fio_http_s *h, void *cdata);

/* *****************************************************************************
Data associated with the Request (usually set by the HTTP protocol)
***************************************************************************** */

/** Gets the method information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_method_get(fio_http_s *);

/** Sets the method information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_method_set(fio_http_s *, fio_str_info_s);

/** Gets the path information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_path_get(fio_http_s *);

/** Sets the path information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_path_set(fio_http_s *, fio_str_info_s);

/** Gets the query information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_query_get(fio_http_s *);

/** Sets the query information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_query_set(fio_http_s *, fio_str_info_s);

/** Gets the version information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_version_get(fio_http_s *);

/** Sets the version information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_version_set(fio_http_s *, fio_str_info_s);

/**
 * Gets the header information associated with the HTTP handle.
 *
 * Since more than a single value may be associated with a header name, the
 * index may be used to collect subsequent values.
 *
 * An empty value is returned if no header value is available (or index is
 * exceeded).
 */
SFUNC fio_str_info_s fio_http_request_header_get(fio_http_s *,
                                                 fio_str_info_s name,
                                                 size_t index);

/** Sets the header information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_request_header_set(fio_http_s *,
                                                 fio_str_info_s name,
                                                 fio_str_info_s value);

/** Sets the header information associated with the HTTP handle. */
SFUNC fio_str_info_s
fio_http_request_header_set_if_missing(fio_http_s *,
                                       fio_str_info_s name,
                                       fio_str_info_s value);

/** Adds to the header information associated with the HTTP handle. */
SFUNC fio_str_info_s fio_http_request_header_add(fio_http_s *,
                                                 fio_str_info_s name,
                                                 fio_str_info_s value);

/**
 * Iterates through all request headers (except cookies!).
 *
 * A non-zero return will stop iteration.
 * */
SFUNC size_t fio_http_request_header_each(fio_http_s *,
                                          int (*callback)(fio_http_s *,
                                                          fio_str_info_s name,
                                                          fio_str_info_s value,
                                                          void *udata),
                                          void *udata);

/** Gets the body (payload) length associated with the HTTP handle. */
SFUNC size_t fio_http_body_length(fio_http_s *);

/** Adjusts the body's reading position. Negative values start at the end. */
SFUNC size_t fio_http_body_seek(fio_http_s *, ssize_t pos);

/** Reads up to `length` of data from the body, returns nothing on EOF. */
SFUNC fio_str_info_s fio_http_body_read(fio_http_s *, size_t length);

/**
 * Reads from the body until finding `token`, reaching `limit` or EOF.
 *
 * Note: `limit` is ignored if the
 */
SFUNC fio_str_info_s fio_http_body_read_until(fio_http_s *,
                                              char token,
                                              size_t limit);

/** Allocates a body (payload) of (at least) the `expected_length`. */
SFUNC void fio_http_body_expect(fio_http_s *, size_t expected_length);

/** Writes `data` to the body (payload) associated with the HTTP handle. */
SFUNC void fio_http_body_write(fio_http_s *, const void *data, size_t len);

/* *****************************************************************************
Cookies
***************************************************************************** */

/**
 * This is a helper for setting cookie data.
 *
 * This struct is used together with the `fio_http_cookie_set` macro. i.e.:
 *
 *       fio_http_set_cookie(h,
 *                      .name = "my_cookie",
 *                      .value = "data");
 *
 */
typedef struct {
  /** The cookie's name. */
  const char *name;
  /** The cookie's value (leave blank to delete cookie). */
  const char *value;
  /** The cookie's domain (optional). */
  const char *domain;
  /** The cookie's path (optional). */
  const char *path;
  /** The cookie name's size in bytes or a terminating NUL will be assumed.*/
  size_t name_len;
  /** The cookie value's size in bytes or a terminating NUL will be assumed.*/
  size_t value_len;
  /** The cookie domain's size in bytes or a terminating NUL will be assumed.*/
  size_t domain_len;
  /** The cookie path's size in bytes or a terminating NULL will be assumed.*/
  size_t path_len;
  /** Max Age (how long should the cookie persist), in seconds (0 == session).*/
  int max_age;
  /**
   * The SameSite settings.
   *
   * See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie
   */
  enum {
    /** allow the browser to dictate this property */
    HTTP_COOKIE_SAME_SITE_BROWSER_DEFAULT = 0,
    /** The browser sends the cookie with cross-site and same-site requests. */
    HTTP_COOKIE_SAME_SITE_NONE,
    /**
     * The cookie is withheld on cross-site sub-requests.
     *
     * The cookie is sent when a user navigates to the URL from an external
     * site.
     */
    HTTP_COOKIE_SAME_SITE_LAX,
    /** The browser sends the cookie only for same-site requests. */
    HTTP_COOKIE_SAME_SITE_STRICT,
  } same_site;
  /** Limit cookie to secure connections.*/
  unsigned secure : 1;
  /** Limit cookie to HTTP (intended to prevent JavaScript access/hijacking).*/
  unsigned http_only : 1;
} fio_http_cookie_args_s;

/**
 * Sets a response cookie.
 *
 * Returns -1 on error and 0 on success.
 *
 * Note: Long cookie names and long cookie values will be considered a security
 * violation and an error will be returned. Many browsers and proxies impose
 * limits on headers and cookies, cookies often limited to 4Kb in total for both
 * name and value.
 */
SFUNC int fio_http_cookie_set(fio_http_s *h, fio_http_cookie_args_s);

#ifndef __cplusplus
/** Named arguments helper. See fio_http_cookie_args_s for details. */
#define fio_http_cookie_set(http___handle, ...)                                \
  fio_http_cookie_set((http___handle), (fio_http_cookie_args_s){__VA_ARGS__})
#endif

/** Returns a cookie value (either received of newly set), if any. */
SFUNC fio_str_info_s fio_http_cookie_get(fio_http_s *,
                                         const char *name,
                                         size_t name_len);

/** Iterates through all cookies. A non-zero return will stop iteration. */
SFUNC size_t fio_http_cookie_each(fio_http_s *,
                                  int (*callback)(fio_http_s *,
                                                  fio_str_info_s name,
                                                  fio_str_info_s value,
                                                  void *udata),
                                  void *udata);

/**
 * Iterates through all response set cookies.
 *
 * A non-zero return value from the callback will stop iteration.
 */
SFUNC size_t
fio_http_set_cookie_each(fio_http_s *h,
                         int (*callback)(fio_http_s *,
                                         fio_str_info_s set_cookie_header,
                                         fio_str_info_s value,
                                         void *udata),
                         void *udata);

/* *****************************************************************************
Responding to an HTTP event.
***************************************************************************** */

/** Returns true if the HTTP handle's response was sent. */
SFUNC int fio_http_is_finished(fio_http_s *);

/** Returns true if the HTTP handle's response is streaming. */
SFUNC int fio_http_is_streaming(fio_http_s *);

/** Gets the status associated with the HTTP handle (response). */
SFUNC size_t fio_http_status_get(fio_http_s *);

/** Sets the status associated with the HTTP handle (response). */
SFUNC size_t fio_http_status_set(fio_http_s *, size_t status);

/**
 * Gets the header information associated with the HTTP handle.
 *
 * Since more than a single value may be associated with a header name, the
 * index may be used to collect subsequent values.
 *
 * An empty value is returned if no header value is available (or index is
 * exceeded).
 *
 * If the response headers were already sent, the returned value is always
 * empty.
 */
SFUNC fio_str_info_s fio_http_response_header_get(fio_http_s *,
                                                  fio_str_info_s name,
                                                  size_t index);

/**
 * Sets the header information associated with the HTTP handle.
 *
 * If the response headers were already sent, the returned value is always
 * empty.
 */
SFUNC fio_str_info_s fio_http_response_header_set(fio_http_s *,
                                                  fio_str_info_s name,
                                                  fio_str_info_s value);
/**
 * Sets the header information associated with the HTTP handle.
 *
 * If the response headers were already sent, the returned value is always
 * empty.
 */
SFUNC fio_str_info_s
fio_http_response_header_set_if_missing(fio_http_s *,
                                        fio_str_info_s name,
                                        fio_str_info_s value);

/**
 * Adds to the header information associated with the HTTP handle.
 *
 * If the response headers were already sent, the returned value is always
 * empty.
 */
SFUNC fio_str_info_s fio_http_response_header_add(fio_http_s *,
                                                  fio_str_info_s name,
                                                  fio_str_info_s value);

/**
 * Iterates through all response headers (except cookies!).
 *
 * A non-zero return will stop iteration.
 * */
SFUNC size_t fio_http_response_header_each(fio_http_s *,
                                           int (*callback)(fio_http_s *,
                                                           fio_str_info_s name,
                                                           fio_str_info_s value,
                                                           void *udata),
                                           void *udata);

/** Arguments for the fio_http_write function. */
typedef struct fio_http_write_args_s {
  /** The data to be written. */
  const void *data;
  /** The length of the data to be written. */
  size_t len;
  /** If streaming a file, set this value. The file is always closed. */
  int fd;
  /** If the data is a buffer, this callback may be set to free it once sent. */
  void (*dealloc)(void *);
  /** If the data is a buffer / a file - should it be copied? */
  int copy;
  /**
   * If `finish` is set, this data marks the end of the response.
   *
   * Otherwise the response will stream the data.
   */
  int finish;
} fio_http_write_args_s;

/**
 * Writes `data` to the response body associated with the HTTP handle after
 * sending all headers (no further headers may be sent).
 */
SFUNC void fio_http_write(fio_http_s *, fio_http_write_args_s args);

#ifndef __cplusplus
/** Named arguments helper. See fio_http_write and fio_http_write_args_s. */
#define fio_http_write(http_handle, ...)                                       \
  fio_http_write(http_handle, (fio_http_write_args_s){__VA_ARGS__})
#define fio_http_finish(http_handle) fio_http_write(http_handle, .finish = 1)
#endif

/* *****************************************************************************
General Helpers
***************************************************************************** */

/** Returns a human readable string related to the HTTP status number. */
SFUNC fio_str_info_s fio_http_status2str(size_t status);

/** Logs an HTTP (response) to STDOUT. */
SFUNC void fio_http_write_log(fio_http_s *h, fio_buf_info_s peer_addr);

/* *****************************************************************************
The HTTP Controller
***************************************************************************** */

/** (TODO: review necessary callbacks)
 * The HTTP Controller manages all the callbacks required by the HTTP Handler in
 * order for HTTP responses and requests to be sent.
 */
struct fio_http_controller_s {
  /* MUST be initialized to zero, used internally by the HTTP Handle. */
  uintptr_t private_flags;
  /** Called before an HTTP handler link to an HTTP Controller is revoked. */
  void (*on_unlinked)(fio_http_s *h, void *cdata);
  /** Informs the controller that a response is starting. */
  int (*start_response)(fio_http_s *h, int status, int will_stream);
  /** Informs the controller that a request is starting. */
  int (*start_request)(fio_http_s *h, int reserved, int will_stream);
  /** Informs the controller that all headers must be sent. */
  void (*send_headers)(fio_http_s *h);
  /** called by the HTTP handle for each body chunk (or to finish a response. */
  void (*write_body)(fio_http_s *h, fio_http_write_args_s args);
  /** called once a request / response had finished */
  void (*on_finish)(fio_http_s *h);
};

/* *****************************************************************************
HTTP Handle Implementation - inlined static functions
***************************************************************************** */

#define FIO___HTTP_GETSET_PTR(type, name, index_, pre_set_code)                \
  /** Used internally to set / get the propecrty at its known pointer index.   \
   */                                                                          \
  FIO_IFUNC type *fio_http_##name##_get(fio_http_s *h) {                       \
    return ((type **)h)[index_];                                               \
  }                                                                            \
  /** Used internally to set / get the propercty at its known pointer index.   \
   */                                                                          \
  FIO_IFUNC type *fio_http_##name##_set(fio_http_s *h, type *ptr) {            \
    pre_set_code;                                                              \
    return (((type **)h)[index_] = ptr);                                       \
  }

SFUNC void fio___http_controller_validate(fio_http_controller_s *c);

/* Create fio_http_udata_(get|set) functions */
FIO___HTTP_GETSET_PTR(void, udata, 0, (void)0)
/* Create fio_http_cdata_(get|set) functions */
FIO___HTTP_GETSET_PTR(void, cdata, 1, (void)0)
/* Create fio_http_controller_(get|set) functions */
FIO___HTTP_GETSET_PTR(fio_http_controller_s,
                      controller,
                      2,
                      if (!ptr->private_flags)
                          fio___http_controller_validate(ptr))

#undef FIO___HTTP_GETSET_PTR
/*
REMEMBER:
========

All memory allocations should use:
* FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)
* FIO_MEM_FREE_(ptr, size)

*/

/* *****************************************************************************
HTTP Handle Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
Helpers - memory allocation & logging time collection
***************************************************************************** */

FIO_SFUNC void fio___http_keystr_free(void *ptr, size_t len) {
  FIO_MEM_FREE_(ptr, len);
  (void)len; /* if unused */
}
FIO_SFUNC void *fio___http_keystr_alloc(size_t capa) {
  return FIO_MEM_REALLOC_(NULL, 0, capa, 0);
}

#if FIO_HTTP_EXACT_LOGGING
FIO_IFUNC int64_t fio_http_get_timestump(void) { return fio_time_milli(); }
#else
int64_t fio_last_tick(void);
FIO_IFUNC int64_t fio_http_get_timestump(void) {
  return (int64_t)fio_last_tick();
}
#endif

FIO_SFUNC fio_str_info_s fio_http_date(uint64_t now_milli) {
  static char date_buf[128];
  static size_t date_len;
  static uint64_t date_buf_val;
  const uint64_t now_time = now_milli / 1000;
  if (date_buf_val == now_time)
    return FIO_STR_INFO2(date_buf, date_len);
  date_len = fio_time2rfc7231(date_buf, now_time);
  date_buf[date_len] = 0;
  date_buf_val = now_time;
  return FIO_STR_INFO2(date_buf, date_len);
}

#define FIO_STL_KEEP__ 1
/* *****************************************************************************
String Cache
***************************************************************************** */

#define FIO_MAP_NAME fio___http_str_cache
#define FIO_MAP_LRU  1024
#define FIO_MAP_KEY_BSTR
#define FIO_MAP_HASH_FN(k)                                                     \
  fio_risky_hash((k).buf, (k).len, (uint64_t)(uintptr_t)http_new)
#include FIO_INCLUDE_FILE

static fio___http_str_cache_s FIO___HTTP_STRING_CACHE[3] = {{0}};
#define FIO___HTTP_STR_CACHE_NAME   0
#define FIO___HTTP_STR_CACHE_COOKIE 1
#define FIO___HTTP_STR_CACHE_VALUE  2

static fio_str_info_s fio___http_str_copy(size_t group, fio_str_info_s s) {
  fio_str_info_s r =
      fio___http_str_cache_set_if_missing(FIO___HTTP_STRING_CACHE + group, s);
  r.buf = fio_bstr_copy(r.buf);
  return r;
}

FIO_DESTRUCTOR(fio___http_str_cache_cleanup) {
  fio___http_str_cache_destroy(FIO___HTTP_STRING_CACHE);
  fio___http_str_cache_destroy(FIO___HTTP_STRING_CACHE + 1);
  fio___http_str_cache_destroy(FIO___HTTP_STRING_CACHE + 2);
}

/* *****************************************************************************
Headers Maps
***************************************************************************** */

#define FIO_ARRAY_NAME              fio___http_sary
#define FIO_ARRAY_TYPE              char *
#define FIO_ARRAY_TYPE_DESTROY(obj) fio_bstr_free(obj)

#define FIO_MAP_NAME                 fio___http_hmap
#define FIO_MAP_KEY                  fio_str_info_s
#define FIO_MAP_KEY_INTERNAL         char *
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_bstr_info((k))
#define FIO_MAP_KEY_CMP(a, b)        fio_bstr_is_eq2info((a), (b))
#define FIO_MAP_KEY_DESTROY(key)     fio_bstr_free((key))
#define FIO_MAP_KEY_COPY(dest, src)                                            \
  (dest) = fio___http_str_copy(FIO___HTTP_STR_CACHE_NAME, (src))
#define FIO_MAP_KEY_DISCARD(key)
#define FIO_MAP_VALUE fio___http_sary_s
#define FIO_MAP_VALUE_COPY(a, b)                                               \
  do {                                                                         \
    (a) = (fio___http_sary_s)FIO_ARRAY_INIT;                                   \
    (void)(b);                                                                 \
  } while (0) /*no-op*/
#define FIO_MAP_VALUE_DESTROY(o) fio___http_sary_destroy(&(o))
#define FIO_MAP_HASH_FN(k)                                                     \
  fio_risky_hash((k).buf, (k).len, (uint64_t)(uintptr_t)http_new)
#include FIO_INCLUDE_FILE

/** set `add` to positive to add multiple values or negative to overwrite. */
FIO_IFUNC fio_str_info_s fio___http_hmap_set2(fio___http_hmap_s *map,
                                              fio_str_info_s key,
                                              fio_str_info_s val,
                                              int add) {
  fio_str_info_s r = {0};
  fio___http_sary_s *o;
  if (!key.buf || !key.len || !map)
    return r;
  if (!val.buf || !val.len)
    goto remove_key;
  o = fio___http_hmap_node2val_ptr(fio___http_hmap_get_ptr(map, key));
  if (!o) {
    fio___http_sary_s va = {0};
    o = fio___http_hmap_node2val_ptr(
        fio___http_hmap_set_ptr(map, key, va, NULL, 1));
    add = 1;
  }
  if (FIO_UNLIKELY(!o)) {
    FIO_LOG_ERROR("Couldn't add value to header: %.*s:%.*s",
                  (int)key.len,
                  key.buf,
                  (int)val.len,
                  val.buf);
    return r;
  }
  if (add) {
    if (add < 0) {
      fio___http_sary_destroy(o);
    }
    r = fio___http_str_copy(FIO___HTTP_STR_CACHE_VALUE, val);
    fio___http_sary_push(o, r.buf);
    return r;
  }
  r = fio_bstr_info(fio___http_sary_get(o, -1));
  return r;

remove_key:
  if (!add)
    fio___http_hmap_remove(map, key, NULL);
  return r;
}

FIO_IFUNC fio_str_info_s fio___http_hmap_get2(fio___http_hmap_s *map,
                                              fio_str_info_s key,
                                              int32_t index) {
  fio_str_info_s r = {0};
  fio___http_sary_s *a =
      fio___http_hmap_node2val_ptr(fio___http_hmap_get_ptr(map, key));
  if (!a)
    return r;
  const uint32_t count = fio___http_sary_count(a);
  if (!count)
    return r;
  if (index < 0) {
    index += count;
    if (index < 0)
      index = 0;
  }
  if ((uint32_t)index >= count)
    index = count - 1;
  r = fio_bstr_info(fio___http_sary_get(a, index));
  return r;
}

/* *****************************************************************************
Header iteration Task
***************************************************************************** */

typedef struct {
  fio_http_s *h;
  int (*callback)(fio_http_s *, fio_str_info_s, fio_str_info_s, void *);
  void *udata;
} fio___http_hmap_each_info_s;

FIO_SFUNC int http___h_each_task_wrapper(fio___http_hmap_each_s *e) {
  fio___http_hmap_each_info_s *data = (fio___http_hmap_each_info_s *)(e->udata);
  FIO_ARRAY_EACH(fio___http_sary, &e->value, pos) {
    if (data->callback(data->h, e->key, fio_bstr_info(*pos), data->udata) == -1)
      return -1;
  }
  return 0;
}

/* *****************************************************************************
Cookie Maps
***************************************************************************** */

#define FIO_MAP_NAME                 fio___http_cmap /* cached names */
#define FIO_MAP_KEY                  fio_str_info_s
#define FIO_MAP_KEY_INTERNAL         char *
#define FIO_MAP_KEY_FROM_INTERNAL(k) fio_bstr_info((k))
#define FIO_MAP_KEY_CMP(a, b)        fio_bstr_is_eq2info((a), (b))
#define FIO_MAP_KEY_DESTROY(key)     fio_bstr_free((key))
#define FIO_MAP_KEY_COPY(dest, src)                                            \
  (dest) = fio___http_str_copy(FIO___HTTP_STR_CACHE_COOKIE, (src))
#define FIO_MAP_KEY_DISCARD(key)

#define FIO_MAP_VALUE_BSTR /* not cached */
#define FIO_MAP_HASH_FN(k)                                                     \
  fio_risky_hash((k).buf, (k).len, (uint64_t)(uintptr_t)http_new)
#include FIO_INCLUDE_FILE

/* *****************************************************************************
Controller Validation
***************************************************************************** */

FIO_SFUNC void fio___mock_c_on_unlinked(fio_http_s *h, void *cdata) {
  (void)h, (void)cdata;
}
FIO_SFUNC int fio___mock_c_start_response(fio_http_s *h,
                                          int status,
                                          int streaming) {
  return -1;
  (void)h, (void)status, (void)streaming;
}
FIO_SFUNC void fio___mock_c_send_headers(fio_http_s *h) { (void)h; }
FIO_SFUNC void fio___mock_c_write_body(fio_http_s *h,
                                       fio_http_write_args_s args) {
  if (args.data) {
    if (args.dealloc)
      args.dealloc((void *)args.data);
  } else if (args.fd != -1) {
    close(args.fd);
  }
  (void)h;
}

FIO_SFUNC void fio___mock_c_on_finish(fio_http_s *h) { (void)h; }

SFUNC void fio___http_controller_validate(fio_http_controller_s *c) {
  if (!c->on_unlinked)
    c->on_unlinked = fio___mock_c_on_unlinked;
  if (!c->start_response)
    c->start_response = fio___mock_c_start_response;
  if (!c->start_request)
    c->start_request = fio___mock_c_start_response;
  if (!c->send_headers)
    c->send_headers = fio___mock_c_send_headers;
  if (!c->write_body)
    c->write_body = fio___mock_c_write_body;
  if (!c->on_finish)
    c->on_finish = fio___mock_c_on_finish;
}

/* *****************************************************************************
HTTP Handle Type
***************************************************************************** */

#define FIO_HTTP_STATE_FINISHED       1
#define FIO_HTTP_STATE_STREAMING      2
#define FIO_HTTP_STATE_COOKIES_PARSED 4

struct fio_http_s {
  void *udata;
  void *cdata;
  fio_http_controller_s *controller;
  int64_t received_at;
  size_t state;
  size_t sent;
  size_t status;
  fio_keystr_s method;
  fio_keystr_s path;
  fio_keystr_s query;
  fio_keystr_s version;
  fio___http_hmap_s headers[2]; /* request, response */
  fio___http_cmap_s cookies[2]; /* read, write */
  struct {
    char *buf;
    size_t len;
    size_t pos;
    size_t capa;
    int fd;
  } body;
};

#define HTTP_HDR_REQUEST(h)  (h->headers + 0)
#define HTTP_HDR_RESPONSE(h) (h->headers + 1)

void fio_http_destroy(fio_http_s *h) {
  if (!h)
    return;
  if (h->controller)
    h->controller->on_unlinked(h, h->cdata);
  fio_keystr_destroy(&h->method, fio___http_keystr_free);
  fio_keystr_destroy(&h->path, fio___http_keystr_free);
  fio_keystr_destroy(&h->query, fio___http_keystr_free);
  fio_keystr_destroy(&h->version, fio___http_keystr_free);
  fio___http_hmap_destroy(h->headers);
  fio___http_hmap_destroy(h->headers + 1);
  fio___http_cmap_destroy(h->cookies);
  fio___http_cmap_destroy(h->cookies + 1);
  FIO_MEM_FREE(h->body.buf, h->body.capa);
  if (h->body.fd != -1)
    close(h->body.fd);
  *h = (fio_http_s){.received_at = fio_http_get_timestump(), .body.fd = -1};
}

#define FIO_REF_NAME fio_http
#define FIO_REF_INIT(h)                                                        \
  h = (fio_http_s) { .received_at = fio_http_get_timestump(), .body.fd = -1 }
#define FIO_REF_DESTROY(h) fio_http_destroy(&(h))
#include FIO_INCLUDE_FILE

/** Create a new http_s handle. */
SFUNC fio_http_s *fio_http_new(void) { return fio_http_new2(); }

/** Reduces an http_s handle's reference count or frees it. */
SFUNC void fio_http_free(fio_http_s *h) { fio_http_free2(h); }

/** Increases an http_s handle's reference count. */
SFUNC fio_http_s *fio_http_dup(fio_http_s *h) { return fio_http_dup2(h); }

#undef FIO_STL_KEEP__

/* *****************************************************************************
ETag Helper
***************************************************************************** */
FIO_IFUNC int fio___http_response_etag_if_none_match(fio_http_s *h) {
  if (!h->status)
    return 0;
  fio_str_info_s method = fio_keystr_info(&h->method);
  if ((method.len < 3) | (method.len > 4))
    return 0;
  if (!(((method.buf[0] | 32) == 'g') & ((method.buf[1] | 32) == 'e') &
        ((method.buf[2] | 32) == 't')) &&
      !(((method.buf[0] | 32) == 'h') & ((method.buf[1] | 32) == 'e') &
        ((method.buf[2] | 32) == 'a') & ((method.buf[3] | 32) == 'd')))
    return 0;
  fio_str_info_s etag = fio___http_hmap_get2(HTTP_HDR_RESPONSE(h),
                                             FIO_STR_INFO2((char *)"etag", 4),
                                             0);
  if (!etag.len)
    return 0;
  fio_str_info_s cond =
      fio___http_hmap_get2(HTTP_HDR_REQUEST(h),
                           FIO_STR_INFO2((char *)"if-none-match", 13),
                           0);
  return FIO_STR_INFO_IS_EQ(etag, cond);
}

/* *****************************************************************************
Simple Property Set / Get
***************************************************************************** */

#define HTTP___MAKE_GET_SET(property)                                          \
  fio_str_info_s fio_http_##property##_get(fio_http_s *h) {                    \
    FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");                                 \
    return fio_keystr_info(&h->property);                                      \
  }                                                                            \
                                                                               \
  fio_str_info_s fio_http_##property##_set(fio_http_s *h,                      \
                                           fio_str_info_s value) {             \
    FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");                                 \
    fio_keystr_destroy(&h->property, fio___http_keystr_free);                  \
    h->property = fio_keystr_copy(value, fio___http_keystr_alloc);             \
    return fio_keystr_info(&h->property);                                      \
  }

HTTP___MAKE_GET_SET(method)
HTTP___MAKE_GET_SET(path)
HTTP___MAKE_GET_SET(query)
HTTP___MAKE_GET_SET(version)

#undef HTTP___MAKE_GET_SET

/** Gets the status associated with the HTTP handle (response). */
SFUNC size_t fio_http_status_get(fio_http_s *h) { return h->status; }

/** Sets the status associated with the HTTP handle (response). */
SFUNC size_t fio_http_status_set(fio_http_s *h, size_t status) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return (h->status = status);
}
/* *****************************************************************************
Handler State
***************************************************************************** */

/** Returns true if the HTTP handle's response was sent. */
SFUNC int fio_http_is_finished(fio_http_s *h) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return (FIO_HTTP_STATE_STREAMING == (h->state & FIO_HTTP_STATE_FINISHED));
}

/** Returns true if the HTTP handle's response is streaming. */
SFUNC int fio_http_is_streaming(fio_http_s *h) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP handler!");
  return (FIO_HTTP_STATE_STREAMING == (h->state & FIO_HTTP_STATE_STREAMING));
}

/* *****************************************************************************
Header Data Management
***************************************************************************** */

/**
 * Gets the header information associated with the HTTP handle.
 *
 * Since more than a single value may be associated with a header name, the
 * index may be used to collect subsequent values.
 *
 * An empty value is returned if no header value is available (or index is
 * exceeded).
 */

#define FIO___HTTP_HEADER_SET_FN(category, name_, headers, add_val)            \
  /** Sets the header information associated with the HTTP handle. */          \
  fio_str_info_s http_##category##_header_##name_(fio_http_s *h,               \
                                                  fio_str_info_s name,         \
                                                  fio_str_info_s value) {      \
    FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");                                  \
    return fio___http_hmap_set2(headers(h), name, value, add_val);             \
  }
FIO___HTTP_HEADER_SET_FN(request, set, HTTP_HDR_REQUEST, -1)
FIO___HTTP_HEADER_SET_FN(request, set_if_missing, HTTP_HDR_REQUEST, 0)
FIO___HTTP_HEADER_SET_FN(request, add, HTTP_HDR_REQUEST, 1)
FIO___HTTP_HEADER_SET_FN(response, set, HTTP_HDR_RESPONSE, -1)
FIO___HTTP_HEADER_SET_FN(response, set_if_missing, HTTP_HDR_RESPONSE, 0)
FIO___HTTP_HEADER_SET_FN(response, add, HTTP_HDR_RESPONSE, 1)
#undef FIO___HTTP_HEADER_SET_FN

fio_str_info_s fio_http_request_header_get(fio_http_s *h,
                                           fio_str_info_s name,
                                           size_t index) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  return fio___http_hmap_get2(HTTP_HDR_REQUEST(h), name, index);
}
fio_str_info_s fio_http_response_header_get(fio_http_s *h,
                                            fio_str_info_s name,
                                            size_t index) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  return fio___http_hmap_get2(HTTP_HDR_RESPONSE(h), name, index);
}

/** Iterates through all headers. A non-zero return will stop iteration. */
size_t fio_http_request_header_each(fio_http_s *h,
                                    int (*callback)(fio_http_s *,
                                                    fio_str_info_s name,
                                                    fio_str_info_s value,
                                                    void *udata),
                                    void *udata) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  if (!callback)
    return fio___http_hmap_count(HTTP_HDR_REQUEST(h));
  fio___http_hmap_each_info_s d = {.h = h,
                                   .callback = callback,
                                   .udata = udata};
  return fio___http_hmap_each(HTTP_HDR_REQUEST(h),
                              http___h_each_task_wrapper,
                              &d,
                              0);
}

/** Iterates through all headers. A non-zero return will stop iteration. */
size_t fio_http_response_header_each(
    fio_http_s *h,
    int (*callback)(fio_http_s *, fio_str_info_s, fio_str_info_s, void *),
    void *udata) {
  FIO_ASSERT_DEBUG(h, "NULL HTTP Handle!");
  if (!callback)
    return fio___http_hmap_count(HTTP_HDR_RESPONSE(h));
  fio___http_hmap_each_info_s d = {.h = h,
                                   .callback = callback,
                                   .udata = udata};
  return fio___http_hmap_each(HTTP_HDR_RESPONSE(h),
                              http___h_each_task_wrapper,
                              &d,
                              0);
}
/* *****************************************************************************






                                TODO WIP Marker!!!






***************************************************************************** */

/* *****************************************************************************
Cookies
***************************************************************************** */

int fio_http_cookie_set___(void); /* IDE Marker */
/* Sets a response cookie. */
SFUNC int fio_http_cookie_set(fio_http_s *h, fio_http_cookie_args_s);

/** Returns a cookie value (either received of newly set), if any. */
SFUNC fio_str_info_s fio_http_cookie_get(fio_http_s *,
                                         const char *name,
                                         size_t name_len);

/** Iterates through all cookies. A non-zero return will stop iteration. */
SFUNC size_t fio_http_cookie_each(fio_http_s *,
                                  int (*callback)(fio_http_s *,
                                                  fio_str_info_s name,
                                                  fio_str_info_s value,
                                                  void *udata),
                                  void *udata);

/**
 * Iterates through all response set cookies.
 *
 * A non-zero return value from the callback will stop iteration.
 */
SFUNC size_t
fio_http_set_cookie_each(fio_http_s *h,
                         int (*callback)(fio_http_s *,
                                         fio_str_info_s set_cookie_header,
                                         fio_str_info_s value,
                                         void *udata),
                         void *udata);

/* *****************************************************************************
Body Management
***************************************************************************** */

/** Gets the body (payload) length associated with the HTTP handle. */
SFUNC size_t fio_http_body_length(fio_http_s *);

/** Adjusts the body's reading position. Negative values start at the end. */
SFUNC size_t fio_http_body_seek(fio_http_s *, ssize_t pos);

/** Reads up to `length` of data from the body, returns nothing on EOF. */
SFUNC fio_str_info_s fio_http_body_read(fio_http_s *, size_t length);

/**
 * Reads from the body until finding `token`, reaching `limit` or EOF.
 *
 * Note: `limit` is ignored if the
 */
SFUNC fio_str_info_s fio_http_body_read_until(fio_http_s *,
                                              char token,
                                              size_t limit);

/** Allocates a body (payload) of (at least) the `expected_length`. */
SFUNC void fio_http_body_expect(fio_http_s *, size_t expected_length);

/** Writes `data` to the body (payload) associated with the HTTP handle. */
SFUNC void fio_http_body_write(fio_http_s *, const void *data, size_t len);

/* *****************************************************************************
A Response Payload
***************************************************************************** */

void fio_http_write___(void); /* IDE Marker */
/**
 * Writes `data` to the response body associated with the HTTP handle after
 * sending all headers (no further headers may be sent).
 */
SFUNC void fio_http_write FIO_NOOP(fio_http_s *, fio_http_write_args_s args);

/* *****************************************************************************






                                TODO WIP Marker!!!






***************************************************************************** */

/* *****************************************************************************
HTTP Logging
***************************************************************************** */

/** Logs an HTTP (response) to STDOUT. */
SFUNC void fio_http_write_log(fio_http_s *h, fio_buf_info_s peer_addr) {
  char buf_mem[1024];
  fio_str_info_s buf = FIO_STR_INFO3(buf_mem, 0, 1023);
  intptr_t bytes_sent = h->sent;
  uint64_t milli_start, milli_end;
  milli_start = h->received_at;
  milli_end = fio_http_get_timestump();
  fio_str_info_s date = fio_http_date(milli_end);

  { /* try to gather address from request headers */
    /* TODO Guess IP address from headers (forwarded) where possible */
    /* if we failed */
    fio_str_info_s forwarded =
        fio_http_request_header_get(h,
                                    FIO_STR_INFO2((char *)"forwarded", 9),
                                    -1);
    if (forwarded.len) {
      forwarded.len &= 1023; /* limit possible attack surface */
      for (; forwarded.len > 5;) {
        if ((forwarded.buf[0] | 32) != 'f' || (forwarded.buf[1] | 32) != 'o' ||
            (forwarded.buf[2] | 32) != 'r' || forwarded.buf[3] != '=') {
          ++forwarded.buf;
          --forwarded.len;
          continue;
        }
        forwarded.buf += 4 + (forwarded.buf[4] == '"');
        char *end = forwarded.buf;
        while (*end && *end != '"' && *end != ',' && *end != ' ' &&
               *end != ';' && (end - forwarded.buf) < 48)
          ++end;
        buf.len = (size_t)(end - forwarded.buf);
        if (buf.len)
          memcpy(buf.buf, forwarded.buf, buf.len);
        break;
      }
    }
    if (!buf.len) {
      if (peer_addr.len) {
        memcpy(buf.buf, peer_addr.buf, peer_addr.len);
        buf.len = peer_addr.len;
      } else {
        memcpy(buf.buf, "[unknown]", 9);
        buf.len = 9;
      }
    }
  }
  memcpy(buf.buf + buf.len, " - - [", 6);
  memcpy(buf.buf + 6, date.buf, date.len);
  buf.len += date.len + 6;
  fio_string_write2(&buf,
                    NULL,
                    FIO_STRING_WRITE_STR2((const char *)"] \"", 3),
                    FIO_STRING_WRITE_STR_INFO(fio_keystr_info(&h->method)),
                    FIO_STRING_WRITE_STR2((const char *)" ", 1),
                    FIO_STRING_WRITE_STR_INFO(fio_keystr_info(&h->path)),
                    FIO_STRING_WRITE_STR2((const char *)" ", 1),
                    FIO_STRING_WRITE_STR_INFO(fio_keystr_info(&h->version)),
                    FIO_STRING_WRITE_STR2((const char *)"\" ", 2),
                    FIO_STRING_WRITE_NUM(h->status),
                    FIO_STRING_WRITE_STR2(" ", 1),
                    ((bytes_sent > 0)
                         ? (FIO_STRING_WRITE_UNUM(bytes_sent))
                         : (FIO_STRING_WRITE_STR2((const char *)"---", 3))),
                    FIO_STRING_WRITE_STR2((const char *)" ", 1),
                    FIO_STRING_WRITE_NUM((milli_end - milli_start)),
                    FIO_STRING_WRITE_STR2((const char *)"ms\r\n", 4));

  if (buf.buf[buf.len - 1] != '\n')
    buf.buf[buf.len++] = '\n'; /* log was truncated, data too long */

  fwrite(buf.buf, 1, buf.len, stdout);
}

/* *****************************************************************************
Status Strings
***************************************************************************** */

/** Returns a human readable string related to the HTTP status number. */
SFUNC fio_str_info_s fio_http_status2str(size_t status) {
  fio_str_info_s r = {0};
#define HTTP_RETURN_STATUS(str)                                                \
  do {                                                                         \
    r.len = strlen(str);                                                       \
    r.buf = (char *)str;                                                       \
    return r;                                                                  \
  } while (0);
  switch (status) {
  // clang-format off
  case 100: HTTP_RETURN_STATUS("Continue");
  case 101: HTTP_RETURN_STATUS("Switching Protocols");
  case 102: HTTP_RETURN_STATUS("Processing");
  case 103: HTTP_RETURN_STATUS("Early Hints");
  case 110: HTTP_RETURN_STATUS("Response is Stale"); /* caching code*/
  case 111: HTTP_RETURN_STATUS("Re-validation Failed"); /* caching code*/
  case 112: HTTP_RETURN_STATUS("Disconnected Operation"); /* caching code*/
  case 113: HTTP_RETURN_STATUS("Heuristic Expiration"); /* caching code*/
  case 199: HTTP_RETURN_STATUS("Miscellaneous Warning"); /* caching code*/
  case 200: HTTP_RETURN_STATUS("OK");
  case 201: HTTP_RETURN_STATUS("Created");
  case 202: HTTP_RETURN_STATUS("Accepted");
  case 203: HTTP_RETURN_STATUS("Non-Authoritative Information");
  case 204: HTTP_RETURN_STATUS("No Content");
  case 205: HTTP_RETURN_STATUS("Reset Content");
  case 206: HTTP_RETURN_STATUS("Partial Content");
  case 207: HTTP_RETURN_STATUS("Multi-Status");
  case 208: HTTP_RETURN_STATUS("Already Reported");
  case 214: HTTP_RETURN_STATUS("Transformation Applied"); /* caching code*/
  case 218: HTTP_RETURN_STATUS("This is fine (Apache Web Server)"); /* unofficial */
  case 226: HTTP_RETURN_STATUS("IM Used");
  case 299: HTTP_RETURN_STATUS("Miscellaneous Persistent Warning"); /* caching code*/
  case 300: HTTP_RETURN_STATUS("Multiple Choices");
  case 301: HTTP_RETURN_STATUS("Moved Permanently");
  case 302: HTTP_RETURN_STATUS("Found");
  case 303: HTTP_RETURN_STATUS("See Other");
  case 304: HTTP_RETURN_STATUS("Not Modified");
  case 305: HTTP_RETURN_STATUS("Use Proxy");
  case 307: HTTP_RETURN_STATUS("Temporary Redirect");
  case 308: HTTP_RETURN_STATUS("Permanent Redirect");
  case 400: HTTP_RETURN_STATUS("Bad Request");
  case 401: HTTP_RETURN_STATUS("Unauthorized");
  case 402: HTTP_RETURN_STATUS("Payment Required");
  case 403: HTTP_RETURN_STATUS("Forbidden");
  case 404: HTTP_RETURN_STATUS("Not Found");
  case 405: HTTP_RETURN_STATUS("Method Not Allowed");
  case 406: HTTP_RETURN_STATUS("Not Acceptable");
  case 407: HTTP_RETURN_STATUS("Proxy Authentication Required");
  case 408: HTTP_RETURN_STATUS("Request Timeout");
  case 409: HTTP_RETURN_STATUS("Conflict");
  case 410: HTTP_RETURN_STATUS("Gone");
  case 411: HTTP_RETURN_STATUS("Length Required");
  case 412: HTTP_RETURN_STATUS("Precondition Failed");
  case 413: HTTP_RETURN_STATUS("Content Too Large");
  case 414: HTTP_RETURN_STATUS("URI Too Long");
  case 415: HTTP_RETURN_STATUS("Unsupported Media Type");
  case 416: HTTP_RETURN_STATUS("Range Not Satisfiable");
  case 417: HTTP_RETURN_STATUS("Expectation Failed");
  case 419: HTTP_RETURN_STATUS("Page Expired (Laravel Framework)"); /* unofficial */
  case 420: HTTP_RETURN_STATUS("Enhance Your Calm (Twitter) - Method Failure (Spring Framework)"); /* unofficial */
  case 421: HTTP_RETURN_STATUS("Misdirected Request");
  case 422: HTTP_RETURN_STATUS("Unprocessable Content");
  case 423: HTTP_RETURN_STATUS("Locked");
  case 424: HTTP_RETURN_STATUS("Failed Dependency");
  case 425: HTTP_RETURN_STATUS("Too Early");
  case 426: HTTP_RETURN_STATUS("Upgrade Required");
  case 427: HTTP_RETURN_STATUS("Unassigned");
  case 428: HTTP_RETURN_STATUS("Precondition Required");
  case 429: HTTP_RETURN_STATUS("Too Many Requests");
  case 430: HTTP_RETURN_STATUS("Request Header Fields Too Large (Shopify)"); /* unofficial */
  case 431: HTTP_RETURN_STATUS("Request Header Fields Too Large");
  case 444: HTTP_RETURN_STATUS("No Response"); /* nginx code */
  case 450: HTTP_RETURN_STATUS("Blocked by Windows Parental Controls (Microsoft)"); /* unofficial */
  case 451: HTTP_RETURN_STATUS("Unavailable For Legal Reasons");
  case 494: HTTP_RETURN_STATUS("Request header too large"); /* nginx code */
  case 495: HTTP_RETURN_STATUS("SSL Certificate Error"); /* nginx code */
  case 496: HTTP_RETURN_STATUS("SSL Certificate Required"); /* nginx code */
  case 497: HTTP_RETURN_STATUS("HTTP Request Sent to HTTPS Port"); /* nginx code */
  case 498: HTTP_RETURN_STATUS("Invalid Token (Esri)"); /* unofficial */
  case 499: HTTP_RETURN_STATUS("Client Closed Request"); /* nginx code */
  case 500: HTTP_RETURN_STATUS("Internal Server Error");
  case 501: HTTP_RETURN_STATUS("Not Implemented");
  case 502: HTTP_RETURN_STATUS("Bad Gateway");
  case 503: HTTP_RETURN_STATUS("Service Unavailable");
  case 504: HTTP_RETURN_STATUS("Gateway Timeout");
  case 505: HTTP_RETURN_STATUS("HTTP Version Not Supported");
  case 506: HTTP_RETURN_STATUS("Variant Also Negotiates");
  case 507: HTTP_RETURN_STATUS("Insufficient Storage");
  case 508: HTTP_RETURN_STATUS("Loop Detected");
  case 509: HTTP_RETURN_STATUS("Bandwidth Limit Exceeded (Apache Web Server/cPanel)"); /* unofficial */
  case 510: HTTP_RETURN_STATUS("Not Extended");
  case 511: HTTP_RETURN_STATUS("Network Authentication Required");
  case 529: HTTP_RETURN_STATUS("Site is overloaded (Qualys)"); /* unofficial */
  case 530: HTTP_RETURN_STATUS("Site is frozen (Pantheon web)"); /* unofficial */
  case 598: HTTP_RETURN_STATUS("Network read timeout error"); /* unofficial */
    // clang-format on
  }
  HTTP_RETURN_STATUS("Unknown");
#undef HTTP_RETURN_STATUS
}

/* *****************************************************************************
HTTP Handle Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, FIO_MODULE_NAME)(void) {
  /*
   * TODO: test module here
   */
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_HTTP_HANDLE */
#undef FIO_HTTP_HANDLE
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_MODULE_NAME module /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                                HTTP/1.1 Parser




Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_HTTP1_PARSER) && !defined(H___FIO_HTTP1_PARSER___H)
#define H___FIO_HTTP1_PARSER___H
/* *****************************************************************************
The HTTP/1.1 provides static functions only, always as part or implementation.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
HTTP/1.x Parser API
***************************************************************************** */

/** The HTTP/1.1 parser type */
typedef struct fio_http1_parser_s fio_http1_parser_s;
/** Initialization value for the parser */
#define FIO_HTTP1_PARSER_INIT ((fio_http1_parser_s){0})

/**
 * Parses HTTP/1.x data, calling any callbacks.
 *
 * Returns bytes consumed or `FIO_HTTP1_PARSER_ERROR` (`(size_t)-1`) on error.
 */
static size_t fio_http1_parse(fio_http1_parser_s *p,
                              fio_buf_info_s buf,
                              void *udata);

/** The error return value for fio_http1_parse. */
#define FIO_HTTP1_PARSER_ERROR ((size_t)-1)

/* *****************************************************************************
HTTP/1.x callbacks (to be implemented by parser user)
***************************************************************************** */

/** called when either a request or a response was received. */
static void fio_http1_on_complete(void *udata);
/** called when a request method is parsed. */
static int fio_http1_on_method(fio_buf_info_s method, void *udata);
/** called when a response status is parsed. the status_str is the string
 * without the prefixed numerical status indicator.*/
static int fio_http1_on_status(size_t istatus,
                               fio_buf_info_s status,
                               void *udata);
/** called when a request URL is parsed. */
static int fio_http1_on_url(fio_buf_info_s path, void *udata);
/** called when a the HTTP/1.x version is parsed. */
static int fio_http1_on_version(fio_buf_info_s version, void *udata);
/** called when a header is parsed. */
static int fio_http1_on_header(fio_buf_info_s name,
                               fio_buf_info_s value,
                               void *udata);
/** called when the special content-length header is parsed. */
static int fio_http1_on_header_content_length(fio_buf_info_s name,
                                              fio_buf_info_s value,
                                              size_t content_length,
                                              void *udata);
/** called when `Expect` arrives and may require a 100 continue response. */
static int fio_http1_on_expect(fio_buf_info_s expected, void *udata);
/** called when a body chunk is parsed. */
static int fio_http1_on_body_chunk(fio_buf_info_s chunk, void *udata);

/* *****************************************************************************
Implementation Stage Helpers
***************************************************************************** */

/* parsing stage 0 - read first line (proxy?). */
static int fio_http1___start(fio_http1_parser_s *p,
                             fio_buf_info_s *buf,
                             void *udata);
/* parsing stage 1 - read headers. */
static int fio_http1___read_header(fio_http1_parser_s *p,
                                   fio_buf_info_s *buf,
                                   void *udata);
/* parsing stage 2 - read body. */
static int fio_http1___read_body(fio_http1_parser_s *p,
                                 fio_buf_info_s *buf,
                                 void *udata);
/* parsing stage 2 - read chunked body. */
static int fio_http1___read_body_chunked(fio_http1_parser_s *p,
                                         fio_buf_info_s *buf,
                                         void *udata);
/* parsing stage 1 - read headers. */
static int fio_http1___read_trailer(fio_http1_parser_s *p,
                                    fio_buf_info_s *buf,
                                    void *udata);
/* completed parsing. */
static int fio_http1___finish(fio_http1_parser_s *p,
                              fio_buf_info_s *buf,
                              void *udata);

/* *****************************************************************************
Main Parsing Loop
***************************************************************************** */

/** The HTTP/1.1 parser type implementation */
struct fio_http1_parser_s {
  int (*fn)(fio_http1_parser_s *, fio_buf_info_s *, void *);
  size_t expected;
};

static size_t fio_http1_parse(fio_http1_parser_s *p,
                              fio_buf_info_s buf,
                              void *udata) {
  int i = 0;
  char *buf_start = buf.buf;
  if (!buf.len)
    return 0;
  if (!p->fn)
    p->fn = fio_http1___start;
  while (!(i = p->fn(p, &buf, udata)))
    ;
  if (i < 0)
    return FIO_HTTP1_PARSER_ERROR;
  return buf.buf - buf_start;
}
#define HTTP1___EXPECTED_CHUNKED ((size_t)(-1))

/* completed parsing. */
static int fio_http1___finish(fio_http1_parser_s *p,
                              fio_buf_info_s *buf,
                              void *udata) {
  (void)buf;
  *p = (fio_http1_parser_s){0};
  fio_http1_on_complete(udata);
  return 1;
}

/* *****************************************************************************
Reading the first line
***************************************************************************** */

/* parsing stage 0 - read first line (TODO: proxy protocol support?). */
static int fio_http1___start(fio_http1_parser_s *p,
                             fio_buf_info_s *buf,
                             void *udata) {
  /* find line start/end and test */
  char *start = buf->buf;
  char *tmp;
  while ((start[0] == ' ' || start[0] == '\r' || start[0] == '\n') &&
         start < buf->buf + buf->len) /* skip white space */
    ++start;
  if (start == buf->buf + buf->len) {
    buf->buf = start;
    return fio_http1___finish(p, buf, udata);
  }
  char *eol = FIO_MEMCHR(start, '\n', buf->len);
  if (!eol)
    return 1;
  if (start + 13 > eol) /* test for minimal data GET HTTP/1 or ### HTTP/1 */
    return -1;

  /* prep next stage */
  buf->len -= (eol - buf->buf) + 1;
  buf->buf = eol + 1;
  eol -= eol[-1] == '\r';

  /* parse first line */
  if (start[0] > ('0' - 1) && start[0] < ('9' + 1))
    goto parse_response_line;
  /* request: method path version */
  if (!(tmp = FIO_MEMCHR(start, ' ', eol - start)))
    return -1;
  if (fio_http1_on_method(FIO_BUF_INFO2(start, tmp - start), udata))
    return -1;
  start = tmp + 1;
  if (!(tmp = FIO_MEMCHR(start, ' ', eol - start)))
    return -1;
  if (fio_http1_on_url(FIO_BUF_INFO2(start, tmp - start), udata))
    return -1;
  start = tmp + 1;
  if (start >= eol)
    return -1;
  if (fio_http1_on_version(FIO_BUF_INFO2(start, (eol - start)), udata))
    return -1;
  return (p->fn = fio_http1___read_header)(p, buf, udata);

parse_response_line:
  /* response: version code text */
  if (!(tmp = FIO_MEMCHR(start, ' ', eol - start)))
    return -1;
  if (fio_http1_on_version(FIO_BUF_INFO2(start, (tmp - start)), udata))
    return -1;
  start = tmp + 1;
  if (!(tmp = FIO_MEMCHR(start, ' ', eol - start)))
    return -1;
  if (fio_http1_on_status(fio_atol10(&start),
                          FIO_BUF_INFO2((tmp + 1), eol - tmp),
                          udata))
    return -1;
  return (p->fn = fio_http1___read_header)(p, buf, udata);
}

/* *****************************************************************************
Reading Headers
***************************************************************************** */

/* handle headers before calling callback. */
static inline int fio_http1___on_header(fio_http1_parser_s *p,
                                        fio_buf_info_s name,
                                        fio_buf_info_s value,
                                        void *udata) {
  /* test for special headers */
  switch (name.len) {
  case 6: /* test for "expect" */
    if (fio_buf2u32_local(name.buf) == fio_buf2u32_local("expe") &&
        fio_buf2u32_local(name.buf + 2) ==
            fio_buf2u32_local("pect")) { /* Expect */
      return 0 - fio_http1_on_expect(value, udata);
    }
    break;
  case 14: /* test for "content-length" */
    if (fio_buf2u64_local(name.buf) == fio_buf2u64_local("content-") &&
        fio_buf2u64_local(name.buf + 6) == fio_buf2u64_local("t-length")) {
      char *tmp = value.buf;
      uint64_t clen = fio_atol10u(&tmp);
      if (tmp != value.buf + value.len)
        return -1;
      if (p->expected)
        return 0 - (p->expected != clen);
      p->expected = clen;
      return 0 -
             (fio_http1_on_header_content_length(name, value, clen, udata) ==
              -1);
    }
    break;
  case 17: /* test for "transfer-encoding" (chunked?) */
    if (value.len >= 7 && (name.buf[16] == 'g') &&
        ((fio_buf2u64_local(name.buf) == fio_buf2u64_local("transfer")) &
         (fio_buf2u64_local(name.buf + 8) == fio_buf2u64_local("-encodin")))) {
      char *c_start = value.buf + value.len - 7;
      if ((fio_buf2u32_local(c_start) | 0x20202020UL) ==
              fio_buf2u32_local("chun") &&
          (fio_buf2u32_local(c_start + 3) | 0x20202020UL) ==
              fio_buf2u32_local("nked")) {
        if (p->expected && p->expected != HTTP1___EXPECTED_CHUNKED)
          return -1;
        p->expected = HTTP1___EXPECTED_CHUNKED;
        /* endpoint does not need to know if the body was chunked or not */
        if (value.len == 7)
          return 0;
        while (
            (c_start[-1] == ' ' || c_start[-1] == ',' || c_start[-1] == '\t') &&
            c_start > value.buf)
          --c_start;
        if (c_start == value.buf)
          return 0;
        value.len = c_start - value.buf;
      }
    }
    break;
  }
  /* perform callback */
  return 0 - (fio_http1_on_header(name, value, udata) == -1);
}

/* handle trailers (chunked encoding only) before calling callback. */
static inline int fio_http1___on_trailer(fio_http1_parser_s *p,
                                         fio_buf_info_s name,
                                         fio_buf_info_s value,
                                         void *udata) {
  (void)p;
  fio_buf_info_s forbidden[] = {
      FIO_BUF_INFO1("authorization"),
      FIO_BUF_INFO1("cache-control"),
      FIO_BUF_INFO1("content-encoding"),
      FIO_BUF_INFO1("content-length"),
      FIO_BUF_INFO1("content-range"),
      FIO_BUF_INFO1("content-type"),
      FIO_BUF_INFO1("expect"),
      FIO_BUF_INFO1("host"),
      FIO_BUF_INFO1("max-forwards"),
      FIO_BUF_INFO1("set-cookie"),
      FIO_BUF_INFO1("te"),
      FIO_BUF_INFO1("trailer"),
      FIO_BUF_INFO1("transfer-encoding"),
      FIO_BUF_INFO2(NULL, 0),
  }; /* known forbidden headers in trailer */
  for (size_t i = 0; forbidden[i].buf; ++i) {
    if (FIO_BUF_INFO_IS_EQ(name, forbidden[i]))
      return -1;
  }
  return fio_http1_on_header(name, value, udata);
}

/* returns either a lower case (ASCI) or the original char. */
static uint8_t fio_http1_tolower(uint8_t c) {
  if ((c - ((uint8_t)'A' - 1U)) < ((uint8_t)'Z' - (uint8_t)'A'))
    c |= 32;
  return c;
}

/* seeks to the ':' divisor while testing and converting to downcase. */
static char *fio_http1___seek_header_div(char *p) {
  /* this is the subset of the forbidden chars that allows UTF-8 headers */
  static const _Bool forbidden_name_chars[256] = {
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  for (;;) {
    *p = (char)fio_http1_tolower((uint8_t)(*p));
    ++p;
    if (FIO_UNLIKELY(forbidden_name_chars[((uint8_t)(*p))]))
      return p;
  }
}

/* extract header name and value from a line and pass info to handler */
static inline int fio_http1___read_header_line(
    fio_http1_parser_s *p,
    fio_buf_info_s *buf,
    void *udata,
    int (*handler)(fio_http1_parser_s *,
                   fio_buf_info_s,
                   fio_buf_info_s,
                   void *)) {
  int r;
  for (;;) {
    char *start = buf->buf;
    char *eol = FIO_MEMCHR(start, '\n', buf->len);
    char *div;
    fio_buf_info_s name, value;
    if (!eol)
      return 1;

    buf->len -= (eol - buf->buf) + 1;
    buf->buf = eol + 1;
    eol -= (eol[-1] == '\r');
    if (FIO_UNLIKELY(eol == start))
      goto headers_finished;

    div = fio_http1___seek_header_div(start);
    if (div[0] != ':')
      return -1;
    name = FIO_BUF_INFO2(start, (div - start));
    do {
      ++div;
    } while (*div == ' ' || *div == '\t');

    if (div != eol)
      while (eol[-1] == ' ' || eol[-1] == '\t')
        --eol;
    value = FIO_BUF_INFO2((div == eol) ? NULL : div, (eol - div));
    r = handler(p, name, value, udata);
    if (FIO_UNLIKELY(r))
      return r;
  }

headers_finished:
  p->fn = (!p->expected)         ? fio_http1___finish
          : (!(p->expected + 1)) ? fio_http1___read_body_chunked
                                 : fio_http1___read_body;
  return p->fn(p, buf, udata);
}

/* parsing stage 1 - read headers. */
static int fio_http1___read_header(fio_http1_parser_s *p,
                                   fio_buf_info_s *buf,
                                   void *udata) {
  return fio_http1___read_header_line(p, buf, udata, fio_http1___on_header);
}

/* parsing stage 1 - read headers. */
static int fio_http1___read_trailer(fio_http1_parser_s *p,
                                    fio_buf_info_s *buf,
                                    void *udata) {
  return fio_http1___read_header_line(p, buf, udata, fio_http1___on_trailer);
}

/* *****************************************************************************
Reading the Body
***************************************************************************** */

/* parsing stage 2 - read body - known content length. */
static int fio_http1___read_body(fio_http1_parser_s *p,
                                 fio_buf_info_s *buf,
                                 void *udata) {
  if (!buf->len)
    return 1;
  if (buf->len >= p->expected) {
    buf->len = p->expected;
    if (fio_http1_on_body_chunk(*buf, udata))
      return -1;
    buf->buf += buf->len;
    return fio_http1___finish(p, buf, udata);
  }
  if (fio_http1_on_body_chunk(*buf, udata))
    return -1;
  buf->buf += buf->len;
  return 1;
}

/* *****************************************************************************
Reading the Body (chunked)
***************************************************************************** */

/* parsing stage 2 - read chunked body - read chunk data. */
static int fio_http1___read_body_chunked_read(fio_http1_parser_s *p,
                                              fio_buf_info_s *buf,
                                              void *udata) {
  if (!buf->len)
    return 1;
  if (buf->len >= p->expected) {
    if (fio_http1_on_body_chunk(FIO_BUF_INFO2(buf->buf, p->expected), udata))
      return -1;
    buf->buf += p->expected;
    buf->len -= p->expected;
    p->fn = fio_http1___read_body_chunked;
    return 0;
  }
  if (fio_http1_on_body_chunk(buf[0], udata))
    return -1;
  p->expected -= buf->len;
  buf->buf += buf->len;
  return 1;
}

/* parsing stage 2 - read chunked body - read next chunk length. */
static int fio_http1___read_body_chunked(fio_http1_parser_s *p,
                                         fio_buf_info_s *buf,
                                         void *udata) {
  (void)udata;
  if (buf->len < 3)
    return 1;
  { /* remove possible extra EOL after chunk payload */
    size_t tmp = (buf->buf[0] == '\r');
    tmp += (buf->buf[tmp] == '\n');
    buf->len -= tmp;
    buf->buf += tmp;
  }

  // if (!FIO_MEMCHR(buf->buf, '\n', buf->len)) /* prevent read overflow? */
  //   return 1;

  char *eol = buf->buf;
  size_t expected = fio_atol16u(&eol); /* may read overflow, tests after */
  if (eol == buf->buf)
    return -1;
  eol += (eol[0] == '\r');
  if (eol >= buf->buf + buf->len)
    return 1; /* read overflowed */
  if (eol[0] != '\n')
    return -1;
  ++eol;
  p->expected = expected;
  if (p->expected) {
    /* further data expected */
    buf->len -= eol - buf->buf;
    buf->buf = eol;
    return (p->fn = fio_http1___read_body_chunked_read)(p, buf, udata);
  }
  if ((eol + 1 < buf->buf + buf->len) && (eol[0] == '\r' || eol[0] == '\n')) {
    /* no trailers, finish now. */
    eol += (eol[0] == '\r');
    ++eol;
    buf->len -= eol - buf->buf;
    buf->buf = eol;
    return fio_http1___finish(p, buf, udata);
  }
  /* possible trailers */
  buf->len -= eol - buf->buf;
  buf->buf = eol;
  return (p->fn = fio_http1___read_trailer)(p, buf, udata);
}

/* *****************************************************************************
Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, FIO_MODULE_NAME)(void) {
  /*
   * TODO: test HTTP parser here
   */
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_HTTP1_PARSER */
#undef FIO_HTTP1_PARSER
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_FIOBJ      /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************








                          FIOBJ - soft (dynamic) types



FIOBJ - dynamic types

These are dynamic types that use pointer tagging for fast type identification.

Pointer tagging on 64 bit systems allows for 3 bits at the lower bits. On most
32 bit systems this is also true due to allocator alignment. When in doubt, use
the provided custom allocator.

To keep the 64bit memory address alignment on 32bit systems, a 32bit metadata
integer is added when a virtual function table is missing. This doesn't effect
memory consumption on 64 bit systems and uses 4 bytes on 32 bit systems.

Note: this code is placed at the end of the STL file, since it leverages most of
the SLT features and could be affected by their inclusion.

Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_FIOBJ) && !defined(H___FIOBJ___H) && !defined(FIO_STL_KEEP__)
#define H___FIOBJ___H
#define FIO_STL_KEEP__ 99 /* a magic value to keep FIO_EXTERN rules */
/* *****************************************************************************
FIOBJ compilation settings (type names and JSON nesting limits).

Type Naming Macros for FIOBJ types. By default, results in:
- fiobj_true()
- fiobj_false()
- fiobj_null()
- fiobj_num_new() ... (etc')
- fiobj_float_new() ... (etc')
- fiobj_str_new() ... (etc')
- fiobj_array_new() ... (etc')
- fiobj_hash_new() ... (etc')
***************************************************************************** */

#define FIOBJ___NAME_TRUE   true
#define FIOBJ___NAME_FALSE  false
#define FIOBJ___NAME_NULL   null
#define FIOBJ___NAME_NUMBER num
#define FIOBJ___NAME_FLOAT  float
#define FIOBJ___NAME_STRING str
#define FIOBJ___NAME_ARRAY  array
#define FIOBJ___NAME_HASH   hash

#ifndef FIOBJ_MAX_NESTING
/**
 * Sets the limit on nesting level transversal by recursive functions.
 *
 * This effects JSON output / input and the `fiobj_each2` function since they
 * are recursive.
 *
 * HOWEVER: this value will NOT effect the recursive `fiobj_free` which could
 * (potentially) expload the stack if given melformed input such as cyclic data
 * structures.
 *
 * Values should be less than 32K.
 */
#define FIOBJ_MAX_NESTING 512
#endif

/* make sure roundtrips work */
#ifndef JSON_MAX_DEPTH
#define JSON_MAX_DEPTH FIOBJ_MAX_NESTING
#endif

#ifndef FIOBJ_JSON_APPEND
#define FIOBJ_JSON_APPEND 1
#endif
/* *****************************************************************************
General Requirements / Macros
***************************************************************************** */

#ifdef __cplusplus /* C++ doesn't allow declarations for static variables */
#define FIOBJ_EXTERN_OBJ     extern "C" FIO_WEAK
#define FIOBJ_EXTERN_OBJ_IMP extern "C" FIO_WEAK
#elif defined(FIO_EXTERN)
#define FIOBJ_EXTERN_OBJ     extern
#define FIOBJ_EXTERN_OBJ_IMP FIO_WEAK
#else
#define FIOBJ_EXTERN_OBJ     static __attribute__((unused))
#define FIOBJ_EXTERN_OBJ_IMP static __attribute__((unused))
#endif
/* *****************************************************************************
Debugging / Leak Detection
***************************************************************************** */
#if defined(TEST) || defined(DEBUG) || defined(FIO_LEAK_COUNTER)
#define FIOBJ_MARK_MEMORY 1
#endif

#if FIOBJ_MARK_MEMORY
size_t FIO_WEAK FIOBJ_MARK_MEMORY_ALLOC_COUNTER;
size_t FIO_WEAK FIOBJ_MARK_MEMORY_FREE_COUNTER;
#define FIOBJ_MARK_MEMORY_ALLOC()                                              \
  fio_atomic_add(&FIOBJ_MARK_MEMORY_ALLOC_COUNTER, 1)
#define FIOBJ_MARK_MEMORY_FREE()                                               \
  fio_atomic_add(&FIOBJ_MARK_MEMORY_FREE_COUNTER, 1)
#define FIOBJ_MARK_MEMORY_PRINT()                                              \
  FIO_LOG_PRINT__(                                                             \
      ((FIOBJ_MARK_MEMORY_ALLOC_COUNTER == FIOBJ_MARK_MEMORY_FREE_COUNTER)     \
           ? 4 /* FIO_LOG_LEVEL_INFO */                                        \
           : 3 /* FIO_LOG_LEVEL_WARNING */),                                   \
      ((FIOBJ_MARK_MEMORY_ALLOC_COUNTER == FIOBJ_MARK_MEMORY_FREE_COUNTER)     \
           ? "INFO: total remaining FIOBJ allocations: %zu (%zu - %zu)"        \
           : "WARNING: LEAKED! FIOBJ allocations: %zu (%zu - %zu)"),           \
      FIOBJ_MARK_MEMORY_ALLOC_COUNTER - FIOBJ_MARK_MEMORY_FREE_COUNTER,        \
      FIOBJ_MARK_MEMORY_ALLOC_COUNTER,                                         \
      FIOBJ_MARK_MEMORY_FREE_COUNTER)
#define FIOBJ_MARK_MEMORY_ENABLED 1

#else

#define FIOBJ_MARK_MEMORY_ALLOC_COUNTER 0 /* when testing unmarked FIOBJ */
#define FIOBJ_MARK_MEMORY_FREE_COUNTER  0 /* when testing unmarked FIOBJ */
#define FIOBJ_MARK_MEMORY_ALLOC()
#define FIOBJ_MARK_MEMORY_FREE()
#define FIOBJ_MARK_MEMORY_PRINT()
#define FIOBJ_MARK_MEMORY_ENABLED 0
#endif

/* *****************************************************************************
The FIOBJ Type
***************************************************************************** */

/** Use the FIOBJ type for dynamic types. */
typedef struct FIOBJ_s {
  struct FIOBJ_s *compiler_validation_type;
} * FIOBJ;

/** FIOBJ type enum for common / primitive types. */
typedef enum {
  FIOBJ_T_NUMBER = 0x01, /* 0b001 3 bits taken for small numbers */
  FIOBJ_T_PRIMITIVE = 2, /* 0b010 a lonely second bit signifies a primitive */
  FIOBJ_T_STRING = 3,    /* 0b011 */
  FIOBJ_T_ARRAY = 4,     /* 0b100 */
  FIOBJ_T_HASH = 5,      /* 0b101 */
  FIOBJ_T_FLOAT = 6,     /* 0b110 */
  FIOBJ_T_OTHER = 7,     /* 0b111 dynamic type - test content */
} fiobj_class_en;

#define FIOBJ_T_NULL  2  /* 0b010 a lonely second bit signifies a primitive */
#define FIOBJ_T_TRUE  18 /* 0b010 010 - primitive value */
#define FIOBJ_T_FALSE 34 /* 0b100 010 - primitive value */

/** Use the macros to avoid future API changes. */
#define FIOBJ_TYPE(o) fiobj_type(o)
/** Use the macros to avoid future API changes. */
#define FIOBJ_TYPE_IS(o, type) (fiobj_type(o) == type)
/** Identifies an invalid type identifier (returned from FIOBJ_TYPE(o) */
#define FIOBJ_T_INVALID 0
/** Identifies an invalid object */
#define FIOBJ_INVALID 0
/** Tests if the object is (probably) a valid FIOBJ */
#define FIOBJ_IS_INVALID(o)       (((uintptr_t)(o)&7UL) == 0)
#define FIOBJ_IS_NULL(o)          (FIOBJ_IS_INVALID(o) || ((o) == FIOBJ_T_NULL))
#define FIOBJ_TYPE_CLASS(o)       ((fiobj_class_en)(((uintptr_t)(o)) & 7UL))
#define FIOBJ_PTR_TAG(o, klass)   ((uintptr_t)((uintptr_t)(o) | (klass)))
#define FIOBJ_PTR_UNTAG(o)        ((uintptr_t)((uintptr_t)(o) & (~7ULL)))
#define FIOBJ_PTR_TAG_VALIDATE(o) ((uintptr_t)((uintptr_t)(o) & (7ULL)))
/** Returns an objects type. This isn't limited to known types. */
FIO_IFUNC size_t fiobj_type(FIOBJ o);

/* *****************************************************************************
FIOBJ Memory Management
***************************************************************************** */

/** Increases an object's reference count (or copies) and returns it. */
FIO_IFUNC FIOBJ fiobj_dup(FIOBJ o);

/** Decreases an object's reference count or frees it. */
FIO_IFUNC void fiobj_free(FIOBJ o);

/* *****************************************************************************
FIOBJ Data / Info
***************************************************************************** */

/** Compares two objects. */
FIO_IFUNC unsigned char FIO_NAME_BL(fiobj, eq)(FIOBJ a, FIOBJ b);

/** Returns a temporary String representation for any FIOBJ object. */
FIO_IFUNC fio_str_info_s FIO_NAME2(fiobj, cstr)(FIOBJ o);

/** Returns an integer representation for any FIOBJ object. */
FIO_IFUNC intptr_t FIO_NAME2(fiobj, i)(FIOBJ o);

/** Returns a float (double) representation for any FIOBJ object. */
FIO_IFUNC double FIO_NAME2(fiobj, f)(FIOBJ o);

/* *****************************************************************************
FIOBJ Containers (iteration)
***************************************************************************** */

/** Iteration information structure passed to the callback. */
typedef struct fiobj_each_s {
  /** The being iterated. Once set, cannot be safely changed. */
  FIOBJ const parent;
  /** The index to start at / the current object's index */
  uint64_t index;
  /** The callback / task called for each index, may be updated mid-cycle. */
  int (*task)(struct fiobj_each_s *info);
  /** The argument passed along to the task. */
  void *udata;
  /** The value of the current object in the Array or Hash Map */
  FIOBJ value;
  /* The key, if a Hash Map */
  FIOBJ key;
} fiobj_each_s;

/**
 * Performs a task for each element held by the FIOBJ object.
 *
 * If `task` returns -1, the `each` loop will break (stop).
 *
 * Returns the "stop" position - the number of elements processed + `start_at`.
 */
FIO_SFUNC uint32_t fiobj_each1(FIOBJ o,
                               int (*task)(fiobj_each_s *info),
                               void *udata,
                               int32_t start_at);

/**
 * Performs a task for the object itself and each element held by the FIOBJ
 * object or any of it's elements (a deep task).
 *
 * The order of performance is by order of appearance, as if all nesting levels
 * were flattened.
 *
 * If `task` returns -1, the `each` loop will break (stop).
 *
 * Returns the number of elements processed.
 */
SFUNC uint32_t fiobj_each2(FIOBJ o,
                           int (*task)(fiobj_each_s *info),
                           void *udata);

/* *****************************************************************************
FIOBJ Primitives (NULL, True, False)
***************************************************************************** */

/** Returns the `true` primitive. */
FIO_IFUNC FIOBJ FIO_NAME(fiobj, FIOBJ___NAME_TRUE)(void) {
  return (FIOBJ)(FIOBJ_T_TRUE);
}

/** Returns the `false` primitive. */
FIO_IFUNC FIOBJ FIO_NAME(fiobj, FIOBJ___NAME_FALSE)(void) {
  return (FIOBJ)(FIOBJ_T_FALSE);
}

/** Returns the `nil` / `null` primitive. */
FIO_IFUNC FIOBJ FIO_NAME(fiobj, FIOBJ___NAME_NULL)(void) {
  return (FIOBJ)(FIOBJ_T_NULL);
}

/* *****************************************************************************
FIOBJ Type - Extensibility (FIOBJ_T_OTHER)
***************************************************************************** */

/** FIOBJ types can be extended using virtual function tables. */
typedef struct {
  /**
   * MUST return a unique number to identify object type.
   *
   * Numbers (type IDs) under 100 are reserved. Numbers under 40 are illegal.
   */
  size_t type_id;
  /** Test for equality between two objects with the same `type_id` */
  unsigned char (*is_eq)(FIOBJ restrict a, FIOBJ restrict b);
  /** Converts an object to a String */
  fio_str_info_s (*to_s)(FIOBJ o);
  /** Converts an object to an integer */
  intptr_t (*to_i)(FIOBJ o);
  /** Converts an object to a double */
  double (*to_f)(FIOBJ o);
  /** Returns the number of exposed elements held by the object, if any. */
  uint32_t (*count)(FIOBJ o);
  /** Iterates the exposed elements held by the object. See `fiobj_each1`. */
  uint32_t (*each1)(FIOBJ o,
                    int (*task)(fiobj_each_s *e),
                    void *udata,
                    int32_t start_at);
  /**
   * Decreases the reference count and/or frees the object, calling `free2` for
   * any nested objects.
   */
  void (*free2)(FIOBJ o);
} FIOBJ_class_vtable_s;

FIOBJ_EXTERN_OBJ const FIOBJ_class_vtable_s FIOBJ___OBJECT_CLASS_VTBL;

#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_REF_NAME             fiobj_object
#define FIO_REF_TYPE             void *
#define FIO_REF_METADATA         const FIOBJ_class_vtable_s *
#define FIO_REF_METADATA_INIT(m)                                               \
  do {                                                                         \
    m = &FIOBJ___OBJECT_CLASS_VTBL;                                            \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#define FIO_REF_METADATA_DESTROY(m)                                            \
  do {                                                                         \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_PTR_TAG(p)   FIOBJ_PTR_TAG(p, FIOBJ_T_OTHER)
#define FIO_PTR_UNTAG(p) FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_TYPE FIOBJ
#include FIO_INCLUDE_FILE

/* *****************************************************************************
FIOBJ Integers
***************************************************************************** */

/** Creates a new Number object. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)(intptr_t i);

/** Reads the number from a FIOBJ Number. */
FIO_IFUNC intptr_t FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(FIOBJ i);

/** Reads the number from a FIOBJ Number, fitting it in a double. */
FIO_IFUNC double FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), f)(FIOBJ i);

/** Returns a String representation of the number (in base 10). */
SFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER),
                               cstr)(FIOBJ i);

/** Frees a FIOBJ number. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), free)(FIOBJ i);

FIOBJ_EXTERN_OBJ const FIOBJ_class_vtable_s FIOBJ___NUMBER_CLASS_VTBL;

/* *****************************************************************************
FIOBJ Floats
***************************************************************************** */

/** Creates a new Float (double) object. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), new)(double i);

/** Reads the number from a FIOBJ Float rounding it to an integer. */
FIO_IFUNC intptr_t FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), i)(FIOBJ i);

/** Reads the value from a FIOBJ Float, as a double. */
FIO_IFUNC double FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(FIOBJ i);

/** Returns a String representation of the float. */
SFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT),
                               cstr)(FIOBJ i);

/** Frees a FIOBJ Float. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), free)(FIOBJ i);

FIOBJ_EXTERN_OBJ const FIOBJ_class_vtable_s FIOBJ___FLOAT_CLASS_VTBL;

/* *****************************************************************************
FIOBJ Strings
***************************************************************************** */

#define FIO_STR_NAME              FIO_NAME(fiobj, FIOBJ___NAME_STRING)
#define FIO_STR_OPTIMIZE_EMBEDDED 1
#define FIO_REF_NAME              FIO_NAME(fiobj, FIOBJ___NAME_STRING)
#define FIO_REF_CONSTRUCTOR_ONLY  1
#define FIO_REF_DESTROY(s)                                                     \
  do {                                                                         \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), destroy)((FIOBJ)&s);        \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_REF_INIT(s_)                                                       \
  do {                                                                         \
    s_ = (FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s))FIO_STR_INIT;      \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)

#if SIZE_T_MAX == 0xFFFFFFFF /* for 32bit system pointer alignment */
#define FIO_REF_METADATA uint32_t
#endif
#define FIO_PTR_TAG(p)   FIOBJ_PTR_TAG(p, FIOBJ_T_STRING)
#define FIO_PTR_UNTAG(p) FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_TYPE FIOBJ
#include FIO_INCLUDE_FILE

/* Creates a new FIOBJ string object, copying the data to the new string. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                         new_cstr)(const char *ptr, size_t len) {
  FIOBJ s = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_ASSERT_ALLOC(FIOBJ_PTR_UNTAG(s));
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(s, ptr, len);
  return s;
}

/* Creates a new FIOBJ string object with (at least) the requested capacity. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                         new_buf)(size_t capa) {
  FIOBJ s = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_ASSERT_ALLOC(FIOBJ_PTR_UNTAG(s));
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), reserve)(s, capa);
  return s;
}

/* Creates a new FIOBJ string object, copying the origin (`fiobj2cstr`). */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                         new_copy)(FIOBJ original) {
  FIOBJ s = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_ASSERT_ALLOC(FIOBJ_PTR_UNTAG(s));
  fio_str_info_s i = FIO_NAME2(fiobj, cstr)(original);
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(s, i.buf, i.len);
  return s;
}

/** Returns information about the string. Same as fiobj_str_info(). */
FIO_IFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                                   cstr)(FIOBJ s) {
  return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), info)(s);
}

/**
 * Creates a temporary FIOBJ String object on the stack.
 *
 * String data might be allocated dynamically.
 */
#define FIOBJ_STR_TEMP_VAR(str_name)                                           \
  struct {                                                                     \
    uint64_t i1;                                                               \
    uint64_t i2;                                                               \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s) s;                       \
  } FIO_NAME(str_name, __auto_mem_tmp) = {0x7f7f7f7f7f7f7f7fULL,               \
                                          0x7f7f7f7f7f7f7f7fULL,               \
                                          FIO_STR_INIT};                       \
  FIOBJ str_name =                                                             \
      (FIOBJ)(((uintptr_t) & (FIO_NAME(str_name, __auto_mem_tmp).s)) |         \
              FIOBJ_T_STRING);

/**
 * Creates a temporary FIOBJ String object on the stack, initialized with a
 * static string.
 *
 * String data might be allocated dynamically.
 */
#define FIOBJ_STR_TEMP_VAR_STATIC(str_name, buf_, len_)                        \
  struct {                                                                     \
    uint64_t i1;                                                               \
    uint64_t i2;                                                               \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s) s;                       \
  } FIO_NAME(str_name,                                                         \
             __auto_mem_tmp) = {0x7f7f7f7f7f7f7f7fULL,                         \
                                0x7f7f7f7f7f7f7f7fULL,                         \
                                FIO_STR_INIT_STATIC2((buf_), (len_))};         \
  FIOBJ str_name =                                                             \
      (FIOBJ)(((uintptr_t) & (FIO_NAME(str_name, __auto_mem_tmp).s)) |         \
              FIOBJ_T_STRING);

/**
 * Creates a temporary FIOBJ String object on the stack, initialized with a
 * static string.
 *
 * String data might be allocated dynamically.
 */
#define FIOBJ_STR_TEMP_VAR_EXISTING(str_name, buf_, len_, capa_)               \
  struct {                                                                     \
    uint64_t i1;                                                               \
    uint64_t i2;                                                               \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), s) s;                       \
  } FIO_NAME(str_name, __auto_mem_tmp) = {                                     \
      0x7f7f7f7f7f7f7f7fULL,                                                   \
      0x7f7f7f7f7f7f7f7fULL,                                                   \
      FIO_STR_INIT_EXISTING((buf_), (len_), (capa_))};                         \
  FIOBJ str_name =                                                             \
      (FIOBJ)(((uintptr_t) & (FIO_NAME(str_name, __auto_mem_tmp).s)) |         \
              FIOBJ_T_STRING);

/** Resets a temporary FIOBJ String, freeing and any resources allocated. */
#define FIOBJ_STR_TEMP_DESTROY(str_name)                                       \
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), destroy)(str_name);

/* *****************************************************************************
FIOBJ Arrays
***************************************************************************** */

#define FIO_ARRAY_NAME           FIO_NAME(fiobj, FIOBJ___NAME_ARRAY)
#define FIO_REF_NAME             FIO_NAME(fiobj, FIOBJ___NAME_ARRAY)
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_REF_DESTROY(a)                                                     \
  do {                                                                         \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), destroy)((FIOBJ)&a);         \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_REF_INIT(a)                                                        \
  do {                                                                         \
    a = (FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), s))FIO_ARRAY_INIT;      \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#if SIZE_T_MAX == 0xFFFFFFFF /* for 32bit system pointer alignment */
#define FIO_REF_METADATA uint32_t
#endif
#define FIO_ARRAY_TYPE            FIOBJ
#define FIO_ARRAY_TYPE_CMP(a, b)  FIO_NAME_BL(fiobj, eq)((a), (b))
#define FIO_ARRAY_TYPE_DESTROY(o) fiobj_free(o)
#define FIO_ARRAY_TYPE_CONCAT_COPY(dest, obj)                                  \
  do {                                                                         \
    dest = fiobj_dup(obj);                                                     \
  } while (0)
#define FIO_PTR_TAG(p)   FIOBJ_PTR_TAG(p, FIOBJ_T_ARRAY)
#define FIO_PTR_UNTAG(p) FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_TYPE FIOBJ
#include FIO_INCLUDE_FILE

/* *****************************************************************************
FIOBJ Hash Maps
***************************************************************************** */

#define FIO_OMAP_NAME            FIO_NAME(fiobj, FIOBJ___NAME_HASH)
#define FIO_REF_NAME             FIO_NAME(fiobj, FIOBJ___NAME_HASH)
#define FIO_REF_CONSTRUCTOR_ONLY 1
#define FIO_REF_DESTROY(a)                                                     \
  do {                                                                         \
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), destroy)                      \
    ((FIOBJ)FIOBJ_PTR_TAG(&(a), FIOBJ_T_HASH));                                \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_REF_INIT(a)                                                        \
  do {                                                                         \
    a = (FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), s))FIO_MAP_INIT;         \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#if SIZE_T_MAX == 0xFFFFFFFF /* for 32bit system pointer alignment */
#define FIO_REF_METADATA uint32_t
#endif
#define FIO_MAP_KEY               FIOBJ
#define FIO_MAP_KEY_CMP(a, b)     FIO_NAME_BL(fiobj, eq)((a), (b))
#define FIO_MAP_KEY_COPY(dest, o) (dest = fiobj_dup(o))
#define FIO_MAP_KEY_DESTROY(o)    fiobj_free(o)
#define FIO_MAP_VALUE             FIOBJ
#define FIO_MAP_VALUE_DESTROY(o)  fiobj_free(o)
#define FIO_MAP_VALUE_DISCARD(o)  fiobj_free(o)
#define FIO_PTR_TAG(p)            FIOBJ_PTR_TAG(p, FIOBJ_T_HASH)
#define FIO_PTR_UNTAG(p)          FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_TYPE          FIOBJ
#include FIO_INCLUDE_FILE
/** Calculates an object's hash value for a specific hash map object. */
FIO_IFUNC uint64_t FIO_NAME2(fiobj, hash)(FIOBJ target_hash, FIOBJ object_key);

/** Inserts a value to a hash map, with a default hash value calculation. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         set2)(FIOBJ hash, FIOBJ key, FIOBJ value);

/**
 * Inserts a value to a hash map, with a default hash value calculation.
 *
 * If the key already exists in the Hash Map, the value will be freed instead.
 */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         set_if_missing2)(FIOBJ hash, FIOBJ key, FIOBJ value);

/** Finds a value in a hash map, with a default hash value calculation. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get2)(FIOBJ hash,
                                                                   FIOBJ key);

/** Removes a value from a hash map, with a default hash value calculation. */
FIO_IFUNC int FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                       remove2)(FIOBJ hash, FIOBJ key, FIOBJ *old);

/**
 * Sets a value in a hash map, allocating the key String and automatically
 * calculating the hash value.
 */
FIO_IFUNC
FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
               set3)(FIOBJ hash, const char *key, size_t len, FIOBJ value);

/**
 * Finds a value in the hash map, using a temporary String and automatically
 * calculating the hash value.
 */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         get3)(FIOBJ hash, const char *buf, size_t len);

/**
 * Removes a value in a hash map, using a temporary String and automatically
 * calculating the hash value.
 */
FIO_IFUNC int FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                       remove3)(FIOBJ hash,
                                const char *buf,
                                size_t len,
                                FIOBJ *old);

/* *****************************************************************************
FIOBJ JSON support
***************************************************************************** */

/**
 * Returns a JSON valid FIOBJ String, representing the object.
 *
 * If `dest` is an existing String, the formatted JSON data will be appended to
 * the existing string.
 */
FIO_IFUNC FIOBJ FIO_NAME2(fiobj, json)(FIOBJ dest, FIOBJ o, uint8_t beautify);

/**
 * Updates a Hash using JSON data.
 *
 * Parsing errors and non-dictionary object JSON data are silently ignored,
 * attempting to update the Hash as much as possible before any errors
 * encountered.
 *
 * Conflicting Hash data is overwritten (preferring the new over the old).
 *
 * Returns the number of bytes consumed. On Error, 0 is returned and no data is
 * consumed.
 */
SFUNC size_t FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                      update_json)(FIOBJ hash, fio_str_info_s str);

/** Helper function, calls `fiobj_hash_update_json` with string information */
FIO_IFUNC size_t FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                          update_json2)(FIOBJ hash, char *ptr, size_t len);

/**
 * Parses a C string for JSON data. If `consumed` is not NULL, the `size_t`
 * variable will contain the number of bytes consumed before the parser stopped
 * (due to either error or end of a valid JSON data segment).
 *
 * Returns a FIOBJ object matching the JSON valid C string `str`.
 *
 * If the parsing failed (no complete valid JSON data) `FIOBJ_INVALID` is
 * returned.
 */
SFUNC FIOBJ fiobj_json_parse(fio_str_info_s str, size_t *consumed);

/** Helper macro, calls `fiobj_json_parse` with string information */
#define fiobj_json_parse2(data_, len_, consumed)                               \
  fiobj_json_parse((fio_str_info_s){.buf = data_, .len = len_}, consumed)

/**
 * Uses JavaScript style notation to find data in an object structure.
 *
 * For example, "[0].name" will return the "name" property of the first object
 * in an array object.
 *
 * Returns a temporary reference to the object or FIOBJ_INVALID on an error.
 *
 * Use `fiobj_dup` to collect an actual reference to the returned object.
 */
SFUNC FIOBJ fiobj_json_find(FIOBJ object, fio_str_info_s notation);
/**
 * Uses JavaScript style notation to find data in an object structure.
 *
 * For example, "[0].name" will return the "name" property of the first object
 * in an array object.
 *
 * Returns a temporary reference to the object or FIOBJ_INVALID on an error.
 *
 * Use `fiobj_dup` to collect an actual reference to the returned object.
 */
#define fiobj_json_find2(object, str, length)                                  \
  fiobj_json_find(object, (fio_str_info_s){.buf = str, .len = length})
/* *****************************************************************************







FIOBJ - Implementation - Inline / Macro like fucntions







***************************************************************************** */

/* *****************************************************************************
The FIOBJ Type
***************************************************************************** */

/** Returns an objects type. This isn't limited to known types. */
FIO_IFUNC size_t fiobj_type(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    switch ((uintptr_t)(o)) {
    case FIOBJ_T_NULL: return FIOBJ_T_NULL;
    case FIOBJ_T_TRUE: return FIOBJ_T_TRUE;
    case FIOBJ_T_FALSE: return FIOBJ_T_FALSE;
    };
    return FIOBJ_T_INVALID;
  case FIOBJ_T_NUMBER: return FIOBJ_T_NUMBER;
  case FIOBJ_T_FLOAT: return FIOBJ_T_FLOAT;
  case FIOBJ_T_STRING: return FIOBJ_T_STRING;
  case FIOBJ_T_ARRAY: return FIOBJ_T_ARRAY;
  case FIOBJ_T_HASH: return FIOBJ_T_HASH;
  case FIOBJ_T_OTHER: return (*fiobj_object_metadata(o))->type_id;
  }
  if (!o)
    return FIOBJ_T_NULL;
  return FIOBJ_T_INVALID;
}

/* *****************************************************************************
FIOBJ Memory Management
***************************************************************************** */

/** Increases an object's reference count (or copies) and returns it. */
FIO_IFUNC FIOBJ fiobj_dup(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_FLOAT: /* fall through */ return o;
  case FIOBJ_T_STRING: /* fall through */
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), dup)(o);
    break;
  case FIOBJ_T_ARRAY: /* fall through */
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), dup)(o);
    break;
  case FIOBJ_T_HASH: /* fall through */
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), dup)(o);
    break;
  case FIOBJ_T_OTHER: /* fall through */ fiobj_object_dup(o);
  }
  return o;
}

/** Decreases an object's reference count or frees it. */
FIO_IFUNC void fiobj_free(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_FLOAT: return;
  case FIOBJ_T_STRING:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), free)(o);
    return;
  case FIOBJ_T_ARRAY:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), free)(o);
    return;
  case FIOBJ_T_HASH:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), free)(o);
    return;
  case FIOBJ_T_OTHER: (*fiobj_object_metadata(o))->free2(o); return;
  }
}

/* *****************************************************************************
FIOBJ Data / Info
***************************************************************************** */

/** Internal: compares two nestable objects. */
SFUNC unsigned char fiobj___test_eq_nested(FIOBJ restrict a,
                                           FIOBJ restrict b,
                                           size_t nesting);

/** Compares two objects. */
FIO_IFUNC unsigned char FIO_NAME_BL(fiobj, eq)(FIOBJ a, FIOBJ b) {
  if (a == b)
    return 1;
  if (FIOBJ_TYPE_CLASS(a) != FIOBJ_TYPE_CLASS(b))
    return 0;
  switch (FIOBJ_TYPE_CLASS(a)) {
  case FIOBJ_T_PRIMITIVE:
  case FIOBJ_T_NUMBER: /* fall through */
  case FIOBJ_T_FLOAT: /* fall through */ return a == b;
  case FIOBJ_T_STRING:
    return FIO_NAME_BL(FIO_NAME(fiobj, FIOBJ___NAME_STRING), eq)(a, b);
  case FIOBJ_T_ARRAY: return fiobj___test_eq_nested(a, b, 0);
  case FIOBJ_T_HASH: return fiobj___test_eq_nested(a, b, 0);
  case FIOBJ_T_OTHER:
    if ((*fiobj_object_metadata(a))->count(a) ||
        (*fiobj_object_metadata(b))->count(b)) {
      if ((*fiobj_object_metadata(a))->count(a) !=
          (*fiobj_object_metadata(b))->count(b))
        return 0;
      return fiobj___test_eq_nested(a, b, 0);
    }
    return (*fiobj_object_metadata(a))->type_id ==
               (*fiobj_object_metadata(b))->type_id &&
           (*fiobj_object_metadata(a))->is_eq(a, b);
  }
  return 0;
}

/** Returns a temporary String representation for any FIOBJ object. */
FIO_IFUNC fio_str_info_s FIO_NAME2(fiobj, cstr)(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    switch ((uintptr_t)(o)) {
    case FIOBJ_T_NULL: return (fio_str_info_s){.buf = (char *)"null", .len = 4};
    case FIOBJ_T_TRUE: return (fio_str_info_s){.buf = (char *)"true", .len = 4};
    case FIOBJ_T_FALSE:
      return (fio_str_info_s){.buf = (char *)"false", .len = 5};
    };
    return (fio_str_info_s){.buf = (char *)""};
  case FIOBJ_T_NUMBER:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), cstr)(o);
  case FIOBJ_T_FLOAT:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), cstr)(o);
  case FIOBJ_T_STRING:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), info)(o);
  case FIOBJ_T_ARRAY: /* fall through */
    return (fio_str_info_s){.buf = (char *)"[...]", .len = 5};
  case FIOBJ_T_HASH: {
    return (fio_str_info_s){.buf = (char *)"{...}", .len = 5};
  }
  case FIOBJ_T_OTHER: return (*fiobj_object_metadata(o))->to_s(o);
  }
  /* a non-explicit NULL is an empty string. */
  return (fio_str_info_s){.buf = (char *)""};
}

/** Returns an integer representation for any FIOBJ object. */
FIO_IFUNC intptr_t FIO_NAME2(fiobj, i)(FIOBJ o) {
  fio_str_info_s tmp;
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    switch ((uintptr_t)(o)) {
    case FIOBJ_T_NULL: return 0;
    case FIOBJ_T_TRUE: return 1;
    case FIOBJ_T_FALSE: return 0;
    };
    return -1;
  case FIOBJ_T_NUMBER:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(o);
  case FIOBJ_T_FLOAT:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), i)(o);
  case FIOBJ_T_STRING:
    tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), info)(o);
    if (!tmp.len)
      return 0;
    return fio_atol(&tmp.buf);
  case FIOBJ_T_ARRAY:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
  case FIOBJ_T_HASH:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
  case FIOBJ_T_OTHER: return (*fiobj_object_metadata(o))->to_i(o);
  }
  if (!o)
    return 0;
  return -1;
}

/** Returns a float (double) representation for any FIOBJ object. */
FIO_IFUNC double FIO_NAME2(fiobj, f)(FIOBJ o) {
  fio_str_info_s tmp;
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    switch ((uintptr_t)(o)) {
    case FIOBJ_T_FALSE: /* fall through */
    case FIOBJ_T_NULL: return 0.0;
    case FIOBJ_T_TRUE: return 1.0;
    };
    return -1.0;
  case FIOBJ_T_NUMBER:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), f)(o);
  case FIOBJ_T_FLOAT:
    return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(o);
  case FIOBJ_T_STRING:
    tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), info)(o);
    if (!tmp.len)
      return 0;
    return (double)fio_atof(&tmp.buf);
  case FIOBJ_T_ARRAY:
    return (double)FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
  case FIOBJ_T_HASH:
    return (double)FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
  case FIOBJ_T_OTHER: return (*fiobj_object_metadata(o))->to_f(o);
  }
  if (!o)
    return 0.0;
  return -1.0;
}

/* *****************************************************************************
FIOBJ Integers
***************************************************************************** */

#define FIO_REF_NAME     fiobj___bignum
#define FIO_REF_TYPE     intptr_t
#define FIO_REF_METADATA const FIOBJ_class_vtable_s *
#define FIO_REF_METADATA_INIT(m)                                               \
  do {                                                                         \
    m = &FIOBJ___NUMBER_CLASS_VTBL;                                            \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#define FIO_REF_METADATA_DESTROY(m)                                            \
  do {                                                                         \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_PTR_TAG(p)   FIOBJ_PTR_TAG(p, FIOBJ_T_OTHER)
#define FIO_PTR_UNTAG(p) FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_TYPE FIOBJ
#include FIO_INCLUDE_FILE

/* Places a 61 or 29 bit signed integer in the leftmost bits of a word. */
#define FIO_NUMBER_ENCODE(i) (((uintptr_t)(i) << 3) | FIOBJ_T_NUMBER)
/* Reads a 61 or 29 bit signed integer from the leftmost bits of a word. */
#define FIO_NUMBER_DECODE(i)                                                   \
  ((intptr_t)(((uintptr_t)(i) >> 3) |                                          \
              ((((uintptr_t)(i) >> ((sizeof(uintptr_t) * 8) - 1)) *            \
                ((uintptr_t)3 << ((sizeof(uintptr_t) * 8) - 3))))))

/** Creates a new Number object. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER),
                         new)(intptr_t i) {
  FIOBJ o = (FIOBJ)FIO_NUMBER_ENCODE(i);
  if (FIO_NUMBER_DECODE(o) == i)
    return o;
  o = fiobj___bignum_new2();

  FIO_PTR_MATH_RMASK(intptr_t, o, 3)[0] = i;
  return o;
}

/** Reads the number from a FIOBJ number. */
FIO_IFUNC intptr_t FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(FIOBJ i) {
  if (FIOBJ_TYPE_CLASS(i) == FIOBJ_T_NUMBER)
    return FIO_NUMBER_DECODE(i);
  return FIO_PTR_MATH_RMASK(intptr_t, i, 3)[0];
}

/** Reads the number from a FIOBJ number, fitting it in a double. */
FIO_IFUNC double FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), f)(FIOBJ i) {
  return (double)FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(i);
}

/** Frees a FIOBJ number. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), free)(FIOBJ i) {
  if (FIOBJ_TYPE_CLASS(i) == FIOBJ_T_NUMBER)
    return;
  fiobj___bignum_free2(i);
  return;
}

FIO_IFUNC unsigned char FIO_NAME_BL(fiobj___num, eq)(FIOBJ restrict a,
                                                     FIOBJ restrict b) {
  /* it should be safe to assume that FIOBJ_TYPE_CLASS(i) != FIOBJ_T_NUMBER */
  return FIO_PTR_MATH_RMASK(intptr_t, a, 3)[0] ==
         FIO_PTR_MATH_RMASK(intptr_t, b, 3)[0];
  // return FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(a) ==
  //        FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(b);
}

#undef FIO_NUMBER_ENCODE
#undef FIO_NUMBER_DECODE

/* *****************************************************************************
FIOBJ Floats
***************************************************************************** */

#define FIO_REF_NAME     fiobj___bigfloat
#define FIO_REF_TYPE     double
#define FIO_REF_METADATA const FIOBJ_class_vtable_s *
#define FIO_REF_METADATA_INIT(m)                                               \
  do {                                                                         \
    m = &FIOBJ___FLOAT_CLASS_VTBL;                                             \
    FIOBJ_MARK_MEMORY_ALLOC();                                                 \
  } while (0)
#define FIO_REF_METADATA_DESTROY(m)                                            \
  do {                                                                         \
    FIOBJ_MARK_MEMORY_FREE();                                                  \
  } while (0)
#define FIO_PTR_TAG(p)   FIOBJ_PTR_TAG(p, FIOBJ_T_OTHER)
#define FIO_PTR_UNTAG(p) FIOBJ_PTR_UNTAG(p)
#define FIO_PTR_TAG_TYPE FIOBJ
#include FIO_INCLUDE_FILE

/** Creates a new Float object. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), new)(double i) {
  FIOBJ ui;
  if (sizeof(double) <= sizeof(FIOBJ)) {
    union {
      double d;
      uintptr_t i;
    } punned;
    punned.i = 0; /* dead code, but leave it, just in case */
    punned.d = i;
    if ((punned.i & 7) == 0) {
      return (FIOBJ)(punned.i | FIOBJ_T_FLOAT);
    }
  }
  ui = fiobj___bigfloat_new2();

  FIO_PTR_MATH_RMASK(double, ui, 3)[0] = i;
  return ui;
}

/** Reads the integer part from a FIOBJ Float. */
FIO_IFUNC intptr_t FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), i)(FIOBJ i) {
  return (intptr_t)floor(FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(i));
}

/** Reads the number from a FIOBJ number, fitting it in a double. */
FIO_IFUNC double FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(FIOBJ i) {
  if (sizeof(double) <= sizeof(FIOBJ) && FIOBJ_TYPE_CLASS(i) == FIOBJ_T_FLOAT) {
    union {
      double d;
      uint64_t i;
    } punned;
    punned.d = 0; /* dead code, but leave it, just in case */
    punned.i = (uint64_t)(uintptr_t)i;
    punned.i = ((uint64_t)(uintptr_t)i & (~(uintptr_t)7ULL));
    return punned.d;
  }
  return FIO_PTR_MATH_RMASK(double, i, 3)[0];
}

/** Frees a FIOBJ number. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), free)(FIOBJ i) {
  if (FIOBJ_TYPE_CLASS(i) == FIOBJ_T_FLOAT)
    return;
  fiobj___bigfloat_free2(i);
  return;
}

/* *****************************************************************************
FIOBJ Basic Iteration
***************************************************************************** */

/**
 * Performs a task for each element held by the FIOBJ object.
 *
 * If `task` returns -1, the `each` loop will break (stop).
 *
 * Returns the "stop" position - the number of elements processed + `start_at`.
 */
FIO_SFUNC uint32_t fiobj_each1(FIOBJ o,
                               int (*task)(fiobj_each_s *e),
                               void *udata,
                               int32_t start_at) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_STRING:    /* fall through */
  case FIOBJ_T_FLOAT: return 0;
  case FIOBJ_T_ARRAY:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), each)(
        o,
        (int (*)(FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), each_s *)))task,
        udata,
        start_at);
  case FIOBJ_T_HASH:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), each)(
        o,
        (int (*)(FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), each_s *)))task,
        udata,
        start_at);
  case FIOBJ_T_OTHER:
    return (*fiobj_object_metadata(o))->each1(o, task, udata, start_at);
  }
  return 0;
}

/* *****************************************************************************
FIOBJ Hash Maps
***************************************************************************** */

/** Calculates an object's hash value for a specific hash map object. */
FIO_IFUNC uint64_t FIO_NAME2(fiobj, hash)(FIOBJ target_hash, FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE:
    return fio_risky_hash(&o,
                          sizeof(o),
                          (uint64_t)(uintptr_t)target_hash + (uintptr_t)o);
  case FIOBJ_T_NUMBER: {
    uintptr_t tmp = FIO_NAME2(fiobj, i)(o);
    return fio_risky_hash(&tmp, sizeof(tmp), (uint64_t)(uintptr_t)target_hash);
  }
  case FIOBJ_T_FLOAT: {
    double tmp = FIO_NAME2(fiobj, f)(o);
    return fio_risky_hash(&tmp, sizeof(tmp), (uint64_t)(uintptr_t)target_hash);
  }
  case FIOBJ_T_STRING: /* fall through */
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                    hash)(o, (uint64_t)(uintptr_t)target_hash);
  case FIOBJ_T_ARRAY: {
    uint64_t h = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
    h += fio_risky_hash(&h,
                        sizeof(h),
                        (uint64_t)(uintptr_t)target_hash + FIOBJ_T_ARRAY);
    {
      FIOBJ *a = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), ptr)(o);
      const size_t count =
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
      if (a) {
        for (size_t i = 0; i < count; ++i) {
          h += FIO_NAME2(fiobj, hash)(target_hash + FIOBJ_T_ARRAY + i, a[i]);
        }
      }
    }
    return h;
  }
  case FIOBJ_T_HASH: {
    uint64_t h = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
    size_t c = 0;
    h += fio_risky_hash(&h,
                        sizeof(h),
                        (uint64_t)(uintptr_t)target_hash + FIOBJ_T_HASH);
    FIO_MAP_EACH(FIO_NAME(fiobj, FIOBJ___NAME_HASH), o, i) {
      h += i.hash;
      h += FIO_NAME2(fiobj, hash)(target_hash + FIOBJ_T_HASH + (c++), i.value);
    }
    return h;
  }
  case FIOBJ_T_OTHER: {
    /* TODO: can we avoid "stringifying" the object? */
    fio_str_info_s tmp = (*fiobj_object_metadata(o))->to_s(o);
    return fio_risky_hash(tmp.buf, tmp.len, (uint64_t)(uintptr_t)target_hash);
  }
  }
  return 0;
}

/** Inserts a value to a hash map, with a default hash value calculation. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         set2)(FIOBJ hash, FIOBJ key, FIOBJ value) {
  return FIO_NAME(
      FIO_NAME(fiobj, FIOBJ___NAME_HASH),
      set)(hash, FIO_NAME2(fiobj, hash)(hash, key), key, value, NULL);
}

/**
 * Inserts a value to a hash map, with a default hash value calculation.
 *
 * If the key already exists in the Hash Map, the value will be freed instead.
 */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         set_if_missing2)(FIOBJ hash, FIOBJ key, FIOBJ value) {
  return FIO_NAME(
      FIO_NAME(fiobj, FIOBJ___NAME_HASH),
      set_if_missing)(hash, FIO_NAME2(fiobj, hash)(hash, key), key, value);
}

/** Finds a value in a hash map, automatically calculating the hash value. */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get2)(FIOBJ hash,
                                                                   FIOBJ key) {
  if (FIOBJ_TYPE_CLASS(hash) != FIOBJ_T_HASH)
    return FIOBJ_INVALID;
  return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                  get)(hash, FIO_NAME2(fiobj, hash)(hash, key), key);
}

/** Removes a value from a hash map, with a default hash value calculation. */
FIO_IFUNC int FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                       remove2)(FIOBJ hash, FIOBJ key, FIOBJ *old) {
  return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                  remove)(hash, FIO_NAME2(fiobj, hash)(hash, key), key, old);
}

/**
 * Sets a String value in a hash map, allocating the String and automatically
 * calculating the hash value.
 */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         set3)(FIOBJ hash,
                               const char *key,
                               size_t len,
                               FIOBJ value) {
  FIOBJ tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(tmp, (char *)key, len);
  FIOBJ v = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                     set)(hash,
                          fio_risky_hash(key, len, (uint64_t)(uintptr_t)hash),
                          tmp,
                          value,
                          NULL);
  fiobj_free(tmp);
  return v;
}

/**
 * Finds a String value in a hash map, using a temporary String and
 * automatically calculating the hash value.
 */
FIO_IFUNC FIOBJ FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                         get3)(FIOBJ hash, const char *buf, size_t len) {
  if (FIOBJ_TYPE_CLASS(hash) != FIOBJ_T_HASH)
    return FIOBJ_INVALID;
  FIOBJ_STR_TEMP_VAR_STATIC(tmp, buf, len);
  FIOBJ v = FIO_NAME(
      FIO_NAME(fiobj, FIOBJ___NAME_HASH),
      get)(hash, fio_risky_hash(buf, len, (uint64_t)(uintptr_t)hash), tmp);
  return v;
}

/**
 * Removes a String value in a hash map, using a temporary String and
 * automatically calculating the hash value.
 */
FIO_IFUNC int FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                       remove3)(FIOBJ hash,
                                const char *buf,
                                size_t len,
                                FIOBJ *old) {
  FIOBJ_STR_TEMP_VAR_STATIC(tmp, buf, len);
  int r = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                   remove)(hash,
                           fio_risky_hash(buf, len, (uint64_t)(uintptr_t)hash),
                           tmp,
                           old);
  FIOBJ_STR_TEMP_DESTROY(tmp);
  return r;
}

/** Updates a hash using information from another Hash. */
FIO_IFUNC void FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), update)(FIOBJ dest,
                                                                    FIOBJ src) {
  if (FIOBJ_TYPE_CLASS(dest) != FIOBJ_T_HASH ||
      FIOBJ_TYPE_CLASS(src) != FIOBJ_T_HASH)
    return;
  FIO_MAP_EACH(FIO_NAME(fiobj, FIOBJ___NAME_HASH), src, i) {
    if (i.key == FIOBJ_INVALID || FIOBJ_TYPE_CLASS(i.key) == FIOBJ_T_NULL) {
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), remove2)
      (dest, i.key, NULL);
      continue;
    }
    register FIOBJ tmp;
    switch (FIOBJ_TYPE_CLASS(i.value)) {
    case FIOBJ_T_ARRAY:
      /* TODO? decide if we should merge elements or overwrite...? */
      tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get2)(dest, i.key);
      if (FIOBJ_TYPE_CLASS(tmp) == FIOBJ_T_ARRAY) {
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), concat)
        (tmp, i.value);
        continue;
      }
      break;
    case FIOBJ_T_HASH:
      tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get2)(dest, i.key);
      if (FIOBJ_TYPE_CLASS(tmp) == FIOBJ_T_HASH)
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), update)
      (dest, i.value);
      else break;
      continue;
    case FIOBJ_T_NUMBER:    /* fall through */
    case FIOBJ_T_PRIMITIVE: /* fall through */
    case FIOBJ_T_STRING:    /* fall through */
    case FIOBJ_T_FLOAT:     /* fall through */
    case FIOBJ_T_OTHER: break;
    }
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), set2)
    (dest, i.key, fiobj_dup(i.value));
  }
}

/* *****************************************************************************
FIOBJ JSON support (inline functions)
***************************************************************************** */

typedef struct {
  FIOBJ json;
  size_t level;
  uint8_t beautify;
} fiobj___json_format_internal__s;

/* internal helper function for recursive JSON formatting. */
SFUNC void fiobj___json_format_internal__(fiobj___json_format_internal__s *,
                                          FIOBJ);

/** Helper function, calls `fiobj_hash_update_json` with string information */
FIO_IFUNC size_t FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                          update_json2)(FIOBJ hash, char *ptr, size_t len) {
  return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                  update_json)(hash, (fio_str_info_s){.buf = ptr, .len = len});
}

/**
 * Returns a JSON valid FIOBJ String, representing the object.
 *
 * If `dest` is an existing String, the formatted JSON data will be appended to
 * the existing string.
 */
FIO_IFUNC FIOBJ FIO_NAME2(fiobj, json)(FIOBJ dest, FIOBJ o, uint8_t beautify) {
  fiobj___json_format_internal__s args =
      (fiobj___json_format_internal__s){.json = dest, .beautify = beautify};
  if (FIOBJ_TYPE_CLASS(dest) != FIOBJ_T_STRING)
    args.json = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  fiobj___json_format_internal__(&args, o);
  return args.json;
}

#undef FIO_STL_KEEP__ /* from now on, type helpers are internal */
/* *****************************************************************************


FIOBJ - Externed Implementation


***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/* *****************************************************************************
FIOBJ Basic Object vtable
***************************************************************************** */

FIOBJ_EXTERN_OBJ_IMP const FIOBJ_class_vtable_s FIOBJ___OBJECT_CLASS_VTBL = {
    .type_id = 99, /* type IDs below 100 are reserved. */
};

/* *****************************************************************************
FIOBJ Complex Iteration
***************************************************************************** */
typedef struct {
  FIOBJ obj;
  size_t pos;
} fiobj____stack_element_s;

#define FIO_ARRAY_NAME fiobj____active_stack
#define FIO_ARRAY_TYPE fiobj____stack_element_s
#define FIO_ARRAY_COPY(dest, src)                                              \
  do {                                                                         \
    (dest).obj = fiobj_dup((src).obj);                                         \
    (dest).pos = (src).pos;                                                    \
  } while (0)
#define FIO_ARRAY_TYPE_CMP(a, b) (a).obj == (b).obj
#define FIO_ARRAY_DESTROY(o)     fiobj_free(o)
#define FIO_STL_KEEP__           1
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__
#define FIO_ARRAY_TYPE_CMP(a, b) (a).obj == (b).obj
#define FIO_ARRAY_NAME           fiobj____stack
#define FIO_ARRAY_TYPE           fiobj____stack_element_s
#define FIO_STL_KEEP__
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

typedef struct {
  int (*task)(fiobj_each_s *info);
  void *arg;
  FIOBJ next;
  size_t count;
  fiobj____stack_s stack;
  uint32_t end;
  uint8_t stop;
} fiobj_____each2_data_s;

FIO_SFUNC uint32_t fiobj____each2_element_count(FIOBJ o) {
  switch (FIOBJ_TYPE_CLASS(o)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_STRING:    /* fall through */
  case FIOBJ_T_FLOAT: return 0;
  case FIOBJ_T_ARRAY:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
  case FIOBJ_T_HASH:
    return FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
  case FIOBJ_T_OTHER: /* fall through */
    return (*fiobj_object_metadata(o))->count(o);
  }
  return 0;
}
FIO_SFUNC int fiobj____each2_wrapper_task(fiobj_each_s *e) {
  fiobj_____each2_data_s *d = (fiobj_____each2_data_s *)e->udata;
  e->task = d->task;
  e->udata = d->arg;
  d->stop = (d->task(e) == -1);
  d->task = e->task;
  d->arg = e->udata;
  e->task = fiobj____each2_wrapper_task;
  e->udata = d;
  ++d->count;
  if (d->stop)
    return -1;
  uint32_t c = fiobj____each2_element_count(e->value);
  if (c) {
    d->next = e->value;
    d->end = c;
    return -1;
  }
  return 0;
}

/**
 * Performs a task for the object itself and each element held by the FIOBJ
 * object or any of it's elements (a deep task).
 *
 * The order of performance is by order of appearance, as if all nesting levels
 * were flattened.
 *
 * If `task` returns -1, the `each` loop will break (stop).
 *
 * Returns the number of elements processed.
 */
SFUNC uint32_t fiobj_each2(FIOBJ o, int (*task)(fiobj_each_s *), void *udata) {
  /* TODO - move to recursion with nesting limiter? */
  fiobj_____each2_data_s d = {
      .task = task,
      .arg = udata,
      .next = FIOBJ_INVALID,
      .stack = FIO_ARRAY_INIT,
  };
  struct FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), each_s) e_tmp = {

      .parent = FIOBJ_INVALID,
      .task = (int (*)(FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                                each_s) *))fiobj____each2_wrapper_task,
      .udata = &d,
      .value = o,
  };
  fiobj____stack_element_s i = {.obj = o, .pos = 0};
  uint32_t end = fiobj____each2_element_count(o);
  fiobj____each2_wrapper_task((fiobj_each_s *)&e_tmp);
  while (!d.stop && i.obj && i.pos < end) {
    i.pos = fiobj_each1(i.obj, fiobj____each2_wrapper_task, &d, i.pos);
    if (d.next != FIOBJ_INVALID) {
      if (fiobj____stack_count(&d.stack) + 1 > FIOBJ_MAX_NESTING) {
        FIO_LOG_ERROR("FIOBJ nesting level too deep (%u)."
                      "`fiobj_each2` stopping loop early.",
                      (unsigned int)fiobj____stack_count(&d.stack));
        d.stop = 1;
        continue;
      }
      fiobj____stack_push(&d.stack, i);
      i.pos = 0;
      i.obj = d.next;
      d.next = FIOBJ_INVALID;
      end = d.end;
    } else {
      /* re-collect end position to acommodate for changes */
      end = fiobj____each2_element_count(i.obj);
    }
    while (i.pos >= end && fiobj____stack_count(&d.stack)) {
      fiobj____stack_pop(&d.stack, &i);
      end = fiobj____each2_element_count(i.obj);
    }
  };
  fiobj____stack_destroy(&d.stack);
  return d.count;
}

/* *****************************************************************************
FIOBJ Hash / Array / Other (enumerable) Equality test.
***************************************************************************** */

/** Internal: compares two nestable objects. */
SFUNC unsigned char fiobj___test_eq_nested(FIOBJ restrict a,
                                           FIOBJ restrict b,
                                           size_t nesting) {
  if (a == b)
    return 1;
  if (FIOBJ_TYPE_CLASS(a) != FIOBJ_TYPE_CLASS(b))
    return 0;
  if (fiobj____each2_element_count(a) != fiobj____each2_element_count(b))
    return 0;
  if (nesting >= FIOBJ_MAX_NESTING)
    return 0;

  ++nesting;

  switch (FIOBJ_TYPE_CLASS(a)) {
  case FIOBJ_T_PRIMITIVE: /* fall through */
  case FIOBJ_T_NUMBER:    /* fall through */
  case FIOBJ_T_FLOAT: return a == b;
  case FIOBJ_T_STRING:
    return FIO_NAME_BL(FIO_NAME(fiobj, FIOBJ___NAME_STRING), eq)(a, b);

  case FIOBJ_T_ARRAY:
    if (!fiobj____each2_element_count(a))
      return 1;
    /* test each array member with matching index */
    {
      const size_t count = fiobj____each2_element_count(a);
      for (size_t i = 0; i < count; ++i) {
        if (!fiobj___test_eq_nested(
                FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(a, i),
                FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(b, i),
                nesting))
          return 0;
      }
    }
    return 1;

  case FIOBJ_T_HASH:
    if (!fiobj____each2_element_count(a))
      return 1;
    FIO_MAP_EACH(FIO_NAME(fiobj, FIOBJ___NAME_HASH), a, pos) {
      FIOBJ val = fiobj_hash_get2(b, pos.key);
      if (!fiobj___test_eq_nested(val, pos.value, nesting))
        return 0;
    }
    return 1;
  case FIOBJ_T_OTHER:
    if (!fiobj____each2_element_count(a) &&
        (*fiobj_object_metadata(a))->is_eq(a, b))
      return 1;
    /* TODO: iterate through objects and test equality within nesting */
    return (*fiobj_object_metadata(a))->is_eq(a, b);
    return 1;
  }
  return 0;
}

/* *****************************************************************************
FIOBJ general helpers
***************************************************************************** */

FIO_SFUNC uint32_t fiobj___count_noop(FIOBJ o) {
  return 0;
  (void)o;
}

/* *****************************************************************************
FIOBJ Integers (bigger numbers)
***************************************************************************** */

SFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER),
                               cstr)(FIOBJ i) {
  static char buf[32 * 128];
  static uint8_t pos = 0;
  size_t at = fio_atomic_add(&pos, 1);
  fio_str_info_s s = {.buf = buf + ((at & 127) << 5), .capa = 31};
  fio_string_write_i(&s,
                     NULL,
                     FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(i));
  return s;
}

FIOBJ_EXTERN_OBJ_IMP const FIOBJ_class_vtable_s FIOBJ___NUMBER_CLASS_VTBL = {
    /**
     * MUST return a unique number to identify object type.
     *
     * Numbers (IDs) under 100 are reserved.
     */
    .type_id = FIOBJ_T_NUMBER,
    /** Test for equality between two objects with the same `type_id` */
    .is_eq = FIO_NAME_BL(fiobj___num, eq),
    /** Converts an object to a String */
    .to_s = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), cstr),
    /** Converts and object to an integer */
    .to_i = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i),
    /** Converts and object to a float */
    .to_f = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), f),
    /** Returns the number of exposed elements held by the object, if any. */
    .count = fiobj___count_noop,
    /** Iterates the exposed elements held by the object. See `fiobj_each1`. */
    .each1 = NULL,
    /** Deallocates the element (but NOT any of it's exposed elements). */
    .free2 = fiobj___bignum_free2,
};

/* *****************************************************************************
FIOBJ Floats (bigger / smaller doubles)
***************************************************************************** */

FIO_SFUNC unsigned char FIO_NAME_BL(fiobj___float, eq)(FIOBJ restrict a,
                                                       FIOBJ restrict b) {
  unsigned char r = 0;
  union {
    uint64_t u;
    double f;
  } da, db;
  da.f = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(a);
  db.f = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(b);
  /* regular equality? */
  r |= da.f == db.f;
  /* test for small rounding errors (4 bit difference) on normalize floats */
  r |= !((da.u ^ db.u) & UINT64_C(0xFFFFFFFFFFFFFFF0)) &&
       (da.u & UINT64_C(0x7FF0000000000000));
  /* test for small ULP: */
  r |= (((da.u > db.u) ? da.u - db.u : db.u - da.u) < 2);
  /* test for +-0 */
  r |= !((da.u | db.u) & UINT64_C(0x7FFFFFFFFFFFFFFF));
  return r;
}

SFUNC fio_str_info_s FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT),
                               cstr)(FIOBJ i) {
  static char buf[32 * 128];
  static uint8_t pos = 0;
  size_t at = fio_atomic_add(&pos, 1);
  char *tmp = buf + ((at & 127) << 5);
  size_t len =
      fio_ftoa(tmp, FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(i), 10);
  tmp[len] = 0;
  return (fio_str_info_s){.buf = tmp, .len = len};
}

FIOBJ_EXTERN_OBJ_IMP const FIOBJ_class_vtable_s FIOBJ___FLOAT_CLASS_VTBL = {
    /**
     * MUST return a unique number to identify object type.
     *
     * Numbers (IDs) under 100 are reserved.
     */
    .type_id = FIOBJ_T_FLOAT,
    /** Test for equality between two objects with the same `type_id` */
    .is_eq = FIO_NAME_BL(fiobj___float, eq),
    /** Converts an object to a String */
    .to_s = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), cstr),
    /** Converts and object to an integer */
    .to_i = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), i),
    /** Converts and object to a float */
    .to_f = FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f),
    /** Returns the number of exposed elements held by the object, if any. */
    .count = fiobj___count_noop,
    /** Iterates the exposed elements held by the object. See `fiobj_each1`. */
    .each1 = NULL,
    /** Deallocates the element (but NOT any of it's exposed elements). */
    .free2 = fiobj___bigfloat_free2,
};

/* *****************************************************************************
FIOBJ JSON support - output
***************************************************************************** */

FIO_IFUNC void fiobj___json_format_internal_beauty_pad(FIOBJ json,
                                                       size_t level) {
  size_t pos = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(json);
  fio_str_info_s tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                                resize)(json, (level << 1) + pos + 2);
  tmp.buf[pos++] = '\r';
  tmp.buf[pos++] = '\n';
  for (size_t i = 0; i < level; ++i) {
    tmp.buf[pos++] = ' ';
    tmp.buf[pos++] = ' ';
  }
}

SFUNC void fiobj___json_format_internal__(fiobj___json_format_internal__s *args,
                                          FIOBJ o) {
  switch (FIOBJ_TYPE(o)) {
  case FIOBJ_T_TRUE:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
    (args->json, "true", 4);
    return;
  case FIOBJ_T_FALSE:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
    (args->json, "false", 5);
    return;
  case FIOBJ_T_NULL:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
    (args->json, "null", 4);
    return;
  case FIOBJ_T_NUMBER:
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_i)
    (args->json, FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), i)(o));
    return;
  case FIOBJ_T_FLOAT: {
    char tmp_buf[256];
    size_t len = fio_ftoa(tmp_buf,
                          FIO_NAME2(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), f)(o),
                          10);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
    (args->json, tmp_buf, len);
    return;
  }
  case FIOBJ_T_STRING: /* fall through */
  default: {
    fio_str_info_s info = FIO_NAME2(fiobj, cstr)(o);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(args->json, "\"", 1);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_escape)
    (args->json, info.buf, info.len);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(args->json, "\"", 1);
    return;
  }
  case FIOBJ_T_ARRAY:
    if (!FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o))
      goto empty_array;
    if (args->level == FIOBJ_MAX_NESTING)
      goto err_array_nesting;
    {
      ++args->level;
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(args->json, "[", 1);
      const uint32_t len =
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o);
      if (args->beautify) {
        fiobj___json_format_internal_beauty_pad(args->json, args->level);
      }
      fiobj___json_format_internal__(
          args,
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(o, 0));
      if (args->beautify) {
        for (size_t i = 1; i < len; ++i) {
          FIOBJ child =
              FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(o, i);
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
          (args->json, ",", 1);
          fiobj___json_format_internal_beauty_pad(args->json, args->level);
          fiobj___json_format_internal__(args, child);
        }
      } else {
        for (size_t i = 1; i < len; ++i) {
          FIOBJ child =
              FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(o, i);
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
          (args->json, ",", 1);
          fiobj___json_format_internal__(args, child);
        }
      }
      --args->level;
      if (args->beautify) {
        fiobj___json_format_internal_beauty_pad(args->json, args->level);
      }
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(args->json, "]", 1);
    }
    return;
  case FIOBJ_T_HASH:
    if (!FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o))
      goto empty_hash;
    if (args->level == FIOBJ_MAX_NESTING)
      goto err_hash_nesting;
    {
      size_t i = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), count)(o);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
      (args->json, "{", 1);
      ++args->level;
      FIO_MAP_EACH(FIO_NAME(fiobj, FIOBJ___NAME_HASH), o, couplet) {
        if (args->beautify) {
          fiobj___json_format_internal_beauty_pad(args->json, args->level);
        }
        fio_str_info_s info = FIO_NAME2(fiobj, cstr)(couplet.key);
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
        (args->json, "\"", 1);
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_escape)
        (args->json, info.buf, info.len);
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
        (args->json, "\":", 2);
        fiobj___json_format_internal__(args, couplet.value);
        if (--i)
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
        (args->json, ",", 1);
      }
      --args->level;
      if (args->beautify) {
        fiobj___json_format_internal_beauty_pad(args->json, args->level);
      }
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
      (args->json, "}", 1);
    }
    return;
  }
empty_hash:
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
  (args->json, "{}", 2);
  return;
empty_array:
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
  (args->json, "[]", 2);
  return;
err_array_nesting:
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
  (args->json, "[ ]", 3);
  goto log_nesting_error;
err_hash_nesting:
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)
  (args->json, "{ }", 3);
log_nesting_error:
  FIO_LOG_ERROR("JSON formatting truncated - nesting level too deep.");
}

/* *****************************************************************************
FIOBJ JSON parsing
***************************************************************************** */

#define FIO_JSON
#define FIO_STL_KEEP__
#include FIO_INCLUDE_FILE
#undef FIO_STL_KEEP__

/* FIOBJ JSON parser */
typedef struct {
  fio_json_parser_s p;
  FIOBJ key;
  FIOBJ top;
  FIOBJ target;
  FIOBJ stack[JSON_MAX_DEPTH + 1];
  uint8_t so; /* stack offset */
} fiobj_json_parser_s;

static inline void fiobj_json_add2parser(fiobj_json_parser_s *p, FIOBJ o) {
  if (p->top) {
    if (FIOBJ_TYPE_CLASS(p->top) == FIOBJ_T_HASH) {
      if (p->key) {
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), set2)(p->top, p->key, o);
        fiobj_free(p->key);
        p->key = FIOBJ_INVALID;
      } else {
        p->key = o;
      }
    } else {
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(p->top, o);
    }
  } else {
    p->top = o;
  }
}

/** a NULL object was detected */
static inline void fio_json_on_null(fio_json_parser_s *p) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p,
                        FIO_NAME(fiobj, FIOBJ___NAME_NULL)());
}
/** a TRUE object was detected */
static inline void fio_json_on_true(fio_json_parser_s *p) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p,
                        FIO_NAME(fiobj, FIOBJ___NAME_TRUE)());
}
/** a FALSE object was detected */
static inline void fio_json_on_false(fio_json_parser_s *p) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p,
                        FIO_NAME(fiobj, FIOBJ___NAME_FALSE)());
}
/** a Numberl was detected (long long). */
static inline void fio_json_on_number(fio_json_parser_s *p, long long i) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p,
                        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)(i));
}
/** a Float was detected (double). */
static inline void fio_json_on_float(fio_json_parser_s *p, double f) {
  fiobj_json_add2parser((fiobj_json_parser_s *)p,
                        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), new)(f));
}
/** a String was detected (int / float). update `pos` to point at ending */
static inline void fio_json_on_string(fio_json_parser_s *p,
                                      const void *start,
                                      size_t len) {
  FIOBJ str = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_unescape)
  (str, start, len);
  fiobj_json_add2parser((fiobj_json_parser_s *)p, str);
}
/** a dictionary object was detected */
static inline int fio_json_on_start_object(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  if (pr->target) {
    /* push NULL, don't free the objects */
    pr->stack[pr->so++] = FIOBJ_INVALID;
    pr->top = pr->target;
    pr->target = FIOBJ_INVALID;
  } else {
    FIOBJ hash;
#if FIOBJ_JSON_APPEND
    hash = FIOBJ_INVALID;
    if (pr->key && FIOBJ_TYPE_CLASS(pr->top) == FIOBJ_T_HASH) {
      hash =
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get2)(pr->top, pr->key);
    }
    if (FIOBJ_TYPE_CLASS(hash) != FIOBJ_T_HASH) {
      hash = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), new)();
      fiobj_json_add2parser(pr, hash);
    } else {
      fiobj_free(pr->key);
      pr->key = FIOBJ_INVALID;
    }
#else
    hash = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), new)();
    fiobj_json_add2parser(pr, hash);
#endif
    pr->stack[pr->so++] = pr->top;
    pr->top = hash;
  }
  return 0;
}
/** a dictionary object closure detected */
static inline void fio_json_on_end_object(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  if (pr->key) {
    FIO_LOG_WARNING("(JSON parsing) malformed JSON, "
                    "ignoring dangling Hash key.");
    fiobj_free(pr->key);
    pr->key = FIOBJ_INVALID;
  }
  pr->top = FIOBJ_INVALID;
  if (pr->so)
    pr->top = pr->stack[--pr->so];
}
/** an array object was detected */
static int fio_json_on_start_array(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  FIOBJ ary = FIOBJ_INVALID;
  if (pr->target != FIOBJ_INVALID) {
    if (FIOBJ_TYPE_CLASS(pr->target) != FIOBJ_T_ARRAY)
      return -1;
    ary = pr->target;
    pr->target = FIOBJ_INVALID;
  }
#if FIOBJ_JSON_APPEND
  if (pr->key && FIOBJ_TYPE_CLASS(pr->top) == FIOBJ_T_HASH) {
    ary = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get2)(pr->top, pr->key);
  }
  if (FIOBJ_TYPE_CLASS(ary) != FIOBJ_T_ARRAY) {
    ary = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    fiobj_json_add2parser(pr, ary);
  } else {
    fiobj_free(pr->key);
    pr->key = FIOBJ_INVALID;
  }
#else
  FIOBJ ary = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
  fiobj_json_add2parser(pr, ary);
#endif

  pr->stack[pr->so++] = pr->top;
  pr->top = ary;
  return 0;
}
/** an array closure was detected */
static inline void fio_json_on_end_array(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  pr->top = FIOBJ_INVALID;
  if (pr->so)
    pr->top = pr->stack[--pr->so];
}
/** the JSON parsing is complete */
static void fio_json_on_json(fio_json_parser_s *p) {
  (void)p; /* nothing special... right? */
}
/** the JSON parsing is complete */
static inline void fio_json_on_error(fio_json_parser_s *p) {
  fiobj_json_parser_s *pr = (fiobj_json_parser_s *)p;
  fiobj_free(pr->stack[0]);
  fiobj_free(pr->key);
  *pr = (fiobj_json_parser_s){.top = FIOBJ_INVALID};
  FIO_LOG_DEBUG("JSON on_error callback called.");
}

/**
 * Updates a Hash using JSON data.
 *
 * Parsing errors and non-dictionary object JSON data are silently ignored,
 * attempting to update the Hash as much as possible before any errors
 * encountered.
 *
 * Conflicting Hash data is overwritten (preferring the new over the old).
 *
 * Returns the number of bytes consumed. On Error, 0 is returned and no data is
 * consumed.
 */
SFUNC size_t FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH),
                      update_json)(FIOBJ hash, fio_str_info_s str) {
  if (hash == FIOBJ_INVALID)
    return 0;
  fiobj_json_parser_s p = {.top = FIOBJ_INVALID, .target = hash};
  size_t consumed = fio_json_parse(&p.p, str.buf, str.len);
  fiobj_free(p.key);
  if (p.top != hash)
    fiobj_free(p.top);
  return consumed;
}

/** Returns a JSON valid FIOBJ String, representing the object. */
SFUNC FIOBJ fiobj_json_parse(fio_str_info_s str, size_t *consumed_p) {
  fiobj_json_parser_s p = {.top = FIOBJ_INVALID};
  register const size_t consumed = fio_json_parse(&p.p, str.buf, str.len);
  if (consumed_p) {
    *consumed_p = consumed;
  }
  if (!consumed || p.p.depth) {
    if (p.top) {
      FIO_LOG_DEBUG("WARNING - JSON failed secondary validation, no on_error");
    }
#ifdef DEBUG
    FIOBJ s = FIO_NAME2(fiobj, json)(FIOBJ_INVALID, p.top, 0);
    FIO_LOG_DEBUG("JSON data being deleted:\n%s",
                  FIO_NAME2(fiobj, cstr)(s).buf);
    fiobj_free(s);
#endif
    fiobj_free(p.stack[0]);
    p.top = FIOBJ_INVALID;
  }
  fiobj_free(p.key);
  return p.top;
}

/** Uses JSON (JavaScript) notation to find data in an object structure. Returns
 * a temporary object. */
SFUNC FIOBJ fiobj_json_find(FIOBJ o, fio_str_info_s n) {
  for (;;) {
  top:
    if (!n.len)
      return o;
    switch (FIOBJ_TYPE_CLASS(o)) {
    case FIOBJ_T_ARRAY: {
      if (n.len <= 2 || n.buf[0] != '[' || n.buf[1] < '0' || n.buf[1] > '9')
        return FIOBJ_INVALID;
      size_t i = 0;
      ++n.buf;
      --n.len;
      while (n.len && fio_c2i(n.buf[0]) < 10) {
        i = (i * 10) + fio_c2i(n.buf[0]);
        ++n.buf;
        --n.len;
      }
      if (!n.len || n.buf[0] != ']')
        return FIOBJ_INVALID;
      o = fiobj_array_get(o, i);
      ++n.buf;
      --n.len;
      if (n.len) {
        if (n.buf[0] == '.') {
          ++n.buf;
          --n.len;
        } else if (n.buf[0] != '[') {
          return FIOBJ_INVALID;
        }
        continue;
      }
      return o;
    }
    case FIOBJ_T_HASH: {
      FIOBJ tmp = fiobj_hash_get3(o, n.buf, n.len);
      if (tmp != FIOBJ_INVALID)
        return tmp;
      char *end = n.buf + n.len - 1;
      while (end > n.buf) {
        while (end > n.buf && end[0] != '.' && end[0] != '[')
          --end;
        if (end == n.buf)
          return FIOBJ_INVALID;
        const size_t t_len = end - n.buf;
        tmp = fiobj_hash_get3(o, n.buf, t_len);
        if (tmp != FIOBJ_INVALID) {
          o = tmp;
          n.len -= t_len + (end[0] == '.');
          n.buf = end + (end[0] == '.');
          goto top;
        }
        --end;
      }
    } /* fall through */
    default: return FIOBJ_INVALID;
    }
  }
}

/* *****************************************************************************
FIOBJ and JSON testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC int FIO_NAME_TEST(stl, fiobj_task)(fiobj_each_s *e) {
  static size_t index = 0;
  if (!e) {
    index = 0;
    return -1;
  }
  int *expect = (int *)e->udata;
  FIO_ASSERT(e->key == FIOBJ_INVALID, "key is set in an Array loop?");
  if (expect[index] == -1) {
    FIO_ASSERT(FIOBJ_TYPE(e->value) == FIOBJ_T_ARRAY,
               "each2 ordering issue [%zu] (array).",
               index);
  } else {
    FIO_ASSERT(FIO_NAME2(fiobj, i)(e->value) == expect[index],
               "each2 ordering issue [%zu] (number) %ld != %d",
               index,
               FIO_NAME2(fiobj, i)(e->value),
               expect[index]);
  }
  ++index;
  return 0;
}

FIO_SFUNC void FIO_NAME_TEST(stl, fiobj)(void) {
  FIOBJ o = FIOBJ_INVALID;
  if (!FIOBJ_MARK_MEMORY_ENABLED) {
    FIO_LOG_WARNING("FIOBJ defined without allocation counter. "
                    "Tests might not be complete.");
  }
  /* primitives - (in)sanity */
  {
    fprintf(stderr, "* Testing FIOBJ primitives.\n");
    FIO_ASSERT(FIOBJ_TYPE(o) == FIOBJ_T_NULL,
               "invalid FIOBJ type should be FIOBJ_T_NULL.");
    FIO_ASSERT(!FIO_NAME_BL(fiobj, eq)(o, FIO_NAME(fiobj, FIOBJ___NAME_NULL)()),
               "invalid FIOBJ is NOT a fiobj_null().");
    FIO_ASSERT(!FIO_NAME_BL(fiobj, eq)(FIO_NAME(fiobj, FIOBJ___NAME_TRUE)(),
                                       FIO_NAME(fiobj, FIOBJ___NAME_NULL)()),
               "fiobj_true() is NOT fiobj_null().");
    FIO_ASSERT(!FIO_NAME_BL(fiobj, eq)(FIO_NAME(fiobj, FIOBJ___NAME_FALSE)(),
                                       FIO_NAME(fiobj, FIOBJ___NAME_NULL)()),
               "fiobj_false() is NOT fiobj_null().");
    FIO_ASSERT(!FIO_NAME_BL(fiobj, eq)(FIO_NAME(fiobj, FIOBJ___NAME_FALSE)(),
                                       FIO_NAME(fiobj, FIOBJ___NAME_TRUE)()),
               "fiobj_false() is NOT fiobj_true().");
    FIO_ASSERT(FIOBJ_TYPE(FIO_NAME(fiobj, FIOBJ___NAME_NULL)()) == FIOBJ_T_NULL,
               "fiobj_null() type should be FIOBJ_T_NULL.");
    FIO_ASSERT(FIOBJ_TYPE(FIO_NAME(fiobj, FIOBJ___NAME_TRUE)()) == FIOBJ_T_TRUE,
               "fiobj_true() type should be FIOBJ_T_TRUE.");
    FIO_ASSERT(FIOBJ_TYPE(FIO_NAME(fiobj, FIOBJ___NAME_FALSE)()) ==
                   FIOBJ_T_FALSE,
               "fiobj_false() type should be FIOBJ_T_FALSE.");
    FIO_ASSERT(FIO_NAME_BL(fiobj, eq)(FIO_NAME(fiobj, FIOBJ___NAME_NULL)(),
                                      FIO_NAME(fiobj, FIOBJ___NAME_NULL)()),
               "fiobj_null() should be equal to self.");
    FIO_ASSERT(FIO_NAME_BL(fiobj, eq)(FIO_NAME(fiobj, FIOBJ___NAME_TRUE)(),
                                      FIO_NAME(fiobj, FIOBJ___NAME_TRUE)()),
               "fiobj_true() should be equal to self.");
    FIO_ASSERT(FIO_NAME_BL(fiobj, eq)(FIO_NAME(fiobj, FIOBJ___NAME_FALSE)(),
                                      FIO_NAME(fiobj, FIOBJ___NAME_FALSE)()),
               "fiobj_false() should be equal to self.");
  }
  {
    fprintf(stderr, "* Testing FIOBJ integers.\n");
    uint8_t allocation_flags = 0;
    for (uint8_t bit = 0; bit < (sizeof(intptr_t) * 8); ++bit) {
      uintptr_t i = (uintptr_t)1 << bit;
      o = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)((intptr_t)i);
      FIO_ASSERT(FIO_NAME2(fiobj, i)(o) == (intptr_t)i,
                 "Number not reversible at bit %d (%zd != %zd)!",
                 (int)bit,
                 (ssize_t)FIO_NAME2(fiobj, i)(o),
                 (ssize_t)i);
      fio_str_info_s str = FIO_NAME2(fiobj, cstr)(o);
      char *str_buf = str.buf;
      FIO_ASSERT(fio_atol(&str_buf) == (intptr_t)i,
                 "Number atol not reversible at bit %d (%s != %zd)!",
                 (int)bit,
                 str.buf,
                 (ssize_t)i);
      allocation_flags |= (FIOBJ_TYPE_CLASS(o) == FIOBJ_T_NUMBER) ? 1 : 2;
      fiobj_free(o);
    }
    FIO_ASSERT(allocation_flags == 3,
               "no bits are allocated / no allocations optimized away (%d)",
               (int)allocation_flags);
  }
  {
    fprintf(stderr, "* Testing FIOBJ floats.\n");
    uint8_t allocation_flags = 0;
    for (uint8_t bit = 0; bit < (sizeof(double) * 8); ++bit) {
      union {
        double d;
        uint64_t i;
      } punned;
      punned.i = (uint64_t)1 << bit;
      o = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), new)(punned.d);
      FIO_ASSERT(FIO_NAME2(fiobj, f)(o) == punned.d,
                 "Float not reversible at bit %d (%lf != %lf)!",
                 (int)bit,
                 FIO_NAME2(fiobj, f)(o),
                 punned.d);

      fio_str_info_s str = FIO_NAME2(fiobj, cstr)(o);
      char buf_tmp[32];
      FIO_ASSERT(fio_ftoa(buf_tmp, FIO_NAME2(fiobj, f)(o), 10) == str.len,
                 "fio_atof length didn't match Float's fiobj2cstr length.");
      FIO_ASSERT(!memcmp(str.buf, buf_tmp, str.len),
                 "fio_atof string didn't match Float's fiobj2cstr.");
      allocation_flags |= (FIOBJ_TYPE_CLASS(o) == FIOBJ_T_FLOAT) ? 1 : 2;
      fiobj_free(o);
    }
    FIO_ASSERT(allocation_flags == 3,
               "no bits are allocated / no allocations optimized away (%d)",
               (int)allocation_flags);
  }
  {
    fprintf(stderr, "* Testing FIOBJ each2.\n");
    FIOBJ a = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    o = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(o, a);
    for (int i = 1; i < 10; ++i) // 1, 2, 3 ... 10
    {
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)
      (a, FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)(i));
      if (i % 3 == 0) {
        a = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(o, a);
      }
    }
    int expectation[] =
        {-1 /* array */, -1, 1, 2, 3, -1, 4, 5, 6, -1, 7, 8, 9, -1};
    size_t c =
        fiobj_each2(o, FIO_NAME_TEST(stl, fiobj_task), (void *)expectation);
    FIO_ASSERT(c == FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), count)(o) +
                        9 + 1,
               "each2 repetition count error");
    fiobj_free(o);
    FIO_NAME_TEST(stl, fiobj_task)(NULL);
  }
  {
    fprintf(stderr, "* Testing FIOBJ JSON handling.\n");
    char json[] =
        "                    "
        "\n# comment 1"
        "\n// comment 2"
        "\n/* comment 3 */"
        "{\"true\":true,\"false\":false,\"null\":null,\"array\":[1,2,3,4.2,"
        "\"five\"],"
        "\"string\":\"hello\\tjson\\bworld!\\r\\n\",\"hash\":{\"true\":true,"
        "\"false\":false},\"array2\":[1,2,3,4.2,\"five\",{\"hash\":true},[{"
        "\"hash\":{\"true\":true}}]]}";
    o = fiobj_json_parse2(json, strlen(json), NULL);
    FIO_ASSERT(o, "JSON parsing failed - no data returned.");
    FIO_ASSERT(fiobj_json_find2(o, (char *)"array2[6][0].hash.true", 22) ==
                   fiobj_true(),
               "fiobj_json_find2 failed");
    FIOBJ j = FIO_NAME2(fiobj, json)(FIOBJ_INVALID, o, 0);
#ifdef DEBUG
    fprintf(stderr, "JSON: %s\n", FIO_NAME2(fiobj, cstr)(j).buf);
#endif
    FIO_ASSERT(FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(j) ==
                   strlen(json + 61),
               "JSON roundtrip failed (length error).");
    FIO_ASSERT(!memcmp(json + 61,
                       FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(j),
                       strlen(json + 61)),
               "JSON roundtrip failed (data error).");
    fiobj_free(o);
    fiobj_free(j);
    o = FIOBJ_INVALID;
  }
  {
    fprintf(stderr, "* Testing FIOBJ array equality test (fiobj_is_eq).\n");
    FIOBJ a1 = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    FIOBJ a2 = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    FIOBJ n1 = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    FIOBJ n2 = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(a1, fiobj_null());
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(a2, fiobj_null());
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(n1, fiobj_true());
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(n2, fiobj_true());
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(a1, n1);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(a2, n2);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)
    (a1, FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new_cstr)("test", 4));
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)
    (a2, FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new_cstr)("test", 4));
    FIO_ASSERT(FIO_NAME_BL(fiobj, eq)(a1, a2), "equal arrays aren't equal?");
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(n1, fiobj_null());
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(n2, fiobj_false());
    FIO_ASSERT(!FIO_NAME_BL(fiobj, eq)(a1, a2), "unequal arrays are equal?");
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), remove)(n1, -1, NULL);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), remove)(n2, -1, NULL);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), remove)(a1, 0, NULL);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), remove)(a2, -1, NULL);
    FIO_ASSERT(!FIO_NAME_BL(fiobj, eq)(a1, a2), "unequal arrays are equal?");
    fiobj_free(a1);
    fiobj_free(a2);
  }
  {
    fprintf(stderr, "* Testing FIOBJ array ownership.\n");
    FIOBJ a = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    for (int i = 1; i <= FIO_TEST_REPEAT; ++i) {
      FIOBJ tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                           new_cstr)("number: ", 8);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_i)(tmp, i);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(a, tmp);
    }
    FIOBJ shifted = FIOBJ_INVALID;
    FIOBJ popped = FIOBJ_INVALID;
    FIOBJ removed = FIOBJ_INVALID;
    FIOBJ set = FIOBJ_INVALID;
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), shift)(a, &shifted);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), pop)(a, &popped);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), set)
    (a, 1, FIO_NAME(fiobj, FIOBJ___NAME_TRUE)(), &set);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), remove)(a, 2, &removed);
    fiobj_free(a);
    if (1) {
      FIO_ASSERT(
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(popped) ==
                  strlen("number: " FIO_MACRO2STR(FIO_TEST_REPEAT)) &&
              !memcmp(
                  "number: " FIO_MACRO2STR(FIO_TEST_REPEAT),
                  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(popped),
                  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(popped)),
          "Object popped from Array lost it's value %s",
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(popped));
      FIO_ASSERT(FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(shifted) ==
                         9 &&
                     !memcmp("number: 1",
                             FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                                      ptr)(shifted),
                             9),
                 "Object shifted from Array lost it's value %s",
                 FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(shifted));
      FIO_ASSERT(
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(set) == 9 &&
              !memcmp("number: 3",
                      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(set),
                      9),
          "Object retrieved from Array using fiobj_array_set() lost it's "
          "value %s",
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(set));
      FIO_ASSERT(
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(removed) == 9 &&
              !memcmp(
                  "number: 4",
                  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(removed),
                  9),
          "Object retrieved from Array using fiobj_array_set() lost it's "
          "value %s",
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(removed));
    }
    fiobj_free(shifted);
    fiobj_free(popped);
    fiobj_free(set);
    fiobj_free(removed);
  }
  {
    fprintf(stderr, "* Testing FIOBJ array ownership after concat.\n");
    FIOBJ a1, a2;
    a1 = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    a2 = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    for (int i = 0; i < FIO_TEST_REPEAT; ++i) {
      FIOBJ str = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_i)(str, i);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(a1, str);
    }
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), concat)(a2, a1);
    fiobj_free(a1);
    for (int i = 0; i < FIO_TEST_REPEAT; ++i) {
      FIOBJ_STR_TEMP_VAR(tmp);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_i)(tmp, i);
      FIO_ASSERT(
          FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(
              FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(a2, i)) ==
              FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(tmp),
          "string length zeroed out - string freed?");
      FIO_ASSERT(
          !memcmp(
              FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(tmp),
              FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(
                  FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), get)(a2, i)),
              FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(tmp)),
          "string data error - string freed?");
      FIOBJ_STR_TEMP_DESTROY(tmp);
    }
    fiobj_free(a2);
  }
  {
    fprintf(stderr, "* Testing FIOBJ hash ownership.\n");
    o = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), new)();
    for (int i = 1; i <= FIO_TEST_REPEAT; ++i) {
      FIOBJ tmp = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING),
                           new_cstr)("number: ", 8);
      FIOBJ k = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)(i);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_i)(tmp, i);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), set2)(o, k, tmp);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), set_if_missing2)
      (o, k, fiobj_dup(tmp));
      fiobj_free(k);
    }

    FIOBJ set = FIOBJ_INVALID;
    FIOBJ removed = FIOBJ_INVALID;
    FIOBJ k = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)(1);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), remove2)(o, k, &removed);
    fiobj_free(k);
    k = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)(2);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), set)
    (o, fiobj2hash(o, k), k, FIO_NAME(fiobj, FIOBJ___NAME_TRUE)(), &set);
    fiobj_free(k);
    FIO_ASSERT(set, "fiobj_hash_set2 didn't copy information to old pointer?");
    FIO_ASSERT(removed,
               "fiobj_hash_remove2 didn't copy information to old pointer?");
    // fiobj_hash_set(o, uintptr_t hash, FIOBJ key, FIOBJ value, FIOBJ *old)
    FIO_ASSERT(
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(removed) ==
                strlen("number: 1") &&
            !memcmp(
                "number: 1",
                FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(removed),
                FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(removed)),
        "Object removed from Hash lost it's value %s",
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(removed));
    FIO_ASSERT(
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(set) ==
                strlen("number: 2") &&
            !memcmp("number: 2",
                    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(set),
                    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(set)),
        "Object removed from Hash lost it's value %s",
        FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(set));

    fiobj_free(removed);
    fiobj_free(set);
    fiobj_free(o);
  }

#if FIOBJ_MARK_MEMORY
  {
    fprintf(stderr, "* Testing FIOBJ for memory leaks.\n");
    FIOBJ a = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), new)();
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), reserve)(a, 64);
    for (uint8_t bit = 0; bit < (sizeof(intptr_t) * 8); ++bit) {
      uintptr_t i = (uintptr_t)1 << bit;
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)
      (a, FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_NUMBER), new)((intptr_t)i));
    }
    FIOBJ h = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), new)();
    FIOBJ key = FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), new)();
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(key, "array", 5);
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), set2)(h, key, a);
    FIO_ASSERT(FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_HASH), get2)(h, key) == a,
               "FIOBJ Hash retrieval failed");
    FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)(a, key);
    if (0) {
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)
      (a, FIO_NAME(fiobj, FIOBJ___NAME_NULL)());
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)
      (a, FIO_NAME(fiobj, FIOBJ___NAME_TRUE)());
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)
      (a, FIO_NAME(fiobj, FIOBJ___NAME_FALSE)());
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_ARRAY), push)
      (a, FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_FLOAT), new)(0.42));

      FIOBJ json = FIO_NAME2(fiobj, json)(FIOBJ_INVALID, h, 0);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write)(json, "\n", 1);
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), reserve)
      (json,
       FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(json)
           << 1); /* prevent memory realloc */
      FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), write_escape)
      (json,
       FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), ptr)(json),
       FIO_NAME(FIO_NAME(fiobj, FIOBJ___NAME_STRING), len)(json) - 1);
      fprintf(stderr, "%s\n", FIO_NAME2(fiobj, cstr)(json).buf);
      fiobj_free(json);
    }
    fiobj_free(h);
    FIOBJ_MARK_MEMORY_PRINT();
    FIO_ASSERT(FIOBJ_MARK_MEMORY_ALLOC_COUNTER ==
                   FIOBJ_MARK_MEMORY_FREE_COUNTER,
               "FIOBJ leak detected (freed %zu/%zu)",
               FIOBJ_MARK_MEMORY_FREE_COUNTER,
               FIOBJ_MARK_MEMORY_ALLOC_COUNTER);
  }
#endif
  fprintf(stderr, "* Passed.\n");
}
#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
FIOBJ cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIOBJ_EXTERN_OBJ
#undef FIOBJ_EXTERN_OBJ_IMP
#endif /* FIO_FIOBJ */
#undef FIO_FIOBJ
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___           /* Development inclusion - ignore line */
#define FIO_MODULE_NAME module /* Development inclusion - ignore line */
#include "./include.h"         /* Development inclusion - ignore line */
#endif                         /* Development inclusion - ignore line */
/* *****************************************************************************




                  A Template for New Types / Modules




Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */
#if defined(FIO_MODULE_NAME) /* && !defined(FIO_STL_KEEP__) */

/* *****************************************************************************
Module Settings

At this point, define any MACROs and customizable settings available to the
developer.
***************************************************************************** */

/* *****************************************************************************
Pointer Tagging Support: !!! valid only for dynamic types, filename 2xx XXX.h
***************************************************************************** */

#ifdef FIO_PTR_TAG_TYPE
#define FIO_MODULE_PTR FIO_PTR_TAG_TYPE
#else
#define FIO_MODULE_PTR FIO_NAME(FIO_MODULE_NAME, s) *
#endif

#define FIO___UNTAG_T FIO_NAME(FIO_MODULE_NAME, s)

/* *****************************************************************************
Module API
***************************************************************************** */

typedef struct {
  /* module's type(s) if any */
  void *data;
} FIO_NAME(FIO_MODULE_NAME, s);

/* at this point publish (declare only) the public API */

#ifndef FIO_MODULE_INIT
/* Initialization macro. */
#define FIO_MODULE_INIT                                                        \
  { 0 }
#endif

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY

/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC FIO_MODULE_PTR FIO_NAME(FIO_MODULE_NAME, new)(void);

/* Frees any internal data AND the object's container! */
FIO_IFUNC int FIO_NAME(FIO_MODULE_NAME, free)(FIO_MODULE_PTR obj);

#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/** Destroys the object, reinitializing its container. */
SFUNC void FIO_NAME(FIO_MODULE_NAME, destroy)(FIO_MODULE_PTR obj);

/* *****************************************************************************
Module Implementation - inlined static functions
***************************************************************************** */
/*
REMEMBER:
========

All memory allocations should use:
* FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)
* FIO_MEM_FREE_(ptr, size)

*/

/* do we have a constructor? */
#ifndef FIO_REF_CONSTRUCTOR_ONLY
/* Allocates a new object on the heap and initializes it's memory. */
FIO_IFUNC FIO_MODULE_PTR FIO_NAME(FIO_MODULE_NAME, new)(void) {
  FIO_NAME(FIO_MODULE_NAME, s) *o =
      (FIO_NAME(FIO_MODULE_NAME, s) *)FIO_MEM_REALLOC_(NULL, 0, sizeof(*o), 0);
  if (!o)
    return (FIO_MODULE_PTR)NULL;
  *o = (FIO_NAME(FIO_MODULE_NAME, s))FIO_MODULE_INIT;
  return (FIO_MODULE_PTR)FIO_PTR_TAG(o);
}
/* Frees any internal data AND the object's container! */
FIO_IFUNC int FIO_NAME(FIO_MODULE_NAME, free)(FIO_MODULE_PTR obj) {
  FIO_PTR_TAG_VALID_OR_RETURN(obj, 0);
  FIO_NAME(FIO_MODULE_NAME, destroy)(obj);
  FIO_NAME(FIO_MODULE_NAME, s) *o =
      FIO_PTR_TAG_GET_UNTAGGED(FIO___UNTAG_T, obj);
  FIO_MEM_FREE_(o, sizeof(*o));
  return 0;
}
#endif /* FIO_REF_CONSTRUCTOR_ONLY */

/* *****************************************************************************
Module Implementation - possibly externed functions.
***************************************************************************** */
#if defined(FIO_EXTERN_COMPLETE) || !defined(FIO_EXTERN)

/*
REMEMBER:
========

All memory allocations should use:
* FIO_MEM_REALLOC_(ptr, old_size, new_size, copy_len)
* FIO_MEM_FREE_(ptr, size)

*/

/* Frees any internal data AND the object's container! */
SFUNC void FIO_NAME(FIO_MODULE_NAME, destroy)(FIO_MODULE_PTR obj) {
  FIO_PTR_TAG_VALID_OR_RETURN_VOID(obj);
  FIO_NAME(FIO_MODULE_NAME, s) *o =
      FIO_PTR_TAG_GET_UNTAGGED(FIO___UNTAG_T, obj);
  /* TODO: add destruction logic */

  *o = (FIO_NAME(FIO_MODULE_NAME, s))FIO_MODULE_INIT;
  return;
}

/* *****************************************************************************
Module Testing
***************************************************************************** */
#ifdef FIO_TEST_CSTL
FIO_SFUNC void FIO_NAME_TEST(stl, FIO_MODULE_NAME)(void) {
  /*
   * TODO: test module here
   */
}

#endif /* FIO_TEST_CSTL */
/* *****************************************************************************
Module Cleanup
***************************************************************************** */

#endif /* FIO_EXTERN_COMPLETE */
#undef FIO_MODULE_PTR
#undef FIO_MODULE_NAME
#undef FIO___UNTAG_T
#endif /* FIO_MODULE_NAME */
/* *****************************************************************************




                            Common Cleanup




***************************************************************************** */

/* *****************************************************************************
Common cleanup
***************************************************************************** */
#ifndef FIO_STL_KEEP__

/* undefine FIO_EXTERN only if its value indicates it is temporary. */
#if (FIO_EXTERN + 1) < 3
#undef FIO_EXTERN
#endif
#if (FIO_EXTERN_COMPLETE + 1) < 3
#undef FIO_EXTERN_COMPLETE
#endif

#undef SFUNC
#undef IFUNC
#undef SFUNC_
#undef IFUNC_

#undef FIO_MALLOC_TMP_USE_SYSTEM
#undef FIO_MEM_REALLOC_
#undef FIO_MEM_FREE_
#undef FIO_MEM_REALLOC_IS_SAFE_
#undef FIO_MEMORY_NAME /* postponed due to possible use in macros */

#undef FIO___LOCK_TYPE
#undef FIO___LOCK_INIT
#undef FIO___LOCK_LOCK
#undef FIO___LOCK_LOCK_TRY
#undef FIO___LOCK_UNLOCK
#undef FIO_USE_THREAD_MUTEX_TMP

#else

#undef SFUNC
#undef IFUNC
#define SFUNC SFUNC_
#define IFUNC IFUNC_

#endif /* !FIO_STL_KEEP__ */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H) &&                                     \
    !defined(FIO___CSTL_NON_COMBINED_INCLUSION) /* Dev test - ignore line */
#define FIO___DEV___   /* Development inclusion - ignore line */
#define FIO_TEST_CSTL  /* Development inclusion - ignore line */
#include "./include.h" /* Development inclusion - ignore line */
#endif                 /* Development inclusion - ignore line */
/* *****************************************************************************



                                Testing


Copyright and License: see header file (000 header.h) or top of file
***************************************************************************** */

#if !defined(FIO_FIO_TEST_CSTL_ONLY_ONCE) && (defined(FIO_TEST_CSTL))
#define FIO_FIO_TEST_CSTL_ONLY_ONCE 1

#ifdef FIO_EXTERN_TEST
void fio_test_dynamic_types(void);
#else
FIO_SFUNC void fio_test_dynamic_types(void);
#endif

#if !defined(FIO_EXTERN_TEST) || defined(FIO_EXTERN_COMPLETE)

/* Make sure logging and memory leak counters are set. */
#define FIO_LOG
#undef FIO_LEAK_COUNTER
#define FIO_LEAK_COUNTER 1
#ifndef FIO_FIOBJ
#define FIO_FIOBJ
#endif
#ifndef FIOBJ_MALLOC
#define FIOBJ_MALLOC /* define to test with custom allocator */
#endif
#define FIO_TIME
#include FIO_INCLUDE_FILE

/* Add non-type options to minimize `#include` instructions */
#define FIO_ATOL
#define FIO_ATOMIC
#define FIO_BITMAP
#define FIO_BITWISE
#define FIO_CHACHA
#define FIO_CLI
#define FIO_GLOB_MATCH
#define FIO_MATH
#define FIO_POLL
#define FIO_QUEUE
#define FIO_RAND
#define FIO_RISKY_HASH
#define FIO_SHA1
#define FIO_SHA2
#define FIO_SIGNAL
#define FIO_SOCK
#define FIO_STATE
#define FIO_STREAM
#define FIO_THREADS
#define FIO_TIME
#define FIO_URL
#define FIO_SERVER
#define FIO_PUBSUB
#define FIO_SORT_NAME num
#define FIO_SORT_TYPE size_t
#define FIO_SORT_TEST 1
// #define FIO_LOCK2 /* a signal based blocking lock is WIP */
#include FIO_INCLUDE_FILE

FIO_SFUNC uintptr_t fio___dynamic_types_test_tag(uintptr_t i) { return i | 1; }
FIO_SFUNC uintptr_t fio___dynamic_types_test_untag(uintptr_t i) {
  return i & (~((uintptr_t)1UL));
}

/* *****************************************************************************
Dynamically Produced Test Types
***************************************************************************** */

static int ary____test_was_destroyed = 0;
#define FIO_ARRAY_NAME    ary____test
#define FIO_ARRAY_TYPE    int
#define FIO_REF_NAME      ary____test
#define FIO_REF_INIT(obj) obj = (ary____test_s)FIO_ARRAY_INIT
#define FIO_REF_DESTROY(obj)                                                   \
  do {                                                                         \
    ary____test_destroy(&obj);                                                 \
    ary____test_was_destroyed = 1;                                             \
  } while (0)
#define FIO_PTR_TAG(p)   fio___dynamic_types_test_tag(((uintptr_t)p))
#define FIO_PTR_UNTAG(p) fio___dynamic_types_test_untag(((uintptr_t)p))
#include FIO_INCLUDE_FILE

#define FIO_ARRAY_NAME                 ary2____test
#define FIO_ARRAY_TYPE                 uint8_t
#define FIO_ARRAY_TYPE_INVALID         0xFF
#define FIO_ARRAY_TYPE_COPY(dest, src) (dest) = (src)
#define FIO_ARRAY_TYPE_DESTROY(obj)    (obj = FIO_ARRAY_TYPE_INVALID)
#define FIO_ARRAY_TYPE_CMP(a, b)       (a) == (b)
#define FIO_PTR_TAG(p)                 fio___dynamic_types_test_tag(((uintptr_t)p))
#define FIO_PTR_UNTAG(p)               fio___dynamic_types_test_untag(((uintptr_t)p))
#include FIO_INCLUDE_FILE

/* test all defaults */
#define FIO_ARRAY_NAME ary3____test
#include FIO_INCLUDE_FILE

#define FIO_UMAP_NAME   uset___test_size_t
#define FIO_MEMORY_NAME uset___test_size_t_mem
#define FIO_MAP_KEY     size_t
#define FIO_MAP_TEST
#include FIO_INCLUDE_FILE
#define FIO_UMAP_NAME   umap___test_size
#define FIO_MEMORY_NAME umap___test_size_mem
#define FIO_MAP_KEY     size_t
#define FIO_MAP_VALUE   size_t
#define FIO_MAP_TEST
#include FIO_INCLUDE_FILE
#define FIO_OMAP_NAME   omap___test_size_t
#define FIO_MEMORY_NAME omap___test_size_t_mem
#define FIO_MAP_KEY     size_t
#define FIO_MAP_ORDERED 1
#define FIO_MAP_TEST
#include FIO_INCLUDE_FILE
#define FIO_OMAP_NAME   omap___test_size_lru
#define FIO_MEMORY_NAME omap___test_size_lru_mem
#define FIO_MAP_KEY     size_t
#define FIO_MAP_VALUE   size_t
#define FIO_MAP_LRU     (1UL << 24)
#define FIO_MAP_TEST
#include FIO_INCLUDE_FILE

#define FIO_STR_NAME fio_big_str
#define FIO_STR_WRITE_TEST_FUNC
#include FIO_INCLUDE_FILE

#define FIO_STR_SMALL fio_small_str
#define FIO_STR_WRITE_TEST_FUNC
#include FIO_INCLUDE_FILE

#define FIO_MEMORY_NAME                   fio_mem_test_safe
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 1
#undef FIO_MEMORY_USE_THREAD_MUTEX
#define FIO_MEMORY_USE_THREAD_MUTEX 0
#define FIO_MEMORY_ARENA_COUNT      4
#include FIO_INCLUDE_FILE

#define FIO_MEMORY_NAME                   fio_mem_test_unsafe
#define FIO_MEMORY_INITIALIZE_ALLOCATIONS 0
#undef FIO_MEMORY_USE_THREAD_MUTEX
#define FIO_MEMORY_USE_THREAD_MUTEX 0
#define FIO_MEMORY_ARENA_COUNT      4
#include FIO_INCLUDE_FILE

/* *****************************************************************************
Linked List - Test
***************************************************************************** */

typedef struct {
  int data;
  FIO_LIST_NODE node;
} ls____test_s;

#define FIO_LIST_NAME    ls____test
#define FIO_PTR_TAG(p)   fio___dynamic_types_test_tag(((uintptr_t)p))
#define FIO_PTR_UNTAG(p) fio___dynamic_types_test_untag(((uintptr_t)p))

#include FIO_INCLUDE_FILE

FIO_SFUNC void fio___dynamic_types_test___linked_list_test(void) {
  fprintf(stderr, "* Testing linked lists.\n");
  FIO_LIST_HEAD ls = FIO_LIST_INIT(ls);
  for (int i = 0; i < FIO_TEST_REPEAT; ++i) {
    ls____test_s *node = ls____test_push(
        &ls,
        (ls____test_s *)FIO_MEM_REALLOC(NULL, 0, sizeof(*node), 0));
    node->data = i;
  }
  int tester = 0;
  FIO_LIST_EACH(ls____test_s, node, &ls, pos) {
    FIO_ASSERT(pos->data == tester++,
               "Linked list ordering error for push or each");
    FIO_ASSERT(ls____test_root(&pos->node) == pos,
               "Linked List root offset error");
  }
  FIO_ASSERT(tester == FIO_TEST_REPEAT,
             "linked list EACH didn't loop through all the list");
  while (ls____test_any(&ls)) {
    ls____test_s *node = ls____test_pop(&ls);
    node = (ls____test_s *)fio___dynamic_types_test_untag((uintptr_t)(node));
    FIO_ASSERT(node, "Linked list pop or any failed");
    FIO_ASSERT(node->data == --tester, "Linked list ordering error for pop");
    FIO_MEM_FREE(node, sizeof(*node));
  }
  tester = FIO_TEST_REPEAT;
  for (int i = 0; i < FIO_TEST_REPEAT; ++i) {
    ls____test_s *node = ls____test_unshift(
        &ls,
        (ls____test_s *)FIO_MEM_REALLOC(NULL, 0, sizeof(*node), 0));
    node->data = i;
  }
  FIO_LIST_EACH(ls____test_s, node, &ls, pos) {
    FIO_ASSERT(pos->data == --tester,
               "Linked list ordering error for unshift or each");
  }
  FIO_ASSERT(tester == 0,
             "linked list EACH didn't loop through all the list after unshift");
  tester = FIO_TEST_REPEAT;
  while (ls____test_any(&ls)) {
    ls____test_s *node = ls____test_shift(&ls);
    node = (ls____test_s *)fio___dynamic_types_test_untag((uintptr_t)(node));
    FIO_ASSERT(node, "Linked list pop or any failed");
    FIO_ASSERT(node->data == --tester, "Linked list ordering error for shift");
    FIO_MEM_FREE(node, sizeof(*node));
  }
  FIO_ASSERT(FIO_NAME_BL(ls____test, empty)(&ls),
             "Linked list empty should have been true");
  for (int i = 0; i < FIO_TEST_REPEAT; ++i) {
    ls____test_s *node = ls____test_push(
        &ls,
        (ls____test_s *)FIO_MEM_REALLOC(NULL, 0, sizeof(*node), 0));
    node->data = i;
  }
  FIO_LIST_EACH(ls____test_s, node, &ls, pos) {
    ls____test_remove(pos);
    pos = (ls____test_s *)fio___dynamic_types_test_untag((uintptr_t)(pos));
    FIO_MEM_FREE(pos, sizeof(*pos));
  }
  FIO_ASSERT(FIO_NAME_BL(ls____test, empty)(&ls),
             "Linked list empty should have been true");
}

FIO_SFUNC void fio___dynamic_types_test___index_list_test(void) {
  fprintf(stderr, "* Testing indexed lists.\n");
  struct {
    size_t i;
    struct {
      uint16_t next;
      uint16_t prev;
    } node;
  } data[16];
  size_t count;
  const size_t len = 16;
  for (size_t i = 0; i < len; ++i) {
    data[i].i = i;
    if (!i)
      data[i].node.prev = data[i].node.next = i;
    else
      FIO_INDEXED_LIST_PUSH(data, node, 0, i);
  }
  count = 0;
  FIO_INDEXED_LIST_EACH(data, node, 0, i) {
    FIO_ASSERT(data[i].i == count,
               "indexed list order issue? %zu != %zu",
               data[i].i != i);
    ++count;
  }
  FIO_ASSERT(count == 16, "indexed list each failed? (%zu != %zu)", count, len);
  count = 0;
  while (data[0].node.next != 0 && count < 32) {
    ++count;
    uint16_t n = data[0].node.prev;
    FIO_INDEXED_LIST_REMOVE(data, node, n);
  }
  FIO_ASSERT(count == 15,
             "indexed list remove failed? (%zu != %zu)",
             count,
             len);
  for (size_t i = 0; i < len; ++i) {
    data[i].i = i;
    if (!i)
      data[i].node.prev = data[i].node.next = i;
    else {
      FIO_INDEXED_LIST_PUSH(data, node, 0, i);
      FIO_INDEXED_LIST_REMOVE(data, node, i);
      FIO_INDEXED_LIST_PUSH(data, node, 0, i);
    }
  }
  count = 0;
  FIO_INDEXED_LIST_EACH(data, node, 0, i) {
    FIO_ASSERT(data[i].i == count,
               "indexed list order issue (push-pop-push? %zu != %zu",
               data[i].i != count);
    ++count;
  }
}

/* *****************************************************************************
Environment printout
***************************************************************************** */

#define FIO_PRINT_SIZE_OF(T)                                                   \
  fprintf(stderr, "\t%-19s%zu Bytes\n", #T, sizeof(T))

FIO_SFUNC void FIO_NAME_TEST(stl, type_sizes)(void) {
  switch (sizeof(void *)) {
  case 2:
    fprintf(stderr, "* 16bit words size (unexpected, unknown effects).\n");
    break;
  case 4:
    fprintf(stderr, "* 32bit words size (some features might be slower).\n");
    break;
  case 8: fprintf(stderr, "* 64bit words size okay.\n"); break;
  case 16: fprintf(stderr, "* 128bit words size... wow!\n"); break;
  default:
    fprintf(stderr, "* Unknown words size %zubit!\n", sizeof(void *) << 3);
    break;
  }
  fprintf(stderr, "* Using the following type sizes:\n");
  FIO_PRINT_SIZE_OF(char);
  FIO_PRINT_SIZE_OF(short);
  FIO_PRINT_SIZE_OF(int);
  FIO_PRINT_SIZE_OF(float);
  FIO_PRINT_SIZE_OF(long);
  FIO_PRINT_SIZE_OF(double);
  FIO_PRINT_SIZE_OF(size_t);
  FIO_PRINT_SIZE_OF(void *);
  FIO_PRINT_SIZE_OF(uintmax_t);
  FIO_PRINT_SIZE_OF(long double);
#ifdef __SIZEOF_INT128__
  FIO_PRINT_SIZE_OF(__uint128_t);
#endif
  FIO_PRINT_SIZE_OF(fio_thread_t);
  FIO_PRINT_SIZE_OF(fio_thread_mutex_t);
#if FIO_OS_POSIX || defined(_SC_PAGESIZE)
  long page = sysconf(_SC_PAGESIZE);
  if (page > 0) {
    fprintf(stderr, "\t%-17s%ld bytes.\n", "Page", page);
    if (page != (1UL << FIO_MEM_PAGE_SIZE_LOG))
      FIO_LOG_INFO("unexpected page size != 4096\n          "
                   "facil.io could be recompiled with:\n          "
                   "`CFLAGS=\"-DFIO_MEM_PAGE_SIZE_LOG=%.0lf\"`",
                   log2(page));
  }
#endif /* FIO_OS_POSIX */
}
#undef FIO_PRINT_SIZE_OF

/* *****************************************************************************
Locking - Speed Test
***************************************************************************** */

FIO_SFUNC void FIO_NAME_TEST(stl, math_speed)(void) {
  uint64_t n = 0, d = 1;
  uint64_t start[2], end[2];
  start[0] = fio_time_nano();
  for (size_t i = 0; i < 64; ++i) {
    n = (n << 7) ^ 0xAA;
    uint64_t q = 0, r = 0;
    FIO_COMPILER_GUARD;
    for (size_t j = 0; j < 64; ++j) {
      d = (d << 3) ^ 0xAA;
      FIO_COMPILER_GUARD;
      fio_math_div(&q, &r, &n, &d, 1);
      FIO_COMPILER_GUARD;
    }
    (void)q;
  }
  end[0] = fio_time_nano();
  n = 0, d = 1;
  start[1] = fio_time_nano();
  for (size_t i = 0; i < 64; ++i) {
    n = (n << 7) ^ 0xAA;
    uint64_t q = 0;
    FIO_COMPILER_GUARD;
    for (size_t j = 0; j < 64; ++j) {
      d = (d << 3) ^ 0xAA;
      FIO_COMPILER_GUARD;
      q = n / d;
      FIO_COMPILER_GUARD;
    }
    (void)q;
  }
  end[1] = fio_time_nano();
  FIO_LOG_INFO("\t fio_math_div test took %zu us (vs. %zu us) for a single "
               "64 bit word.",
               (size_t)(end[0] - start[0]),
               (size_t)(end[1] - start[1]));
}

/* *****************************************************************************
Locking - Speed Test
***************************************************************************** */
#define FIO___LOCK2_TEST_TASK    (1LU << 25)
#define FIO___LOCK2_TEST_THREADS 32U
#define FIO___LOCK2_TEST_REPEAT  1

FIO_SFUNC void fio___lock_speedtest_task_inner(void *s) {
  size_t *r = (size_t *)s;
  static size_t i;
  for (i = 0; i < FIO___LOCK2_TEST_TASK; ++i) {
    FIO_COMPILER_GUARD;
    ++r[0];
  }
}

static void *fio___lock_mytask_lock(void *s) {
  static fio_lock_i lock = FIO_LOCK_INIT;
  fio_lock(&lock);
  if (s)
    fio___lock_speedtest_task_inner(s);
  fio_unlock(&lock);
  return NULL;
}

#ifdef H___FIO_LOCK2___H
static void *fio___lock_mytask_lock2(void *s) {
  static fio_lock2_s lock = {FIO_LOCK_INIT};
  fio_lock2(&lock, 1);
  if (s)
    fio___lock_speedtest_task_inner(s);
  fio_unlock2(&lock, 1);
  return NULL;
}
#endif

static void *fio___lock_mytask_mutex(void *s) {
  static fio_thread_mutex_t mutex = FIO_THREAD_MUTEX_INIT;
  fio_thread_mutex_lock(&mutex);
  if (s)
    fio___lock_speedtest_task_inner(s);
  fio_thread_mutex_unlock(&mutex);
  return NULL;
}

FIO_SFUNC void FIO_NAME_TEST(stl, lock_speed)(void) {
  uint64_t start, end;
  fio_thread_t threads[FIO___LOCK2_TEST_THREADS];

  struct {
    size_t type_size;
    const char *type_name;
    const char *name;
    void *(*task)(void *);
  } test_funcs[] = {
      {
          .type_size = sizeof(fio_lock_i),
          .type_name = "fio_lock_i",
          .name = "fio_lock      (spinlock)",
          .task = fio___lock_mytask_lock,
      },
#ifdef H___FIO_LOCK2___H
      {
          .type_size = sizeof(fio_lock2_s),
          .type_name = "fio_lock2_s",
          .name = "fio_lock2 (pause/resume)",
          .task = fio___lock_mytask_lock2,
      },
#endif
      {
          .type_size = sizeof(fio_thread_mutex_t),
          .type_name = "fio_thread_mutex_t",
          .name = "OS threads (pthread_mutex / Windows handle)",
          .task = fio___lock_mytask_mutex,
      },
      {
          .name = NULL,
          .task = NULL,
      },
  };
  fprintf(stderr, "* Speed testing The following types:\n");
  for (size_t fn = 0; test_funcs[fn].name; ++fn) {
    fprintf(stderr,
            "\t%s\t(%zu bytes)\n",
            test_funcs[fn].type_name,
            test_funcs[fn].type_size);
  }
#ifndef H___FIO_LOCK2___H
  FIO_LOG_WARNING("Won't test `fio_lock2` functions (needs `FIO_LOCK2`).");
#endif

  start = fio_time_micro();
  for (size_t i = 0; i < FIO___LOCK2_TEST_TASK; ++i) {
    FIO_COMPILER_GUARD;
  }
  end = fio_time_micro();
  fprintf(stderr,
          "\n* Speed testing locking schemes - no contention, short work (%zu "
          "mms):\n"
          "\t\t(%zu itterations)\n",
          (size_t)(end - start),
          (size_t)FIO___LOCK2_TEST_TASK);

  for (int test_repeat = 0; test_repeat < FIO___LOCK2_TEST_REPEAT;
       ++test_repeat) {
    if (FIO___LOCK2_TEST_REPEAT > 1)
      fprintf(stderr,
              "%s (%d)\n",
              (test_repeat ? "Round" : "Warmup"),
              test_repeat);
    for (size_t fn = 0; test_funcs[fn].name; ++fn) {
      test_funcs[fn].task(NULL); /* warmup */
      start = fio_time_micro();
      for (size_t i = 0; i < FIO___LOCK2_TEST_TASK; ++i) {
        FIO_COMPILER_GUARD;
        test_funcs[fn].task(NULL);
      }
      end = fio_time_micro();
      fprintf(stderr,
              "\t%s: %zu mms\n",
              test_funcs[fn].name,
              (size_t)(end - start));
    }
  }

  fprintf(stderr,
          "\n* Speed testing locking schemes - no contention, long work ");
  start = fio_time_micro();
  for (size_t i = 0; i < FIO___LOCK2_TEST_THREADS; ++i) {
    size_t result = 0;
    FIO_COMPILER_GUARD;
    fio___lock_speedtest_task_inner(&result);
  }
  end = fio_time_micro();
  fprintf(stderr, " %zu mms\n", (size_t)(end - start));
  clock_t long_work = end - start;
  fprintf(stderr, "(%zu mms):\n", (size_t)long_work);
  for (int test_repeat = 0; test_repeat < FIO___LOCK2_TEST_REPEAT;
       ++test_repeat) {
    if (FIO___LOCK2_TEST_REPEAT > 1)
      fprintf(stderr,
              "%s (%d)\n",
              (test_repeat ? "Round" : "Warmup"),
              test_repeat);
    for (size_t fn = 0; test_funcs[fn].name; ++fn) {
      size_t result = 0;
      test_funcs[fn].task((void *)&result); /* warmup */
      result = 0;
      start = fio_time_micro();
      for (size_t i = 0; i < FIO___LOCK2_TEST_THREADS; ++i) {
        FIO_COMPILER_GUARD;
        test_funcs[fn].task(&result);
      }
      end = fio_time_micro();
      fprintf(stderr,
              "\t%s: %zu mms (%zu mms)\n",
              test_funcs[fn].name,
              (size_t)(end - start),
              (size_t)(end - (start + long_work)));
      FIO_ASSERT(result == (FIO___LOCK2_TEST_TASK * FIO___LOCK2_TEST_THREADS),
                 "%s final result error.",
                 test_funcs[fn].name);
    }
  }

  fprintf(stderr,
          "\n* Speed testing locking schemes - %zu threads, long work (%zu "
          "mms):\n",
          (size_t)FIO___LOCK2_TEST_THREADS,
          (size_t)long_work);
  for (int test_repeat = 0; test_repeat < FIO___LOCK2_TEST_REPEAT;
       ++test_repeat) {
    if (FIO___LOCK2_TEST_REPEAT > 1)
      fprintf(stderr,
              "%s (%d)\n",
              (test_repeat ? "Round" : "Warmup"),
              test_repeat);
    for (size_t fn = 0; test_funcs[fn].name; ++fn) {
      size_t result = 0;
      test_funcs[fn].task((void *)&result); /* warmup */
      result = 0;
      start = fio_time_micro();
      for (size_t i = 0; i < FIO___LOCK2_TEST_THREADS; ++i) {
        fio_thread_create(threads + i, test_funcs[fn].task, &result);
      }
      for (size_t i = 0; i < FIO___LOCK2_TEST_THREADS; ++i) {
        fio_thread_join(threads + i);
      }
      end = fio_time_micro();
      fprintf(stderr,
              "\t%s: %zu mms (%zu mms)\n",
              test_funcs[fn].name,
              (size_t)(end - start),
              (size_t)(end - (start + long_work)));
      FIO_ASSERT(result == (FIO___LOCK2_TEST_TASK * FIO___LOCK2_TEST_THREADS),
                 "%s final result error.",
                 test_funcs[fn].name);
    }
  }
}

/* *****************************************************************************
Testing function
***************************************************************************** */

FIO_SFUNC void fio____test_dynamic_types__stack_poisoner(void) {
#define FIO___STACK_POISON_LENGTH (1ULL << 16)
  uint8_t buf[FIO___STACK_POISON_LENGTH];
  FIO_COMPILER_GUARD;
  FIO_MEMSET(buf, (int)(~0U), FIO___STACK_POISON_LENGTH);
  FIO_COMPILER_GUARD;
  fio_trylock(buf);
#undef FIO___STACK_POISON_LENGTH
}

void fio_test_dynamic_types(void) {
  char *filename = (char *)FIO_INCLUDE_FILE;
  while (filename[0] == '.' && filename[1] == '/')
    filename += 2;
  fio____test_dynamic_types__stack_poisoner();
  fprintf(stderr, "===============\n");
  fprintf(stderr, "Testing facil.io CSTL (%s)\n", filename);
  fprintf(
      stderr,
      "Version: \x1B[1m" FIO_VERSION_STRING "\x1B[0m\n"
      "The facil.io library was originally coded by \x1B[1mBoaz Segev\x1B[0m.\n"
      "Please give credit where credit is due.\n"
      "\x1B[1mYour support is only fair\x1B[0m - give value for value.\n"
      "(code contributions / donations)\n\n");
  fprintf(stderr, "===============\n");
  FIO_LOG_DEBUG("example FIO_LOG_DEBUG message.");
  FIO_LOG_DEBUG2("example FIO_LOG_DEBUG2 message.");
  FIO_LOG_INFO("example FIO_LOG_INFO message.");
  FIO_LOG_WARNING("example FIO_LOG_WARNING message.");
  FIO_LOG_SECURITY("example FIO_LOG_SECURITY message.");
  FIO_LOG_ERROR("example FIO_LOG_ERROR message.");
  FIO_LOG_FATAL("example FIO_LOG_FATAL message.");
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, type_sizes)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, random)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, atomics)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, bitwise)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, atol)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, math)();
  FIO_NAME_TEST(stl, math_speed)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, FIO_NAME(sort, num))();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, url)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, glob_matching)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, imap_core)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, state)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, string_core_helpers)();
  fprintf(stderr, "===============\n");
  fio___dynamic_types_test___linked_list_test();
  fprintf(stderr, "===============\n");
  fio___dynamic_types_test___index_list_test();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, ary____test)();
  FIO_NAME_TEST(stl, ary2____test)();
  FIO_NAME_TEST(stl, ary3____test)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, uset___test_size_t)();
  FIO_NAME_TEST(stl, umap___test_size)();
  FIO_NAME_TEST(stl, omap___test_size_t)();
  FIO_NAME_TEST(stl, omap___test_size_lru)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, fio_big_str)();
  FIO_NAME_TEST(stl, fio_small_str)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, time)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, queue)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, cli)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, stream)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, poll)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, filename)();
  fprintf(stderr, "===============\n");
#ifndef FIO_MEMORY_DISABLE
  FIO_NAME_TEST(stl, mem_helper_speeds)();
  fprintf(stderr, "===============\n");
#endif
  /* test memory allocator that initializes memory to zero */
  FIO_NAME_TEST(FIO_NAME(stl, fio_mem_test_safe), mem)();
  fprintf(stderr, "===============\n");
  /* test memory allocator that allows junk data in allocations */
  FIO_NAME_TEST(FIO_NAME(stl, fio_mem_test_unsafe), mem)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, sock)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, fiobj)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, server)();
  FIO_NAME_TEST(stl, pubsub)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, risky)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, sha1)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, sha2)();
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, chacha)();
#if !DEBUG
  fprintf(stderr, "===============\n");
  FIO_NAME_TEST(stl, lock_speed)();
#endif
  fprintf(stderr, "===============\n");
  {
    char timebuf[64];
    fio_time2rfc7231(timebuf, fio_time_real().tv_sec);
    fprintf(stderr,
            "On %s\n"
            "Testing \x1B[1mPASSED\x1B[0m "
            "for facil.io core version: "
            "\x1B[1m" FIO_VERSION_STRING "\x1B[0m"
            "\n",
            timebuf);
  }
  fprintf(stderr,
          "\nThe facil.io library was originally coded by \x1B[1mBoaz "
          "Segev\x1B[0m.\n"
          "Please give credit where credit is due.\n"
          "\x1B[1mYour support is only fair\x1B[0m - give value for value.\n"
          "(code contributions / donations)\n\n");
#if !defined(FIO_NO_COOKIE)
  fio___();
#endif
}

/* *****************************************************************************
Testing cleanup
***************************************************************************** */
#undef FIO_TEST_CSTL
#undef FIO_TEST_REPEAT

#endif /* FIO_EXTERN_COMPLETE */
#endif /* FIO_TEST_CSTL */

/* do not build test if fio-stl.h was already included once */
#ifndef FIO_FIO_TEST_CSTL_ONLY_ONCE
#define FIO_FIO_TEST_CSTL_ONLY_ONCE 1
#endif
/* *****************************************************************************




***************************************************************************** */

/* *****************************************************************************
C++ extern end
***************************************************************************** */
/* support C++ */
#ifdef __cplusplus
}
#endif

#if !defined(FIO_STL_KEEP__)
/* *****************************************************************************
Everything, and the Kitchen Sink
***************************************************************************** */
#if defined(FIO_EVERYTHING) && !defined(H___FIO_EVERYTHING___H)
#undef FIO_EVERYTHING
#define H___FIO_EVERYTHING___H

#define FIO_BASIC
#define FIO_CORE
#define FIO_CRYPT
#define FIO_SERVER_COMPLETE

#endif /* FIO_EVERYTHING */

#ifdef FIO_BASIC
#define FIO_SERVER_COMPLETE
#endif

/* *****************************************************************************
Basic Elements
***************************************************************************** */
#if defined(FIO_BASIC)
#undef FIO_BASIC

#define FIO_CLI
#define FIO_LOG
#include FIO_INCLUDE_FILE

#define FIO_FIOBJ
#define FIOBJ_MALLOC
#include FIO_INCLUDE_FILE

#define FIO_CORE
#define FIO_MALLOC
#define FIO_THREADS

#endif /* FIO_BASIC */

/* *****************************************************************************
Core Elements
***************************************************************************** */
#if defined(FIO_CORE)
#undef FIO_CORE

#define FIO_ATOL
#define FIO_ATOMIC
#define FIO_BITMAP
#define FIO_BITWISE
#define FIO_FILES
#define FIO_GLOB_MATCH
#define FIO_LOG
#define FIO_MATH
#define FIO_RAND
#define FIO_STATE
#define FIO_STR
#define FIO_TIME
#define FIO_URL

#include FIO_INCLUDE_FILE

#endif /* FIO_CORE */

/* *****************************************************************************
Core Elements
***************************************************************************** */
#if defined(FIO_CRYPT)
#undef FIO_CRYPT
#define FIO_CHACHA
#define FIO_ED25519
#define FIO_SHA1
#define FIO_SHA2

#include FIO_INCLUDE_FILE

#endif /* FIO_CRYPT */
/* *****************************************************************************
Server Elements
***************************************************************************** */
#if defined(FIO_SERVER_COMPLETE)
#undef FIO_SERVER_COMPLETE

// #define FIO_HTTP1_PARSER
#define FIO_PUBSUB
#define FIO_QUEUE
#define FIO_SERVER
#define FIO_SIGNAL
#define FIO_SOCK
#define FIO_STREAM

#include FIO_INCLUDE_FILE
#endif /* FIO_SERVER_COMPLETE */

/* *****************************************************************************
Cleanup
***************************************************************************** */
#ifdef FIO_EVERYTHING___REMOVE_EXTERN
#undef FIO_EXTERN
#undef FIO_EVERYTHING___REMOVE_EXTERN
#endif
#ifdef FIO_EVERYTHING___REMOVE_EXTERN_COMPLETE
#undef FIO_EXTERN_COMPLETE
#undef FIO_EVERYTHING___REMOVE_EXTERN_COMPLETE
#endif

#endif /* FIO_STL_KEEP__ */
/* ************************************************************************* */
#if !defined(H___FIO_CSTL_COMBINED___H)
/* *****************************************************************************
                    Including requested facil.io C STL modules
***************************************************************************** */
#ifndef FIO_INCLUDE_FILE
#define FIO_INCLUDE_FILE "fio-stl/include.h"
#endif
#ifndef FIO___CSTL_NON_COMBINED_INCLUSION
#define FIO___CSTL_NON_COMBINED_INCLUSION
#endif
#include "001 header.h"

#ifdef FIO_LOG
#include "002 logging.h"
#endif
#ifdef FIO_ATOMIC
#include "003 atomics.h"
#endif
#if defined(FIO_BITWISE) || defined(FIO_BITMAP)
#include "004 bitwise.h"
#endif
#ifdef FIO_MATH
#include "005 math.h"
#endif
#ifdef FIO_ATOL
#include "006 atol.h"
#endif
#ifdef FIO_THREADS
#include "007 threads.h"
#endif
#ifdef FIO_TIME
#include "008 time.h"
#endif
#ifdef FIO_RAND
#include "010 random.h"
#endif
#ifdef FIO_SHA1
#include "011 sha1.h"
#endif
#ifdef FIO_SHA2
#include "011 sha2.h"
#endif
#ifdef FIO_CHACHA
#include "012 chacha20poly1305.h"
#endif
#ifdef FIO_ED25519
#include "013 ed25519.h"
#endif
#ifdef FIO_IMAP_CORE
#include "020 imap.h"
#endif
#if defined(FIO_URL) || defined(FIO_URI)
#include "050 url.h"
#endif
#ifdef FIO_JSON
#include "051 json.h"
#endif
#ifdef FIO_STATE
#include "090 state callbacks.h"
#endif

#include "100 mem.h" /* later files rely on macros from here. */

#ifdef FIO_QUEUE
#include "102 queue.h"
#endif
#ifdef FIO_SOCK
#include "104 sock.h"
#endif
#ifdef FIO_STREAM
#include "105 stream.h"
#endif
#ifdef FIO_SIGNAL
#include "106 signals.h"
#endif
#ifdef FIO_GLOB_MATCH
#include "107 glob matching.h"
#endif
#ifdef FIO_FILES
#include "108 files.h"
#endif
#ifdef FIO_STR
#include "199 string core.h"
#endif
#if defined(FIO_STR_SMALL) || defined(FIO_STR_NAME)
#include "200 string.h"
#endif
#ifdef FIO_ARRAY_NAME
#include "201 array.h"
#endif
#if defined(FIO_UMAP_NAME) || defined(FIO_OMAP_NAME) || defined(FIO_MAP_NAME)
#include "210 map.h"
#endif
#ifdef FIO_LIST_NAME
#include "220 linked lists.h"
#endif

#include "299 reference counter.h" /* pointer tagging cleanup is here */

#ifdef FIO_SORT_NAME
#include "301 sort.h"
#endif
#if defined(FIO_CLI) && !defined(FIO_STL_KEEP__)
#include "302 cli.h"
#endif
#if defined(FIO_POLL) && !defined(FIO_STL_KEEP__)
#include "330 poll api.h"
#include "331 poll epoll.h"
#include "331 poll kqueue.h"
#include "331 poll poll.h"
#endif
#if defined(FIO_SERVER) && !defined(FIO_STL_KEEP__)
#include "400 server.h"
#if defined(FIO_TEST_CSTL)
#include "409 server test.h"
#endif
#endif
#if defined(FIO_PUBSUB) && !defined(FIO_STL_KEEP__)
#include "420 pubsub.h"
#endif

#ifdef FIO_HTTP1_PARSER
#include "431 http1 parser.h"
#endif

#if defined(FIO_FIOBJ) && !defined(FIO_STL_KEEP__)
#include "500 fiobj.h"
#endif

#ifndef FIO___DEV___
#include "700 cleanup.h"
#endif

#if defined(FIO_TEST_CSTL) && !defined(FIO_FIO_TEST_CSTL_ONLY_ONCE) &&         \
    !defined(FIO_STL_KEEP__)
#include "998 tests.h"
#endif

#include "999 footer.h"

#ifndef FIO_STL_KEEP__
#undef FIO___CSTL_NON_COMBINED_INCLUSION
#endif

#endif /* !H___FIO_CSTL_COMBINED___H */
/* ************************************************************************* */
